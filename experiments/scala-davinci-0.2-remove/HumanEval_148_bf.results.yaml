language: scala
name: HumanEval_148_bf
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val idx1 = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n\
    \        if (idx1 == -1 || idx2 == -1) return List()\n        val min = min(idx1,\
    \ idx2)\n        val max = max(idx1, idx2)\n        planets.slice(min + 1, max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx3_u0g5c.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(idx1, idx2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx3_u0g5c.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(idx1, idx2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 >\
    \ index2) return planets.slice(index2, index1 + 1)\n        planets.slice(index1,\
    \ index2 + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswhz5fp4.scala:23)\n\tat Problem.main(tmpswhz5fp4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) List()\n        else if (i1 < i2) planets.slice(i1\
    \ + 1, i2)\n        else planets.slice(i2 + 1, i1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val idx1 = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n\
    \        if (idx1 == -1 || idx2 == -1) return List()\n        val minIdx = min(idx1,\
    \ idx2)\n        val maxIdx = max(idx1, idx2)\n        planets.slice(minIdx +\
    \ 1, maxIdx)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        return planets.slice(p1, p2 + 1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoyikyawg.scala:23)\n\tat Problem.main(tmpoyikyawg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (i1, i2) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(i1 + 1, i2)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 < 0 || p2 < 0) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n      \
    \      } else {\n                planets.slice(p2 + 1, p1)\n            }\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 < 0 || p2 < 0) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwxuztu1f.scala:23)\n\tat Problem.main(tmpwxuztu1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) Nil\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (a, b) = if (i1\
    \ < i2) (i1, i2) else (i2, i1)\n        planets.slice(a + 1, b)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else {\n            val (min,\
    \ max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min +\
    \ 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val idx1 = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n\
    \        if (idx1 == -1 || idx2 == -1) List()\n        else if (idx1 < idx2) planets.slice(idx1,\
    \ idx2 + 1)\n        else planets.slice(idx2, idx1 + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8sc1ouny.scala:23)\n\tat Problem.main(tmp8sc1ouny.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        if (index1 >\
    \ index2) return planets.slice(index2, index1 + 1)\n        else return planets.slice(index1,\
    \ index2 + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl9gxkkzi.scala:23)\n\tat Problem.main(tmpl9gxkkzi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 < 0 || p2 < 0) return List()\n        if (p1 > p2) return planets.slice(p2,\
    \ p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwxuztu1f.scala:23)\n\tat Problem.main(tmpwxuztu1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        planets.slice(p1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf6se7_e7.scala:23)\n\tat Problem.main(tmpf6se7_e7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val planet1Index = planets.indexOf(planet1)\n        val planet2Index\
    \ = planets.indexOf(planet2)\n        if (planet1Index == -1 || planet2Index ==\
    \ -1) return List()\n        val (min, max) = if (planet1Index < planet2Index)\
    \ (planet1Index, planet2Index) else (planet2Index, planet1Index)\n        planets.slice(min\
    \ + 1, max)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        else return planets.slice(p1, p2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4sqfjs8y.scala:23)\n\tat Problem.main(tmp4sqfjs8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1)\n        planets.slice(i1, i2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprzg_xdfx.scala:23)\n\tat Problem.main(tmprzg_xdfx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009198
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val planet1Index = planets.indexOf(planet1)\n        val planet2Index\
    \ = planets.indexOf(planet2)\n        if (planet1Index == -1 || planet2Index ==\
    \ -1) return List()\n        val minIndex = min(planet1Index, planet2Index)\n\
    \        val maxIndex = max(planet1Index, planet2Index)\n        planets.slice(minIndex\
    \ + 1, maxIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009197
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        (min + 1 until max).map(planets(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        return planets.slice(p1, p2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwhhrf2dk.scala:23)\n\tat Problem.main(tmpwhhrf2dk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else {\n            val (min,\
    \ max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min +\
    \ 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp719dkk2j.scala:23)\n\tat Problem.main(tmp719dkk2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp719dkk2j.scala:23)\n\tat Problem.main(tmp719dkk2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1)\n        planets.slice(i1, i2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprzg_xdfx.scala:23)\n\tat Problem.main(tmprzg_xdfx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009198
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) return\
    \ planets.slice(p1 + 1, p2)\n        else return planets.slice(p2 + 1, p1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp719dkk2j.scala:23)\n\tat Problem.main(tmp719dkk2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        else return planets.slice(p1, p2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4sqfjs8y.scala:23)\n\tat Problem.main(tmp4sqfjs8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) Nil\n        else if (i1 < i2) planets.slice(i1\
    \ + 1, i2)\n        else planets.slice(i2 + 1, i1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1 + 1)\n        planets.slice(i1, i2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1mctacjv.scala:23)\n\tat Problem.main(tmp1mctacjv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           val (min, max) = if (p1 < p2) (p1, p2) else (p2, p1)\n           \
    \ planets.slice(min + 1, max)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n      \
    \      } else {\n                planets.slice(p2 + 1, p1)\n            }\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1)\n        else return planets.slice(i1, i2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuvv9t2ys.scala:23)\n\tat Problem.main(tmpuvv9t2ys.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            return List()\n        }\n \
    \       if (p1 < p2) {\n            return planets.slice(p1 + 1, p2)\n       \
    \ }\n        return planets.slice(p2 + 1, p1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val idx1 = planets.indexOf(planet1)\n        val idx2 = planets.indexOf(planet2)\n\
    \        if (idx1 == -1 || idx2 == -1) return List()\n        val (min, max) =\
    \ if (idx1 < idx2) (idx1, idx2) else (idx2, idx1)\n        planets.slice(min +\
    \ 1, max)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List()\n        val min = min(index1,\
    \ index2)\n        val max = max(index1, index2)\n        planets.slice(min +\
    \ 1, max)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4qm6_da.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(index1, index2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4qm6_da.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(index1, index2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009197
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1 + 1)\n        planets.slice(i1, i2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1mctacjv.scala:23)\n\tat Problem.main(tmp1mctacjv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else {\n            val (min,\
    \ max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min +\
    \ 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        (min + 1 until max).map(planets(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val planet1Index = planets.indexOf(planet1)\n        val planet2Index\
    \ = planets.indexOf(planet2)\n        if (planet1Index == -1 || planet2Index ==\
    \ -1) return List()\n        if (planet1Index < planet2Index) planets.slice(planet1Index\
    \ + 1, planet2Index)\n        else planets.slice(planet2Index + 1, planet1Index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val (i1, i2) = (planets.indexOf(planet1), planets.indexOf(planet2))\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1 + 1)\n        else return planets.slice(i1, i2 + 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy9f7eia7.scala:22)\n\tat Problem.main(tmpy9f7eia7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (a, b) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(a + 1, b)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) List()\n        else if (i1 < i2) planets.slice(i1\
    \ + 1, i2)\n        else planets.slice(i2 + 1, i1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (a, b) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(a + 1, b)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp719dkk2j.scala:23)\n\tat Problem.main(tmp719dkk2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val p = if (p1 < p2)\
    \ planets.slice(p1, p2) else planets.slice(p2, p1)\n        return p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnqxj75d5.scala:23)\n\tat Problem.main(tmpnqxj75d5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        else return planets.slice(p1, p2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4sqfjs8y.scala:23)\n\tat Problem.main(tmp4sqfjs8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (from, to) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(from + 1, to)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else {\n            val (min,\
    \ max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            (min + 1 until max).map(planets(_)).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) Nil\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) List()\n        else if (i1 < i2) planets.slice(i1\
    \ + 1, i2)\n        else planets.slice(i2 + 1, i1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 < 0 || p2 < 0) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1 + 1)\n        return planets.slice(i1, i2 + 1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_gpsuo7.scala:23)\n\tat Problem.main(tmpq_gpsuo7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2, i1 + 1)\n        planets.slice(i1, i2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1mctacjv.scala:23)\n\tat Problem.main(tmp1mctacjv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) List()\n        else if (i1 < i2) planets.slice(i1\
    \ + 1, i2)\n        else planets.slice(i2 + 1, i1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        else return planets.slice(p1, p2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4sqfjs8y.scala:23)\n\tat Problem.main(tmp4sqfjs8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        else return planets.slice(p1, p2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4sqfjs8y.scala:23)\n\tat Problem.main(tmp4sqfjs8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else {\n            val (min,\
    \ max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min +\
    \ 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n \
    \           if (p1 < p2) {\n                planets.slice(p1 + 1, p2)\n      \
    \      } else {\n                planets.slice(p2 + 1, p1)\n            }\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        if (planets.contains(planet1) && planets.contains(planet2)) {\n   \
    \         val i1 = planets.indexOf(planet1)\n            val i2 = planets.indexOf(planet2)\n\
    \            val (min, max) = if (i1 < i2) (i1, i2) else (i2, i1)\n          \
    \  planets.slice(min + 1, max)\n        } else List()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        planets.slice(p1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf6se7_e7.scala:23)\n\tat Problem.main(tmpf6se7_e7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) {\n   \
    \         planets.slice(p1 + 1, p2)\n        } else {\n            planets.slice(p2\
    \ + 1, p1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009201
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        else return planets.slice(p1, p2 + 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp719dkk2j.scala:23)\n\tat Problem.main(tmp719dkk2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        else return planets.slice(p1, p2)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4sqfjs8y.scala:23)\n\tat Problem.main(tmp4sqfjs8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else {\n            val (min,\
    \ max) = if (p1 < p2) (p1, p2) else (p2, p1)\n            planets.slice(min +\
    \ 1, max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 < 0 || p2 < 0) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1).reverse\n        return planets.slice(p1, p2)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxvt53vd0.scala:23)\n\tat Problem.main(tmpxvt53vd0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009201
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) List()\n        else if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val index1 = planets.indexOf(planet1)\n        val index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) Nil\n        else {\n            val\
    \ (min, max) = if (index1 < index2) (index1, index2) else (index2, index1)\n \
    \           planets.slice(min + 1, max)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val planet1Index = planets.indexOf(planet1)\n        val planet2Index\
    \ = planets.indexOf(planet2)\n        if (planet1Index == -1 || planet2Index ==\
    \ -1) return List()\n        val start = min(planet1Index, planet2Index)\n   \
    \     val end = max(planet1Index, planet2Index)\n        planets.slice(start,\
    \ end + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8s35zmmk.scala:24)\n\tat Problem.main(tmp8s35zmmk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        if (i1 > i2) return\
    \ planets.slice(i2 + 1, i1)\n        planets.slice(i1 + 1, i2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (a, b) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(a + 1, b)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val min = min(p1, p2)\n\
    \        val max = max(p1, p2)\n        planets.slice(min + 1, max)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7tkbkow7.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max(p1, p2)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1)\n        planets.slice(p1, p2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf6se7_e7.scala:23)\n\tat Problem.main(tmpf6se7_e7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 < p2) planets.slice(p1\
    \ + 1, p2)\n        else planets.slice(p2 + 1, p1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val i1 = planets.indexOf(planet1)\n        val i2 = planets.indexOf(planet2)\n\
    \        if (i1 == -1 || i2 == -1) return List()\n        val (min, max) = if\
    \ (i1 < i2) (i1, i2) else (i2, i1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        if (p1 > p2) return\
    \ planets.slice(p2, p1 + 1)\n        planets.slice(p1, p2 + 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrf1ekf7.scala:23)\n\tat Problem.main(tmpjrf1ekf7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (min, max) = if\
    \ (p1 < p2) (p1, p2) else (p2, p1)\n        planets.slice(min + 1, max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    def bf(planet1 : String,\
    \ planet2 : String) : List[String] = {\n        val planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n        val p1 = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n\
    \        if (p1 == -1 || p2 == -1) return List()\n        val (a, b) = if (p1\
    \ < p2) (p1, p2) else (p2, p1)\n        planets.slice(a + 1, b)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009200
