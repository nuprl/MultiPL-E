name: HumanEval_107_even_odd_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a tuple that has the number of even and\
  \ odd\n    // integer palindromes that fall within the range(1, n), inclusive.\n\
  \    // Example 1:\n    // Explanation:\n    // Integer palindrome are 1, 2, 3.\
  \ one of them is even, and two of them are odd.\n    // Example 2:\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even,\
  \ and 6 of them are odd.\n    // Note:\n    // 1. 1 <= n <= 10^3\n    // 2. returned\
  \ tuple has the number of even and odd integer palindromes respectively.\n    def\
  \ evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l,\
  \ 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l,\
  \ 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l,\
  \ 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l,\
  \ 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"
completions: ["        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).size\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n    \
    \            else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        return (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        def\
    \ isPalindrome(n : Long) : Boolean = {\n            val s = n.toString\n     \
    \       val l = s.length\n            for (i <- 0 until l / 2) {\n           \
    \     if (s(i) != s(l - 1 - i)) return false\n            }\n            true\n\
    \        }\n        var even = 0L\n        var odd = 0L\n        for (i <- 1L\
    \ to n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0)\
    \ even += 1\n                else odd += 1\n            }\n        }\n       \
    \ (even, odd)", "        var even = 0L\n        var odd = 0L\n        for (i <-\
    \ 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n       \
    \         if (i % 2 == 0) even += 1\n                else odd += 1\n         \
    \   }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        def isPalindrome(n : Long) : Boolean = {\n   \
    \         val s = n.toString\n            s == s.reverse\n        }\n        val\
    \ even = (1L to n).filter(x => isPalindrome(x) && x % 2 == 0).size\n        val\
    \ odd = (1L to n).filter(x => isPalindrome(x) && x % 2 == 1).size\n        (even,\
    \ odd)", "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ evens = palindromes.filter(x => x % 2 == 0).length\n        val odds = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (evens, odds)", "        def isPalindrome(n :\
    \ Long) : Boolean = {\n            val s = n.toString\n            s == s.reverse\n\
    \        }\n        def isEven(n : Long) : Boolean = {\n            n % 2 == 0\n\
    \        }\n        var even = 0L\n        var odd = 0L\n        for (i <- 1L\
    \ to n) {\n            if (isPalindrome(i)) {\n                if (isEven(i))\
    \ even += 1\n                else odd += 1\n            }\n        }\n       \
    \ (even, odd)", "        def isPalindrome(n : Long) : Boolean = {\n          \
    \  val s = n.toString\n            s == s.reverse\n        }\n        def isEven(n\
    \ : Long) : Boolean = n % 2 == 0\n        var even = 0L\n        var odd = 0L\n\
    \        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n          \
    \      if (isEven(i)) even += 1\n                else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes\
    \ += i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even += 1 else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        return (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i.toString)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n        }\n \
    \       val even = palindromes.filter(_ % 2 == 0).length\n        val odd = palindromes.filter(_\
    \ % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val digits = n.toString.length\n        val even\
    \ = digits / 2\n        val odd = digits - even\n        val evenPalindrome =\
    \ pow(10, even).toLong - 1\n        val oddPalindrome = pow(10, odd).toLong -\
    \ 1\n        return (evenPalindrome, oddPalindrome)", "        val even = (1 to\
    \ 9).map(x => x * pow(10, x - 1).toLong).sum\n        val odd = (1 to 9).map(x\
    \ => x * pow(10, x).toLong).sum\n        val even2 = (1 to 9).map(x => x * pow(10,\
    \ x - 1).toLong).sum\n        val odd2 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n\
    \        val even3 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n      \
    \  val odd3 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val even4\
    \ = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n        val odd4 = (1 to\
    \ 9).map(x => x * pow(10, x).toLong).sum\n        val even5 = (1 to 9).map(x =>\
    \ x * pow(10, x - 1).toLong).sum\n        val odd5 = (1 to 9).map(x => x * pow(10,\
    \ x).toLong).sum\n        val even6 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n\
    \        val odd6 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val\
    \ even7 = (1 to 9).map(x => x * pow(10, x - 1).toLong).sum\n        val odd7 =\
    \ (1 to 9).map(x => x * pow(10, x).toLong).sum\n        val even8 = (1 to 9).map(x\
    \ => x * pow(10, x - 1).toLong).sum\n        val odd8 = (1 to 9).map(x => x *\
    \ pow(10, x).toLong).sum\n        val even9 = (1 to 9).map(x => x * pow(10, x\
    \ - 1).toLong).sum\n        val odd9 = (1 to 9).map(x => x * pow(10, x).toLong).sum\n\
    \        val even10 = (1 to 9", "        var even = 0L\n        var odd = 0L\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n     \
    \           if (i % 2 == 0) even += 1\n                else odd += 1\n       \
    \     }\n        }\n        (even, odd)", "        var even = 0L\n        var\
    \ odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(i => i.toString\
    \ == i.toString.reverse && i % 2 == 0).length\n        val odd = (1 to n.toInt).filter(i\
    \ => i.toString == i.toString.reverse && i % 2 == 1).length\n        (even, odd)",
  "        val (even, odd) = (new ArrayBuffer[Long](), new ArrayBuffer[Long]())\n\
    \        def helper(n : Long) : Unit = {\n            if (n == 0) return\n   \
    \         val d = n % 10\n            if (d % 2 == 0) even += n\n            else\
    \ odd += n\n            helper(n / 10)\n        }\n        helper(n)\n       \
    \ (even.size, odd.size)", "        var even = 0L\n        var odd = 0L\n     \
    \   for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n          \
    \      if (i % 2 == 0) even += 1\n                else odd += 1\n            }\n\
    \        }\n        return (even, odd)", "        var even = 0\n        var odd\
    \ = 0\n        for (i <- 1 to n.toInt) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val evens = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odds = palindromes.filter(x => x % 2 == 1).length\n        (evens,\
    \ odds)", "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        return (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (n + 1) / 2\n        val odd = n / 2\n        (even, odd)", "   \
    \     val palindromes = new ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val even = palindromes.filter(_ % 2 == 0).length\n   \
    \     val odd = palindromes.filter(_ % 2 == 1).length\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).size\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n    \
    \            else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes\
    \ += i\n        }\n        val evens = palindromes.filter(_ % 2 == 0).length\n\
    \        val odds = palindromes.filter(_ % 2 == 1).length\n        (evens, odds)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        val\
    \ palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n     \
    \       if (isPalindrome(i)) palindromes += i\n        }\n        val evens =\
    \ palindromes.filter(_ % 2 == 0).length\n        val odds = palindromes.filter(_\
    \ % 2 == 1).length\n        (evens, odds)", "        var even = 0L\n        var\
    \ odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to 9).map(x\
    \ => x * 10).sum + (1 to 9).map(x => x).sum\n        val odd = (1 to 9).map(x\
    \ => x).sum\n        val even2 = (1 to 9).map(x => x * 100).sum + (1 to 9).map(x\
    \ => x * 10).sum + (1 to 9).map(x => x).sum\n        val odd2 = (1 to 9).map(x\
    \ => x * 10).sum + (1 to 9).map(x => x).sum\n        val even3 = (1 to 9).map(x\
    \ => x * 1000).sum + (1 to 9).map(x => x * 100).sum + (1 to 9).map(x => x * 10).sum\
    \ + (1 to 9).map(x => x).sum\n        val odd3 = (1 to 9).map(x => x * 100).sum\
    \ + (1 to 9).map(x => x * 10).sum + (1 to 9).map(x => x).sum\n        val even4\
    \ = (1 to 9).map(x => x * 10000).sum + (1 to 9).map(x => x * 1000).sum + (1 to\
    \ 9).map(x => x * 100).sum + (1 to 9).map(x => x * 10).sum + (1 to 9).map(x =>\
    \ x).sum\n        val odd4 = (1 to 9).map(x => x * 1000).sum + (1 to 9).map(x\
    \ => x * 100).sum + (1 to 9).map(x => x * 10).sum + (1 to 9).map(x => x).sum\n\
    \        val even5 = (1 to 9).map(x => x * 100000).sum + (1 to 9).map(x => x *\
    \ 10000).sum + (1 to 9).map(x => x * 1000).sum + (1 to 9).map(x => x * 100).sum\
    \ + (1 to 9).map(x => x * 10).sum + (1 to 9).map(x => x).sum\n        val odd5\
    \ = (1 to 9).map(x => x * 10000).sum + (1 to 9).map(x => x * 1000).sum +", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i.toString == i.toString.reverse) {\n          \
    \      if (i % 2 == 0) even += 1 else odd += 1\n            }\n        }\n   \
    \     (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ evens = palindromes.filter(_ % 2 == 0).length\n        val odds = palindromes.filter(_\
    \ % 2 == 1).length\n        (evens, odds)", "        val s = n.toString\n    \
    \    val l = s.length\n        val even = (l + 1) / 2\n        val odd = l / 2\n\
    \        if (s(0) == '1') (even, odd)\n        else (even - 1, odd + 1)", "  \
    \      val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i.toString)) {\n                if (i % 2 == 0)\
    \ even += 1\n                else odd += 1\n            }\n        }\n       \
    \ (even, odd)", "        val even = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => isPalindrome(x)\
    \ && x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        return (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        val even = palindromes.filter(x => x % 2 == 0).length\n\
    \        val odd = palindromes.filter(x => x % 2 == 1).length\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      var i = 1L\n        while (i <= n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n            i += 1\n        }\n        (even, odd)", "       \
    \ val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x\
    \ % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "        val\
    \ palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n     \
    \       if (isPalindrome(i)) palindromes += i\n        }\n        val even = palindromes.filter(i\
    \ => i % 2 == 0).length\n        val odd = palindromes.filter(i => i % 2 == 1).length\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        return (even, odd)", "        var even = 0L\n        var odd =\
    \ 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) even += 1\n      \
    \          else odd += 1\n            }\n        }\n        return (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        var even = 0L\n        var odd = 0L\n        for (i\
    \ <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        return (even,\
    \ odd)", "        val palindromes = new ArrayBuffer[Long]\n        for (i <- 1\
    \ to n.toInt) {\n            if (isPalindrome(i)) palindromes += i\n        }\n\
    \        val evens = palindromes.filter(_ % 2 == 0).length\n        val odds =\
    \ palindromes.filter(_ % 2 == 1).length\n        (evens, odds)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n    \
    \            else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       val palindromes = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) even += 1\n      \
    \          else odd += 1\n            }\n        }\n        (even, odd)", "  \
    \      var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        return (even, odd)", " \
    \       var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i.toString)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        return (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        return (even, odd)", "        var even = 0L\n        var odd = 0L\n \
    \       for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n      \
    \          if (i % 2 == 0) even += 1\n                else odd += 1\n        \
    \    }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).size\n        val odd = (1\
    \ to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).size\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        return Tuple2(even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ even = palindromes.filter(x => x % 2 == 0).length\n        val odd = palindromes.filter(x\
    \ => x % 2 == 1).length\n        (even, odd)", "        var even = 0\n       \
    \ var odd = 0\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n       \
    \         if (i % 2 == 0) even += 1\n                else odd += 1\n         \
    \   }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString)) {\n       \
    \         if (i % 2 == 0) even += 1\n                else odd += 1\n         \
    \   }\n        }\n        (even, odd)", "        val even = (1 to 9).map(x =>\
    \ x * 10 + x).sum\n        val odd = (1 to 9).map(x => x * 100 + x).sum\n    \
    \    var result = (0L, 0L)\n        var i = 1\n        while (i <= n) {\n    \
    \        if (i <= 9) {\n                result = (result._1 + 1, result._2)\n\
    \            } else if (i <= 99) {\n                result = (result._1, result._2\
    \ + 1)\n            } else if (i <= 999) {\n                result = (result._1\
    \ + even, result._2 + odd)\n            } else {\n                result = (result._1\
    \ + even * 10, result._2 + odd * 10)\n            }\n            i *= 10\n   \
    \     }\n        result", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        return (even,\
    \ odd)", "        var even = 0\n        var odd = 0\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) even\
    \ += 1\n                else odd += 1\n            }\n        }\n        (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        var even = 0L\n        var odd = 0L\n        for (i\
    \ <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if (i\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        return (even, odd)", "        var even = 0L\n        var odd =\
    \ 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        return (even, odd)", "        val even = (1\
    \ to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 0).length\n\
    \        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        return (even, odd)", "        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        return (even, odd)", "        var even = 0L\n\
    \        var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        def isPalindrome(n :\
    \ Long) : Boolean = {\n            val s = n.toString\n            s == s.reverse\n\
    \        }\n        def isEven(n : Long) : Boolean = n % 2 == 0\n        val palindromes\
    \ = (1 to n.toInt).filter(isPalindrome(_))\n        val evens = palindromes.filter(isEven(_))\n\
    \        val odds = palindromes.filter(!isEven(_))\n        (evens.length, odds.length)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\
    \ else odd += 1\n            }\n        }\n        (even, odd)", "        val\
    \ even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2\
    \ == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        var even = 0L\n    \
    \    var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val palindromes = new\
    \ ArrayBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ palindromes += i\n        }\n        val evens = palindromes.filter(x => x %\
    \ 2 == 0).length\n        val odds = palindromes.filter(x => x % 2 == 1).length\n\
    \        (evens, odds)", "        var even = 0L\n        var odd = 0L\n      \
    \  for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n           \
    \     if (i % 2 == 0) even += 1\n                else odd += 1\n            }\n\
    \        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString ==\
    \ x.toString.reverse && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).size\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).size\n        (even, odd)", "        val\
    \ even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2\
    \ == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(i\
    \ => i.toString == i.toString.reverse && i % 2 == 0).size\n        val odd = (1\
    \ to n.toInt).filter(i => i.toString == i.toString.reverse && i % 2 == 1).size\n\
    \        (even, odd)", "        val palindromes = ArrayBuffer[Long]()\n      \
    \  for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s\
    \ == s.reverse) palindromes += i\n        }\n        val evens = palindromes.filter(x\
    \ => x % 2 == 0).length\n        val odds = palindromes.length - evens\n     \
    \   (evens, odds)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n       \
    \         if (i % 2 == 0) even += 1\n                else odd += 1\n         \
    \   }\n        }\n        (even, odd)", "        var even = 0L\n        var odd\
    \ = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        var even = 0L\n        var odd = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i.toString == i.toString.reverse) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        def isPalindrome(n : Long)\
    \ : Boolean = {\n            val s = n.toString\n            s == s.reverse\n\
    \        }\n        var even = 0L\n        var odd = 0L\n        for (i <- 1L\
    \ to n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0)\
    \ even += 1\n                else odd += 1\n            }\n        }\n       \
    \ (even, odd)", "        var even = 0L\n        var odd = 0L\n        for (i <-\
    \ 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        val even = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 1).length\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).size\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n    \
    \            else odd += 1\n            }\n        }\n        return (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) palindromes += i\n        }\n        val\
    \ evens = palindromes.filter(x => x % 2 == 0).size\n        val odds = palindromes.filter(x\
    \ => x % 2 == 1).size\n        (evens, odds)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        val sqrt = sqrt(n).toLong\n        val even =\
    \ (1L to sqrt).filter(x => x % 2 == 0).map(x => x * x).filter(x => x <= n).length\n\
    \        val odd = (1L to sqrt).filter(x => x % 2 == 1).map(x => x * x).filter(x\
    \ => x <= n).length\n        (even, odd)", "        val even = (1 to n.toInt).filter(x\
    \ => x.toString == x.toString.reverse && x % 2 == 0).length\n        val odd =\
    \ (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2 == 1).length\n\
    \        (even, odd)", "        var evenCount = 0L\n        var oddCount = 0L\n\
    \        for (i <- 1L to n) {\n            if (isPalindrome(i)) {\n          \
    \      if (i % 2 == 0) evenCount += 1\n                else oddCount += 1\n  \
    \          }\n        }\n        return (evenCount, oddCount)", "        var even\
    \ = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if\
    \ (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n           \
    \     else odd += 1\n            }\n        }\n        (even, odd)", "       \
    \ val palindromes = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n \
    \           if (isPalindrome(i)) palindromes += i\n        }\n        val even\
    \ = palindromes.filter(_ % 2 == 0).length\n        val odd = palindromes.filter(_\
    \ % 2 == 1).length\n        (even, odd)", "        var even = 0L\n        var\
    \ odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (i.toString.reverse\
    \ == i.toString) {\n                if (i % 2 == 0) even += 1\n              \
    \  else odd += 1\n            }\n        }\n        (even, odd)", "        val\
    \ even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse && x % 2\
    \ == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 1).length\n        (even, odd)", "        var even = 0L\n      \
    \  var odd = 0L\n        for (i <- 1 to n.toInt) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) even += 1\n      \
    \          else odd += 1\n            }\n        }\n        (even, odd)", "  \
    \      val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).length\n        (even, odd)", "       \
    \ var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n   \
    \         if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        var even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        (even, odd)",
  "        val even = (1 to n.toInt).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).size\n        val odd = (1 to n.toInt).filter(x => x.toString\
    \ == x.toString.reverse && x % 2 == 1).size\n        (even, odd)", "        var\
    \ even = 0L\n        var odd = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n    \
    \            else odd += 1\n            }\n        }\n        (even, odd)"]
stop_tokens:
- "\n    }\n"
