name: HumanEval_96_count_up_to
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement a function that takes an non-negative integer and returns an array\
  \ of the first n\n    // integers that are prime numbers and less than n.\n    //\
  \ for example:\n    def countUpTo(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
  \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
  \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
  \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
  \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
  \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
  \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
  \ 97l.toLong))));\n    }\n\n}\n"
completions: ["        var result = List[Long]()\n        for (i <- 1L to n) {\n \
    \           result = result :+ i\n        }\n        return result", "       \
    \ val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n          \
    \  if (isPrime(i)) primes += i\n        }\n        primes.toList", "        var\
    \ list = List[Long]()\n        for (i <- 1L to n) {\n            list = list :+\
    \ i\n        }\n        list", "        var list = List[Long]()\n        for (i\
    \ <- 1L to n) {\n            list = list :+ i\n        }\n        list", "   \
    \     val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n      \
    \      if (isPrime(i)) {\n                primes += i\n            }\n       \
    \ }\n        primes.toList", "        var result = List[Long]()\n        for (i\
    \ <- 1L to n) {\n            result = result :+ i\n        }\n        return result",
  "        val l = ListBuffer[Long]()\n        for (i <- 2L to n) {\n            l\
    \ += i\n        }\n        l.toList", "        var result = List[Long]()\n   \
    \     for (i <- 2L to n) {\n            if (isPrime(i)) {\n                result\
    \ = result :+ i\n            }\n        }\n        result", "        val list\
    \ = new ListBuffer[Long]\n        for (i <- 1L to n) {\n            list += i\n\
    \        }\n        list.toList", "        var result = List[Long]()\n       \
    \ for (i <- 1L to n) {\n            result = result :+ i\n        }\n        return\
    \ result", "        var result = List[Long]()\n        for (i <- 1L to n) {\n\
    \            result = result :+ i\n        }\n        return result", "      \
    \  if (n == 0) return List()\n        else return countUpTo(n - 1) :+ n", "  \
    \      var list = List[Long]()\n        for (i <- 1L to n) {\n            list\
    \ = list :+ i\n        }\n        list", "        var result = List[Long]()\n\
    \        for (i <- 1L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        var list = List[Long]()\n        for (i <- 2L\
    \ to n) {\n            list = list :+ i\n        }\n        return list", "  \
    \      val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n     \
    \       if (isPrime(i)) primes += i\n        }\n        primes.toList", "    \
    \    var list = List[Long]()\n        for (i <- 1L to n) {\n            list =\
    \ list :+ i\n        }\n        list", "        var sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 0 until n.toInt) sieve(i) = true\n        sieve(0) = false\n\
    \        sieve(1) = false\n        for (i <- 2 until n.toInt) {\n            if\
    \ (sieve(i)) {\n                var j = i + i\n                while (j < n.toInt)\
    \ {\n                    sieve(j) = false\n                    j += i\n      \
    \          }\n            }\n        }\n        var result = List[Long]()\n  \
    \      for (i <- 0 until n.toInt) {\n            if (sieve(i)) result = result\
    \ :+ i\n        }\n        return result", "        var result = List[Long]()\n\
    \        for (i <- 1L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        var list = List[Long]()\n        for (i <- 2L\
    \ to n) {\n            list = list :+ i\n        }\n        return list", "  \
    \      val primes = ListBuffer[Long]()\n        for (i <- 2L to n) {\n       \
    \     if (isPrime(i)) primes += i\n        }\n        primes.toList", "      \
    \  def countUpToHelper(n : Long, acc : List[Long]) : List[Long] = {\n        \
    \    if (n == 0) acc\n            else countUpToHelper(n - 1, n :: acc)\n    \
    \    }\n        countUpToHelper(n, List())", "        var l = List[Long]()\n \
    \       for (i <- 2L to n) {\n            l = i :: l\n        }\n        return\
    \ l", "        var list = List[Long]()\n        for (i <- 1L to n) {\n       \
    \     list = list :+ i\n        }\n        list", "        var result = List[Long]()\n\
    \        for (i <- 1L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        var result = List[Long]()\n        for (i <-\
    \ 1L to n) {\n            result = result :+ i\n        }\n        return result",
  "        var result = List[Long]()\n        for (i <- 2L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 2L to n) {\n            list = list :+ i\n        }\n     \
    \   return list", "        var list = List[Long]()\n        for (i <- 2L to n)\
    \ {\n            list = list :+ i\n        }\n        return list", "        var\
    \ result = List[Long]()\n        for (i <- 1L to n) {\n            result = result\
    \ :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 2 to n.toInt) {\n            list = list :+ i.toLong\n    \
    \    }\n        return list", "        var list = List[Long]()\n        var i\
    \ = 2L\n        while (i < n) {\n            list = list :+ i\n            i +=\
    \ 1\n        }\n        list", "        var result = List[Long]()\n        for\
    \ (i <- 2L to n) {\n            if (isPrime(i)) {\n                result = result\
    \ :+ i\n            }\n        }\n        result", "        val primes = new ListBuffer[Long]\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        val primes = ListBuffer[Long]()\n    \
    \    for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n        }\n\
    \        primes.toList", "        var result = List[Long]()\n        for (i <-\
    \ 2 to n.toInt) {\n            result = result :+ i.toLong\n        }\n      \
    \  return result", "        var result = List[Long]()\n        for (i <- 1L to\
    \ n) {\n            result = result :+ i\n        }\n        return result", " \
    \       var list = List[Long]()\n        for (i <- 1L to n) {\n            list\
    \ = list :+ i\n        }\n        list", "        var result = List[Long]()\n\
    \        for (i <- 2L to n) {\n            result = i :: result\n        }\n \
    \       return result", "        var result = List[Long]()\n        for (i <-\
    \ 2L to n) {\n            if (isPrime(i)) {\n                result = result :+\
    \ i\n            }\n        }\n        result", "        var count = 0L\n    \
    \    var result = List[Long]()\n        while (count < n) {\n            result\
    \ = result :+ count\n            count += 1\n        }\n        result", "   \
    \     var result = List[Long]()\n        for (i <- 2L to n) {\n            if\
    \ (isPrime(i)) {\n                result = result :+ i\n            }\n      \
    \  }\n        result", "        var list = List[Long]()\n        for (i <- 1L\
    \ to n) {\n            list = list :+ i\n        }\n        list", "        var\
    \ result = List[Long]()\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ {\n                result = result :+ i\n            }\n        }\n        result",
  "        val primes = new ArrayBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n        \
    \        primes += i\n                for (j <- i until n.toInt by i) {\n    \
    \                sieve(j) = true\n                }\n            }\n        }\n\
    \        primes.toList", "        var result = List[Long]()\n        for (i <-\
    \ 2L to n) {\n            if (isPrime(i)) {\n                result = result :+\
    \ i\n            }\n        }\n        result", "        var result = List[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ result = result :+ i\n            }\n        }\n        result", "        val\
    \ primes = new ListBuffer[Long]()\n        for (i <- 2L to n) {\n            if\
    \ (isPrime(i)) primes += i\n        }\n        primes.toList", "        var result\
    \ = List[Long]()\n        for (i <- 2L to n) {\n            if (isPrime(i)) {\n\
    \                result = result :+ i\n            }\n        }\n        result",
  "        var list = List[Long]()\n        for (i <- 1L to n) {\n            list\
    \ = list :+ i\n        }\n        list", "        val primes = new ListBuffer[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ primes += i\n            }\n        }\n        primes.toList", "        var\
    \ result = List[Long]()\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ {\n                result = result :+ i\n            }\n        }\n        result",
  "        val primes = ListBuffer[Long]()\n        for (i <- 2L to n) {\n       \
    \     if (isPrime(i)) {\n                primes += i\n            }\n        }\n\
    \        primes.toList", "        var result = List[Long]()\n        for (i <-\
    \ 2L to n) {\n            result = i :: result\n        }\n        return result",
  "        var l = List[Long]()\n        for (i <- 2 to n.toInt) {\n            l\
    \ = i :: l\n        }\n        return l", "        var result = List[Long]()\n\
    \        for (i <- 2L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        var result = List[Long]()\n        for (i <-\
    \ 1L to n) {\n            result = result :+ i\n        }\n        return result",
  "        var list = List[Long]()\n        for (i <- 2 to n.toInt) {\n          \
    \  if (isPrime(i)) {\n                list = list :+ i\n            }\n      \
    \  }\n        return list", "        val primes = new ListBuffer[Long]\n     \
    \   for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n        }\n\
    \        primes.toList", "        var result = List[Long]()\n        for (i <-\
    \ 1L to n) {\n            result = result :+ i\n        }\n        return result",
  "        var l = List[Long]()\n        for (i <- 1L to n) {\n            l = i ::\
    \ l\n        }\n        return l", "        var result = List[Long]()\n      \
    \  for (i <- 1L to n) {\n            result = result :+ i\n        }\n       \
    \ return result", "        var result = List[Long]()\n        for (i <- 2L to\
    \ n) {\n            if (isPrime(i)) {\n                result = result :+ i\n\
    \            }\n        }\n        result", "        var result = List[Long]()\n\
    \        for (i <- 1L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        val primes = new ListBuffer[Long]\n        val\
    \ sieve = new Array[Boolean](n.toInt)\n        for (i <- 2 until n.toInt) {\n\
    \            if (!sieve(i)) {\n                primes += i\n                for\
    \ (j <- i until n.toInt by i) {\n                    sieve(j) = true\n       \
    \         }\n            }\n        }\n        primes.toList", "        val primes\
    \ = new ListBuffer[Long]\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ {\n                primes += i\n            }\n        }\n        primes.toList",
  "        val primes = new ListBuffer[Long]\n        var i = 2L\n        while (i\
    \ < n) {\n            if (isPrime(i)) {\n                primes += i\n       \
    \     }\n            i += 1\n        }\n        primes.toList", "        var result\
    \ = List[Long]()\n        for (i <- 1L to n) {\n            result = result :+\
    \ i\n        }\n        return result", "        val primes = ListBuffer[Long]()\n\
    \        var i = 2L\n        while (i < n) {\n            if (isPrime(i)) primes\
    \ += i\n            i += 1\n        }\n        primes.toList", "        val primes\
    \ = new ArrayBuffer[Long]\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ primes += i\n        }\n        primes.toList", "        if (n == 0) return\
    \ List()\n        else return countUpTo(n - 1) :+ n", "        var result = List[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ result = result :+ i\n            }\n        }\n        result", "        var\
    \ list = List[Long]()\n        for (i <- 2L to n) {\n            list = list :+\
    \ i\n        }\n        return list", "        val primes = new ArrayBuffer[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        var l = List[Long]()\n        for (i <-\
    \ 2L to n) {\n            l = i :: l\n        }\n        return l", "        val\
    \ primes = new ArrayBuffer[Long]()\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            sieve(i) = true\n        }\n\
    \        for (i <- 2 until n.toInt) {\n            if (sieve(i)) {\n         \
    \       primes += i\n                for (j <- i until n.toInt by i) {\n     \
    \               sieve(j) = false\n                }\n            }\n        }\n\
    \        primes.toList", "        def countUpToHelper(n : Long, acc : List[Long])\
    \ : List[Long] = {\n            if (n == 0) acc\n            else countUpToHelper(n\
    \ - 1, n :: acc)\n        }\n        countUpToHelper(n, List())", "        val\
    \ list = new ListBuffer[Long]()\n        for (i <- 2L to n) {\n            list\
    \ += i\n        }\n        return list.toList", "        val primes = new ListBuffer[Long]()\n\
    \        primes += 2\n        for (i <- 3L to n) {\n            if (primes.forall(i\
    \ % _ != 0)) {\n                primes += i\n            }\n        }\n      \
    \  primes.toList", "        val primes = new ListBuffer[Long]\n        for (i\
    \ <- 2L to n) {\n            if (isPrime(i)) primes += i\n        }\n        primes.toList",
  "        var result = List[Long]()\n        for (i <- 1L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        var l = List[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            l = l :+ i.toLong\n        }\n\
    \        return l", "        var list = List[Long]()\n        for (i <- 1L to\
    \ n) {\n            list = list :+ i\n        }\n        list", "        def countUpToHelper(n\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n  \
    \          else countUpToHelper(n - 1, n :: acc)\n        }\n        countUpToHelper(n,\
    \ List())", "        var result = List[Long]()\n        for (i <- 1L to n) {\n\
    \            result = result :+ i\n        }\n        return result", "      \
    \  var l = List[Long]()\n        for (i <- 1 to n.toInt) {\n            l = l\
    \ :+ i.toLong\n        }\n        return l", "        var result = List[Long]()\n\
    \        for (i <- 1L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        val list = new ListBuffer[Long]\n        for\
    \ (i <- 2L to n) {\n            list += i\n        }\n        return list.toList",
  "        var result = List[Long]()\n        for (i <- 2L to n) {\n            if\
    \ (isPrime(i)) result = i :: result\n        }\n        result", "        var\
    \ result = ListBuffer[Long]()\n        for (i <- 1L to n) {\n            result\
    \ += i\n        }\n        result.toList", "        var result = List[Long]()\n\
    \        for (i <- 2 to n.toInt) {\n            result = result :+ i.toLong\n\
    \        }\n        return result", "        var result = List[Long]()\n     \
    \   for (i <- 1L to n) {\n            result = result :+ i\n        }\n      \
    \  return result", "        var primes : List[Long] = List()\n        for (i <-\
    \ 2L to n) {\n            if (isPrime(i)) primes = i :: primes\n        }\n  \
    \      primes", "        val list = new ListBuffer[Long]\n        for (i <- 1L\
    \ to n) {\n            list += i\n        }\n        list.toList", "        var\
    \ result = List[Long]()\n        for (i <- 1L to n) {\n            result = result\
    \ :+ i\n        }\n        return result", "        var primes = List[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes = i :: primes\n\
    \        }\n        primes", "        var l = List[Long]()\n        for (i <-\
    \ 1L to n) {\n            l = i :: l\n        }\n        return l", "        var\
    \ result = List[Long]()\n        for (i <- 2L to n) {\n            result = result\
    \ :+ i\n        }\n        return result", "        var result = List[Long]()\n\
    \        for (i <- 1L to n) {\n            result = result :+ i\n        }\n \
    \       return result", "        var l = List[Long]()\n        for (i <- 2L to\
    \ n) {\n            l = i :: l\n        }\n        return l", "        var list\
    \ = List[Long]()\n        for (i <- 2L to n) {\n            list = list :+ i\n\
    \        }\n        return list", "        val primes = new ArrayBuffer[Long]\n\
    \        val isPrime = new Array[Boolean](n.toInt)\n        for (i <- 0 until\
    \ n.toInt) isPrime(i) = true\n        for (i <- 2 until n.toInt) {\n         \
    \   if (isPrime(i)) {\n                primes += i\n                var j = i\n\
    \                while (j < n.toInt) {\n                    isPrime(j) = false\n\
    \                    j += i\n                }\n            }\n        }\n   \
    \     primes.toList", "        var result = List[Long]()\n        for (i <- 2L\
    \ to n) {\n            if (isPrime(i)) {\n                result = result :+ i\n\
    \            }\n        }\n        result", "        var list = List[Long]()\n\
    \        for (i <- 1L to n) {\n            list = list :+ i\n        }\n     \
    \   list", "        var result = List[Long]()\n        for (i <- 2L to n) {\n\
    \            if (isPrime(i)) {\n                result = result :+ i\n       \
    \     }\n        }\n        result", "        val list = ListBuffer[Long]()\n\
    \        for (i <- 1L to n) {\n            list += i\n        }\n        list.toList",
  "        val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n     \
    \       if (isPrime(i)) primes += i\n        }\n        primes.toList", "    \
    \    val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n       \
    \     if (isPrime(i)) primes += i\n        }\n        primes.toList", "      \
    \  var result = List[Long]()\n        for (i <- 1L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 1L to n) {\n            list = list :+ i\n        }\n     \
    \   list", "        val primes = new ListBuffer[Long]\n        for (i <- 2L to\
    \ n) {\n            if (isPrime(i)) primes += i\n        }\n        primes.toList",
  "        var l = List[Long]()\n        for (i <- 2L to n) {\n            l = i ::\
    \ l\n        }\n        return l", "        val l = ListBuffer[Long]()\n     \
    \   for (i <- 1L to n) {\n            l += i\n        }\n        l.toList", " \
    \       val primes = new ListBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt\
    \ + 1)\n        for (i <- 2 to n.toInt) {\n            if (!sieve(i)) {\n    \
    \            primes += i\n                var j = i\n                while (j\
    \ <= n.toInt) {\n                    sieve(j) = true\n                    j +=\
    \ i\n                }\n            }\n        }\n        primes.toList", "  \
    \      val l = ListBuffer[Long]()\n        for (i <- 2L to n) {\n            l\
    \ += i\n        }\n        l.toList", "        var result = List[Long]()\n   \
    \     for (i <- 2L to n) {\n            if (isPrime(i)) {\n                result\
    \ = result :+ i\n            }\n        }\n        result", "        val primes\
    \ = new ListBuffer[Long]\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ primes += i\n        }\n        primes.toList", "        var list = List[Long]()\n\
    \        for (i <- 2L to n) {\n            list = list :+ i\n        }\n     \
    \   return list", "        var result = List[Long]()\n        for (i <- 1L to\
    \ n) {\n            result = result :+ i\n        }\n        return result", " \
    \       var result = List[Long]()\n        for (i <- 2L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 2L to n) {\n            list = list :+ i\n        }\n     \
    \   return list", "        var result = List[Long]()\n        for (i <- 2L to\
    \ n) {\n            result = result :+ i\n        }\n        return result", " \
    \       val primes = new ArrayBuffer[Long]\n        for (i <- 2L to n) {\n   \
    \         var isPrime = true\n            for (j <- 2L to sqrt(i).toLong) {\n\
    \                if (i % j == 0) {\n                    isPrime = false\n    \
    \                break\n                }\n            }\n            if (isPrime)\
    \ primes += i\n        }\n        primes.toList", "        val primes = ListBuffer[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        var result = List[Long]()\n        for\
    \ (i <- 1L to n) {\n            result = result :+ i\n        }\n        return\
    \ result", "        val primes = new ListBuffer[Long]()\n        for (i <- 2L\
    \ to n) {\n            if (isPrime(i)) primes += i\n        }\n        primes.toList",
  "        var result = List[Long]()\n        for (i <- 2L to n) {\n            if\
    \ (isPrime(i)) {\n                result = result :+ i\n            }\n      \
    \  }\n        result", "        var result = List[Long]()\n        for (i <- 1L\
    \ to n) {\n            result = result :+ i\n        }\n        return result",
  "        val primes = new ArrayBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n        \
    \        primes += i\n                for (j <- i until n.toInt by i) {\n    \
    \                sieve(j) = true\n                }\n            }\n        }\n\
    \        primes.toList", "        val primes = new ListBuffer[Long]\n        var\
    \ i = 2L\n        while (i < n) {\n            if (isPrime(i)) primes += i\n \
    \           i += 1\n        }\n        primes.toList", "        var result = List[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ result = result :+ i\n            }\n        }\n        result", "        val\
    \ primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n            if\
    \ (isPrime(i)) primes += i\n        }\n        primes.toList", "        val primes\
    \ = new ListBuffer[Long]\n        var i = 2L\n        while (i < n) {\n      \
    \      if (isPrime(i)) {\n                primes += i\n            }\n       \
    \     i += 1\n        }\n        primes.toList", "        var list = List[Long]()\n\
    \        for (i <- 2L to n) {\n            list = list :+ i\n        }\n     \
    \   return list", "        val primes = ListBuffer[Long]()\n        for (i <-\
    \ 2L to n) {\n            if (isPrime(i)) primes += i\n        }\n        primes.toList",
  "        val primes = new ListBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n        \
    \        primes += i\n                var j = i\n                while (j < n.toInt)\
    \ {\n                    sieve(j) = true\n                    j += i\n       \
    \         }\n            }\n        }\n        primes.toList", "        val result\
    \ = new ListBuffer[Long]()\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ {\n                result += i\n            }\n        }\n        result.toList",
  "        val l = new ListBuffer[Long]\n        for (i <- 2L to n) {\n          \
    \  l += i\n        }\n        l.toList", "        val primes = new ListBuffer[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ primes += i\n            }\n        }\n        primes.toList", "        var\
    \ result = List[Long]()\n        for (i <- 1L to n) {\n            result = result\
    \ :+ i\n        }\n        return result", "        val primes = new ListBuffer[Long]\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        var primes = List[Long]()\n        for\
    \ (i <- 2L to n) {\n            if (isPrime(i)) {\n                primes = i\
    \ :: primes\n            }\n        }\n        primes", "        val primes =\
    \ new ArrayBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n   \
    \     for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n           \
    \     primes += i\n                for (j <- i until n.toInt by i) {\n       \
    \             sieve(j) = true\n                }\n            }\n        }\n \
    \       primes.toList", "        var l = List[Long]()\n        for (i <- 1L to\
    \ n) {\n            l = i :: l\n        }\n        return l", "        val primes\
    \ = new ArrayBuffer[Long]\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ primes += i\n        }\n        primes.toList", "        var result = List[Long]()\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ result = result :+ i\n            }\n        }\n        result", "        val\
    \ primes = new ListBuffer[Long]\n        var i = 2L\n        while (i < n) {\n\
    \            if (isPrime(i)) primes += i\n            i += 1\n        }\n    \
    \    primes.toList", "        var list = List[Long]()\n        for (i <- 2L to\
    \ n) {\n            list = list :+ i\n        }\n        return list", "     \
    \   val primes = new ListBuffer[Long]()\n        for (i <- 2L to n) {\n      \
    \      if (isPrime(i)) primes += i\n        }\n        primes.toList", "     \
    \   var result = List[Long]()\n        for (i <- 2L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 1L to n) {\n            list = list :+ i\n        }\n     \
    \   list", "        var result = List[Long]()\n        for (i <- 1L to n) {\n\
    \            result = result :+ i\n        }\n        return result", "      \
    \  val primes = new ListBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n        \
    \        primes += i\n                var j = i\n                while (j < n.toInt)\
    \ {\n                    sieve(j) = true\n                    j += i\n       \
    \         }\n            }\n        }\n        primes.toList", "        var result\
    \ = List[Long]()\n        for (i <- 1L to n) {\n            result = result :+\
    \ i\n        }\n        return result", "        var list = List[Long]()\n   \
    \     for (i <- 1L to n) {\n            list = list :+ i\n        }\n        list",
  "        var result = List[Long]()\n        for (i <- 1L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 1L to n) {\n            list = list :+ i\n        }\n     \
    \   list", "        val primes = new ListBuffer[Long]\n        val sieve = new\
    \ Array[Boolean](n.toInt + 1)\n        for (i <- 2 to n.toInt) {\n           \
    \ if (!sieve(i)) {\n                primes += i\n                for (j <- i to\
    \ n.toInt by i) {\n                    sieve(j) = true\n                }\n  \
    \          }\n        }\n        primes.toList", "        var l = List[Long]()\n\
    \        for (i <- 1L to n) {\n            l = i :: l\n        }\n        return\
    \ l", "        var list = List[Long]()\n        for (i <- 1L to n) {\n       \
    \     list = list :+ i\n        }\n        list", "        var result = List[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            result = result :+ i.toLong\n\
    \        }\n        return result", "        var result = List[Long]()\n     \
    \   for (i <- 2L to n) {\n            var isPrime = true\n            for (j <-\
    \ 2L to sqrt(i).toLong) {\n                if (i % j == 0) {\n               \
    \     isPrime = false\n                    break\n                }\n        \
    \    }\n            if (isPrime) result = i :: result\n        }\n        result",
  "        val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n     \
    \       if (isPrime(i)) primes += i\n        }\n        primes.toList", "    \
    \    val result = new ListBuffer[Long]()\n        for (i <- 1L to n) {\n     \
    \       result += i\n        }\n        result.toList", "        var list = List[Long]()\n\
    \        for (i <- 1L to n) {\n            list = list :+ i\n        }\n     \
    \   list", "        var list = List[Long]()\n        for (i <- 1L to n) list =\
    \ list :+ i\n        list", "        var result = List[Long]()\n        for (i\
    \ <- 1L to n) {\n            result = result :+ i\n        }\n        return result",
  "        var result = List[Long]()\n        for (i <- 2L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        if (n == 0)\n   \
    \         return List()\n        else\n            return countUpTo(n - 1) :+\
    \ n", "        val primes = new ListBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt\
    \ + 1)\n        for (i <- 2 to n.toInt) {\n            if (!sieve(i)) {\n    \
    \            primes += i\n                for (j <- i to n.toInt by i) {\n   \
    \                 sieve(j) = true\n                }\n            }\n        }\n\
    \        primes.toList", "        var list = List[Long]()\n        for (i <- 2L\
    \ to n) {\n            list = list :+ i\n        }\n        return list", "  \
    \      var result = List[Long]()\n        for (i <- 1L to n) {\n            result\
    \ = result :+ i\n        }\n        return result", "        if (n == 0) {\n \
    \           List()\n        } else {\n            countUpTo(n - 1) :+ n\n    \
    \    }", "        val l = new ListBuffer[Long]\n        for (i <- 1L to n) {\n\
    \            l += i\n        }\n        l.toList", "        val list = new ListBuffer[Long]\n\
    \        for (i <- 2L to n) {\n            list += i\n        }\n        list.toList",
  "        val primes = new ListBuffer[Long]\n        for (i <- 2L to n) {\n     \
    \       if (isPrime(i)) {\n                primes += i\n            }\n      \
    \  }\n        primes.toList", "        val result = new ListBuffer[Long]\n   \
    \     for (i <- 1L to n) {\n            result += i\n        }\n        result.toList",
  "        var l = List[Long]()\n        for (i <- 2L to n) {\n            l = i ::\
    \ l\n        }\n        return l", "        val primes = new ListBuffer[Long]\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        var count = 0L\n        var result = List[Long]()\n\
    \        while (count < n) {\n            result = result :+ count\n         \
    \   count += 1\n        }\n        result", "        var list = List[Long]()\n\
    \        for (i <- 2L to n) {\n            list = list :+ i\n        }\n     \
    \   return list", "        val primes = new ArrayBuffer[Long]()\n        for (i\
    \ <- 2L to n) {\n            if (isPrime(i)) primes += i\n        }\n        primes.toList",
  "        val primes = new ListBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n        \
    \        primes += i\n                for (j <- i until n.toInt by i) {\n    \
    \                sieve(j) = true\n                }\n            }\n        }\n\
    \        primes.toList", "        var result = List[Long]()\n        var i = 2L\n\
    \        while (i < n) {\n            result = result :+ i\n            i += 1\n\
    \        }\n        result", "        var l = List[Long]()\n        for (i <-\
    \ 1L to n) {\n            l = i :: l\n        }\n        return l", "        var\
    \ result = List[Long]()\n        for (i <- 1L to n) {\n            result = result\
    \ :+ i\n        }\n        return result", "        val primes = new ListBuffer[Long]\n\
    \        var i = 2L\n        while (i < n) {\n            if (isPrime(i)) primes\
    \ += i\n            i += 1\n        }\n        primes.toList", "        var result\
    \ = List[Long]()\n        for (i <- 1L to n) {\n            result = result :+\
    \ i\n        }\n        return result", "        val primes = new ListBuffer[Long]()\n\
    \        var i = 2L\n        while (i < n) {\n            if (isPrime(i)) {\n\
    \                primes += i\n            }\n            i += 1\n        }\n \
    \       primes.toList", "        var l = List[Long]()\n        for (i <- 1L to\
    \ n) {\n            l = i :: l\n        }\n        return l", "        val primes\
    \ = new ListBuffer[Long]()\n        for (i <- 2L to n) {\n            if (isPrime(i))\
    \ primes += i\n        }\n        primes.toList", "        val primes = new ArrayBuffer[Long]\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) {\n               \
    \ primes += i\n            }\n        }\n        primes.toList", "        var\
    \ result = List[Long]()\n        for (i <- 2L to n) {\n            result = result\
    \ :+ i\n        }\n        return result", "        var list = List[Long]()\n\
    \        for (i <- 1L to n) {\n            list = list :+ i\n        }\n     \
    \   list", "        var result = List[Long]()\n        for (i <- 2L to n) {\n\
    \            if (isPrime(i)) {\n                result = result :+ i\n       \
    \     }\n        }\n        result", "        var l = List[Long]()\n        for\
    \ (i <- 1 to n.toInt) l = i :: l\n        l", "        val primes = new ListBuffer[Long]\n\
    \        for (i <- 2L to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        var result = List[Long]()\n        for\
    \ (i <- 1L to n) {\n            result = result :+ i\n        }\n        return\
    \ result", "        if (n == 0) {\n            return List[Long]()\n        }\n\
    \        else {\n            return countUpTo(n - 1) :+ n\n        }", "     \
    \   val primes = new ArrayBuffer[Long]\n        val sieve = new Array[Boolean](n.toInt)\n\
    \        for (i <- 2 until n.toInt) {\n            if (!sieve(i)) {\n        \
    \        primes += i\n                for (j <- i until n.toInt by i) {\n    \
    \                sieve(j) = true\n                }\n            }\n        }\n\
    \        primes.toList"]
stop_tokens:
- "\n    }\n"
