name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long],\
  \ Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        val negatives = lst.filter(_ < 0).sortWith(_ > _)\n       \
    \ val positives = lst.filter(_ > 0).sortWith(_ < _)\n        (if (negatives.length\
    \ > 0) Some(negatives(0)) else None, if (positives.length > 0) Some(positives(0))\
    \ else None)", "        var maxNeg = None : Option[Long]\n        var minPos =\
    \ None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (maxNeg == None) maxNeg = Some(i)\n                else if (i\
    \ > maxNeg.get) maxNeg = Some(i)\n            }\n            else if (i > 0) {\n\
    \                if (minPos == None) minPos = Some(i)\n                else if\
    \ (i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        var neg = None : Option[Long]\n        var pos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) neg = Some(i)\n                else if (i > neg.get) neg = Some(i)\n \
    \           }\n            else if (i > 0) {\n                if (pos == None)\
    \ pos = Some(i)\n                else if (i < pos.get) pos = Some(i)\n       \
    \     }\n        }\n        (neg, pos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None\
    \ || i > largestNegative.get) largestNegative = Some(i)\n            } else if\
    \ (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        return (largestNegative, smallestPositive)", "      \
    \  val negatives = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_\
    \ > 0).sorted\n        if (negatives.isEmpty) (None, Some(positives.head))\n \
    \       else if (positives.isEmpty) (Some(negatives.last), None)\n        else\
    \ (Some(negatives.last), Some(positives.head))", "        val negatives = lst.filter(_\
    \ < 0).sorted\n        val positives = lst.filter(_ > 0).sorted\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.last), if (positives.isEmpty) None else Some(positives.head))",
  "        var minPos : Option[Long] = None\n        var maxNeg : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (minPos\
    \ == None || i < minPos.get) minPos = Some(i)\n            } else if (i < 0) {\n\
    \                if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        val neg = lst.filter(_\
    \ < 0).sortWith(_ > _)\n        val pos = lst.filter(_ > 0).sortWith(_ < _)\n\
    \        (if (neg.isEmpty) None else Some(neg.head), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        val neg = lst.filter(_ < 0).sorted\n        val pos\
    \ = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        val negatives = lst.filter(_\
    \ < 0).sorted\n        val positives = lst.filter(_ > 0).sorted\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.last), if (positives.isEmpty) None else Some(positives.head))",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        if (neg.isEmpty) (None, Some(pos.head))\n        else if (pos.isEmpty)\
    \ (Some(neg.last), None)\n        else (Some(neg.last), Some(pos.head))", "  \
    \      val neg = lst.filter(x => x < 0).sorted\n        val pos = lst.filter(x\
    \ => x > 0).sorted\n        if (neg.isEmpty) (None, if (pos.isEmpty) None else\
    \ Some(pos.head))\n        else if (pos.isEmpty) (Some(neg.last), None)\n    \
    \    else (Some(neg.last), Some(pos.head))", "        val neg = lst.filter(_ <\
    \ 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     var neg = None : Option[Long]\n        var pos = None : Option[Long]\n \
    \       for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) neg = Some(i)\n                else if (i > neg.get) neg = Some(i)\n \
    \           }\n            else if (i > 0) {\n                if (pos == None)\
    \ pos = Some(i)\n                else if (i < pos.get) pos = Some(i)\n       \
    \     }\n        }\n        return (neg, pos)", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var minPos = None : Option[Long]\n        var maxNeg\
    \ = None : Option[Long]\n        for (x <- lst) {\n            if (x > 0) {\n\
    \                if (minPos == None || x < minPos.get) minPos = Some(x)\n    \
    \        } else if (x < 0) {\n                if (maxNeg == None || x > maxNeg.get)\
    \ maxNeg = Some(x)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n   \
    \     val neg = if (negs.isEmpty) None else Some(negs.max)\n        val pos =\
    \ if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)", "        var\
    \ largestNegative = None : Option[Long]\n        var smallestPositive = None :\
    \ Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n         \
    \       if (largestNegative == None) largestNegative = Some(i)\n             \
    \   else if (i > largestNegative.get) largestNegative = Some(i)\n            }\n\
    \            else if (i > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative = None : Option[Long]\n   \
    \     var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var minPos =\
    \ None : Option[Long]\n        var maxNeg = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None || i\
    \ > maxNeg.get) maxNeg = Some(i)\n            } else {\n                if (minPos\
    \ == None || i < minPos.get) minPos = Some(i)\n            }\n        }\n    \
    \    (maxNeg, minPos)", "        val negatives = lst.filter(_ < 0).sorted\n  \
    \      val positives = lst.filter(_ > 0).sorted\n        if (negatives.isEmpty)\
    \ (None, if (positives.isEmpty) None else Some(positives.head))\n        else\
    \ if (positives.isEmpty) (Some(negatives.last), None)\n        else (Some(negatives.last),\
    \ Some(positives.head))", "        val negs = lst.filter(_ < 0)\n        val poss\
    \ = lst.filter(_ > 0)\n        val neg = if (negs.isEmpty) None else Some(negs.max)\n\
    \        val pos = if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var largestNegative = None : Option[Long]\n     \
    \   var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        val negatives\
    \ = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_ > 0).sorted\n\
    \        (if (negatives.isEmpty) None else Some(negatives.last), if (positives.isEmpty)\
    \ None else Some(positives.head))", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (x <-\
    \ lst) {\n            if (x < 0) {\n                if (largestNegative == None\
    \ || x > largestNegative.get) largestNegative = Some(x)\n            } else if\
    \ (x > 0) {\n                if (smallestPositive == None || x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || largestNegative.get < i) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || smallestPositive.get > i) smallestPositive = Some(i)\n          \
    \  }\n        }\n        (largestNegative, smallestPositive)", "        var maxNegative\
    \ : Option[Long] = None\n        var minPositive : Option[Long] = None\n     \
    \   for (x <- lst) {\n            if (x < 0) {\n                if (maxNegative\
    \ == None || x > maxNegative.get) maxNegative = Some(x)\n            } else if\
    \ (x > 0) {\n                if (minPositive == None || x < minPositive.get) minPositive\
    \ = Some(x)\n            }\n        }\n        (maxNegative, minPositive)", " \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        (largestNegative, smallestPositive)", "        val negatives\
    \ = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_ > 0).sorted\n\
    \        (if (negatives.isEmpty) None else Some(negatives.last), if (positives.isEmpty)\
    \ None else Some(positives.head))", "        val negatives = lst.filter(_ < 0).sorted\n\
    \        val positives = lst.filter(_ > 0).sorted\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.last), if (positives.isEmpty) None else Some(positives.head))",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n        val\
    \ pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || largestNegative.get < i) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || smallestPositive.get\
    \ > i) smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(_ < 0).sortWith(_ >\
    \ _)\n        val positives = lst.filter(_ > 0).sortWith(_ < _)\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.head), if (positives.isEmpty) None else Some(positives.head))",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var largestNegative : Option[Long] = None\n     \
    \   var smallestPositive : Option[Long] = None\n        for (x <- lst) {\n   \
    \         if (x < 0) {\n                if (largestNegative == None || x > largestNegative.get)\
    \ largestNegative = Some(x)\n            } else if (x > 0) {\n               \
    \ if (smallestPositive == None || x < smallestPositive.get) smallestPositive =\
    \ Some(x)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var maxNeg : Option[Long] = None\n        var minPos : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None || i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n\
    \                if (minPos == None || i < minPos.get) minPos = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var minPos = None :\
    \ Option[Long]\n        var maxNeg = None : Option[Long]\n        for (i <- lst)\
    \ {\n            if (i < 0) {\n                if (maxNeg == None || i > maxNeg.get)\
    \ maxNeg = Some(i)\n            } else {\n                if (minPos == None ||\
    \ i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        var min : Option[Long] = None\n        var max : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i > 0) {\n               \
    \ if (min == None) min = Some(i)\n                else if (i < min.get) min =\
    \ Some(i)\n            }\n            else if (i < 0) {\n                if (max\
    \ == None) max = Some(i)\n                else if (i > max.get) max = Some(i)\n\
    \            }\n        }\n        (max, min)", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || i > largestNegative.get) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n        val\
    \ pos = lst.filter(_ > 0).sorted\n        if (neg.isEmpty) (None, Some(pos.head))\n\
    \        else if (pos.isEmpty) (Some(neg.last), None)\n        else (Some(neg.last),\
    \ Some(pos.head))", "        var neg : Long = 0\n        var pos : Long = 0\n\
    \        var negExists : Boolean = false\n        var posExists : Boolean = false\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (!negExists)\
    \ {\n                    neg = i\n                    negExists = true\n     \
    \           } else {\n                    neg = max(neg, i)\n                }\n\
    \            } else if (i > 0) {\n                if (!posExists) {\n        \
    \            pos = i\n                    posExists = true\n                }\
    \ else {\n                    pos = min(pos, i)\n                }\n         \
    \   }\n        }\n        if (negExists) {\n            if (posExists) {\n   \
    \             return (Some(neg), Some(pos))\n            } else {\n          \
    \      return (Some(neg), None)\n            }\n        } else {\n           \
    \ if (posExists) {\n                return (None, Some(pos))\n            } else\
    \ {\n                return (None, None)\n            }\n        }", "       \
    \ var largestNegative = None : Option[Long]\n        var smallestPositive = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (largestNegative == None) largestNegative = Some(i)\n           \
    \     else if (i > largestNegative.get) largestNegative = Some(i)\n          \
    \  }\n            else if (i > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(x => x < 0).sorted\n\
    \        val positives = lst.filter(x => x > 0).sorted\n        if (negatives.length\
    \ == 0) (None, Some(positives.head))\n        else if (positives.length == 0)\
    \ (Some(negatives.last), None)\n        else (Some(negatives.last), Some(positives.head))",
  "        val negs = lst.filter(x => x < 0)\n        val poss = lst.filter(x => x\
    \ > 0)\n        if (negs.isEmpty && poss.isEmpty) (None, None)\n        else (Some(negs.max),\
    \ Some(poss.min))", "        var maxNeg = Option.empty[Long]\n        var minPos\
    \ = Option.empty[Long]\n        for (i <- lst) {\n            if (i < 0) {\n \
    \               if (maxNeg.isEmpty || i > maxNeg.get) maxNeg = Some(i)\n     \
    \       } else if (i > 0) {\n                if (minPos.isEmpty || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) {\n \
    \                   largestNegative = Some(i)\n                }\n           \
    \ } else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ {\n                    smallestPositive = Some(i)\n                }\n     \
    \       }\n        }\n        return (largestNegative, smallestPositive)", " \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || largestNegative.get < i) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || smallestPositive.get\
    \ > i) smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNegative = None : Option[Long]\n       \
    \ var minPositive = None : Option[Long]\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (maxNegative == None) maxNegative = Some(i)\n\
    \                else maxNegative = Some(max(maxNegative.get, i))\n          \
    \  }\n            else if (i > 0) {\n                if (minPositive == None)\
    \ minPositive = Some(i)\n                else minPositive = Some(min(minPositive.get,\
    \ i))\n            }\n        }\n        (maxNegative, minPositive)", "      \
    \  val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n      \
    \  val neg = if (negs.isEmpty) None else Some(negs.max)\n        val pos = if\
    \ (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)", "        val neg\
    \ = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n   \
    \     (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))",
  "        var neg : Long = 0\n        var pos : Long = 0\n        var negFlag : Boolean\
    \ = false\n        var posFlag : Boolean = false\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (!negFlag) {\n                  \
    \  neg = i\n                    negFlag = true\n                } else {\n   \
    \                 neg = max(neg, i)\n                }\n            } else if\
    \ (i > 0) {\n                if (!posFlag) {\n                    pos = i\n  \
    \                  posFlag = true\n                } else {\n                \
    \    pos = min(pos, i)\n                }\n            }\n        }\n        if\
    \ (negFlag) {\n            if (posFlag) {\n                return (Some(neg),\
    \ Some(pos))\n            } else {\n                return (Some(neg), None)\n\
    \            }\n        } else {\n            if (posFlag) {\n               \
    \ return (None, Some(pos))\n            } else {\n                return (None,\
    \ None)\n            }\n        }", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var maxNeg =\
    \ Option.empty[Long]\n        var minPos = Option.empty[Long]\n        for (x\
    \ <- lst) {\n            if (x < 0) {\n                if (maxNeg.isEmpty || x\
    \ > maxNeg.get) maxNeg = Some(x)\n            } else if (x > 0) {\n          \
    \      if (minPos.isEmpty || x < minPos.get) minPos = Some(x)\n            }\n\
    \        }\n        (maxNeg, minPos)", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        val neg = lst.filter(_ < 0).sorted\n\
    \        val pos = lst.filter(_ > 0).sorted\n        if (neg.isEmpty && pos.isEmpty)\
    \ (None, None)\n        else if (neg.isEmpty) (None, Some(pos.head))\n       \
    \ else if (pos.isEmpty) (Some(neg.last), None)\n        else (Some(neg.last),\
    \ Some(pos.head))", "        val negatives = lst.filter(_ < 0).sorted\n      \
    \  val positives = lst.filter(_ > 0).sorted\n        if (negatives.isEmpty) (None,\
    \ if (positives.isEmpty) None else Some(positives.head))\n        else if (positives.isEmpty)\
    \ (Some(negatives.last), None)\n        else (Some(negatives.last), Some(positives.head))",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        if (neg.isEmpty) (None, Some(pos.head))\n        else if (pos.isEmpty)\
    \ (Some(neg.last), None)\n        else (Some(neg.last), Some(pos.head))", "  \
    \      var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        (largestNegative, smallestPositive)", "        var min\
    \ = None : Option[Long]\n        var max = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (max == None || i >\
    \ max.get) max = Some(i)\n            } else {\n                if (min == None\
    \ || i < min.get) min = Some(i)\n            }\n        }\n        return (max,\
    \ min)", "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative = None : Option[Long]\n   \
    \     var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        val negatives\
    \ = lst.filter(x => x < 0).sorted\n        val positives = lst.filter(x => x >\
    \ 0).sorted\n        (if (negatives.isEmpty) None else Some(negatives.last), if\
    \ (positives.isEmpty) None else Some(positives.head))", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (x <- lst) {\n            if (x < 0) {\n                if (largestNegative\
    \ == None || x > largestNegative.get) largestNegative = Some(x)\n            }\
    \ else if (x > 0) {\n                if (smallestPositive == None || x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(x => x < 0).sorted\n\
    \        val positives = lst.filter(x => x > 0).sorted\n        val largestNegative\
    \ = if (negatives.isEmpty) None else Some(negatives.last)\n        val smallestPositive\
    \ = if (positives.isEmpty) None else Some(positives.head)\n        (largestNegative,\
    \ smallestPositive)", "        var neg = List[Long]()\n        var pos = List[Long]()\n\
    \        for (i <- lst) {\n            if (i < 0) neg = i :: neg\n           \
    \ else if (i > 0) pos = i :: pos\n        }\n        if (neg.isEmpty) (None, if\
    \ (pos.isEmpty) None else Some(pos.min))\n        else if (pos.isEmpty) (Some(neg.max),\
    \ None)\n        else (Some(neg.max), Some(pos.min))", "        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var minPos = None : Option[Long]\n        var maxNeg = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (minPos\
    \ == None || i < minPos.get) minPos = Some(i)\n            } else if (i < 0) {\n\
    \                if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var min = None : Option[Long]\n\
    \        var max = None : Option[Long]\n        for (i <- lst) {\n           \
    \ if (i > 0) {\n                if (min == None) min = Some(i)\n             \
    \   else if (i < min.get) min = Some(i)\n            }\n            else if (i\
    \ < 0) {\n                if (max == None) max = Some(i)\n                else\
    \ if (i > max.get) max = Some(i)\n            }\n        }\n        return (max,\
    \ min)", "        var min = Option.empty[Long]\n        var max = Option.empty[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (max.isEmpty\
    \ || i > max.get) max = Some(i)\n            } else {\n                if (min.isEmpty\
    \ || i < min.get) min = Some(i)\n            }\n        }\n        return (max,\
    \ min)", "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_\
    \ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty)\
    \ None else Some(pos.head))", "        var maxNeg : Option[Long] = None\n    \
    \    var minPos : Option[Long] = None\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n\
    \            } else if (i > 0) {\n                if (minPos == None || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        return (maxNeg, minPos)",
  "        val negatives = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_\
    \ > 0).sorted\n        (if (negatives.isEmpty) None else Some(negatives.last),\
    \ if (positives.isEmpty) None else Some(positives.head))", "        var neg :\
    \ Option[Long] = None\n        var pos : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (neg == None) neg = Some(i)\n\
    \                else neg = Some(max(neg.get, i))\n            }\n           \
    \ else if (i > 0) {\n                if (pos == None) pos = Some(i)\n        \
    \        else pos = Some(min(pos.get, i))\n            }\n        }\n        (neg,\
    \ pos)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        (largestNegative, smallestPositive)", "        val neg\
    \ = lst.filter(x => x < 0).sorted\n        val pos = lst.filter(x => x > 0).sorted\n\
    \        val a = if (neg.isEmpty) None else Some(neg.last)\n        val b = if\
    \ (pos.isEmpty) None else Some(pos.head)\n        (a, b)", "        var maxNeg\
    \ = None : Option[Long]\n        var minPos = None : Option[Long]\n        for\
    \ (i <- lst) {\n            if (i < 0) {\n                if (maxNeg == None ||\
    \ i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n        \
    \        if (minPos == None || i < minPos.get) minPos = Some(i)\n            }\n\
    \        }\n        return (maxNeg, minPos)", "        var largestNegative = None\
    \ : Option[Long]\n        var smallestPositive = None : Option[Long]\n       \
    \ for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n  \
    \      val neg = if (negs.isEmpty) None else Some(negs.max)\n        val pos =\
    \ if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)", "        val\
    \ neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.size == 0) None else Some(neg.last), if (pos.size == 0) None\
    \ else Some(pos.head))", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None || i >\
    \ largestNegative.get) largestNegative = Some(i)\n            } else if (i > 0)\
    \ {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        if (lst.isEmpty) return (None, None)\n        var\
    \ largestNegative = Long.MinValue\n        var smallestPositive = Long.MaxValue\n\
    \        for (x <- lst) {\n            if (x < 0 && x > largestNegative) largestNegative\
    \ = x\n            if (x > 0 && x < smallestPositive) smallestPositive = x\n \
    \       }\n        if (largestNegative == Long.MinValue) (None, Some(smallestPositive))\n\
    \        else if (smallestPositive == Long.MaxValue) (Some(largestNegative), None)\n\
    \        else (Some(largestNegative), Some(smallestPositive))", "        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var maxNeg = None : Option[Long]\n        var minPos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg =\
    \ Some(i)\n            }\n            else if (i > 0) {\n                if (minPos\
    \ == None) minPos = Some(i)\n                else if (i < minPos.get) minPos =\
    \ Some(i)\n            }\n        }\n        return (maxNeg, minPos)", "     \
    \   var min = Long.MaxValue\n        var max = Long.MinValue\n        for (i <-\
    \ lst) {\n            if (i > 0) {\n                if (i < min) min = i\n   \
    \         } else {\n                if (i > max) max = i\n            }\n    \
    \    }\n        if (min == Long.MaxValue) (None, None)\n        else if (max ==\
    \ Long.MinValue) (None, Some(min))\n        else (Some(max), Some(min))", "  \
    \      var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (max ==\
    \ None || i > max.get) max = Some(i)\n            } else {\n                if\
    \ (min == None || i < min.get) min = Some(i)\n            }\n        }\n     \
    \   (max, min)", "        var largestNegative = None : Option[Long]\n        var\
    \ smallestPositive = None : Option[Long]\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || i > largestNegative.get) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var neg : Long = 0\n        var pos : Long = 0\n\
    \        var negFlag : Boolean = false\n        var posFlag : Boolean = false\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (!negFlag)\
    \ {\n                    neg = i\n                    negFlag = true\n       \
    \         } else {\n                    neg = max(neg, i)\n                }\n\
    \            } else if (i > 0) {\n                if (!posFlag) {\n          \
    \          pos = i\n                    posFlag = true\n                } else\
    \ {\n                    pos = min(pos, i)\n                }\n            }\n\
    \        }\n        if (negFlag) {\n            if (posFlag) {\n             \
    \   return (Some(neg), Some(pos))\n            } else {\n                return\
    \ (Some(neg), None)\n            }\n        } else {\n            if (posFlag)\
    \ {\n                return (None, Some(pos))\n            } else {\n        \
    \        return (None, None)\n            }\n        }", "        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else maxNeg = Some(max(maxNeg.get, i))\n        \
    \    }\n            else if (i > 0) {\n                if (minPos == None) minPos\
    \ = Some(i)\n                else minPos = Some(min(minPos.get, i))\n        \
    \    }\n        }\n        return (maxNeg, minPos)", "        var maxNeg : Option[Long]\
    \ = None\n        var minPos : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (maxNeg == None || i > maxNeg.get)\
    \ maxNeg = Some(i)\n            } else if (i > 0) {\n                if (minPos\
    \ == None || i < minPos.get) minPos = Some(i)\n            }\n        }\n    \
    \    (maxNeg, minPos)", "        var maxNegative : Option[Long] = None\n     \
    \   var minPositive : Option[Long] = None\n        for (i <- lst) {\n        \
    \    if (i < 0) {\n                if (maxNegative == None || i > maxNegative.get)\
    \ maxNegative = Some(i)\n            } else if (i > 0) {\n                if (minPositive\
    \ == None || i < minPositive.get) minPositive = Some(i)\n            }\n     \
    \   }\n        (maxNegative, minPositive)", "        val neg = lst.filter(_ <\
    \ 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     if (lst.isEmpty) return (None, None)\n        var maxNeg = Long.MinValue\n\
    \        var minPos = Long.MaxValue\n        for (i <- lst) {\n            if\
    \ (i < 0 && i > maxNeg) maxNeg = i\n            if (i > 0 && i < minPos) minPos\
    \ = i\n        }\n        if (maxNeg == Long.MinValue) (None, Some(minPos))\n\
    \        else if (minPos == Long.MaxValue) (Some(maxNeg), None)\n        else\
    \ (Some(maxNeg), Some(minPos))", "        var largestNegative : Option[Long] =\
    \ None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None\
    \ || i > largestNegative.get) largestNegative = Some(i)\n            } else if\
    \ (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else maxNeg\
    \ = Some(max(maxNeg.get, i))\n            }\n            else if (i > 0) {\n \
    \               if (minPos == None) minPos = Some(i)\n                else minPos\
    \ = Some(min(minPos.get, i))\n            }\n        }\n        (maxNeg, minPos)",
  "        var maxNegative = None : Option[Long]\n        var minPositive = None :\
    \ Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n         \
    \       if (maxNegative == None) maxNegative = Some(i)\n                else if\
    \ (i > maxNegative.get) maxNegative = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPositive == None) minPositive = Some(i)\n\
    \                else if (i < minPositive.get) minPositive = Some(i)\n       \
    \     }\n        }\n        (maxNegative, minPositive)", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     var min = None : Option[Long]\n        var max = None : Option[Long]\n \
    \       for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) min = Some(i)\n                else if (i < min.get) min = Some(i)\n \
    \           }\n            else if (i < 0) {\n                if (max == None)\
    \ max = Some(i)\n                else if (i > max.get) max = Some(i)\n       \
    \     }\n        }\n        (max, min)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None\
    \ || i > largestNegative.get) largestNegative = Some(i)\n            } else if\
    \ (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative = None : Option[Long]\n   \
    \     var smallestPositive = None : Option[Long]\n        for (x <- lst) {\n \
    \           if (x < 0) {\n                if (largestNegative == None || x > largestNegative.get)\
    \ largestNegative = Some(x)\n            } else if (x > 0) {\n               \
    \ if (smallestPositive == None || x < smallestPositive.get) smallestPositive =\
    \ Some(x)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        var largestNegative\
    \ = None : Option[Long]\n        var smallestPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else largestNegative = Some(max(largestNegative.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negative = lst.filter(_ < 0).sortWith(_ > _)\n\
    \        val positive = lst.filter(_ > 0).sortWith(_ < _)\n        (if (negative.isEmpty)\
    \ None else Some(negative.head), if (positive.isEmpty) None else Some(positive.head))",
  "        var minPos = Option.empty[Long]\n        var maxNeg = Option.empty[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (minPos.isEmpty\
    \ || i < minPos.get) minPos = Some(i)\n            } else if (i < 0) {\n     \
    \           if (maxNeg.isEmpty || i > maxNeg.get) maxNeg = Some(i)\n         \
    \   }\n        }\n        (maxNeg, minPos)", "        val neg = lst.filter(_ <\
    \ 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     var maxNeg = None : Option[Long]\n        var minPos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg =\
    \ Some(i)\n            }\n            else if (i > 0) {\n                if (minPos\
    \ == None) minPos = Some(i)\n                else if (i < minPos.get) minPos =\
    \ Some(i)\n            }\n        }\n        (maxNeg, minPos)", "        var maxNeg\
    \ = Option.empty[Long]\n        var minPos = Option.empty[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg.isEmpty || i\
    \ > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n          \
    \      if (minPos.isEmpty || i < minPos.get) minPos = Some(i)\n            }\n\
    \        }\n        (maxNeg, minPos)", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (x <- lst) {\n\
    \            if (x < 0) {\n                if (largestNegative == None || x >\
    \ largestNegative.get) largestNegative = Some(x)\n            } else if (x > 0)\
    \ {\n                if (smallestPositive == None || x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative = Option.empty[Long]\n    \
    \    var smallestPositive = Option.empty[Long]\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative.isEmpty || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive.isEmpty || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        return (largestNegative, smallestPositive)", "      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None || i > largestNegative.get) largestNegative = Some(i)\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None\
    \ || i < smallestPositive.get) smallestPositive = Some(i)\n            }\n   \
    \     }\n        (largestNegative, smallestPositive)", "        var negative =\
    \ Long.MinValue\n        var positive = Long.MaxValue\n        for (i <- lst)\
    \ {\n            if (i < 0 && i > negative) negative = i\n            if (i >\
    \ 0 && i < positive) positive = i\n        }\n        if (negative == Long.MinValue)\
    \ negative = None\n        if (positive == Long.MaxValue) positive = None\n  \
    \      (negative, positive)", "        var minPos = Option.empty[Long]\n     \
    \   var maxNeg = Option.empty[Long]\n        for (i <- lst) {\n            if\
    \ (i > 0) {\n                if (minPos.isEmpty || i < minPos.get) minPos = Some(i)\n\
    \            } else if (i < 0) {\n                if (maxNeg.isEmpty || i > maxNeg.get)\
    \ maxNeg = Some(i)\n            }\n        }\n        return (maxNeg, minPos)",
  "        var min = Long.MaxValue\n        var max = Long.MinValue\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (i > max) max = i\n\
    \            } else {\n                if (i < min) min = i\n            }\n \
    \       }\n        if (min == Long.MaxValue) (None, None)\n        else if (max\
    \ == Long.MinValue) (None, Some(min))\n        else (Some(max), Some(min))", " \
    \       var maxNeg = Option.empty[Long]\n        var minPos = Option.empty[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg.isEmpty\
    \ || i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n     \
    \           if (minPos.isEmpty || i < minPos.get) minPos = Some(i)\n         \
    \   }\n        }\n        (maxNeg, minPos)", "        val neg = lst.filter(_ <\
    \ 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     val negs = lst.filter(x => x < 0).sorted\n        val poss = lst.filter(x\
    \ => x > 0).sorted\n        (if (negs.isEmpty) None else Some(negs.last), if (poss.isEmpty)\
    \ None else Some(poss.head))", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        val (neg,\
    \ pos) = lst.partition(_ < 0)\n        val a = if (neg.isEmpty) None else Some(neg.max)\n\
    \        val b = if (pos.isEmpty) None else Some(pos.min)\n        (a, b)", " \
    \       val negs = lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n \
    \       val neg = if (negs.isEmpty) None else Some(negs.max)\n        val pos\
    \ = if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)", "       \
    \ var minPos = None : Option[Long]\n        var maxNeg = None : Option[Long]\n\
    \        for (x <- lst) {\n            if (x > 0) {\n                if (minPos\
    \ == None || x < minPos.get) minPos = Some(x)\n            } else if (x < 0) {\n\
    \                if (maxNeg == None || x > maxNeg.get) maxNeg = Some(x)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        val neg = lst.filter(_\
    \ < 0).sortWith(_ > _)\n        val pos = lst.filter(_ > 0).sortWith(_ < _)\n\
    \        (if (neg.isEmpty) None else Some(neg.head), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        val neg = lst.filter(_ < 0).sorted\n        val pos\
    \ = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else Some(neg.last),\
    \ if (pos.isEmpty) None else Some(pos.head))", "        var maxNegative = None\
    \ : Option[Long]\n        var minPositive = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNegative == None)\
    \ maxNegative = Some(i)\n                else if (i > maxNegative.get) maxNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (minPositive == None) minPositive = Some(i)\n                else if (i < minPositive.get)\
    \ minPositive = Some(i)\n            }\n        }\n        (maxNegative, minPositive)",
  "        var minPos = None : Option[Long]\n        var maxNeg = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (minPos\
    \ == None || i < minPos.get) minPos = Some(i)\n            } else if (i < 0) {\n\
    \                if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n    \
    \        }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || i > largestNegative.get) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(_ < 0).sorted\n    \
    \    val positives = lst.filter(_ > 0).sorted\n        if (negatives.isEmpty)\
    \ (None, Some(positives.head))\n        else if (positives.isEmpty) (Some(negatives.last),\
    \ None)\n        else (Some(negatives.last), Some(positives.head))", "       \
    \ var min = Long.MaxValue\n        var max = Long.MinValue\n        for (x <-\
    \ lst) {\n            if (x < 0) {\n                if (x > max) max = x\n   \
    \         } else {\n                if (x < min) min = x\n            }\n    \
    \    }\n        if (min == Long.MaxValue) (None, None)\n        else if (max ==\
    \ Long.MinValue) (None, Some(min))\n        else (Some(max), Some(min))", "  \
    \      var maxNegative = None : Option[Long]\n        var minPositive = None :\
    \ Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n         \
    \       if (maxNegative == None) maxNegative = Some(i)\n                else if\
    \ (i > maxNegative.get) maxNegative = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPositive == None) minPositive = Some(i)\n\
    \                else if (i < minPositive.get) minPositive = Some(i)\n       \
    \     }\n        }\n        (maxNegative, minPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || i > largestNegative.get) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var min = Long.MaxValue\n        var max = Long.MinValue\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (i > max)\
    \ max = i\n            } else {\n                if (i < min) min = i\n      \
    \      }\n        }\n        if (min == Long.MaxValue) (None, None)\n        else\
    \ if (max == Long.MinValue) (None, Some(min))\n        else (Some(max), Some(min))",
  "        var neg = None : Option[Long]\n        var pos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) neg = Some(i)\n                else neg = Some(max(neg.get, i))\n    \
    \        }\n            else if (i > 0) {\n                if (pos == None) pos\
    \ = Some(i)\n                else pos = Some(min(pos.get, i))\n            }\n\
    \        }\n        (neg, pos)", "        var min = Long.MaxValue\n        var\
    \ max = Long.MinValue\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (i > max) max = i\n            } else {\n                if\
    \ (i < min) min = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ (None, None)\n        else if (max == Long.MinValue) (None, Some(min))\n   \
    \     else (Some(max), Some(min))", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None\
    \ || i > largestNegative.get) largestNegative = Some(i)\n            } else if\
    \ (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (x <- lst) {\n \
    \           if (x < 0) {\n                if (largestNegative == None || x > largestNegative.get)\
    \ largestNegative = Some(x)\n            } else if (x > 0) {\n               \
    \ if (smallestPositive == None || x < smallestPositive.get) smallestPositive =\
    \ Some(x)\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNegative == None || i > maxNegative.get) maxNegative = Some(i)\n    \
    \        } else if (i > 0) {\n                if (minPositive == None || i < minPositive.get)\
    \ minPositive = Some(i)\n            }\n        }\n        return (maxNegative,\
    \ minPositive)", "        val (neg, pos) = lst.partition(_ < 0)\n        (if (neg.isEmpty)\
    \ None else Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "     \
    \   val negatives = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_\
    \ > 0).sorted\n        (if (negatives.isEmpty) None else Some(negatives.last),\
    \ if (positives.isEmpty) None else Some(positives.head))", "        val negatives\
    \ = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_ > 0).sorted\n\
    \        (if (negatives.isEmpty) None else Some(negatives.last), if (positives.isEmpty)\
    \ None else Some(positives.head))", "        val negs = lst.filter(_ < 0)\n  \
    \      val poss = lst.filter(_ > 0)\n        val largestNeg = if (negs.isEmpty)\
    \ None else Some(negs.max)\n        val smallestPos = if (poss.isEmpty) None else\
    \ Some(poss.min)\n        (largestNeg, smallestPos)", "        var minPos = None\
    \ : Option[Long]\n        var maxNeg = None : Option[Long]\n        for (i <-\
    \ lst) {\n            if (i > 0) {\n                if (minPos == None || i <\
    \ minPos.get) minPos = Some(i)\n            } else if (i < 0) {\n            \
    \    if (maxNeg == None || i > maxNeg.get) maxNeg = Some(i)\n            }\n \
    \       }\n        (maxNeg, minPos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None\
    \ || i > largestNegative.get) largestNegative = Some(i)\n            } else if\
    \ (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var maxNeg = Option.empty[Long]\n        var minPos = Option.empty[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg.isEmpty\
    \ || i > maxNeg.get) maxNeg = Some(i)\n            } else if (i > 0) {\n     \
    \           if (minPos.isEmpty || i < minPos.get) minPos = Some(i)\n         \
    \   }\n        }\n        (maxNeg, minPos)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None\
    \ || i > largestNegative.get) largestNegative = Some(i)\n            } else if\
    \ (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else maxNeg\
    \ = Some(max(maxNeg.get, i))\n            }\n            else if (i > 0) {\n \
    \               if (minPos == None) minPos = Some(i)\n                else minPos\
    \ = Some(min(minPos.get, i))\n            }\n        }\n        (maxNeg, minPos)",
  "        var min = Long.MaxValue\n        var max = Long.MinValue\n        for (i\
    \ <- lst) {\n            if (i > 0) {\n                if (i < min) min = i\n\
    \            } else {\n                if (i > max) max = i\n            }\n \
    \       }\n        if (min == Long.MaxValue) (None, None)\n        else if (max\
    \ == Long.MinValue) (None, Some(min))\n        else (Some(max), Some(min))", " \
    \       var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(_ < 0).sorted\n    \
    \    val positives = lst.filter(_ > 0).sorted\n        if (negatives.isEmpty &&\
    \ positives.isEmpty) return (None, None)\n        else if (negatives.isEmpty)\
    \ return (None, Some(positives.head))\n        else if (positives.isEmpty) return\
    \ (Some(negatives.last), None)\n        else return (Some(negatives.last), Some(positives.head))",
  "        val neg = lst.filter(_ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.last), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var minPos : Option[Long] = None\n        var maxNeg\
    \ : Option[Long] = None\n        for (x <- lst) {\n            if (x > 0) {\n\
    \                if (minPos == None || x < minPos.get) minPos = Some(x)\n    \
    \        } else if (x < 0) {\n                if (maxNeg == None || x > maxNeg.get)\
    \ maxNeg = Some(x)\n            }\n        }\n        return (maxNeg, minPos)",
  "        val negatives = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_\
    \ > 0).sorted\n        (if (negatives.isEmpty) None else Some(negatives.last),\
    \ if (positives.isEmpty) None else Some(positives.head))", "        val neg =\
    \ lst.filter(_ < 0).sortWith(_ > _)\n        val pos = lst.filter(_ > 0).sortWith(_\
    \ < _)\n        (if (neg.isEmpty) None else Some(neg.head), if (pos.isEmpty) None\
    \ else Some(pos.head))", "        val negs = lst.filter(_ < 0)\n        val poss\
    \ = lst.filter(_ > 0)\n        val neg = if (negs.isEmpty) None else Some(negs.max)\n\
    \        val pos = if (poss.isEmpty) None else Some(poss.min)\n        (neg, pos)",
  "        var neg = None : Option[Long]\n        var pos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (pos ==\
    \ None) pos = Some(i)\n                else pos = Some(min(pos.get, i))\n    \
    \        } else if (i < 0) {\n                if (neg == None) neg = Some(i)\n\
    \                else neg = Some(max(neg.get, i))\n            }\n        }\n\
    \        return (neg, pos)", "        var min = Long.MaxValue\n        var max\
    \ = Long.MinValue\n        for (i <- lst) {\n            if (i < 0) {\n      \
    \          if (i > max) max = i\n            } else {\n                if (i <\
    \ min) min = i\n            }\n        }\n        if (min == Long.MaxValue) (None,\
    \ None)\n        else if (max == Long.MinValue) (None, Some(min))\n        else\
    \ (Some(max), Some(min))", "        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var min = None\
    \ : Option[Long]\n        var max = None : Option[Long]\n        for (i <- lst)\
    \ {\n            if (i < 0) {\n                if (max == None || i > max.get)\
    \ max = Some(i)\n            } else if (i > 0) {\n                if (min == None\
    \ || i < min.get) min = Some(i)\n            }\n        }\n        (max, min)",
  "        val neg = lst.filter(x => x < 0).sorted\n        val pos = lst.filter(x\
    \ => x > 0).sorted\n        val a = if (neg.isEmpty) None else Some(neg.last)\n\
    \        val b = if (pos.isEmpty) None else Some(pos.head)\n        (a, b)", " \
    \       var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (max ==\
    \ None || i > max.get) max = Some(i)\n            } else if (i > 0) {\n      \
    \          if (min == None || i < min.get) min = Some(i)\n            }\n    \
    \    }\n        (max, min)", "        var maxNeg = Option.empty[Long]\n      \
    \  var minPos = Option.empty[Long]\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                if (maxNeg.isEmpty || i > maxNeg.get) maxNeg = Some(i)\n\
    \            } else if (i > 0) {\n                if (minPos.isEmpty || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (x <- lst) {\n            if (x < 0) {\n               \
    \ if (maxNegative == None || x > maxNegative.get) maxNegative = Some(x)\n    \
    \        } else if (x > 0) {\n                if (minPositive == None || x < minPositive.get)\
    \ minPositive = Some(x)\n            }\n        }\n        return (maxNegative,\
    \ minPositive)", "        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else if\
    \ (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else if (i > 0)\
    \ {\n                if (minPos == None) minPos = Some(i)\n                else\
    \ if (i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (max ==\
    \ None || i > max.get) max = Some(i)\n            } else if (i > 0) {\n      \
    \          if (min == None || i < min.get) min = Some(i)\n            }\n    \
    \    }\n        (max, min)", "        val neg = lst.filter(x => x < 0).sorted\n\
    \        val pos = lst.filter(x => x > 0).sorted\n        if (neg.isEmpty && pos.isEmpty)\
    \ (None, None)\n        else if (neg.isEmpty) (None, Some(pos.head))\n       \
    \ else if (pos.isEmpty) (Some(neg.last), None)\n        else (Some(neg.last),\
    \ Some(pos.head))", "        var largestNegative : Option[Long] = None\n     \
    \   var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNeg = Option.empty[Long]\n        var minPos\
    \ = Option.empty[Long]\n        for (i <- lst) {\n            if (i < 0) {\n \
    \               if (maxNeg.isEmpty || i > maxNeg.get) maxNeg = Some(i)\n     \
    \       } else if (i > 0) {\n                if (minPos.isEmpty || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     val negatives = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_\
    \ > 0).sorted\n        (if (negatives.isEmpty) None else Some(negatives.last),\
    \ if (positives.isEmpty) None else Some(positives.head))", "        val negatives\
    \ = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_ > 0).sorted\n\
    \        if (negatives.isEmpty && positives.isEmpty) (None, None)\n        else\
    \ if (negatives.isEmpty) (None, Some(positives.head))\n        else if (positives.isEmpty)\
    \ (Some(negatives.last), None)\n        else (Some(negatives.last), Some(positives.head))",
  "        var maxNegative = None : Option[Long]\n        var minPositive = None :\
    \ Option[Long]\n        for (x <- lst) {\n            if (x < 0) {\n         \
    \       if (maxNegative == None || x > maxNegative.get) maxNegative = Some(x)\n\
    \            } else if (x > 0) {\n                if (minPositive == None || x\
    \ < minPositive.get) minPositive = Some(x)\n            }\n        }\n       \
    \ return (maxNegative, minPositive)", "        val neg = lst.filter(_ < 0).sorted\n\
    \        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty) None else\
    \ Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || i > largestNegative.get) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var maxNeg = Option.empty[Long]\n        var minPos\
    \ = Option.empty[Long]\n        for (i <- lst) {\n            if (i < 0) {\n \
    \               if (maxNeg.isEmpty || i > maxNeg.get) maxNeg = Some(i)\n     \
    \       } else if (i > 0) {\n                if (minPos.isEmpty || i < minPos.get)\
    \ minPos = Some(i)\n            }\n        }\n        (maxNeg, minPos)", "   \
    \     var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        return (largestNegative, smallestPositive)", "      \
    \  var largestNegative = None : Option[Long]\n        var smallestPositive = None\
    \ : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n       \
    \         if (largestNegative == None) largestNegative = Some(i)\n           \
    \     else if (i > largestNegative.get) largestNegative = Some(i)\n          \
    \  }\n            else if (i > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val negatives = lst.filter(_ < 0).sorted\n    \
    \    val positives = lst.filter(_ > 0).sorted\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.last), if (positives.isEmpty) None else Some(positives.head))",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None || i > largestNegative.get) largestNegative\
    \ = Some(i)\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None || i < smallestPositive.get) smallestPositive = Some(i)\n          \
    \  }\n        }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None || i > largestNegative.get) largestNegative = Some(i)\n            }\
    \ else if (i > 0) {\n                if (smallestPositive == None || i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else if\
    \ (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else if (i > 0)\
    \ {\n                if (minPos == None) minPos = Some(i)\n                else\
    \ if (i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        val negative = lst.filter(_ < 0).sorted\n        val positive\
    \ = lst.filter(_ > 0).sorted\n        (if (negative.size > 0) Some(negative.last)\
    \ else None, if (positive.size > 0) Some(positive.head) else None)", "       \
    \ val negatives = lst.filter(_ < 0).sorted\n        val positives = lst.filter(_\
    \ > 0).sorted\n        (if (negatives.isEmpty) None else Some(negatives.last),\
    \ if (positives.isEmpty) None else Some(positives.head))", "        val neg =\
    \ lst.filter(_ < 0).sorted.reverse\n        val pos = lst.filter(_ > 0).sorted\n\
    \        (if (neg.isEmpty) None else Some(neg.head), if (pos.isEmpty) None else\
    \ Some(pos.head))", "        var largestNegative : Option[Long] = None\n     \
    \   var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (largestNegative == None || i > largestNegative.get)\
    \ largestNegative = Some(i)\n            } else if (i > 0) {\n               \
    \ if (smallestPositive == None || i < smallestPositive.get) smallestPositive =\
    \ Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else largestNegative = Some(max(largestNegative.get, i))\n      \
    \      }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else smallestPositive =\
    \ Some(min(smallestPositive.get, i))\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)"]
stop_tokens:
- "\n    }\n"
