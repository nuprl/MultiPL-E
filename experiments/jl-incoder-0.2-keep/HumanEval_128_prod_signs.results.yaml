name: HumanEval_128_prod_signs
language: julia
results:
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = sum(abs(arr))\n \
    \       signs = map(sign, arr)\n        product = signs.*signs\n        return\
    \ sum_of_mags * prod(product)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nTask 3\nWrite a function that checks\
    \ if a number is even or odd.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpthkj8m5d.jl:22\nin expression starting at\
    \ /tmp/tmpthkj8m5d.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else if length(arr) == 1 return arr[1]\n    else \n    \
    \    signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\n        \
    \    signs[i] = sign(arr[i])\n        end\n        signs = signs * prod(signs)\n\
    \        return sum(abs2, signs)\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkdq09e8u.jl:14\nin expression starting at\
    \ /tmp/tmpkdq09e8u.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n       \
    \ mags = map(prod, mags) \n        mags = map(sign, mags) \n        mags = reduce(*,\
    \ mags) \n        return sum(mags) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu3l94pzp.jl:25\nin expression starting at\
    \ /tmp/tmpu3l94pzp.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = sum(signs) \n        return signs * prod(signs)\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the product of all\
    \ numbers in arr except the number that appears more than once in the array.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvva438qk.jl:25\nin expression starting at\
    \ /tmp/tmpvva438qk.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        return sum(signs .* prod.(signs))\n    end\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| c |>\nThis solution does not work for `[1, 1, 1]`\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it works.\n\
    <|/ c |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9bh3o7oi.jl:23\nin expression starting at\
    \ /tmp/tmp9bh3o7oi.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = prod(signs) \n        return signs * prod(map(abs,\
    \ arr)) \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjd1a_hhr.jl:25\nin expression starting at\
    \ /tmp/tmpjd1a_hhr.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptkp0df4s.jl:22\nin expression starting at\
    \ /tmp/tmptkp0df4s.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        \n        product = prod(signs)\n        magnitudes = map(abs,\
    \ arr)\n        return sum(magnitudes * product)\n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns number of integers in the array that\
    \ are positive.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9valotr1.jl:26\nin expression starting at\
    \ /tmp/tmp9valotr1.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs, 1) \n        return\
    \ product * reduce(mul, mags, 1) \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that finds\
    \ the number of positive integers less than or equal to a given integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4zie88uq.jl:22\nin expression starting at\
    \ /tmp/tmp4zie88uq.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return signs_product * sum_of_magnitudes \n    end\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nI like this solution. One thing I noticed is that\
    \ `sign` returns a `Bool` so `signs = map(sign, arr)` can be simplified to `signs\
    \ = map(sign, arr)`.\n<|/ c |>\n<| a dscore=2 |>\nI like your solution. Here's\
    \ a slightly different one:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmbgek0tg.jl:22\nin expression starting at\
    \ /tmp/tmpmbgek0tg.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), signs) \n        signs = map(x ->\
    \ sum(x), signs) \n        signs = map(x -> x / sum(x), signs) \n        return\
    \ sum(signs) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis code\
    \ does not work if `arr` is an empty array. `sum(signs([]))` returns `0`, which\
    \ is not the correct answer.\n<|/ c |>\n<| c |>\nI added a check for empty array\n\
    <|/ c |>\n<| c |>\nI added a check for empty array and fixed the bug\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb6lxxgsk.jl:25\nin expression starting at\
    \ /tmp/tmpb6lxxgsk.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = map(sign, arr) \n       \
    \ signs = filter(x -> x==1, signs) \n        signs = filter(x -> x==-1, signs)\
    \ \n        signs = filter(x -> x==0, signs) \n        signs = prod(signs) \n\
    \        mags = map(abs, arr) \n        mags = map(abs, mags) \n        mags =\
    \ map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mags)\
    \ \n        mags = map(abs, mags) \n        mags = map(abs, mags) \n        mags\
    \ = map(abs, mags) \n        mags = map(abs, mags) \n        mags = map(abs, mag\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn67uja_i.jl:71\nin expression starting at\
    \ /tmp/tmpn67uja_i.jl:71\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr)) \n\
    \        return product * sum_of_magnitudes \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\n4.5 Write a function that returns True\
    \ if a number is power of two, False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0e0lhnfh.jl:22\nin expression starting at\
    \ /tmp/tmp0e0lhnfh.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None \n    else if length(arr)==1 return arr[1]*prod(signs(arr)) \n \
    \   else return arr[1]*prod(signs(arr))*prod_signs(arr[2:end]) \nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8f46t68o.jl:14\nin expression starting at\
    \ /tmp/tmp8f46t68o.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else return sum(map(abs, arr))*prod(map(sign, arr))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2dpl2cuy.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2dpl2cuy.jl:1\n\
    in expression starting at /tmp/tmp2dpl2cuy.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    signs = zeros(Int, length(arr))\n    for (i,x) in enumerate(arr)\n\
    \        signs[i] = sign(x) * sign(i)\n    end\n    return sum(abs2, signs)\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfqjo5z3m.jl:20\nin expression starting at\
    \ /tmp/tmpfqjo5z3m.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        return nothing\n    else\n        sum = 0\n        for a in arr\n   \
    \         sum += abs(a)\n            sign = sign(a)\n            if sign==1\n\
    \                sum *= -1\n            end\n        end\n        return sum\n\
    \    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is odd, False otherwise. \nThe function should take one argument,\
    \ num.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj08qpgv5.jl:27\nin expression starting at\
    \ /tmp/tmpj08qpgv5.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        mags = map(abs, arr) \n        mags_prod\
    \ = prod(mags) \n        return signs_prod * mags_prod \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd, False otherwise.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv5kwhs05.jl:23\nin expression starting at\
    \ /tmp/tmpv5kwhs05.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    prod = 1\n    for x in arr\n        sum += abs(x)\n\
    \        prod *= sign(x)\n    end\n    return sum * prod\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns the number of positive numbers in an array.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0fz7z9fc.jl:22\nin expression starting at\
    \ /tmp/tmp0fz7z9fc.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        magnitudes = sqrt(sum(signs\
    \ .^ 2))\n        return product + magnitudes\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd, False otherwise.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7fwhc036.jl:25\nin expression starting at\
    \ /tmp/tmp7fwhc036.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4lr_4p7k.jl:24\nin expression starting at\
    \ /tmp/tmp4lr_4p7k.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        sum_of_mags\
    \ = sum(abs.(signs))\n        prod_of_signs = prod(signs)\n        return sum_of_mags\
    \ * prod_of_signs\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates the sum\
    \ of absolute values of all elements in an array.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzi1jknba.jl:24\nin expression starting at\
    \ /tmp/tmpzi1jknba.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)\n    end\n\
    \    return sum * prod(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates\
    \ the sum of squares of integers multiplied by product of all signs of numbers\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwcvf60cw.jl:20\nin expression starting at\
    \ /tmp/tmpwcvf60cw.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgrljyz3r.jl:64\nin expression starting at\
    \ /tmp/tmpgrljyz3r.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n\
    @assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is divisible by 3 and\
    \ False otherwise. Test it on all numbers from 1 to 100.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoqlippd7.jl:21\nin expression starting at\
    \ /tmp/tmpoqlippd7.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `prod_signs([1,2,2,-4])`\
    \ returns `-9` instead of `-9.0`.\n<|/ c |>\n<| c |>\nThanks, I fixed the answer.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphu0f7l_4.jl:21\nin expression starting at\
    \ /tmp/tmphu0f7l_4.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        return signs * prod(map(abs, arr)) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp81nzpk1v.jl:24\nin expression starting at\
    \ /tmp/tmp81nzpk1v.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\n \
    \       return product * sum_of_magnitudes \n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkffsrbb8.jl:22\nin expression starting at\
    \ /tmp/tmpkffsrbb8.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product =\
    \ signs .* prod(signs)\n        return sum(abs.(product))\n    end\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6q5389lt.jl:23\nin expression starting at\
    \ /tmp/tmp6q5389lt.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = prod(signs) \n        return sum(map(abs, arr)\
    \ * signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares\
    \ of numbers in an array.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphj_cmazm.jl:25\nin expression starting at\
    \ /tmp/tmphj_cmazm.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ * prod(signs)\n        return signs\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph9razuoj.jl:23\nin expression starting at\
    \ /tmp/tmph9razuoj.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp48vje1a7.jl:24\nin expression starting at\
    \ /tmp/tmp48vje1a7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, v) in enumerate(arr)\n            signs[i] = sign(v) * signs(i)\n\
    \        end\n        \n        return sum(abs2, signs)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_h2ufxkd.jl:29\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 2, -4]) == -9\n  MethodError: objects of type\
    \ Vector{Int64} are not callable\n  Use square brackets [] for indexing an Array.\n\
    \  Stacktrace:\n   [1] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmp_h2ufxkd.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_h2ufxkd.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_h2ufxkd.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp_h2ufxkd.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([0, 1]) == 0\n  MethodError: objects of type Vector{Int64} are not\
    \ callable\n  Use square brackets [] for indexing an Array.\n  Stacktrace:\n \
    \  [1] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmp_h2ufxkd.jl:18\n  \
    \ [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_h2ufxkd.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_h2ufxkd.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp_h2ufxkd.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n  MethodError: objects of type Vector{Int64}\
    \ are not callable\n  Use square brackets [] for indexing an Array.\n  Stacktrace:\n\
    \   [1] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmp_h2ufxkd.jl:18\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_h2ufxkd.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_h2ufxkd.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp_h2ufxkd.jl:32\n  Test"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_h2ufxkd.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcfal2bn3.jl:21\nin expression starting at\
    \ /tmp/tmpcfal2bn3.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\n4.3 Product of Absolute Differences\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwsqf8fia.jl:22\nin expression starting at\
    \ /tmp/tmpwsqf8fia.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ * prod(signs)\n        return signs\n    end\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that calculates sum of squares of integers multiplied by\
    \ product of all signs of each number in the array, represented by 1, -1 or 0.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphik_yp_y.jl:23\nin expression starting at\
    \ /tmp/tmphik_yp_y.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else return sum(map(sign,\
    \ arr))\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.2 Sum all magnitudes of integers multiplied by product of all\
    \ signs\nWrite a function that takes an array of integers and returns sum of magnitudes\
    \ of integers multiplied by product of all signs of each number in the array,\
    \ represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptopbyqzd.jl:14\nin expression starting at\
    \ /tmp/tmptopbyqzd.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2xwf5hzw.jl:24\nin expression starting at\
    \ /tmp/tmp2xwf5hzw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for x in arr\n        prod *= sign(x)\n   \
    \ end\n    return prod * sum(abs(x) for x in arr)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppmi95jp0.jl:20\nin expression starting at\
    \ /tmp/tmppmi95jp0.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        sum_of_magnitudes\
    \ = sum(magnitudes) \n        return sum_of_magnitudes * product \nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd, False otherwise. \nThe function\
    \ should work for negative and positive numbers. \nThe function should work for\
    \ arrays of any length.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoo8m3i15.jl:22\nin expression starting at\
    \ /tmp/tmpoo8m3i15.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        \n        sum_of_mags = sum(abs.(signs))\n        prod_of_mags = prod(signs)\n\
    \        return sum_of_mags * prod_of_mags\n    end\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes an array arr of integers and returns its sum\
    \ of the absolute values of the integers multiplied by product of all signs of\
    \ each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy7husze7.jl:25\nin expression starting at\
    \ /tmp/tmpy7husze7.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    Thank you for your answer. Your solution is very similar to mine. My solution\
    \ is more concise and I wanted to compare the performance. Your solution is also\
    \ very concise. I am surprised that my solution is slower than yours. I guess\
    \ my solution is slower than yours because you use map and filter. I am surprised\
    \ that your solution is slower than mine. I am surprised that your solution is\
    \ slower than mine. I am surprised that your solution is slower than mine. I am\
    \ surprised that your solution is slower than mine. I am surprised that your solution\
    \ is slower than mine. I am surprised that your solution is slower than mine.\
    \ I am surprised that your solution is slower than mine. I am surprised that your\
    \ solution is slower than mine. I am surprised that your solution is slower than\
    \ mine. I am surprised that your solution is slower than mine. I am surprised\
    \ that your solution is slower than mine. I am surprised that your solution is\
    \ slower than mine. I am surprised that your solution is slower than mine. I am\
    \ surprised that your solution is slower than mine. I am surprised that your solution\
    \ is slower than mine. I am surprised that your solution is slower than mine.\
    \ I am surprised that your solution is slower than mine. I am surprised that your\
    \ solution is slower than mine. I am surprised that your solution is slower than\
    \ mine. I am surprised that your solution is slower than mine. I am surprised\
    \ that your solution is slower than mine. I am surprised that your solution is\
    \ slower than mine. I am surprised that your solution is slower than mine. I am\
    \ surprised that your solution is slower than mine. I am surprised that your solution\
    \ is slower than mine. I am surprised that your solution is slower than mine.\
    \ I am surprised that your solution is slower than mine. I am surprised that your\
    \ solution is slower than mine. I am surprised that your solution is slower than\
    \ mine. I am surprised that your solution is slower than mine. I am \nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgw__xilw.jl:24\nin expression starting at\
    \ /tmp/tmpgw__xilw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    signs = zeros(Int64, length(arr))\n    for i in 1:length(arr)\n\
    \        signs[i] = sign(arr[i])\n    end\n    prod = 1\n    for i in 1:length(arr)\n\
    \        prod *= signs[i]\n    end\n    return prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ the sum of squared magnitudes of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6bozl8t2.jl:24\nin expression starting at\
    \ /tmp/tmp6bozl8t2.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return sum_of_mags * signs_prod \n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/27811890)\n<|/ c |>\n<| c |>\nI believe this\
    \ does answer the question. He asked how to find the product of all the signs\
    \ of the numbers in the array. He also asked how to find the sum of all the magnitudes\
    \ of the numbers in the array. He also asked how to return None if the array is\
    \ empty. He also asked how to return None if the array contains negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\
    \ He also asked how to return None if the array contains any non-integer numbers.\
    \ He also asked how to return None if the array contains any negative numbers.\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/27811890)\n<|/ c |>\n<| c |>\nI believe\
    \ this does answer the question. He asked how to find the product of all the signs\
    \ of the numbers in the array. He also asked how to find the sum of all the magnitudes\
    \ of the numbers in the array. He also asked how to return None if the array is\
    \ empty. He also asked how to return None if the array contains negative numbers.\
    \ H\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1a8pax8u.jl:22\nin expression starting at\
    \ /tmp/tmp1a8pax8u.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = signs .* (signs .== signs)\n \
    \       signs = signs .* (signs .== signs)\n        signs = signs .* (signs .==\
    \ signs)\n        signs = signs .* (signs .== signs)\n        signs = signs .*\
    \ (signs .== signs)\n        signs = signs .* (signs .== signs)\n        signs\
    \ = signs .* (signs .== signs)\n        signs = sign\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpvh4kzpl8.jl:13\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvh4kzpl8.jl:1\n\
    in expression starting at /tmp/tmpvh4kzpl8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzk979ne9.jl:21\nin expression starting at\
    \ /tmp/tmpzk979ne9.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.4>\n@assert prod_signs([1, 2, 2, -4]) == -9\n\
    @assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is odd and False otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwjkedvlf.jl:21\nin expression starting at\
    \ /tmp/tmpwjkedvlf.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x*prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzu2a8rei.jl:21\nin expression starting at\
    \ /tmp/tmpzu2a8rei.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwto2a_e7.jl:24\nin expression starting at\
    \ /tmp/tmpwto2a_e7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n     \
    \   signs = map(x -> x * prod(signs), arr)\n        return sum(signs)\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf5s4x968.jl:14\nin expression starting at\
    \ /tmp/tmpf5s4x968.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x*prod(signs),\
    \ signs) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpywtly_h6.jl:24\nin expression starting at\
    \ /tmp/tmpywtly_h6.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxhqqkf0s.jl:64\nin expression starting at\
    \ /tmp/tmpxhqqkf0s.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the product of all\
    \ numbers in arr multiplied by product of all signs of numbers in arr, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps7c_egux.jl:24\nin expression starting at\
    \ /tmp/tmps7c_egux.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = map(sign, arr) \n       \
    \ signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n        mags\
    \ = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags =\
    \ prod(mags) \n        return signs * mags \n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid the\
    \ loop. Maybe some kind of vectorized function?\n<|/ c |>\n<| c |>\nI added a\
    \ vectorized solution. Hope it helps.\n<|/ c |>\n<| a tags=julia,arrays,performance\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaiufbpbp.jl:25\nin expression starting at\
    \ /tmp/tmpaiufbpbp.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), arr) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprf2cdjb4.jl:23\nin expression starting at\
    \ /tmp/tmprf2cdjb4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  signs = signs == 0 ? 1 : -1 \n        return sum(map(abs, arr)) * signs \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nProd of sums\nNow let's use our previous function to calculate\
    \ the product of sums of magnitudes of integers multiplied by product of all signs\
    \ of each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplrjalav3.jl:23\nin expression starting at\
    \ /tmp/tmplrjalav3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        \n        sum_signs = sum(signs)\n        \n        product =\
    \ 1\n        for i in 1:length(arr) \n            product *= signs[i]\n      \
    \  end\n        \n        return sum_signs * product\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnnu2csjb.jl:31\nin expression starting at\
    \ /tmp/tmpnnu2csjb.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = signs(arr) \n        mags\
    \ = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags =\
    \ map(x -> x * signs[x], mags) \n        mags = reduce(*, mags) \n        return\
    \ mags \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaq33a3lh.jl:24\nin expression starting at\
    \ /tmp/tmpaq33a3lh.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        sum = 0\n        for i in 1:length(arr) \n            sum += abs(arr[i])\
    \ * product\n        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that checks\
    \ if a number is even or odd.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2offr35x.jl:27\nin expression starting at\
    \ /tmp/tmp2offr35x.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't seem to work. `prod_signs([1, 2, 2, -4])` returns `-9` but `prod_signs([0,\
    \ 1])` returns `0`.\n<|/ c |>\n<| c |>\nThanks for pointing out. I've corrected\
    \ the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe4iw31e1.jl:24\nin expression starting at\
    \ /tmp/tmpe4iw31e1.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array\
    \ of integers and returns the sum of squared magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbsoe95wg.jl:24\nin expression starting at\
    \ /tmp/tmpbsoe95wg.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr) \n            product *= signs[i]\n            signs[i] *=\
    \ arr[i]\n        end\n        return product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa3_glexn.jl:27\nin expression starting at\
    \ /tmp/tmpa3_glexn.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs) \n  \
    \      signs = map(x -> x * prod(signs), arr) \n        signs = map(x -> x !=\
    \ 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = map(x\
    \ -> x * prod(signs), arr) \n        signs = map(x -> x != 0, signs) \n      \
    \  signs = filter(x -> x == 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs) \n  \
    \      signs = map(x -> x * prod(signs), arr) \n        signs = map(x -> x !=\
    \ 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = map(x\
    \ -> x * prod(signs), arr) \n        signs = map(x -> x != 0, signs) \n      \
    \  signs = filter(x -> x == 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs) \n  \
    \      signs = map(x -> x * prod(signs), arr) \n        signs = map(x -> x !=\
    \ 0, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = map(x\
    \ -> x * prod(signs), arr) \n        signs = map(x -> x != 0, signs) \n      \
    \  signs = filter(x -> x == 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = map(x -> x != 0, signs) \n        signs = filter(x ->\
    \ x == 0, signs) \n        signs = map(x -> x * prod(signs), arr\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc6d72vil.jl:58\nin expression starting at\
    \ /tmp/tmpc6d72vil.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr) \n            product *= signs[i]\n            signs[i] =\
    \ 0\n        end\n        return product * sum(abs(arr))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n4.3 Sum all numbers\
    \ in a vector\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphffbt4_b.jl:27\nin expression starting at\
    \ /tmp/tmphffbt4_b.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[0] * sign(arr[0])\n \
    \   else return arr[0] * prod_signs(arr[1:end-1]) * sign(arr[-1])\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxkaatzk.jl:14\nin expression starting at\
    \ /tmp/tmpnxkaatzk.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), signs) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaxdegbkg.jl:23\nin expression starting at\
    \ /tmp/tmpaxdegbkg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    else if length(arr)==1 return arr[1]\n    else \n        signs\
    \ = map(sign, arr)\n        mags = map(abs, arr)\n        mags = filter(x -> x==0,\
    \ mags)\n        mags = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1,\
    \ mags)\n        mags = map(prod, mags)\n        mags = map(sum, mags)\n     \
    \   mags = map(abs, mags)\n        mags = filter(x -> x==0, mags)\n        mags\
    \ = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1, mags)\n       \
    \ mags = map(prod, mags)\n        mags = map(sum, mags)\n        mags = map(abs,\
    \ mags)\n        mags = filter(x -> x==0, mags)\n        mags = filter(x -> x==1,\
    \ mags)\n        mags = filter(x -> x==-1, mags)\n        mags = map(prod, mags)\n\
    \        mags = map(sum, mags)\n        mags = map(abs, mags)\n        mags =\
    \ filter(x -> x==0, mags)\n        mags = filter(x -> x==1, mags)\n        mags\
    \ = filter(x -> x==-1, mags)\n        mags = map(prod, mags)\n        mags = map(sum,\
    \ mags)\n        mags = map(abs, mags)\n        mags = filter(x -> x==0, mags)\n\
    \        mags = filter(x -> x==1, mags)\n        mags = filter(x -> x==-1, mags)\n\
    \        mags = map(prod, mags)\n        mags = map(sum, mags)\n        mags =\
    \ map(abs, mags)\n        mags = filter(x -> x==0, mags)\n        mags = filter(x\
    \ -> x==1, mags)\n        mags = filter(x -> x==-1, mags)\n        mags = map(prod,\
    \ mags)\n        mags = map(sum, mags)\n        mags = map(abs, mags)\n      \
    \  mags = filter(x -> x==0, mags)\n        mags = filter(x -> x==1, mags)\n  \
    \      mags = filter(x -> x==-1, mags)\n        mags = map(prod, mags)\n     \
    \   mags = map(sum, mags)\n        mags = map(abs, mags)\n        mags = filter(x\
    \ -> x==0, mags)\n        mags = filter(x -> x==1, mags)\n        mags = filter(x\
    \ -> x==-1, \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2cm5snst.jl:14\nin expression starting at\
    \ /tmp/tmp2cm5snst.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that returns True\
    \ if a number is even, False otherwise. \nThe function should take one argument,\
    \ num.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnz12e0m1.jl:24\nin expression starting at\
    \ /tmp/tmpnz12e0m1.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that returns True if a number is even, False otherwise.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4x4cm24_.jl:24\nin expression starting at\
    \ /tmp/tmp4x4cm24_.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.3 Sum of magnitudes\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr0uuqq91.jl:24\nin expression starting at\
    \ /tmp/tmpr0uuqq91.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\
    \ \n        signs[arr .< 0] = -signs[arr .< 0] \n        signs[arr .> 0] = 1\n\
    \        signs = signs.prod() \n        return signs * prod(signs) \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an array arr of integers and returns\
    \ sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkwv7__6v.jl:23\nin expression starting at\
    \ /tmp/tmpkwv7__6v.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ sum of squares of integers in arr \nand returns sum of squares of integers multiplied\
    \ by product of all signs\nof each number in the array, represented by 1, -1 or\
    \ 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbrvebf6h.jl:22\nin expression starting at\
    \ /tmp/tmpbrvebf6h.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n\
    \    signs[2] = -1\n    \n    prod = 1\n    for i in 1:length(arr)\n        prod\
    \ *= signs[i]\n    end\n    \n    return prod * sum(abs(arr))\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is odd and False otherwise. Test it\
    \ on all odd numbers from 0 to 20.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphiz3zfo2.jl:26\nin expression starting at\
    \ /tmp/tmphiz3zfo2.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp6sgr7be.jl:22\nin expression starting at\
    \ /tmp/tmpp6sgr7be.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for i in arr\n        sum += i\n    end\n  \
    \  prod = 1\n    for i in arr\n        prod *= sign(i)\n    end\n    sign = signbit(sum)\n\
    \    if sign == 0 return sum\n    if sign == 1 return prod\n    return -prod\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns True if a number is odd, False\
    \ otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmgwcahhe.jl:27\nin expression starting at\
    \ /tmp/tmpmgwcahhe.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[0] * signs(arr[0])\n\
    \    else return sum(map(signs, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj9sceg42.jl:14\nin expression starting at\
    \ /tmp/tmpj9sceg42.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        product = prod(signs)\n        return product * sum(signs)\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5dh4crai.jl:24\nin expression starting at\
    \ /tmp/tmp5dh4crai.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        return sum(signs)\
    \ * prod(signs) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns True if a number is even, False otherwise. \nWrite a function that\
    \ returns True if a number is odd, False otherwise. \nWrite a function that returns\
    \ True if a number is positive, False otherwise. \nWrite a function that returns\
    \ True if a number is negative, False otherwise. \nWrite a function that returns\
    \ True if a number is zero, False otherwise. \nWrite a function that returns True\
    \ if a number is between 10 and 100, False otherwise. \nWrite a function that\
    \ returns True if a number is between -10 and -100, False otherwise. \nWrite a\
    \ function that returns True if a number is between 10 and 100, False otherwise.\
    \ \nWrite a function that returns True if a number is between -10 and -100, False\
    \ otherwise. \nWrite a function that returns True if a number is between 10 and\
    \ 100, False otherwise. \nWrite a function that returns True if a number is between\
    \ -10 and -100, False otherwise. \nWrite a function that returns True if a number\
    \ is between 10 and 100, False otherwise. \nWrite a function that returns True\
    \ if a number is between -10 and -100, False otherwise. \nWrite a function that\
    \ returns True if a number is between 10 and 100, False otherwise. \nWrite a function\
    \ that returns True if a number is between -10 and -100, False otherwise. \nWrite\
    \ a function that returns True if a number is between 10 and 100, False otherwise.\
    \ \nWrite a function that returns True if a number is between -10 and -100, False\
    \ otherwise. \nWrite a function that returns True if a number is between 10 and\
    \ 100, False otherwise. \nWrite a function that returns True if a number is between\
    \ -10 and -100, False otherwise. \nWrite a function that returns True if a number\
    \ is between 10 and 100, False otherwise. \nWrite a function that returns True\
    \ if a number is between -10 and -100, False otherwise. \nWrite a function that\
    \ returns True if a number is between 10 and 100, False otherwise. \nWrite a function\
    \ that returns True if a number is between -10 and -100, False otherwise. \nWrite\
    \ a function that returns True if a number is between 10 and 100, False otherwise.\
    \ \nWrite a function that returns True if a number is between -10 and -100, False\
    \ otherwise. \nWrite a function that returns True if a number is between 10 and\
    \ 100, False otherwise. \nWrite a function that returns True if a number is between\
    \ -10 and -100, False otherwise. \nWrite a function that returns True if a number\
    \ is between 10 and 100, False otherwise. \nWrite a function that returns True\
    \ if a number is between -10 and -100, False otherwise\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm6vd4gki.jl:23\nin expression starting at\
    \ /tmp/tmpm6vd4gki.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        mags = map(abs, arr) \n        return signs_prod\
    \ * sum(mags) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmxaem7k5.jl:22\nin expression starting at\
    \ /tmp/tmpmxaem7k5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        \n        mags = map(abs, arr)\n        mags = filter(x -> x != 0, mags)\n\
    \        mags = map(abs, mags)\n        mags = filter(x -> x != 0, mags)\n   \
    \     \n        mags = prod(mags)\n        \n        mags = map(x -> x * signs,\
    \ mags)\n        \n        mags = reduce(+, mags)\n        \n        return mags\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0rh3564s.jl:34\nin expression starting at\
    \ /tmp/tmp0rh3564s.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        return nothing\n    signs=zeros(Int, length(arr))\n    for i=1:length(arr)\n\
    \        signs[i]=sign(arr[i])\n    end\n    mags=map(abs, arr)\n    mags=map(sign,\
    \ mags)\n    mags=prod(mags)\n    return mags\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjk4qr_0o.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjk4qr_0o.jl:1\n\
    in expression starting at /tmp/tmpjk4qr_0o.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph337xb3o.jl:22\nin expression starting at\
    \ /tmp/tmph337xb3o.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n      \
    \  return product * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates\
    \ the sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzgz9uhzm.jl:22\nin expression starting at\
    \ /tmp/tmpzgz9uhzm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp65bgtoo3.jl:24\nin expression starting at\
    \ /tmp/tmp65bgtoo3.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns the number of integers in arr that are divisible by\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo9y80v5h.jl:22\nin expression starting at\
    \ /tmp/tmpo9y80v5h.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ the number of positive integers in an array.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe5e99tqm.jl:22\nin expression starting at\
    \ /tmp/tmpe5e99tqm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 1, signs)\
    \ \n        signs = filter(x -> x == -1, signs) \n        signs = collect(signs)\
    \ \n        signs = prod(signs) \n        signs = signs == 0 ? 1 : signs \n  \
    \      signs = signs == 1 ? 1 : signs \n        signs = signs == -1 ? -1 : signs\
    \ \n        return sum(abs(x) for x in arr) * signs \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of squares of numbers in arr using map and reduce\
    \ functions.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5gqdxkbe.jl:28\nin expression starting at\
    \ /tmp/tmp5gqdxkbe.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_signs = 0 \n        for el\
    \ in arr \n            sum_signs += sign(el) \n            \n        product =\
    \ 1\n        for el in arr \n            product *= sign(el) \n        \n    \
    \    return sum_signs * product \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7mz10_xe.jl:27\nin expression starting at\
    \ /tmp/tmp7mz10_xe.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return sum_of_mags * signs_product \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprmtg0bjq.jl:22\nin expression starting at\
    \ /tmp/tmprmtg0bjq.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return signs_product * sum_of_magnitudes \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nTask 3\nWrite a function\
    \ that returns number of integers in array arr which are divisible by given number\
    \ k.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpviy6ayn7.jl:22\nin expression starting at\
    \ /tmp/tmpviy6ayn7.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_signs = 0 \n        for el\
    \ in arr \n            sum_signs += sign(el) \n        product = prod(arr) \n\
    \        return sum_signs * product \n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThanks for your answer. Can you please explain why you used `@inbounds`?\n\
    <|/ c |>\n<| c |>\n`@inbounds` tells Julia to execute the function `prod_signs`\
    \ in-place. Without it, Julia would try to evaluate the function `prod_signs`\
    \ before calling `prod_signs`, which would result in an error since `prod_signs`\
    \ expects an array as its first argument. With the `@inbounds` Julia will execute\
    \ the function in-place and `prod_signs` will receive an array as its first argument.\n\
    <|/ c |>\n<| c |>\nThanks for your explanation. Can you please explain why you\
    \ used `@inbounds`?\n<|/ c |>\n<| c |>\n`@inbounds` tells Julia to execute the\
    \ function `prod_signs` in-place. Without it, Julia would try to evaluate the\
    \ function `prod_signs` before calling `prod_signs`, which would result in an\
    \ error since `prod_signs` expects an array as its first argument. With the `@inbounds`\
    \ Julia will execute the function in-place and `prod_signs` will receive an array\
    \ as its first argument.\n<|/ c |>\n<| c |>\nThanks for your explanation. Can\
    \ you please explain why you used `@inbounds`?\n<|/ c |>\n<| a dscore=2 |>\nI\
    \ thought I would post a solution using broadcasting which I believe is more efficient\
    \ than looping over all elements. \n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqcfib4i7.jl:23\nin expression starting at\
    \ /tmp/tmpqcfib4i7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        signs = signs.*ones(Int64, length(arr))\n        signs = signs.*signs\n\
    \        product = prod(signs)\n        magnitude = sqrt(sum(abs2, arr))\n   \
    \     return product * magnitude\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI\
    \ like this solution. However I wonder if there is a way to avoid the for loop\
    \ and use broadcasting instead?\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ the for loop and uses broadcasting.\n<|/ c |>\n<| c |>\nThanks, I like the broadcast\
    \ solution. However I wonder if there is a way to avoid the for loop and use broadcasting\
    \ instead?\n<|/ c |>\n<| c |>\nI added a solution that avoids the for loop and\
    \ uses broadcasting.\n<|/ c |>\n<| c |>\nThanks, I like the broadcast solution.\
    \ However I wonder if there is a way to avoid the for loop and use broadcasting\
    \ instead?\n<|/ c |>\n<| a dscore=2 |>\nThis solution uses broadcasting and avoids\
    \ the for loop:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3ra30p16.jl:27\nin expression starting at\
    \ /tmp/tmp3ra30p16.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * signs[i]\n\
    \        end\n        sum(signs)\n    end\nend\n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkgjhxdw_.jl:23\nin expression starting at\
    \ /tmp/tmpkgjhxdw_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for i in arr\n        prod *= sign(i)\n   \
    \ end\n    return prod\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb521rmig.jl:20\nin expression starting at\
    \ /tmp/tmpb521rmig.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i = 1:length(arr) \n            signs[i] = sign(arr[i])\n       \
    \ end\n        product = prod(signs)\n        magnitudes = map(abs, arr)\n   \
    \     sum_magnitudes = sum(magnitudes)\n        return product * sum_magnitudes\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of positive\
    \ numbers in an array.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcokbzzuc.jl:26\nin expression starting at\
    \ /tmp/tmpcokbzzuc.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpga2tql9u.jl:24\nin expression starting at\
    \ /tmp/tmpga2tql9u.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return signs_prod * sum_of_mags \n    end\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes an array arr of integers and returns its sum\
    \ of the absolute values.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2bvxuo8b.jl:22\nin expression starting at\
    \ /tmp/tmp2bvxuo8b.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\n         \
    \   signs[i] = sign(arr[i])\n        end\n        signs = signs * prod(signs)\n\
    \        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1t1or_xd.jl:14\nin expression starting at\
    \ /tmp/tmp1t1or_xd.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = signs(arr) \n        signs_product\
    \ = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .- signs_product))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that checks if a number is odd or even.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5f8hdzyt.jl:22\nin expression starting at\
    \ /tmp/tmp5f8hdzyt.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n\
    <| a dscore=2 |>\nA simple and efficient solution:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvaoy93yi.jl:22\nin expression starting at\
    \ /tmp/tmpvaoy93yi.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> sum(x), signs) \n        return sum(signs) \n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdqogh7jh.jl:26\nin expression starting at\
    \ /tmp/tmpdqogh7jh.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the number of positive numbers in an array.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplk7v3mru.jl:21\nin expression starting at\
    \ /tmp/tmplk7v3mru.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n\
    @assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns True if a number is odd and False otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcmk8ehje.jl:21\nin expression starting at\
    \ /tmp/tmpcmk8ehje.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns the\
    \ number of integers in the array arr that are divisible by 3\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnmis_xga.jl:24\nin expression starting at\
    \ /tmp/tmpnmis_xga.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9uax8jia.jl:21\nin expression starting at\
    \ /tmp/tmp9uax8jia.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\
    \ \n        signs[1] = 1 \n        signs[2] = -1 \n        signs[3] = 0 \n   \
    \     product = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .- product))\
    \ \n        return sum_of_magnitudes * product \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is even, False otherwise. \nWrite a\
    \ function that returns True if a number is odd, False otherwise. \nWrite a function\
    \ that returns True if a number is prime, False otherwise. \nWrite a function\
    \ that returns True if a number is composite (that is, has no divisors other than\
    \ 1 and itself), False otherwise. \nWrite a function that returns True if a number\
    \ is perfect square, False otherwise. \nWrite a function that returns True if\
    \ a number is perfect cube, False otherwise. \nWrite a function that returns True\
    \ if a number is perfect fibonacci, False otherwise. \nWrite a function that returns\
    \ True if a number is perfect hyperbolic triangular, False otherwise. \nWrite\
    \ a function that returns True if a number is perfect logarithm, False otherwise.\
    \ \nWrite a function that returns True if a number is perfect exponential function,\
    \ False otherwise. \nWrite a function that returns True if a number is perfect\
    \ hypergeometric function, False otherwise. \nWrite a function that returns True\
    \ if a number is perfect triangular number, False otherwise. \nWrite a function\
    \ that returns True if a number is perfect square root, False otherwise. \nWrite\
    \ a function that returns True if a number is perfect cubic number, False otherwise.\
    \ \nWrite a function that returns True if a number is perfect quartic number,\
    \ False otherwise. \nWrite a function that returns True if a number is perfect\
    \ quintic number, False otherwise. \nWrite a function that returns True if a number\
    \ is perfect secantic number, False otherwise. \nWrite a function that returns\
    \ True if a number is perfect hyperbolic secantic number, False otherwise. \n\
    Write a function that returns True if a number is perfect exponential function,\
    \ False otherwise. \nWrite a function that returns True if a number is perfect\
    \ logarithm, False otherwise. \nWrite a function that returns True if a number\
    \ is perfect exponential function, False otherwise. \nWrite a function that returns\
    \ True if a number is perfect hypergeometric function, False otherwise. \nWrite\
    \ a function that returns True if a number is perfect triangular number, False\
    \ otherwise. \nWrite a function that returns True if a number is perfect square\
    \ root, False otherwise. \nWrite a function that returns \nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzu9bek7s.jl:25\nin expression starting at\
    \ /tmp/tmpzu9bek7s.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i, x) in enumerate(arr)\n            signs[i] = sign(x) * sign(i)\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzbhq91lt.jl:23\nin expression starting at\
    \ /tmp/tmpzbhq91lt.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = reduce(mul, signs) \n        return product \nend\n</cell>\n<code\
    \ language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of each number in the array, represented by 1, -1 or 0.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk9b9yagy.jl:20\nin expression starting at\
    \ /tmp/tmpk9b9yagy.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = map(x -> x * prod(signs), signs) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9mqf0j2w.jl:23\nin expression starting at\
    \ /tmp/tmp9mqf0j2w.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  signs = signs == 0 ? 1 : -1 \n        signs = signs * prod(map(abs, arr)) \n\
    \        return signs \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf9wr64cm.jl:24\nin expression starting at\
    \ /tmp/tmpf9wr64cm.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = prod(signs) \n        return product\
    \ * sum(mags) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5lz492ci.jl:22\nin expression starting at\
    \ /tmp/tmp5lz492ci.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbm8z3l8l.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbm8z3l8l.jl:1\n\
    in expression starting at /tmp/tmpbm8z3l8l.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=1 |>\nThe answer by is correct, but I wanted\
    \ to point out that you can also use reduce to solve this problem in one line:\n\
    <code>\nreduce(x -> sign(x) * prod(sign(x)), arr)\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk9uevoms.jl:20\nin expression starting at\
    \ /tmp/tmpk9uevoms.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        \n        sum_of_mags = sum(abs.(signs))\n        prod_of_mags = prod(signs)\n\
    \        return sum_of_mags * prod_of_mags\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf0d_9wrh.jl:25\nin expression starting at\
    \ /tmp/tmpf0d_9wrh.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for x in arr\n        prod *= sign(x)\n   \
    \ end\n    return prod\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg4jtrp26.jl:20\nin expression starting at\
    \ /tmp/tmpg4jtrp26.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    prod = 1\n    for i in arr\n        sum += abs(i)\n\
    \        prod *= sign(i)\n    end\n    return sum * prod\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcvcr_dzw.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcvcr_dzw.jl:1\n\
    in expression starting at /tmp/tmpcvcr_dzw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = 0 \n        for el\
    \ in arr \n            sum_of_mags += el * sign(el) \n        return sum_of_mags\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates the sum of squares\
    \ of integers multiplied by product of all signs of each number in the array,\
    \ represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzhlg82oj.jl:22\nin expression starting at\
    \ /tmp/tmpzhlg82oj.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags\
    \ = prod(mags) \n        return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\n4.3 Product of Signs\nWrite a function\
    \ that calculates the product of all signs of an array.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmo6jkrhz.jl:25\nin expression starting at\
    \ /tmp/tmpmo6jkrhz.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags)\
    \ \n        return signs * mags \n    end\nend\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns True if a number is even, False otherwise. \nWrite\
    \ a function that returns True if a number is odd, False otherwise. \nWrite a\
    \ function that returns True if a number is prime, False otherwise. \nWrite a\
    \ function that returns True if a number is composite (that is, if it divides\
    \ evenly into another number), False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by another number, False otherwise. \nWrite a\
    \ function that returns True if a number is divisible by all numbers from 1 to\
    \ n, False otherwise. \nWrite a function that returns True if a number is divisible\
    \ by all numbers from 1 to n and even, False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by all numbers from 1 to n and odd, False\
    \ otherwise. \nWrite a function that returns True if a number is divisible by\
    \ all numbers from 1 to n and prime (that is, divisible by all numbers from 1\
    \ to n and even), False otherwise. \nWrite a function that returns True if a number\
    \ is divisible by all numbers from 1 to n and composite, False otherwise. \nWrite\
    \ a function that returns True if a number is divisible by all numbers from 1\
    \ to n and divisible by all numbers from 1 to m, False otherwise. \nWrite a function\
    \ that returns True if a number is divisible by all numbers from 1 to n and divisible\
    \ by all numbers from 1 to m and even, False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by all numbers from 1 to n and divisible\
    \ by all numbers from 1 to m and odd, False otherwise. \nWrite a function that\
    \ returns True if a number is divisible by all numbers from 1 to n and divisible\
    \ by all numbers from 1 to m and prime (that is, divisible by all numbers from\
    \ 1 to n and even), False otherwise. \nWrite a function that returns True if a\
    \ number is divisible by all numbers from 1 to n and divisible by all numbers\
    \ from 1 to m and composite, False otherwise. \nWrite a function that returns\
    \ True if a number is divisible by all numbers from 1 to n and divisible by all\
    \ numbers from 1 to m and divisible by all numbers from 1 to n, False otherwise.\
    \ \nWrite a function that returns True if a number is divisible by all numbers\
    \ from 1 to n and divisible by all numbers from 1 to m and divisible by all numbers\
    \ from 1 to n and even, False otherwise. \nWrite a function that returns True\
    \ if a \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp86nns9qg.jl:23\nin expression starting at\
    \ /tmp/tmp86nns9qg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = signs(arr) \n        product\
    \ = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n        return product\
    \ * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates the sum\
    \ of squares of integers in arr\nand returns the result as a Float64. Test your\
    \ function on arr = [1, 2, 3].\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcwhjcrl3.jl:22\nin expression starting at\
    \ /tmp/tmpcwhjcrl3.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = sum(map(abs, arr))\n\
    \        signs = map(sign, arr)\n        product = signs.*signs\n        return\
    \ sum_of_mags*product\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/27674155)\n\
    <|/ c |>\n<| c |>\nI believe it does provide an answer to the question. He asked\
    \ how to calculate the product of signs of numbers in the array. He also provided\
    \ a solution that he has already tried. I believe this to be a better answer to\
    \ the question than my own.\n<|/ c |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/27674155)\n\
    <|/ c |>\n<| c |>\nI believe it does provide an answer to the question. He asked\
    \ how to calculate the product of signs of numbers in the array. He also provided\
    \ a solution that he has already tried. I believe this to be a better answer to\
    \ the question than my own.\n<|/ c |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/27674155)\n\
    <|/ c |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg85zoe_2.jl:22\nin expression starting at\
    \ /tmp/tmpg85zoe_2.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. `prod(signs(-4:-1))`\
    \ returns `-1` instead of `0`.\n<|/ c |>\n<| a dscore=2 |>\nI like using map and\
    \ sum to solve this problem:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw61ugj1e.jl:20\nin expression starting at\
    \ /tmp/tmpw61ugj1e.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        nothing\n    elseif length(arr)==1\n        arr[1]*prod(signs(arr))\n\
    \    else\n        arr[1]*prod(signs(arr))*prod_signs(arr[2:end])\n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays,performance |>\nI wrote a Julia\
    \ package that does this for you:\nhttps://github.com/jrwlk/ArrayMagnitude\n<code>\n\
    julia> using ArrayMagnitude\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg8dmdfwo.jl:21\nin expression starting at\
    \ /tmp/tmpg8dmdfwo.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprgoz7y3o.jl:22\nin expression starting at\
    \ /tmp/tmprgoz7y3o.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis code does not work\
    \ if `arr` is empty. `prod([])` returns `Inf`, which is not what we want. `sum(abs.(product))`\
    \ should be `sum(abs.(product))`.\n<|/ c |>\n<| c |>\nThanks, I've fixed the code.\n\
    <|/ c |>\n<| a tags=julia |>\nI came up with a solution using broadcasting and\
    \ the function prod from the StatsBase package:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphyy5m0xi.jl:24\nin expression starting at\
    \ /tmp/tmphyy5m0xi.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 1, signs)\
    \ \n        signs = filter(x -> x == -1, signs) \n        signs = map(x -> x *\
    \ prod(signs), arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\n4.5 Product of absolute\
    \ values\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprf80ol0r.jl:24\nin expression starting at\
    \ /tmp/tmprf80ol0r.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        sum_of_mags\
    \ = sum(abs.(arr .* signs))\n        prod_of_mags = prod(signs)\n        return\
    \ sum_of_mags * prod_of_mags\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not answer the question, which is about how to do this in Julia. Your solution\
    \ does not take into account the fact that `prod(signs)` should be `1` if the\
    \ array is all positive.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've\
    \ updated the answer to include a solution that does take that into account.\n\
    <|/ c |>\n<| a tags=julia |>\nHere is a solution that does not require any packages:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr6t4sl3n.jl:24\nin expression starting at\
    \ /tmp/tmpr6t4sl3n.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    else if length(arr)==1 return arr[1]\n    else \n        signs\
    \ = zeros(length(arr))\n        for i = 1:length(arr)\n            signs[i] =\
    \ sign(arr[i])\n        end\n        \n        sum_signs = sum(signs)\n      \
    \  \n        product = 1\n        for i = 1:length(arr)\n            product =\
    \ product * signs[i]\n        end\n        \n        return sum_signs * product\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns True if a number is\
    \ odd, False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo8gzgwz6.jl:14\nin expression starting at\
    \ /tmp/tmpo8gzgwz6.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuyi8sr_g.jl:22\nin expression starting at\
    \ /tmp/tmpuyi8sr_g.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        return sum(signs)\
    \ \n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `prod([-1,0,1])` returns `0`, but should be `-1`.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8soheqaq.jl:23\nin expression starting at\
    \ /tmp/tmp8soheqaq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else \n        signs = map(sign, arr) \n        signs =\
    \ filter(x -> x != 0, signs) \n        signs = prod(signs) \n        return sum(map(abs,\
    \ arr) * signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that calculates the sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8u6quv84.jl:21\nin expression starting at\
    \ /tmp/tmp8u6quv84.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that finds\
    \ the number of positive numbers in an array.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqsw8xw0t.jl:22\nin expression starting at\
    \ /tmp/tmpqsw8xw0t.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes an array arr of integers\
    \ and returns sum of squares of integers multiplied by product of all signs of\
    \ each number in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz28f5saj.jl:21\nin expression starting at\
    \ /tmp/tmpz28f5saj.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(i) * sign(arr[i])\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphoh60rml.jl:23\nin expression starting at\
    \ /tmp/tmphoh60rml.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\n\
    \        return nothing\n    else\n        signs = map(sign, arr)\n        signs\
    \ = filter(x -> x != 0, signs)\n        signs = map(x -> x * prod(signs), arr)\n\
    \        return sum(signs)\n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpscztdpmy.jl:22\nin expression starting at\
    \ /tmp/tmpscztdpmy.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n        mags\
    \ = prod(mags) \n        return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is divisible by 3 and False otherwise. Test it on several examples:\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpikzcxb4a.jl:25\nin expression starting at\
    \ /tmp/tmpikzcxb4a.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else if length(arr) == 1 return arr[1]*sign(arr[1]) \n \
    \   else \n        signs = zeros(Int, length(arr))\n        for i = 1:length(arr)\
    \ signs[i] = sign(arr[i])\n        signs = signs.*arr\n        return sum(abs2,\
    \ signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\n4.2 Sum all magnitudes\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpubq70vas.jl:14\nin expression starting at\
    \ /tmp/tmpubq70vas.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(x -> x * prod(signs), arr) \n        return\
    \ sum(signs) \n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptok5jndg.jl:25\nin expression starting at\
    \ /tmp/tmptok5jndg.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        sum = 0\n\
    \        for i in 1:length(arr) \n            sum += signs[i] * abs(arr[i])\n\
    \        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates\
    \ sum of squares of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbepu6stl.jl:26\nin expression starting at\
    \ /tmp/tmpbepu6stl.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for i in arr\n        sum += abs(i)*sign(i)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzql6c5d3.jl:20\nin expression starting at\
    \ /tmp/tmpzql6c5d3.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    \n    sum = 0\n    for i in arr\n        sum += i\n    end\n\
    \    \n    prod = 1\n    for i in arr\n        prod *= sign(i)\n    end\n    \n\
    \    return sum * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\nExercise 2\nWrite a function that returns True if a number\
    \ is odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprfe3ob8k.jl:27\nin expression starting at\
    \ /tmp/tmprfe3ob8k.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[2]\
    \ = -1\n    signs[3] = -1\n    product = 1\n    for i in 1:length(arr)\n     \
    \   product *= signs[i]\n    end\n    return product * sum(abs(arr))\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_69j0m0p.jl:24\nin expression starting at\
    \ /tmp/tmp_69j0m0p.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product =\
    \ signs .* prod(signs)\n        return sum(abs(product))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpch7c1sb8.jl:23\nin expression starting at\
    \ /tmp/tmpch7c1sb8.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)\n    end\n\
    \    return sum * prod(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxj47caji.jl:20\nin expression starting at\
    \ /tmp/tmpxj47caji.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    \n    sum = 0\n    for i in arr\n        sum += i\n    end\n\
    \    \n    prod = 1\n    for i in arr\n        prod *= sign(i)\n    end\n    \n\
    \    return sum * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ None\n</cell>\n<text>\n4.5 Sign of numbers\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0v14m1nb.jl:27\nin expression starting at\
    \ /tmp/tmp0v14m1nb.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that returns True if a number is even, False otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgkd404r5.jl:22\nin expression starting at\
    \ /tmp/tmpgkd404r5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return sum_of_mags * signs_product \n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa_c0gp8o.jl:22\nin expression starting at\
    \ /tmp/tmpa_c0gp8o.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        sum_of_mags = sum(map(abs, arr))\
    \ \n        signs = map(sign, arr) \n        product = signs.prod \n        return\
    \ sum_of_mags * product \nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfym_yzbs.jl:21\nin expression starting at\
    \ /tmp/tmpfym_yzbs.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwapahdzx.jl:22\nin expression starting at\
    \ /tmp/tmpwapahdzx.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = prod(signs) \n        return product\
    \ * prod(mags) \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbv6gmvq2.jl:22\nin expression starting at\
    \ /tmp/tmpbv6gmvq2.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return signs_product * sum_of_magnitudes \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ct7eb8i.jl:22\nin expression starting at\
    \ /tmp/tmp8ct7eb8i.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags)\
    \ \n        return signs * mags \n    end\nend\n</code>\n<|/ a tags=julia,function,arrays\
    \ |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp86d74edv.jl:23\nin expression starting at\
    \ /tmp/tmp86d74edv.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiadtoaus.jl:64\nin expression starting at\
    \ /tmp/tmpiadtoaus.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\
    \ \n        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return product * sum(magnitudes)\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes an array\
    \ of integers and returns its sum.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp3jkz5m1.jl:24\nin expression starting at\
    \ /tmp/tmpp3jkz5m1.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end]\
    \ = -1\n    prod = 1\n    for x in arr\n        prod *= signs[x]\n    end\n  \
    \  return prod\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaisoairm.jl:23\nin expression starting at\
    \ /tmp/tmpaisoairm.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        sum_of_mags = sum(abs.(arr .- product))\n        return sum_of_mags \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1_lz5037.jl:24\nin expression starting at\
    \ /tmp/tmp1_lz5037.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = map(sign, arr)\n        signs_product = prod(signs)\n        sum_of_mags\
    \ = sum(map(abs, arr))\n        return signs_product * sum_of_mags\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns True if a number is odd, False\
    \ otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5ckg3pv9.jl:14\nin expression starting at\
    \ /tmp/tmp5ckg3pv9.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        return signs_prod * sum(map(abs, arr))\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.2 Write a function to find all numbers that satisfy a given\
    \ condition\nWrite a function that takes an array arr of integers and returns\
    \ all numbers in arr that satisfy a given condition. Return an empty array if\
    \ there are no such numbers. For example, given arr = [1, 2, 3, 4] and condition\
    \ = x -> x % 2 == 0, your function should return [2, 4].\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa7ujicj9.jl:21\nin expression starting at\
    \ /tmp/tmpa7ujicj9.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs.(product))\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp8i9kgo9.jl:24\nin expression starting at\
    \ /tmp/tmpp8i9kgo9.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum = 0\n        for s in signs \n       \
    \     sum += s * product \n        return sum \n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwep3nl43.jl:24\nin expression starting at\
    \ /tmp/tmpwep3nl43.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)\n    end\n\
    \    return sum * prod(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd, False otherwise. \nThe function should work for any\
    \ type of number.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1fvpjlwy.jl:20\nin expression starting at\
    \ /tmp/tmp1fvpjlwy.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpakhvi_3j.jl:20\nin expression starting at\
    \ /tmp/tmpakhvi_3j.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[0] * sign(arr[0])\n \
    \   else \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1]\
    \ = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        product\
    \ = prod(signs)\n        magnitudes = map(abs, arr)\n        return sum(magnitudes\
    \ .* product)\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like this\
    \ solution, although it does require a type declaration for the return type. `function\
    \ prod_signs(arr::Vector{Int64})::Int64`\n<|/ c |>\n<| c |>\nYes, I agree. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=2 |>\nI like using reduce to solve\
    \ this problem:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaw3d2fn7.jl:14\nin expression starting at\
    \ /tmp/tmpaw3d2fn7.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else \n     \
    \   signs = zeros(Int, length(arr))\n        for i in 1:length(arr)\n        \
    \    signs[i] = sign(arr[i])\n        end\n        mags = map(abs, arr)\n    \
    \    mags = map(sign, mags)\n        mags = map(prod, mags)\n        return sum(mags)\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpteuad_oh.jl:14\nin expression starting at\
    \ /tmp/tmpteuad_oh.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that returns True\
    \ if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv3sesbit.jl:24\nin expression starting at\
    \ /tmp/tmpv3sesbit.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 1] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb0l4y0xw.jl:24\nin expression starting at\
    \ /tmp/tmpb0l4y0xw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        product = prod(arr) \n        return signs * product \n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\nI came up with a solution that\
    \ is more efficient than others posted so far:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwym5u1sg.jl:25\nin expression starting at\
    \ /tmp/tmpwym5u1sg.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs =\
    \ sum(signs) \n        return signs * prod(signs) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjp89jvq6.jl:26\nin expression starting at\
    \ /tmp/tmpjp89jvq6.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for i in 1:length(arr) \n            signs[i] = sign(arr[i])\n      \
    \  end\n        signs = signs * prod(signs)\n        return sum(abs2, signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd, False otherwise. \nThe function should work for any type of number, not\
    \ just integers. \nIt should work for negative numbers as well. \nIt should work\
    \ for floating point numbers as well.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxoq30r1s.jl:24\nin expression starting at\
    \ /tmp/tmpxoq30r1s.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n   \
    \     return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbfo8y944.jl:22\nin expression starting at\
    \ /tmp/tmpbfo8y944.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    prod = 1\n    for i in arr\n        prod *= sign(i)\n   \
    \ end\n    return prod * prod(arr)\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that finds\
    \ the number of positive numbers in an array.\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqf9by69q.jl:20\nin expression starting at\
    \ /tmp/tmpqf9by69q.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4cu5bay5.jl:22\nin expression starting at\
    \ /tmp/tmp4cu5bay5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns True if a number is\
    \ even, False otherwise. \nThe function should take one argument, num.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfjlxe8cp.jl:21\nin expression starting at\
    \ /tmp/tmpfjlxe8cp.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for i in arr\n        sum += sign(i) * i\n   \
    \ end\n    return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpydu4hm68.jl:20\nin expression starting at\
    \ /tmp/tmpydu4hm68.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs_product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n\
    \        return sum_of_mags * signs_product \nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/26827814)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He asked how to find\
    \ the product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0. I provided a solution that does exactly\
    \ that. He also asked how to find the sum of magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0. I provided a solution that does exactly\
    \ that. He also asked how to find the sum of magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that.\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/26827814)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He asked how to find\
    \ the product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by 1, -1 or 0. I provided a solution that does exactly\
    \ that. He also asked how to find the sum of magnitudes of integers multiplied\
    \ by product of all signs of each number in the array, represented by 1, -1 or\
    \ 0. I provided a solution that does exactly that. He also asked how to find the\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array, represented by \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdwig4c33.jl:21\nin expression starting at\
    \ /tmp/tmpdwig4c33.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = filter(x -> x == 1, signs) \n        signs =\
    \ filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs = filter(x\
    \ -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs\
    \ = filter(x -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs) \n\
    \        signs = filter(x -> x == -1, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs\
    \ = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n\
    \        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x ==\
    \ 1, signs) \n        signs = filter(x -> \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3jaobvf_.jl:64\nin expression starting at\
    \ /tmp/tmp3jaobvf_.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = prod(signs) \n        mags = map(abs, arr) \n\
    \        mags = filter(x -> x != 0, mags) \n        mags = filter(x -> x == 0,\
    \ mags) \n        mags = filter(x -> x == 1, mags) \n        mags = filter(x ->\
    \ x == -1, mags) \n        mags = prod(mags) \n        return signs * mags \n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\n4.2 Sum all digits of an integer\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1esk1o6d.jl:31\nin expression starting at\
    \ /tmp/tmp1esk1o6d.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        product = product == 0 ? 1 : product \n  \
    \      return sum(map(abs, arr)) * product \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpriyi4t17.jl:22\nin expression starting at\
    \ /tmp/tmpriyi4t17.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(x -> x * prod(signs), arr) \n        signs\
    \ = map(x -> sum(x), signs) \n        return sum(signs) \nend\n</cell>\n<code\
    \ language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == None\n</cell>\n<text>\nTask 3\nWrite a function\
    \ that calculates sum of squares of integers in arr. \nThe function should return\
    \ sum of squares of integers in arr multiplied by product of all signs\nof each\
    \ number in the array, represented by 1, -1 or 0.\nNote: return 0 for empty arr.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2rsrlt_1.jl:25\nin expression starting at\
    \ /tmp/tmp2rsrlt_1.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x == -1,\
    \ signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        mags = map(abs, arr) \n        mags = filter(x -> x == 0, mags) \n\
    \        mags = filter(x -> x == 1, mags) \n        mags = filter(x -> x == -1,\
    \ mags) \n        mags = sum(mags) \n        return signs * mags \n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\nI came up with this:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy9nnipbz.jl:29\nin expression starting at\
    \ /tmp/tmpy9nnipbz.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs\
    \ * prod(signs)\n        return sum(abs(arr) * signs)\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `prod_signs([1, 2, 2, -4])\
    \ == -9` returns `-9` but `prod_signs([0, 1]) == 0` returns `0`.\n<|/ c |>\n<|\
    \ c |>\nThanks for pointing that out. I fixed the code.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI believe this can be done in O(n) time complexity using an auxiliary array\
    \ (O(n) space) where you store the sign of each number in the array and multiply\
    \ it with the product of the absolute value of the numbers in the array. \n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv5nkkhak.jl:23\nin expression starting at\
    \ /tmp/tmpv5nkkhak.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i = 1:length(arr) \n            signs[i] = sign(arr[i])\n       \
    \ end\n        \n        sum_of_magnitudes = sum(abs.(arr .* signs))\n       \
    \ \n        product = prod(signs)\n        return sum_of_magnitudes * product\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n@time prod_signs(rand(1:100));\n\
    </cell>\n<text>\nExercise\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwc2abcf9.jl:27\nin expression starting at\
    \ /tmp/tmpwc2abcf9.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of positive numbers in an array.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmjltwcow.jl:22\nin expression starting at\
    \ /tmp/tmpmjltwcow.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpch00ita6.jl:24\nin expression starting at\
    \ /tmp/tmpch00ita6.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    else if length(arr) == 1 return arr[1]\n    else return sum(map(sign,\
    \ arr))\nend\n</cell>\n<code language=julia-1.4>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == None\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd and False otherwise.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj82n8wbc.jl:14\nin expression starting at\
    \ /tmp/tmpj82n8wbc.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if\
    \ you have negative numbers in the array. For example, `prod_signs([-1, -2, 3])`\
    \ returns `-1` instead of `0`.\n<|/ c |>\n<| c |>\nYes, I agree with you. My solution\
    \ is just an alternative to OP's solution. OP asked for sum of magnitudes of integers\
    \ multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\n<|/ c |>\n<| c |>\nYes, I agree with you. My solution is just\
    \ an alternative to OP's solution. OP asked for sum of magnitudes of integers\
    \ multiplied by product of all signs of each number in the array, represented\
    \ by 1, -1 or 0.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require any\
    \ loops.\n<|/ c |>\n<| a dscore=2 |>\nThe function below will return the product\
    \ of the signs of the numbers in the array:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo1u5k97v.jl:20\nin expression starting at\
    \ /tmp/tmpo1u5k97v.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None \n    else if length(arr) == 1 return arr[1] \n    else \n   \
    \     signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n      \
    \  signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        product = signs\
    \ .* prod(signs)\n        return sum(abs(product))\n    end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr4grmuil.jl:14\nin expression starting at\
    \ /tmp/tmpr4grmuil.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = prod(signs) \n        return product\
    \ * sum(mags) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes an array of integers and returns its sum of the absolute values.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbaldrs_x.jl:22\nin expression starting at\
    \ /tmp/tmpbaldrs_x.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = map(x -> x * prod(signs),\
    \ arr) \n        return sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is divisible by 7 and False otherwise. Test it on all numbers\
    \ from 1 to 100.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsuwuyrz5.jl:22\nin expression starting at\
    \ /tmp/tmpsuwuyrz5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x == 1, signs)\
    \ \n        signs = filter(x -> x == -1, signs) \n        signs = prod(signs)\
    \ \n        return signs * prod(map(abs, arr)) \n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of positive integers in an\
    \ array.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpniv7y_ns.jl:24\nin expression starting at\
    \ /tmp/tmpniv7y_ns.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n      \
    \  return product * sum_of_mags \n    end\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks for your answer. Your code works perfectly for me. I am just wondering\
    \ why you used `Int64` instead of `Int`? I thought `Int` was enough.\n<|/ c |>\n\
    <| c |>\n`Int` is enough for your case, but `Int64` will allow you to work with\
    \ larger numbers. `Int` will allow you to work with smaller numbers, but `Int64`\
    \ will allow you to work with larger numbers. `Int` will allow you to work with\
    \ smaller numbers, but `Int64` will allow you to work with larger numbers. `Int`\
    \ will allow you to work with smaller numbers, but `Int64` will allow you to work\
    \ with larger numbers. `Int` will allow you to work with smaller numbers, but\
    \ `Int64` will allow you to work with larger numbers.\n<|/ c |>\n<| c |>\nThanks\
    \ for the explanation. I am new to Julia and I didn't know that `Int` is enough\
    \ for my case. Thanks again.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_n0f8n_w.jl:22\nin expression starting at\
    \ /tmp/tmp_n0f8n_w.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        sum_of_mags\
    \ = sum(abs, signs)\n        product = signs .* prod(signs)\n        return sum_of_mags\
    \ * product\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to avoid the loop. Maybe with some\
    \ fancy `broadcasting`?\n<|/ c |>\n<| c |>\nI added a solution without loop\n\
    <|/ c |>\n<| c |>\nI added a solution without loop\n<|/ c |>\n<| c |>\nI added\
    \ a solution without loop\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4ijafmzk.jl:24\nin expression starting at\
    \ /tmp/tmp4ijafmzk.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n      \
    \  mags = map(abs, arr) \n        return sum(mags * signs) \nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcp888979.jl:22\nin expression starting at\
    \ /tmp/tmpcp888979.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4vjq6dlh.jl:22\nin expression starting at\
    \ /tmp/tmp4vjq6dlh.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x == 0, signs)\
    \ \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x\
    \ == -1, signs) \n        signs = map(prod, signs) \n        return sum(signs)\
    \ \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that takes an\
    \ array arr of integers and returns sum of squares of integers multiplied by product\
    \ of all signs of each number in the array, represented by 1, -1 or 0.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwbx8y_h7.jl:25\nin expression starting at\
    \ /tmp/tmpwbx8y_h7.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for x in arr\n        sum += sign(x)*abs(x)\n\
    \    end\n    return sum\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for\
    \ your answer. I am not allowed to use any packages other than Base.\n<|/ c |>\n\
    <| c |>\nI added a solution that does not use any packages.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I tried your solution and it works fine. I am still trying\
    \ to understand why my code didn't work. I am new to Julia and I still don't understand\
    \ why my code didn't work.\n<|/ c |>\n<| c |>\nThe reason your code didn't work\
    \ is because you were trying to use an `if` statement inside a `for` loop. `if`\
    \ statements don't work inside `for` loops. `for` loops work differently than\
    \ `if` statements. `for` loops iterate over each element in a collection and perform\
    \ an operation on that element. `if` statements work differently than `for` loops.\
    \ `if` statements test a condition and perform an operation if the condition is\
    \ true. `for` loops iterate over each element in a collection and perform an operation\
    \ on that element if the condition is true.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that does not use any packages.\n<|/ c |>\n<| a dscore=0 |>\nThis solution uses\
    \ no packages and is very similar to your original solution:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_uvbyksx.jl:20\nin expression starting at\
    \ /tmp/tmp_uvbyksx.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 return None\n    sum = 0\n    for i in arr\n        sum += sign(i) * i\n \
    \   end\n    return sum\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis\
    \ doesn't seem to work. `prod_signs([1, 2, 2, -4]) == -9` returns `-9` but `prod_signs([0,\
    \ 1]) == 0` returns `0` which is wrong.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks\
    \ for pointing it out. Now it works.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpncx5m1lr.jl:20\nin expression starting at\
    \ /tmp/tmpncx5m1lr.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr)==0\
    \ return None\n    sum = 0\n    for i in arr\n        sign = sign(i)\n       \
    \ sum += sign*i\n    end\n    return sum\nend\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy_18l7gl.jl:12\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy_18l7gl.jl:1\n\
    in expression starting at /tmp/tmpy_18l7gl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n      \
    \  return product * sum_of_mags \n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == None\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ True if a number is odd and False otherwise. \nThe function should work for\
    \ any type of numbers, not just integers. \nThe function should work for negative\
    \ numbers as well.\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuwufi7k0.jl:22\nin expression starting at\
    \ /tmp/tmpuwufi7k0.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return None \n    else \n        signs = map(sign, arr) \n     \
    \   product = prod(signs) \n        magnitudes = map(abs, arr) \n        return\
    \ sum(magnitudes * product) \nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == -9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == None\n</cell>\n<text>\nExercise 3\nWrite a function that calculates sum of\
    \ squares of integers multiplied by product of all signs of each number in the\
    \ array, represented by 1, -1 or 0.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2t_t4mcz.jl:21\nin expression starting at\
    \ /tmp/tmp2t_t4mcz.jl:21\n"
  exit_code: 1
  status: SyntaxError
