name: HumanEval_123_get_odd_collatz
language: julia
results:
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2sl2b89e.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2sl2b89e.jl:1\n\
    in expression starting at /tmp/tmp2sl2b89e.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        if n % 2 == 1 \n            odd_collatz\
    \ .+= [n + 1]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbrm2uy3v.jl:29\nin expression starting at\
    \ /tmp/tmpbrm2uy3v.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 2 if n % 2 == 0 else n * 3]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the factorial of a\
    \ given positive integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmprl90va_1.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprl90va_1.jl:22\n\
    in expression starting at /tmp/tmprl90va_1.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = Vector{Int64}()\n\
    \        odd_list += get_odd_collatz(n/2)\n        odd_list += [n/2]\n       \
    \ odd_list += [n*3+1]\n        return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7j9zgrmz.jl:27\nin expression starting at\
    \ /tmp/tmp7j9zgrmz.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 2 if n % 2 == 0 else n * 3 + 1 ]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_collatz\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_col\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpz4rh5xs_.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz4rh5xs_.jl:22\n\
    in expression starting at /tmp/tmpz4rh5xs_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3\n    odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a positive integer n and returns the\
    \ number of steps to reach 1 from n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphkl79mvp.jl:25\nin expression starting at\
    \ /tmp/tmphkl79mvp.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3]\n    \n\
    \    return odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi9zoedsv.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi9zoedsv.jl:1\n\
    in expression starting at /tmp/tmpi9zoedsv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    if n == 1\n        odd_list\n \
    \   else\n        odd_list = odd_list + get_odd_collatz(n-1)\n        if n % 2\
    \ == 0\n            odd_list = odd_list + [n / 2]\n        else\n            odd_list\
    \ = odd_list + [n / 2] * 3\n        end\n    end\n    odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes in a positive integer n and returns the Collatz conjecture\
    \ sequence for n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxgp8958l.jl:32\nin expression starting at\
    \ /tmp/tmpxgp8958l.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x/2)\n    end\n    \n    odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer n and returns the number of\
    \ even numbers less than or equal to n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwfcejh5h.jl:32\nin expression starting at\
    \ /tmp/tmpwfcejh5h.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsysb4y5m.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsysb4y5m.jl:1\n\
    in expression starting at /tmp/tmpsysb4y5m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an integer n and returns the number of steps it takes\
    \ to reach 1 from the starting number n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp44qz5fpp.jl:26\nin expression starting at\
    \ /tmp/tmp44qz5fpp.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n % 2)\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_3aaykr8.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_3aaykr8.jl:1\n\
    in expression starting at /tmp/tmp_3aaykr8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    odd_list += [n*3+1]\n\
    \    \n    return odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7z9wh_sh.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7z9wh_sh.jl:1\n\
    in expression starting at /tmp/tmp7z9wh_sh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n / 2)\n        if n % 2 == 0 \n            odd_list +=\
    \ [n]\n        else\n            odd_list += [n * 3]\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpowp3gy3p.jl:32\nin expression starting at\
    \ /tmp/tmpowp3gy3p.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an integer n and returns the nth Fibonacci number.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyzqnm5ex.jl:26\nin expression starting at\
    \ /tmp/tmpyzqnm5ex.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n-1) do \n        if i % 2 == 0 \n            odd_list.append(i)\n\
    \        else \n            odd_list.append(3*i+1)\n    end\n    \n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp439w5sn6.jl:23\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp439w5sn6.jl:1\n\
    in expression starting at /tmp/tmp439w5sn6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list\
    \ += [x/2]\n        else \n            odd_list += [x*3]\n    end\n    \n    odd_list\
    \ += [1]\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdk8ux_70.jl:34\nin expression starting at\
    \ /tmp/tmpdk8ux_70.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the factorial of a given positive integer\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp_ui8x6t.jl:24\nin expression starting at\
    \ /tmp/tmpp_ui8x6t.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6uy34y_i.jl:26\nin expression starting at\
    \ /tmp/tmp6uy34y_i.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/3]\n        return odd_collatz\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb_uxo1e0.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpb_uxo1e0.jl:1\n\
    in expression starting at /tmp/tmpb_uxo1e0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz = [odd_collatz[1]*2, odd_collatz[1]*3+1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the factorial of a\
    \ given positive integer n. \nFor example, factorial(5) = 5 x 4 x 3 x 2 x 1 =\
    \ 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4d0an4wv.jl:25\nin expression starting at\
    \ /tmp/tmp4d0an4wv.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n   \
    \     odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n\
    \        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n\
    \        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n\
    \        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz\
    \ .+= [n * 2]\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n\
    \        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 2]\n        odd_collatz\
    \ .+= [n * 3]\n        odd_collat\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmptj6u4tbl.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptj6u4tbl.jl:1\n\
    in expression starting at /tmp/tmptj6u4tbl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 1 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[2:end]\n    else \n        odd_collatz = [odd_collatz[1],\
    \ odd_collatz[1] * 3] + odd_collatz[2:end]\n    \n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp85q64pxj.jl:1\nin expression starting at /tmp/tmp85q64pxj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_jak2c59.jl:26\nin expression starting at\
    \ /tmp/tmp_jak2c59.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes in a positive integer n and returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoqweuplc.jl:27\nin expression starting at\
    \ /tmp/tmpoqweuplc.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n - 1)\n        if x % 2 == 0\n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x * 2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpykdqv7o6.jl:32\nin expression starting at\
    \ /tmp/tmpykdqv7o6.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes in a positive integer n and returns\
    \ the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw7nw5_d8.jl:27\nin expression starting at\
    \ /tmp/tmpw7nw5_d8.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n-1)\n\
    \    odd_collatz .+= [n/2]\n    if n % 2 == 1 \n        odd_collatz .+= [n*3]\n\
    \    odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the Collatz sequence up to n.\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjumwj2k6.jl:26\nin expression starting at\
    \ /tmp/tmpjumwj2k6.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[end]\n    else \n        odd_collatz = [odd_collatz[1] *\
    \ 3, odd_collatz[1] * 3] + odd_collatz[end]\n    \n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy9dppgcg.jl:1\nin expression starting at /tmp/tmpy9dppgcg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz .+= [n]\n    else \n   \
    \     odd_collatz .+= [n * 3]\n    end\n    \n    return odd_collatz\nend\n</cell>\n\
    <code language=julia-1.5>\n@time get_odd_collatz(100)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes an integer n and returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy8jg6ntg.jl:31\nin expression starting at\
    \ /tmp/tmpy8jg6ntg.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n / 2]\n        odd_collatz += [n / 2 * 3]\n \
    \       odd_collatz += [n / 2 * 3 * 5]\n        odd_collatz += [n / 2 * 3 * 5\
    \ * 7]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9\
    \ * 11 * 13]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15]\n\
    \        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25]\n       \
    \ odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25\
    \ * 27]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11\
    \ * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31]\n        odd_collatz += [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31 *\
    \ 33]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29 * 31 * 33 * 35\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxjenpsdu.jl:1\nin expression starting at /tmp/tmpxjenpsdu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3 + 1\n     \
    \   return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the factorial of a\
    \ given positive integer. \nThe factorial of a positive integer is defined as\
    \ the product of all the positive integers less than or equal to it. \nFor example,\
    \ 5! = 5 x 4 x 3 x 2 x 1 = 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpesvtd8_8.jl:25\nin expression starting at\
    \ /tmp/tmpesvtd8_8.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list += [i]\n            else \n                odd_list += [i*3]\n\
    \        end\n        odd_list += [n]\n        return odd_list\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the factorial of a given positive integer n.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk0tgkst5.jl:32\nin expression starting at\
    \ /tmp/tmpk0tgkst5.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n == 1 \n        odd_list = [n]\n    else\n    \
    \    odd_list = [1]\n        for i in 2:n\n            if i%2 == 0\n         \
    \       odd_list[i] = odd_list[i-1]*2\n            else\n                odd_list[i]\
    \ = odd_list[i-1]*3 + 1\n        end\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes an integer n and returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa9ox2ejz.jl:32\nin expression starting at\
    \ /tmp/tmpa9ox2ejz.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 3 + (n % 2 == 0)]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeq5zvt9h.jl:25\nin expression starting at\
    \ /tmp/tmpeq5zvt9h.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    return odd_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmaibi6qe.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmaibi6qe.jl:1\n\
    in expression starting at /tmp/tmpmaibi6qe.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes an integer $n$ and returns the\
    \ number of steps it takes to reach 1 from the initial value of $n$. For example,\
    \ if the initial value is 10, then the number of steps is 10.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe8l4lzb5.jl:27\nin expression starting at\
    \ /tmp/tmpe8l4lzb5.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0w8cvx5o.jl:25\nin expression starting at\
    \ /tmp/tmp0w8cvx5o.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    odd_collatz\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes in a positive integer n and returns the nth Fibonacci\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpt3vq4r85.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpt3vq4r85.jl:22\n\
    in expression starting at /tmp/tmpt3vq4r85.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = Vector{Int64}()\n    odd_list = [1]\n    if n == 1\n      \
    \  odd_list\n    else\n        odd_list = odd_list + get_odd_collatz(n-1)\n  \
    \      odd_list = odd_list + [n/2]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyadsq85k.jl:27\nin expression starting at\
    \ /tmp/tmpyadsq85k.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes an integer $n$ and returns\
    \ the number of steps to reach 1 from $n$. For example, get_steps(3) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpmqj6nz3s.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmqj6nz3s.jl:22\n\
    in expression starting at /tmp/tmpmqj6nz3s.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \    \n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpzts0yl9j.jl:22 expected \"\
    end\", got \"for\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzts0yl9j.jl:22\n\
    in expression starting at /tmp/tmpzts0yl9j.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \        return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the nth Fibonacci number\
    \ using recursion.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpzmay2ntu.jl:22 expected \"\
    end\", got \"for\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzmay2ntu.jl:22\n\
    in expression starting at /tmp/tmpzmay2ntu.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz += [n % 2]\n    if n % 2 == 1 \n        odd_collatz += [n\
    \ / 2]\n    odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n   \
    \ Given a positive integer n, return a sorted list that has the even numbers in\
    \ collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpllg1v7uz.jl:26\nin expression starting at\
    \ /tmp/tmpllg1v7uz.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3 + 1\n    odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the factorial of a given positive integer\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjx88fgkg.jl:25\nin expression starting at\
    \ /tmp/tmpjx88fgkg.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n / 2]\n        odd_collatz += [n / 2 * 3]\n \
    \       odd_collatz += [n / 2 * 3 * 5]\n        odd_collatz += [n / 2 * 3 * 5\
    \ * 7]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9\
    \ * 11 * 13]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15]\n\
    \        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21]\n        odd_collatz +=\
    \ [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23]\n        odd_collatz\
    \ += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25]\n       \
    \ odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25\
    \ * 27]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11\
    \ * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31]\n        odd_collatz += [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31 *\
    \ 33]\n        odd_collatz += [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19\
    \ * 21 * 23 * 25 * 27 * 29 * 31 * 33 * 35\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp27g2hb1p.jl:1\nin expression starting at /tmp/tmp27g2hb1p.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3+1]\n  \
    \  return odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpx6pipcg1.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx6pipcg1.jl:1\n\
    in expression starting at /tmp/tmpx6pipcg1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for n in get_odd_collatz(n-1) do \n            if n % 2 == 0 \n        \
    \        odd_list.append(n) \n            else \n                odd_list.append(n*3\
    \ + 1)\n        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnyg30tlg.jl:31\nin expression starting at\
    \ /tmp/tmpnyg30tlg.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp1b78t77h.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1b78t77h.jl:22\n\
    in expression starting at /tmp/tmp1b78t77h.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_nums = Vector{Int64}()\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj5jipz26.jl:1\nin expression starting at /tmp/tmpj5jipz26.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_steps(10) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpbmbe7vio.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbmbe7vio.jl:22\n\
    in expression starting at /tmp/tmpbmbe7vio.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        if n % 2 == 1 \n            odd_collatz\
    \ .+= [n * 3]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a positive integer n and returns the nth Fibonacci\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyflr9wv6.jl:29\nin expression starting at\
    \ /tmp/tmpyflr9wv6.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the factorial of a given positive integer. \nThe\
    \ factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive integer n.\
    \ \nThe factorial of a positive integer is defined as the product of all the positive\
    \ integers less than or equal to it. \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\
    \ \nWrite a function that returns the factorial of a given positive \nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_0jmm1ao.jl:26\nin expression starting at\
    \ /tmp/tmp_0jmm1ao.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpcvnrje2m.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcvnrje2m.jl:22\n\
    in expression starting at /tmp/tmpcvnrje2m.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/5]\n        odd_collatz .+= [n/7]\n        odd_collatz .+= [n/11]\n \
    \       odd_collatz .+= [n/13]\n        odd_collatz .+= [n/17]\n        odd_collatz\
    \ .+= [n/19]\n        odd_collatz .+= [n/23]\n        odd_collatz .+= [n/29]\n\
    \        odd_collatz .+= [n/37]\n        odd_collatz .+= [n/53]\n        odd_collatz\
    \ .+= [n/59]\n        odd_collatz .+= [n/67]\n        odd_collatz .+= [n/83]\n\
    \        odd_collatz .+= [n/99]\n        odd_collatz .+= [n/107]\n        odd_collatz\
    \ .+= [n/113]\n        odd_collatz .+= [n/129]\n        odd_collatz .+= [n/131]\n\
    \        odd_collatz .+= [n/137]\n        odd_collatz .+= [n/143]\n        odd_collatz\
    \ .+= [n/149]\n        odd_collatz .+= [n/153]\n        odd_collatz .+= [n/157]\n\
    \        odd_collatz .+= [n/163]\n        odd_collatz .+= [n/169]\n        odd_collatz\
    \ .+= [n/173]\n        odd_collatz .+= [n/177]\n        odd_collatz .+= [n/183]\n\
    \        odd_collatz .+= [n/189]\n        odd_collatz .+= [n/193]\n        odd_collatz\
    \ .+= [n/197]\n        odd_collatz .+= [n/203]\n        odd_collatz .+= [n/209]\n\
    \        odd_collatz .+= [n/213]\n        odd_collatz .+= [n/217]\n        odd_collatz\
    \ .+= [n/\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpihigc5x5.jl:1\nin expression starting at /tmp/tmpihigc5x5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz += [n / 2] * (n % 2 == 1 ? 1 : 3)\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a list of numbers and returns the number\
    \ of even numbers in the list.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp993pw8oq.jl:25\nin expression starting at\
    \ /tmp/tmp993pw8oq.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an integer n and returns the nth\
    \ Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdwiwsff3.jl:27\nin expression starting at\
    \ /tmp/tmpdwiwsff3.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the nth term of the Fibonacci sequence. \nThe Fibonacci\
    \ sequence is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa_h_4s03.jl:26\nin expression starting at\
    \ /tmp/tmpa_h_4s03.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.4>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes an integer $n$ and returns the number of steps it\
    \ takes to reach 1 from $n$. For example, get_steps(5) should return 3.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt3yossn5.jl:26\nin expression starting at\
    \ /tmp/tmpt3yossn5.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 1\n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(n*3+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the factorial of a given positive integer\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx1pbbout.jl:32\nin expression starting at\
    \ /tmp/tmpx1pbbout.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a positive integer n and returns the number\
    \ of steps it takes to reach 1 from the first even number.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp335jizts.jl:28\nin expression starting at\
    \ /tmp/tmp335jizts.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz += [n / 2]\n    if n % 2 == 1 \n        odd_collatz += [n\
    \ / 2]\n    end\n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgc6pqkqv.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgc6pqkqv.jl:1\n\
    in expression starting at /tmp/tmpgc6pqkqv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpffgeqj8u.jl:26\nin expression starting at\
    \ /tmp/tmpffgeqj8u.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list.append(i)\n            else \n                odd_list.append(i*2)\n\
    \        end\n        odd_list\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    Given a positive integer n, return a sorted list that has the even\
    \ numbers in collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6tigm_kd.jl:31\nin expression starting at\
    \ /tmp/tmp6tigm_kd.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzgs6iub0.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzgs6iub0.jl:1\n\
    in expression starting at /tmp/tmpzgs6iub0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n - 1) do \n        if i % 2 == 0 \n            odd_list.append(i)\n\
    \        else \n            odd_list.append(i*2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\n@time odd_list = get_odd_collatz(100)\n\
    </cell>\n<code language=julia-1.5>\n@time odd_list = get_odd_collatz(100)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes in a positive integer n and returns\
    \ the n-th Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplpnep9wa.jl:32\nin expression starting at\
    \ /tmp/tmplpnep9wa.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the nth Fibonacci number.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp16w47xyo.jl:24\nin expression starting at\
    \ /tmp/tmp16w47xyo.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a positive integer n and returns the number of steps\
    \ to reach 1 from the starting number n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7o7zzjwz.jl:26\nin expression starting at\
    \ /tmp/tmp7o7zzjwz.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.3>\n@time get_odd_collatz(100)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplu3onvpr.jl:32\nin expression starting at\
    \ /tmp/tmplu3onvpr.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        collatz = get_odd_collatz(n\
    \ / 2)\n        push!(collatz, n % 2 == 0 ? n : 3 * n + 1) \n        return collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_steps(5) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo503bhu3.jl:25\nin expression starting at\
    \ /tmp/tmpo503bhu3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 3 if n % 2 == 0 else n * 2 + 1]\n        return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpb0j_9r34.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpb0j_9r34.jl:22\n\
    in expression starting at /tmp/tmpb0j_9r34.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n-1)\
    \ \n        if x % 2 == 1 \n            odd_list += [x/2]\n        else \n   \
    \         odd_list += [x*3] + [1]\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes in a positive integer n and returns the nth term of the\
    \ Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3cwf73qv.jl:29\nin expression starting at\
    \ /tmp/tmp3cwf73qv.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x/2)\n        end\n    end\n    \n\
    \    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in an integer n and returns\
    \ the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvf0eam3o.jl:33\nin expression starting at\
    \ /tmp/tmpvf0eam3o.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 3]\n   \
    \     return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmux3lze6.jl:26\nin expression starting at\
    \ /tmp/tmpmux3lze6.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 3 + (n % 2 == 0)]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a positive integer n and returns the\
    \ nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7148uuwd.jl:25\nin expression starting at\
    \ /tmp/tmp7148uuwd.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(3*x + 1)\n        end\n    end\n  \
    \  \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n@time odd_list\
    \ = get_odd_collatz(100)\n</cell>\n<code language=julia-1.5>\n@time odd_list =\
    \ get_odd_collatz(100)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ in a positive integer n and returns the nth Fibonacci number.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwfqzv_62.jl:33\nin expression starting at\
    \ /tmp/tmpwfqzv_62.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list.append(1)\n    odd_list.append(n)\n    while\
    \ odd_list[2] != 1\n        odd_list[1] = odd_list[2]\n        odd_list[2] = odd_list[1]\
    \ / 2\n        odd_list[1] = odd_list[1] % 2\n        odd_list.append(odd_list[2])\n\
    \    end\n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps to reach 1 from the first even number. For\
    \ example, get_evens_steps(5) returns 3.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6oyhpzr5.jl:29\nin expression starting at\
    \ /tmp/tmp6oyhpzr5.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    \n    while n != 1\n        if\
    \ n % 2 == 0\n            odd_list .= odd_list .+ [n / 2]\n            n = n /\
    \ 2\n        else\n            odd_list .= odd_list .+ [3*n+1, 3*n+2]\n      \
    \      n = (3*n+2)/2\n        end\n    end\n    return odd_list\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdrarvb3_.jl:37\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  DimensionMismatch(\"\
    array could not be broadcast to match destination\")\n  Stacktrace:\n    [1] check_broadcast_shape\n\
    \      @ ./broadcast.jl:540 [inlined]\n    [2] check_broadcast_axes\n      @ ./broadcast.jl:543\
    \ [inlined]\n    [3] check_broadcast_axes\n      @ ./broadcast.jl:547 [inlined]\n\
    \    [4] instantiate\n      @ ./broadcast.jl:284 [inlined]\n    [5] materialize!\n\
    \      @ ./broadcast.jl:871 [inlined]\n    [6] materialize!\n      @ ./broadcast.jl:868\
    \ [inlined]\n    [7] get_odd_collatz(n::Int64)\n      @ Main /tmp/tmpdrarvb3_.jl:26\n\
    \    [8] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmpdrarvb3_.jl:37 [inlined]\n\
    \   [10] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmpdrarvb3_.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpdrarvb3_.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  DimensionMismatch(\"array could not be broadcast to\
    \ match destination\")\n  Stacktrace:\n    [1] check_broadcast_shape\n      @\
    \ ./broadcast.jl:540 [inlined]\n    [2] check_broadcast_axes\n      @ ./broadcast.jl:543\
    \ [inlined]\n    [3] check_broadcast_axes\n      @ ./broadcast.jl:547 [inlined]\n\
    \    [4] instantiate\n      @ ./broadcast.jl:284 [inlined]\n    [5] materialize!\n\
    \      @ ./broadcast.jl:871 [inlined]\n    [6] materialize!\n      @ ./broadcast.jl:868\
    \ [inlined]\n    [7] get_odd_collatz(n::Int64)\n      @ Main /tmp/tmpdrarvb3_.jl:26\n\
    \    [8] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmpdrarvb3_.jl:38 [inlined]\n\
    \   [10] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmpdrarvb3_.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpdrarv"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdrarvb3_.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_nums = Vector{Int64}()\n\
    \        odd_nums.push(get_odd_collatz(n-1))\n        odd_nums.push(get_odd_collatz(n/2))\n\
    \        odd_nums.push(get_odd_collatz(n*3+1)) \n        return odd_nums\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi7vlvftm.jl:33\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  type Array has no field\
    \ push\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2]\
    \ get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpi7vlvftm.jl:22\n   [3] macro\
    \ expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi7vlvftm.jl:33 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi7vlvftm.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpi7vlvftm.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  type Array has no field push\n  Stacktrace:\n   [1]\
    \ getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] get_odd_collatz(n::Int64)\n\
    \     @ Main /tmp/tmpi7vlvftm.jl:22\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi7vlvftm.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi7vlvftm.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpi7vlvftm.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  type Array has no field push\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] get_odd_collatz(n::Int64)\n\
    \     @ Main /tmp/tmpi7vlvftm.jl:22\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi7vlvftm.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi7vlvftm.jl:32\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi7vlvftm.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n == 1\n        odd_list = [n]\n    else\n     \
    \   odd_list = [1]\n        for i in 2:n\n            if isodd(i)\n          \
    \      odd_list .= [i/2, 3*i+1]\n            else\n                odd_list .=\
    \ [i/2, 3*i+1]\n        end\n    end\n    return odd_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0ruzco97.jl:32\nin expression starting at\
    \ /tmp/tmp0ruzco97.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.3>\nget_odd_collatz(10)\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that takes an integer n and returns the nth Fibonacci number.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbtuvhour.jl:26\nin expression starting at\
    \ /tmp/tmpbtuvhour.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 2]\n        odd_collatz .+= [n * 3]\n   \
    \     odd_collatz .+= [n * 2]\n        return odd_collatz\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the first n positive integers greater than or equal\
    \ to n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjc7buib_.jl:27\nin expression starting at\
    \ /tmp/tmpjc7buib_.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        odd_collatz .+= [n * 3]\n   \
    \     return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2lfm0e_f.jl:26\nin expression starting at\
    \ /tmp/tmp2lfm0e_f.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the number of steps it takes to reach 1 from n.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppydlf3b5.jl:27\nin expression starting at\
    \ /tmp/tmppydlf3b5.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n==1 \n        odd_list = [n]\n    else\n      \
    \  odd_list = [1]\n        for i in 2:n\n            if i%2==0 \n            \
    \    odd_list.append(i/2)\n            else \n                odd_list.append(3*i+1)\n\
    \    end\n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplyswcgy6.jl:31\nin expression starting at\
    \ /tmp/tmplyswcgy6.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the nth number in the Fibonacci sequence.\
    \ \nThe Fibonacci sequence is defined by the recurrence relation:\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpuingugdi.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuingugdi.jl:22\n\
    in expression starting at /tmp/tmpuingugdi.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkznhio6c.jl:27\nin expression starting at\
    \ /tmp/tmpkznhio6c.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the factorial of a given positive integer.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph2n80tf0.jl:24\nin expression starting at\
    \ /tmp/tmph2n80tf0.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz += [n / 2]\n    else \n\
    \        odd_collatz += [n / 2] * 3 + 1\n    \n    return odd_collatz\nend\n</cell>\n\
    <code language=julia-1.4>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the nth Fibonacci number using recursion.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvg5fbw4k.jl:30\nin expression starting at\
    \ /tmp/tmpvg5fbw4k.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    \n    return odd_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpao6izoyl.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpao6izoyl.jl:1\n\
    in expression starting at /tmp/tmpao6izoyl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 1 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[2:end]\n    else \n        odd_collatz = [odd_collatz[1],\
    \ odd_collatz[1] * 3] + odd_collatz[2:end]\n    \n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4cxmjijv.jl:1\nin expression starting at /tmp/tmp4cxmjijv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        collatz = get_odd_collatz(n\
    \ / 2)\n        push!(collatz, n % 2)\n        return collatz\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp86x6qq4_.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp86x6qq4_.jl:1\n\
    in expression starting at /tmp/tmp86x6qq4_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 0 \n        \
    \        odd_list.append(i)\n            else \n                odd_list.append(i*3\
    \ + 1)\n        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a positive integer n and returns the number of steps it takes to reach 1 from\
    \ n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpag8fs0fr.jl:31\nin expression starting at\
    \ /tmp/tmpag8fs0fr.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes an integer n and returns the nth\
    \ Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf95bgu44.jl:27\nin expression starting at\
    \ /tmp/tmpf95bgu44.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list += [i]\n            else \n                odd_list += [i*3]\n\
    \        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj7qu5o7z.jl:31\nin expression starting at\
    \ /tmp/tmpj7qu5o7z.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nProblem 3\nWrite a function that takes in a positive integer n and returns\
    \ the nth term of the Fibonacci sequence. \nThe Fibonacci sequence is defined\
    \ by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzbnfs8s1.jl:26\nin expression starting at\
    \ /tmp/tmpzbnfs8s1.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 2 % n]\n        odd_collatz .+= [n * 3 %\
    \ n]\n        return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp87epiy4m.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp87epiy4m.jl:1\n\
    in expression starting at /tmp/tmp87epiy4m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes in a positive integer n and returns the number of steps\
    \ to reach 1 from n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4k04ayfl.jl:26\nin expression starting at\
    \ /tmp/tmp4k04ayfl.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the number of steps it takes to reach 1 from the first odd number in the Collatz\
    \ sequence. For example, get_odd_steps(5) should return 3 since it takes 3 steps\
    \ to reach 1 from the first odd number in the Collatz sequence starting with 5.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprav1f8lj.jl:27\nin expression starting at\
    \ /tmp/tmprav1f8lj.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n\
    \ - 1) \n        if x % 2 == 1 \n            odd_list.append(x)\n            odd_list.append(x/2)\n\
    \        else \n            odd_list.append(3*x + 1)\n    end\n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a positive integer n and returns the nth\
    \ term of the Fibonacci sequence.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkcbnd83x.jl:30\nin expression starting at\
    \ /tmp/tmpkcbnd83x.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwvvfqzy0.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwvvfqzy0.jl:1\n\
    in expression starting at /tmp/tmpwvvfqzy0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n-1)\n\
    \    odd_collatz += [n/2]\n    if n % 2 == 1 \n        odd_collatz += [n*3]\n\
    \    odd_collatz\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    Given a\
    \ positive integer n, return a sorted list that has the even numbers in collatz\
    \ sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_ounjx6u.jl:26\nin expression starting at\
    \ /tmp/tmp_ounjx6u.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n / 2] * (n % 2 == 0 ? 1 : 3)\n        return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppdm92qqi.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppdm92qqi.jl:1\n\
    in expression starting at /tmp/tmppdm92qqi.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz += [n * 3 if n % 2 == 0 else n * 2 + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the first n prime numbers.\
    \ \nThe function should take an input n and return the prime numbers in increasing\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp8b0ihgtm.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8b0ihgtm.jl:22\n\
    in expression starting at /tmp/tmp8b0ihgtm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x * 2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a positive integer n and returns\
    \ the number of steps it takes to reach 1 from n.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpposn59pg.jl:32\nin expression starting at\
    \ /tmp/tmpposn59pg.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp695206d5.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp695206d5.jl:1\n\
    in expression starting at /tmp/tmp695206d5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp_koq9r9t.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_koq9r9t.jl:22\n\
    in expression starting at /tmp/tmp_koq9r9t.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 3 + (n % 2 == 0)]\n    odd_collatz .= odd_collatz\
    \ .+ get_odd_collatz(n / 2)\n    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2wduuiaf.jl:26\nin expression starting at\
    \ /tmp/tmp2wduuiaf.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz += [n * 2 if n % 2 == 0 else n * 3]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpjgy7p0qd.jl:21 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjgy7p0qd.jl:21\n\
    in expression starting at /tmp/tmpjgy7p0qd.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n-1)\n\
    \    \n    if n % 2 == 0 \n        odd_collatz .+= [n/2]\n    else \n        odd_collatz\
    \ .+= [n*3]\n    \n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe0l6zgl8.jl:1\nin expression starting at /tmp/tmpe0l6zgl8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_nums = get_odd_collatz(n/2)\n\
    \        odd_nums.push(3*n+1)\n        return odd_nums\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw1py21gh.jl:26\nin expression starting at\
    \ /tmp/tmpw1py21gh.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n-1) do \n        if i % 2 == 1 \n            odd_list.append(i)\n\
    \        else \n            odd_list.append(i*2)\n            \n            odd_list.append(i*3+1)\n\
    \    end\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ an integer n and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuc5du_r2.jl:34\nin expression starting at\
    \ /tmp/tmpuc5du_r2.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\
    \ + [n/2]\n        odd_collatz = [i for i in odd_collatz if i % 2 == 1]\n    \
    \    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes an integer n and returns\
    \ the number of even numbers less than or equal to n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsfm9ybva.jl:25\nin expression starting at\
    \ /tmp/tmpsfm9ybva.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 1\n            odd_list += [n/2]\n\
    \        else\n            odd_list += [n*3] + [n/2]\n    end\n    \n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbt5_6usu.jl:1\nin expression starting at /tmp/tmpbt5_6usu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4xo4yagt.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4xo4yagt.jl:1\n\
    in expression starting at /tmp/tmp4xo4yagt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an integer $n$ and returns the\
    \ number of steps it takes to reach 1 from $n$. \nFor example, given $n = 10$,\
    \ the function should return $5$.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpukb9rx1r.jl:26\nin expression starting at\
    \ /tmp/tmpukb9rx1r.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1xzhb5wj.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1xzhb5wj.jl:1\n\
    in expression starting at /tmp/tmp1xzhb5wj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_nums = get_odd_collatz(n-1)\n\
    \        odd_nums.push(3*n+1)\n        return odd_nums\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmph09gzorm.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmph09gzorm.jl:1\n\
    in expression starting at /tmp/tmph09gzorm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpv6phx5n4.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpv6phx5n4.jl:1\n\
    in expression starting at /tmp/tmpv6phx5n4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n\
    \ / 2)\n    odd_list += [n * 3]\n    odd_list += get_odd_collatz(n / 2)\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the factorial of a given number.\
    \ \nThe factorial of a number $n$ is defined as the product of all the positive\
    \ integers less than or equal to $n$. \nFor example, factorial(5) = 5 \xD7 4 \xD7\
    \ 3 \xD7 2 \xD7 1 = 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl495u73t.jl:26\nin expression starting at\
    \ /tmp/tmpl495u73t.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    if n == 1 \n        odd_list =\
    \ [1]\n        return odd_list\n    elseif n % 2 == 0 \n        odd_list = [n,\
    \ 3*n+1]\n        return odd_list\n    else\n        odd_list = [n, 3*n+1]\n \
    \       return odd_list\n    end\nend\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a positive integer n\
    \ and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv9ggw6t3.jl:31\nin expression starting at\
    \ /tmp/tmpv9ggw6t3.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp578a4i88.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp578a4i88.jl:1\n\
    in expression starting at /tmp/tmp578a4i88.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .= [n * 3 if n % 2 == 0 else n * 2 + 1]\n        return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp3wcy8hlc.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3wcy8hlc.jl:22\n\
    in expression starting at /tmp/tmp3wcy8hlc.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplua2q2ux.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplua2q2ux.jl:1\n\
    in expression starting at /tmp/tmplua2q2ux.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = Vector{Int64}()\n    if n == 1\n        odd_list = [n]\n  \
    \  else\n        odd_list = get_odd_collatz(n / 2)\n        if n % 2 == 0\n  \
    \          odd_list.append(n / 2)\n        else\n            odd_list.append(3\
    \ * odd_list[-1] + 1)\n        end\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that takes in a positive integer n and returns the nth term of the\
    \ Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpngbd0ai0.jl:31\nin expression starting at\
    \ /tmp/tmpngbd0ai0.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbqxsexhq.jl:27\nin expression starting at\
    \ /tmp/tmpbqxsexhq.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [n / 2] * 3\n    odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer n and returns the first n odd\
    \ numbers in Collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9gm3d_fv.jl:24\nin expression starting at\
    \ /tmp/tmp9gm3d_fv.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert get_odd_collatz(5) == [1, 5]\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the Collatz conjecture for n \u2264\
    \ 100. Your function should work for any positive integer n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_tvc_fy5.jl:26\nin expression starting at\
    \ /tmp/tmp_tvc_fy5.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n\
    \ - 1) \n        if x % 2 == 1 \n            odd_list += [x/2]\n        else \n\
    \            odd_list += [x * 3] + [1]\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the factorial of a given positive integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo2pfum76.jl:29\nin expression starting at\
    \ /tmp/tmpo2pfum76.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3ff6b7cs.jl:1\nin expression starting at /tmp/tmp3ff6b7cs.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list = [1]\n    odd_list = odd_list + [n / 2]\n\
    \    odd_list = odd_list + [n / 2 * 3]\n    odd_list = odd_list + [n / 2 * 3 *\
    \ 5]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7]\n    odd_list = odd_list +\
    \ [n / 2 * 3 * 5 * 7 * 9]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 *\
    \ 11]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13]\n    odd_list\
    \ = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15]\n    odd_list = odd_list\
    \ + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17]\n    odd_list = odd_list + [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19]\n    odd_list = odd_list + [n\
    \ / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21]\n    odd_list = odd_list\
    \ + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23]\n    odd_list =\
    \ odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25]\n\
    \    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21\
    \ * 23 * 25 * 27]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13\
    \ * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29]\n    odd_list = odd_list + [n / 2 *\
    \ 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31]\n    odd_list\
    \ = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11 * 13 * 15 * 17 * 19 * 21 * 23 * 25\
    \ * 27 * 29 * 31 * 33]\n    odd_list = odd_list + [n / 2 * 3 * 5 * 7 * 9 * 11\
    \ * 13 * 15 * 17 * 19 * 21 * 23 * 25 * 27 * 29 * 31 * 33\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbep7k_0j.jl:1\nin expression starting at /tmp/tmpbep7k_0j.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpldtwqb0h.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpldtwqb0h.jl:1\n\
    in expression starting at /tmp/tmpldtwqb0h.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a positive integer n and returns the nth\
    \ Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqsp5q_3k.jl:25\nin expression starting at\
    \ /tmp/tmpqsp5q_3k.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i % 2 == 1 \n        \
    \        odd_list.append(i)\n            else \n                odd_list.append(i*2)\n\
    \                odd_list.append(i*3+1)\n        end\n        return odd_list\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmkqmggn_.jl:32\nin expression starting at\
    \ /tmp/tmpmkqmggn_.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz .+= [n]\n    else \n   \
    \     odd_collatz .+= [n] * 3 + 1\n    \n    return odd_collatz\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdqtcd5p1.jl:1\nin expression starting at /tmp/tmpdqtcd5p1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    \n    if n % 2 == 0 \n        odd_list += [n/2]\n\
    \    else \n        odd_list += [n*3]\n    \n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the factorial of a given positive integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp771rvxzz.jl:32\nin expression starting at\
    \ /tmp/tmp771rvxzz.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for i in get_odd_collatz(n\
    \ - 1) do \n        if i % 2 == 1 \n            odd_list += [i]\n        else\
    \ \n            odd_list += [i * 3]\n    end\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the nth term of the Fibonacci sequence. \nThe Fibonacci\
    \ sequence is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpljb6m9gp.jl:29\nin expression starting at\
    \ /tmp/tmpljb6m9gp.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x/2)\n    end\n    \n    odd_list\
    \ += [x+1 for x in odd_list if x % 2 != 1]\n    \n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a positive integer n and returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjgk80vtn.jl:34\nin expression starting at\
    \ /tmp/tmpjgk80vtn.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n-1)\
    \ do \n        if x % 2 == 1 \n            odd_list += [x/2]\n        else \n\
    \            odd_list += [x*3]\n    end\n    odd_list += [1]\n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.0>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a positive integer n and returns the\
    \ n-th Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj5t181o6.jl:30\nin expression starting at\
    \ /tmp/tmpj5t181o6.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3]\n        if n % 2 == 1 \n            odd_collatz\
    \ .+= [n + 1]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the factorial of a given positive integer. \nFor\
    \ example, factorial(5) = 5 x 4 x 3 x 2 x 1 = 120\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnhpxmvj9.jl:29\nin expression starting at\
    \ /tmp/tmpnhpxmvj9.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpahnwq1od.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpahnwq1od.jl:1\n\
    in expression starting at /tmp/tmpahnwq1od.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    Given a positive integer n, return a sorted\
    \ list that has the even numbers in collatz sequence.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmz3wa4cl.jl:26\nin expression starting at\
    \ /tmp/tmpmz3wa4cl.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in 1:n\n        if isodd(i) == true\n            odd_list += [i]\n       \
    \ else\n            odd_list += [i/2]\n        end\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk08bul_x.jl:33\nin expression starting at\
    \ /tmp/tmpk08bul_x.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpikuh_1xi.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpikuh_1xi.jl:1\n\
    in expression starting at /tmp/tmpikuh_1xi.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoks2ld4r.jl:26\nin expression starting at\
    \ /tmp/tmpoks2ld4r.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a positive integer n and returns the number\
    \ of steps it takes to reach 1 from n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpslr_f6kj.jl:25\nin expression starting at\
    \ /tmp/tmpslr_f6kj.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp38ae57o9.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp38ae57o9.jl:1\n\
    in expression starting at /tmp/tmp38ae57o9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else n * 2 + 1]\n       \
    \ return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a positive integer n\
    \ and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp2hcdkov7.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2hcdkov7.jl:22\n\
    in expression starting at /tmp/tmp2hcdkov7.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\n@time odd_list = get_odd_collatz(10)\n</cell>\n<code\
    \ language=julia-1.5>\n@time odd_list = get_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a positive integer n and returns the\
    \ nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkfr74hck.jl:26\nin expression starting at\
    \ /tmp/tmpkfr74hck.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes in a positive integer n and returns the nth term of\
    \ the Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence\
    \ relation:\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptf3kufnj.jl:26\nin expression starting at\
    \ /tmp/tmptf3kufnj.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_nums = Vector{Int64}()\n\
    \    \n    for x in get_odd_collatz(n - 1)\n        if x % 2 == 1\n          \
    \  odd_nums += [x]\n        else\n            odd_nums += [x * 3]\n        end\n\
    \    end\n    \n    odd_nums\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the factorial of a\
    \ given number. \nThe factorial of a number $n$ is defined as the product of all\
    \ positive integers less than or equal to $n$.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2oiybhvn.jl:33\nin expression starting at\
    \ /tmp/tmp2oiybhvn.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplvfju7wz.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplvfju7wz.jl:1\n\
    in expression starting at /tmp/tmplvfju7wz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    odd_collatz\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the nth number in the Fibonacci sequence. \n\
    For example, get_fibonacci(3) should return 5.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp_rqnfy69.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_rqnfy69.jl:22\n\
    in expression starting at /tmp/tmp_rqnfy69.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/5]\n        odd_collatz .+= [n/7]\n        odd_collatz .+= [n/11]\n \
    \       odd_collatz .+= [n/13]\n        odd_collatz .+= [n/17]\n        odd_collatz\
    \ .+= [n/19]\n        odd_collatz .+= [n/23]\n        odd_collatz .+= [n/29]\n\
    \        odd_collatz .+= [n/37]\n        odd_collatz .+= [n/53]\n        odd_collatz\
    \ .+= [n/63]\n        odd_collatz .+= [n/79]\n        odd_collatz .+= [n/91]\n\
    \        odd_collatz .+= [n/103]\n        odd_collatz .+= [n/107]\n        odd_collatz\
    \ .+= [n/111]\n        odd_collatz .+= [n/113]\n        odd_collatz .+= [n/115]\n\
    \        odd_collatz .+= [n/117]\n        odd_collatz .+= [n/119]\n        odd_collatz\
    \ .+= [n/121]\n        odd_collatz .+= [n/123]\n        odd_collatz .+= [n/125]\n\
    \        odd_collatz .+= [n/127]\n        odd_collatz .+= [n/129]\n        odd_collatz\
    \ .+= [n/131]\n        odd_collatz .+= [n/133]\n        odd_collatz .+= [n/135]\n\
    \        odd_collatz .+= [n/137]\n        odd_collatz .+= [n/139]\n        odd_collatz\
    \ .+= [n/141]\n        odd_collatz .+= [n/143]\n        odd_collatz .+= [n/145]\n\
    \        odd_collatz .+= [n/147]\n        odd_collatz .+= [n/149]\n        odd_collatz\
    \ .+= [n/\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcig3pkj8.jl:1\nin expression starting at /tmp/tmpcig3pkj8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpamgjk77l.jl:1\nin expression starting at /tmp/tmpamgjk77l.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the factorial of a given positive\
    \ integer n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzvghjq7u.jl:27\nin expression starting at\
    \ /tmp/tmpzvghjq7u.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0\
    \ ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 ==\
    \ 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2\
    \ == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n\
    \ % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+=\
    \ n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp8_e9bi4.jl:1\nin expression starting at /tmp/tmpp8_e9bi4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the Collatz sequence for n.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2kpgnfkd.jl:27\nin expression starting at\
    \ /tmp/tmp2kpgnfkd.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz = [odd_collatz[1], odd_collatz[2]*odd_collatz[1]] \n    \
    \    return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvnj3zeoi.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvnj3zeoi.jl:1\n\
    in expression starting at /tmp/tmpvnj3zeoi.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .= [n/2]\n        if n % 2 == 1 \n            odd_collatz\
    \ .= [n*3]\n        end\n        return odd_collatz\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the nth term of the Fibonacci sequence. \nThe Fibonacci\
    \ sequence is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8dw8jaci.jl:29\nin expression starting at\
    \ /tmp/tmp8dw8jaci.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0\
    \ ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 ==\
    \ 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2\
    \ == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n\
    \ % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+=\
    \ n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1tx0gm4g.jl:1\nin expression starting at /tmp/tmp1tx0gm4g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3]\n    odd_list += [n*3+1]\n    return\
    \ odd_list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwq521wjs.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwq521wjs.jl:1\n\
    in expression starting at /tmp/tmpwq521wjs.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(3*x + 1)\n        end\n    end\n  \
    \  \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(5)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the nth term of the\
    \ Fibonacci sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjvptrqg1.jl:33\nin expression starting at\
    \ /tmp/tmpjvptrqg1.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps to reach 1 from n.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpawa7x_z4.jl:25\nin expression starting at\
    \ /tmp/tmpawa7x_z4.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_steps(5) should return\
    \ 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpmrbc8zrk.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmrbc8zrk.jl:22\n\
    in expression starting at /tmp/tmpmrbc8zrk.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \    return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpm37srb92.jl:22 expected \"\
    end\", got \"for\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpm37srb92.jl:22\n\
    in expression starting at /tmp/tmpm37srb92.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n-1) do \n        if x % 2 == 1 \n            odd_list\
    \ += [x/2]\n        else \n            odd_list += [x*3] + [1]\n    end\n    \n\
    \    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns the nth Fibonacci number.\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt3794l76.jl:32\nin expression starting at\
    \ /tmp/tmpt3794l76.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n\
    \ / 2)\n        odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n        return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes in a positive integer n and returns the\
    \ number of steps it takes to reach 1 from the starting number n.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpbk8w7_mm.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbk8w7_mm.jl:22\n\
    in expression starting at /tmp/tmpbk8w7_mm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_list = []\n   \
    \     for i in get_odd_collatz(n-1) do \n            if i%2 == 1 \n          \
    \      odd_list += [i/2]\n            else \n                odd_list += [i*3]\n\
    \        end\n        return odd_list\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo0p47aep.jl:31\nin expression starting at\
    \ /tmp/tmpo0p47aep.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n\
    \    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list += [n/2]\n    odd_list\
    \ += [n/2]\n    odd_list += [n/2]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_7231c3b.jl:1\nin expression starting at /tmp/tmp_7231c3b.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the factorial of a given positive integer n.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpscstzqum.jl:26\nin expression starting at\
    \ /tmp/tmpscstzqum.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .= [n * 2 if n % 2 == 0 else n * 3 + 1 for i in odd_collatz]\n\
    \    odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a positive integer n\
    \ and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpyzt3rx72.jl:22 expected \"\
    end\", got \"for\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyzt3rx72.jl:22\n\
    in expression starting at /tmp/tmpyzt3rx72.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .= [n/2]\n        odd_collatz .= odd_collatz .+ [n*3+1]\n\
    \        return odd_collatz\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuseqb4l0.jl:26\nin expression starting at\
    \ /tmp/tmpuseqb4l0.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 0 \n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(3*n+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that takes an integer $n$ and returns the number\
    \ of steps it takes to reach 1 from $n$. For example, get_num_steps(5) should\
    \ return 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpye0s9w8l.jl:32\nin expression starting at\
    \ /tmp/tmpye0s9w8l.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp0ah38mpe.jl:21 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0ah38mpe.jl:21\n\
    in expression starting at /tmp/tmp0ah38mpe.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a positive integer n and returns the nth term of the\
    \ Collatz conjecture.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_3ukjs9a.jl:26\nin expression starting at\
    \ /tmp/tmp_3ukjs9a.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ i in get_odd_collatz(n-1) do \n        if i % 2 == 1 \n            odd_list\
    \ += [i]\n        else \n            odd_list += [i * 3]\n    end\n    \n    odd_list\
    \ += [n]\n    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\n\
    get_odd_collatz(5)\n</cell>\n<text>\nProblem 3\nWrite a function that takes an\
    \ integer n and returns the nth Fibonacci number.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprvios5l1.jl:34\nin expression starting at\
    \ /tmp/tmprvios5l1.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    odd_list\
    \ += get_odd_collatz(n-1)\n    odd_list += [n/2]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list +=\
    \ [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n\
    \    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n \
    \   odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n  \
    \  odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n   \
    \ odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list\
    \ += [n*3+1]\n    odd_list += [n*3+1]\n    odd_list += \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw3xrryfl.jl:1\nin expression starting at /tmp/tmpw3xrryfl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuql0b41i.jl:26\nin expression starting at\
    \ /tmp/tmpuql0b41i.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0\
    \ ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 ==\
    \ 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2\
    \ == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n\
    \ % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+=\
    \ n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == 0 ? 1 : 3\n    odd_collatz\
    \ .+= n % 2 == 0 ? 1 : 3\n    odd_collatz .+= n % 2 == \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiwmvbvjd.jl:1\nin expression starting at /tmp/tmpiwmvbvjd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\n</cell>\n\
    <code language=julia-1.5>\nget_odd_collatz(5)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes an integer n and returns the number of positive integers\
    \ less than or equal to n that have the Collatz sequence starting from 1.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp19h05y9j.jl:26\nin expression starting at\
    \ /tmp/tmp19h05y9j.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    if n == 1 \n        odd_list = [n]\n    else\n    \
    \    odd_list = [1]\n        for i in 2:n\n            if isodd(i) == true\n \
    \               odd_list[i] = odd_list[i-1] * 2\n            else\n          \
    \      odd_list[i] = odd_list[i-1] * 3 + 1\n        end\n    end\n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4_l2y9pd.jl:32\nin expression starting at\
    \ /tmp/tmp4_l2y9pd.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ n in get_odd_collatz(n-1)\n        if n % 2 == 0 \n            odd_list.append(n/2)\n\
    \        else\n            odd_list.append(3*n+1)\n    end\n    \n    return odd_list\n\
    end\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes in a positive integer n and returns the\
    \ nth Fibonacci number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkgnovnmx.jl:32\nin expression starting at\
    \ /tmp/tmpkgnovnmx.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n - 1) do \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else\n            odd_list.append(x * 3 + 1)\n        end\n    end\n\
    \    \n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the number of steps it takes to reach 1 from n.\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv6ztjww4.jl:33\nin expression starting at\
    \ /tmp/tmpv6ztjww4.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n/2)\n\
    \    odd_list += [n/2]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n\
    \    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list += [n/3]\n    odd_list\
    \ += [n/3]\n    odd_list += [n/3]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpofmetd1s.jl:1\nin expression starting at /tmp/tmpofmetd1s.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    for x in get_odd_collatz(n-1)\n\
    \        if x % 2 == 1\n            odd_list.append(x)\n        else\n       \
    \     odd_list.append(x*2 + 1)\n    end\n    return odd_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3e0g2_dg.jl:29\nin expression starting at\
    \ /tmp/tmp3e0g2_dg.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n/3]\n        odd_collatz\
    \ .+= [n/5]\n        odd_collatz .+= [n/7]\n        odd_collatz .+= [n/11]\n \
    \       odd_collatz .+= [n/13]\n        odd_collatz .+= [n/17]\n        odd_collatz\
    \ .+= [n/19]\n        odd_collatz .+= [n/23]\n        odd_collatz .+= [n/29]\n\
    \        odd_collatz .+= [n/37]\n        odd_collatz .+= [n/53]\n        odd_collatz\
    \ .+= [n/59]\n        odd_collatz .+= [n/67]\n        odd_collatz .+= [n/83]\n\
    \        odd_collatz .+= [n/99]\n        odd_collatz .+= [n/107]\n        odd_collatz\
    \ .+= [n/131]\n        odd_collatz .+= [n/163]\n        odd_collatz .+= [n/193]\n\
    \        odd_collatz .+= [n/225]\n        odd_collatz .+= [n/251]\n        odd_collatz\
    \ .+= [n/289]\n        odd_collatz .+= [n/361]\n        odd_collatz .+= [n/523]\n\
    \        odd_collatz .+= [n/597]\n        odd_collatz .+= [n/673]\n        odd_collatz\
    \ .+= [n/823]\n        odd_collatz .+= [n/997]\n        odd_collatz .+= [n/1037]\n\
    \        odd_collatz .+= [n/1319]\n        odd_collatz .+= [n/1637]\n        odd_collatz\
    \ .+= [n/1937]\n        odd_collatz .+= [n/2237]\n        odd_collatz .+= [n/2537]\n\
    \        odd_collatz .+= [n/2897]\n        odd_collatz .+= [n/3617]\n        odd_\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpawwbarn3.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpawwbarn3.jl:1\n\
    in expression starting at /tmp/tmpawwbarn3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list.append(1)\n    odd_list.append(n)\n    while\
    \ odd_list[2] != 1\n        odd_list[1] = odd_list[2]\n        odd_list[2] = odd_list[1]\
    \ / 2\n        odd_list[1] = odd_list[1] % 2\n    end\n    return odd_list\nend\n\
    </cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes in a positive integer n and returns the nth Fibonacci\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj9p9lt_7.jl:28\nin expression starting at\
    \ /tmp/tmpj9p9lt_7.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .+= n % 2 == 0 ? [n / 2] : [3 * n + 1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the factorial of a given positive integer. \nFor example,\
    \ factorial(5) returns 120.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpezaa9x8p.jl:23\nin expression starting at\
    \ /tmp/tmpezaa9x8p.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    \n    if n % 2 == 0 \n        odd_collatz = [odd_collatz[1], odd_collatz[1]\
    \ * 3] + odd_collatz[2:end]\n    else \n        odd_collatz = [odd_collatz[1],\
    \ odd_collatz[1] * 3] + odd_collatz[2:end]\n    end\n    \n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi31edp3c.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi31edp3c.jl:1\n\
    in expression starting at /tmp/tmpi31edp3c.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_collatz = get_odd_collatz(n /\
    \ 2)\n    odd_collatz .= [n * 3 + (n % 2 == 0)]\n    odd_collatz .= odd_collatz[end-1]\n\
    \    odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1fy_v698.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1fy_v698.jl:1\n\
    in expression starting at /tmp/tmp1fy_v698.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_nums = Vector{Int64}()\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n    odd_nums.push(2)\n\
    \    odd_nums.push(2)\n    odd_\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx3x4x0y4.jl:1\nin expression starting at /tmp/tmpx3x4x0y4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    for\
    \ x in get_odd_collatz(n - 1) \n        if x % 2 == 1 \n            odd_list.append(x)\n\
    \        else \n            odd_list.append(x * 2 + 1)\n    end\n    \n    return\
    \ odd_list\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the nth number in the Fibonacci\
    \ sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvlhs8w41.jl:32\nin expression starting at\
    \ /tmp/tmpvlhs8w41.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_list = []\n    \n    odd_list\
    \ += get_odd_collatz(n-1)\n    \n    if n % 2 == 1 \n        odd_list += [n/2]\n\
    \    \n    odd_list += [n*3+1]\n    \n    return odd_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a positive integer n and returns the nth term of the Fibonacci\
    \ sequence. \nThe Fibonacci sequence is defined by the recurrence relation:\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg3kbul74.jl:32\nin expression starting at\
    \ /tmp/tmpg3kbul74.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .+= [n/2]\n        odd_collatz .+= [n*3+1]\n        return\
    \ odd_collatz\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes in a positive integer\
    \ n and returns the nth term of the Fibonacci sequence. \nThe Fibonacci sequence\
    \ is defined by the recurrence relation:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2fr_r6o.jl:26\nin expression starting at\
    \ /tmp/tmpt2fr_r6o.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = []\n    odd_list.append(1)\n    odd_list.append(n)\n    while\
    \ odd_list[2] != 1\n        odd_list[1] = odd_list[2]\n        odd_list[2] = odd_list[1]\
    \ / 2\n        odd_list[1] = odd_list[1] % 2\n        odd_list.append(odd_list[2])\n\
    \    end\n    return odd_list\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbv0j2gux.jl:29\nin expression starting at\
    \ /tmp/tmpbv0j2gux.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        odd_collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz .= [n/2]\n        odd_collatz .= odd_collatz .+ [n/3]\n \
    \       odd_collatz .= odd_collatz .+ [n/5]\n        odd_collatz .= odd_collatz\
    \ .+ [n/7]\n        odd_collatz .= odd_collatz .+ [n/11]\n        odd_collatz\
    \ .= odd_collatz .+ [n/13]\n        odd_collatz .= odd_collatz .+ [n/17]\n   \
    \     odd_collatz .= odd_collatz .+ [n/19]\n        odd_collatz .= odd_collatz\
    \ .+ [n/23]\n        odd_collatz .= odd_collatz .+ [n/29]\n        odd_collatz\
    \ .= odd_collatz .+ [n/31]\n        return odd_collatz\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd6lkfpgs.jl:35\nin expression starting at\
    \ /tmp/tmpd6lkfpgs.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    else \n        collatz = get_odd_collatz(n-1)\n\
    \        odd_collatz = collatz\n        for i in collatz \n            if i %\
    \ 2 == 1 \n                odd_collatz += [i / 2]\n            else \n       \
    \         odd_collatz += [i * 3]\n        end\n        return odd_collatz\n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\nget_odd_collatz(10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes in a positive integer n and returns\
    \ the number of positive integers less than or equal to n that are evenly divisible\
    \ by 3.\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpry2v4777.jl:32\nin expression starting at\
    \ /tmp/tmpry2v4777.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    \n    odd_collatz = get_odd_collatz(n\
    \ / 2)\n    odd_collatz .+= [n * 3 if n % 2 == 0 else 1]\n    return odd_collatz\n\
    end\n</cell>\n<code language=julia-1.5>\n@time odd_collatz = get_odd_collatz(10)\n\
    </cell>\n<code language=julia-1.5>\n@time odd_collatz = get_odd_collatz(100)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that computes the factorial of a\
    \ given positive integer. \nThe factorial of a non-negative integer is defined\
    \ as the product of all positive integers less than or equal to that integer.\
    \ \nFor example, 5! = 5 x 4 x 3 x 2 x 1 = 120.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp857b_b36.jl:22 expected \"\
    end\", got \"]\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp857b_b36.jl:22\n\
    in expression starting at /tmp/tmp857b_b36.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    odd_list = []\n    odd_list += get_odd_collatz(n-1)\n\
    \    odd_list += [n/2]\n    odd_list += [n*3+1]\n    return odd_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3q5_0zjs.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3q5_0zjs.jl:1\n\
    in expression starting at /tmp/tmp3q5_0zjs.jl:1\n"
  exit_code: 1
  status: SyntaxError
