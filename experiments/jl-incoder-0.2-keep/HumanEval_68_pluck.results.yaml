name: HumanEval_68_pluck
language: julia
results:
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == -1 || length(arr) == 0\n        return Vector{Int64}()\n    else\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwk_frtpy.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwk_frtpy.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    if even == []\n        return []\n    else\n     \
    \   return even\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvf4iaaw8.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvf4iaaw8.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = arr[smallest_index]\n    \n    smallest_index = smallest_index\
    \ + 1\n    \n    smallest_value = arr[smallest_index]\n    \n    smallest_index\
    \ = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n    \n\
    \    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbe8jj702.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpbe8jj702.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpbe8jj702.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = Int64(0)\n    smallest = Int64(0)\n    largestIndex = 0\n  \
    \  smallestIndex = 0\n    largestValue = Int64(0)\n    smallestValue = Int64(0)\n\
    \    largestEvenValue = Int64(0)\n    smallestEvenValue = Int64(0)\n    largestEvenIndex\
    \ = Int64(0)\n    smallestEvenIndex = Int64(0)\n    for node in arr\n        if\
    \ node.even\n            if node.value > largestValue\n                largestValue\
    \ = node.value\n                largestEvenValue = node.even\n               \
    \ largestEvenIndex = node.index\n            end\n            if node.value <\
    \ smallestValue\n                smallestValue = node.value\n                smallestEvenValue\
    \ = node.even\n                smallestEvenIndex = node.index\n            end\n\
    \        end\n    end\n    if largestEvenValue == 0\n        return []\n    else\n\
    \        return [largestEvenValue, largestEvenIndex]\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpboekpmxr.jl:70\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field even\n\
    \  Stacktrace:\n   [1] getproperty(::Int64, ::Symbol) at ./Base.jl:33\n   [2]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpboekpmxr.jl:46\n   [3] top-level scope at\
    \ /tmp/tmpboekpmxr.jl:70\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \ntest set: Error During\
    \ Test at /tmp/tmpboekpmxr.jl:71\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Int64 has no field even\n  Stacktrace:\n   [1] getproperty(::Int64,\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpboekpmxr.jl:46\n\
    \   [3] top-level scope at /tmp/tmpboekpmxr.jl:71\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \ntest set: Error During\
    \ Test at /tmp/tmpboekpmxr.jl:73\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Int64 has no field even\n  Stacktrace:\n \
    \  [1] getproperty(::Int64, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpboekpmxr.jl:46\n   [3] top-level scope at /tmp/tmpboekpmxr.jl:73\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \ntest set: Error During\
    \ Test at /tmp/tmpboekpmxr.jl:74\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Int64 has no field even\n  Stacktrace:\n \
    \  [1] getproperty(::Int64, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpboekpmxr.jl:46\n   [3] top-level scope at /tmp/tmpboekpmxr.jl:74\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \ntest set: Error During\
    \ Test at /tmp/tmpboekpmxr.jl:75\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Int64 has no field even\n  Stacktrace:\n   [1]\
    \ getproperty(::Int64, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpboekpmxr.jl:46\n   [3] top-level scope at /tmp/tmpboekpmxr.jl:75\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \ntest set: Error During\
    \ Test at /tmp/tmpboekpmxr.jl:76\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Int64 has no field even\n  Stacktrace:\n   [1] getproperty(::Int64,\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpboekpmxr.jl:46\n\
    \   [3] top-level scope at /tmp/tmpboekpmxr.jl:76\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \ntest set: Error During\
    \ Test at /tmp/tmpboekpmxr.jl:77\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  type Int64 has no field even\n  Stacktrace:\n\
    \   [1] getproperty(::Int64, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpboekpmxr.jl:46\n   [3] top-level scope at /tmp/tmpboekpmxr.jl:77\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpboekpmxr.jl:69\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      7      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpboekpmxr.jl:67\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,0,5]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,5,0,5,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,0,5,0,5]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,5,0,5,0,5,0]\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmn604ljj.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmn604ljj.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = arr[smallest_index]\n    \n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3pmz3zhr.jl:53\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3pmz3zhr.jl:53\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnjfhrdlf.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpnjfhrdlf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpnjfhrdlf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = index(even_values, smallest_even_value)\n    if smallest_even_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_even_value,smallest_even_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 7: Given a binary tree, return the level order traversal of its\
    \ nodes' values. (i.e., the in-order traversal of its nodes' values.)\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppb8ty_m5.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppb8ty_m5.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ Vector{Int64}([smallest_value, smallest_index])\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\n4.3 Plucking Elements\
    \ from an Array\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdisshzqb.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdisshzqb.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    return\
    \ [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjby4ih23.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjby4ih23.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = unique(arr .% 2)\n    \n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return [] \n    end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpomg9gdad.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpomg9gdad.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpomg9gdad.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    smallest_index = 2\n    for\
    \ index in 2:length(arr)\n        if arr[index] >= largest\n            largest\
    \ = arr[index]\n        elseif arr[index] < smallest && arr[index] % 2 == 0\n\
    \            smallest = arr[index]\n            smallest_index = index\n     \
    \   end\n    end\n    return smallest_index == 1 ? [smallest, smallest_index]\
    \ : []\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgt1i68p6.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgt1i68p6.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return Vector{Int64}([smallest_value,\
    \ index])\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing\
    \ a binary tree, return the number of nodes in the tree.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsjmw5aqf.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsjmw5aqf.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nProblem 7: Find all nodes\
    \ with value greater than a given value\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbu4y3b3j.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbu4y3b3j.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    \n    smallest_even_value = minimum(even_values)\n\
    \    smallest_even_index = findfirst(x->x==smallest_even_value, even_values)\n\
    \    \n    return [smallest_even_value, smallest_even_index]\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_l1xgjey.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_l1xgjey.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpyiqn6o82.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpyiqn6o82.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:52\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:54\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:56\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \ntest set: Error During\
    \ Test at /tmp/tmpyiqn6o82.jl:57\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpyiqn6o82.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpyiqn6o82.jl:57\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpyiqn6o82.jl:49\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyiqn6o82.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = arr.index(node)\n            end\n        end\n\
    \    end\n    if !isempty(even_values)\n        smallest_value = min(even_values)\n\
    \        smallest_index = arr.index(smallest_value)\n    end\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuq3a43ei.jl:53\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuq3a43ei.jl:53\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice Problems\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzf04oef6.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzf04oef6.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = Int64(0)\n    smallest_index\
    \ = -1\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == 0\n                smallest_value = node\n \
    \               smallest_index = node\n            elseif node < smallest_value\n\
    \                smallest_value = node\n                smallest_index = node\n\
    \            end\n        end\n    end\n    if !even_values\n        return Vector{Int64}()\n\
    \    end\n    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    return smallest_value, smallest_index\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4_e8cuon.jl:62\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n  \
    \ [2] pluck(::Array{Int64,1}) at /tmp/tmp4_e8cuon.jl:40\n   [3] top-level scope\
    \ at /tmp/tmp4_e8cuon.jl:62\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:63\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp4_e8cuon.jl:40\n\
    \   [3] top-level scope at /tmp/tmp4_e8cuon.jl:63\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:64\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching !(::Set{Int64})\n  Closest\
    \ candidates are:\n    !(!Matched::Missing) at missing.jl:100\n    !(!Matched::Bool)\
    \ at bool.jl:35\n    !(!Matched::Function) at operators.jl:880\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp4_e8cuon.jl:50\n   [2] top-level scope\
    \ at /tmp/tmp4_e8cuon.jl:64\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:65\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmp4_e8cuon.jl:40\n   [3] top-level scope at /tmp/tmp4_e8cuon.jl:65\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:66\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmp4_e8cuon.jl:40\n   [3] top-level scope at /tmp/tmp4_e8cuon.jl:66\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:67\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp4_e8cuon.jl:40\n\
    \   [3] top-level scope at /tmp/tmp4_e8cuon.jl:67\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:68\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp4_e8cuon.jl:40\n\
    \   [3] top-level scope at /tmp/tmp4_e8cuon.jl:68\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_e8cuon.jl:69\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching !(::Set{Int64})\n\
    \  Closest candidates are:\n    !(!Matched::Missing) at missing.jl:100\n    !(!Matched::Bool)\
    \ at bool.jl:35\n    !(!Matched::Function) at operators.jl:880\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp4_e8cuon.jl:50\n   [2] top-level scope\
    \ at /tmp/tmp4_e8cuon.jl:69\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_e8cuon.jl:61\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4_e8cuon.jl:59\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = arr[smallest_index]\n    \n    return smallest_value, smallest_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpddhce3c7.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpddhce3c7.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:54\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:56\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:56\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:57\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:57\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:58\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:58\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpddhce3c7.jl:59\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpddhce3c7.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpddhce3c7.jl:59\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpddhce3c7.jl:51\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpddhce3c7.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = node\n            end\n        end\n    end\n\
    \    \n    if !even_values\n        return Vector{Int64}[]\n    end\n    \n  \
    \  smallest_value_index = Set()\n    for node in even_values\n        if smallest_value\
    \ == node\n            smallest_value_index.add(smallest_index)\n        end\n\
    \    end\n    \n    return smallest_value_index\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp1de2i36m.jl:68\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ pluck(::Array{Int64,1}) at /tmp/tmp1de2i36m.jl:42\n   [3] top-level scope at\
    \ /tmp/tmp1de2i36m.jl:68\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:69\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp1de2i36m.jl:42\n\
    \   [3] top-level scope at /tmp/tmp1de2i36m.jl:69\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:70\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching !(::Set{Any})\n  Closest\
    \ candidates are:\n    !(!Matched::Missing) at missing.jl:100\n    !(!Matched::Bool)\
    \ at bool.jl:35\n    !(!Matched::Function) at operators.jl:880\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp1de2i36m.jl:50\n   [2] top-level scope\
    \ at /tmp/tmp1de2i36m.jl:70\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:71\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1de2i36m.jl:42\n   [3] top-level scope at /tmp/tmp1de2i36m.jl:71\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:72\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmp1de2i36m.jl:42\n   [3] top-level scope at /tmp/tmp1de2i36m.jl:72\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:73\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp1de2i36m.jl:42\n\
    \   [3] top-level scope at /tmp/tmp1de2i36m.jl:73\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:74\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp1de2i36m.jl:42\n\
    \   [3] top-level scope at /tmp/tmp1de2i36m.jl:74\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \ntest set: Error During\
    \ Test at /tmp/tmp1de2i36m.jl:75\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching !(::Set{Any})\n\
    \  Closest candidates are:\n    !(!Matched::Missing) at missing.jl:100\n    !(!Matched::Bool)\
    \ at bool.jl:35\n    !(!Matched::Function) at operators.jl:880\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp1de2i36m.jl:50\n   [2] top-level scope\
    \ at /tmp/tmp1de2i36m.jl:75\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1de2i36m.jl:67\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1de2i36m.jl:65\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph16jxc4w.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph16jxc4w.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return Vector{Int64}([smallest_value, smallest_index])\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy_59gwyz.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpy_59gwyz.jl:42\n   [2]\
    \ top-level scope at /tmp/tmpy_59gwyz.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy_59gwyz.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpy_59gwyz.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy_59gwyz.jl:42\n   [2] top-level scope\
    \ at /tmp/tmpy_59gwyz.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy_59gwyz.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpy_59gwyz.jl:55\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy_59gwyz.jl:42\n   [2] top-level scope\
    \ at /tmp/tmpy_59gwyz.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy_59gwyz.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpy_59gwyz.jl:56\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy_59gwyz.jl:42\n   [2] top-level scope\
    \ at /tmp/tmpy_59gwyz.jl:56\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy_59gwyz.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpy_59gwyz.jl:57\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy_59gwyz.jl:42\n   [2] top-level scope\
    \ at /tmp/tmpy_59gwyz.jl:57\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy_59gwyz.jl:51\n  \ntest set: Error During\
    \ Test at /tmp/tmpy_59gwyz.jl:58\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy_59gwyz.jl:42\n   [2] top-level scope\
    \ at /tmp/tmpy_59gwyz.jl:58\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy_59gwyz.jl:51\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy_59gwyz.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2) == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x == smallest_value, even_values)\n    \n \
    \   if smallest_index == nothing\n        return Vector{Int64}()\n    end\n  \
    \  \n    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplpg3af7y.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplpg3af7y.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = length(arr)\n            end\n        end\n\
    \    end\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = min(even_values)\n    smallest_index = index(even_values,\
    \ smallest_value)\n    \n    return [ smallest_value, smallest_index ]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpntwj7t66.jl:64\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpntwj7t66.jl:42\n   [3] top-level scope at\
    \ /tmp/tmpntwj7t66.jl:64\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpntwj7t66.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpntwj7t66.jl:65\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpntwj7t66.jl:42\n\
    \   [3] top-level scope at /tmp/tmpntwj7t66.jl:65\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpntwj7t66.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpntwj7t66.jl:67\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpntwj7t66.jl:42\n   [3] top-level scope at /tmp/tmpntwj7t66.jl:67\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpntwj7t66.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpntwj7t66.jl:68\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpntwj7t66.jl:42\n   [3] top-level scope at /tmp/tmpntwj7t66.jl:68\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpntwj7t66.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpntwj7t66.jl:69\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpntwj7t66.jl:42\n\
    \   [3] top-level scope at /tmp/tmpntwj7t66.jl:69\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpntwj7t66.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpntwj7t66.jl:70\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpntwj7t66.jl:42\n\
    \   [3] top-level scope at /tmp/tmpntwj7t66.jl:70\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpntwj7t66.jl:63\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpntwj7t66.jl:61\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2)==0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvejq5hxl.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvejq5hxl.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv6y2qao6.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv6y2qao6.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even? \n            push!(even_values,\
    \ node.value)\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = node\n            end\n     \
    \   end\n    end\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    \n    return [ smallest_value, smallest_index ]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbh9f_mve.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbh9f_mve.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \        return [ smallest_even_value, smallest_even_index ]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz1ngo7xh.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpz1ngo7xh.jl:39\n   [2]\
    \ top-level scope at /tmp/tmpz1ngo7xh.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz1ngo7xh.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpz1ngo7xh.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpz1ngo7xh.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpz1ngo7xh.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz1ngo7xh.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpz1ngo7xh.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpz1ngo7xh.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpz1ngo7xh.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz1ngo7xh.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpz1ngo7xh.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpz1ngo7xh.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpz1ngo7xh.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz1ngo7xh.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpz1ngo7xh.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpz1ngo7xh.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpz1ngo7xh.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz1ngo7xh.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpz1ngo7xh.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpz1ngo7xh.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpz1ngo7xh.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz1ngo7xh.jl:48\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz1ngo7xh.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = find(even_values == smallest_even_value)[0]\n\
    \    return smallest_even_value,smallest_index\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7qdhsvuu.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7qdhsvuu.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = 1\n    smallestIndex\
    \ = 1\n    for node in arr[2:end]\n        if node < smallest \n            smallest\
    \ = node\n            smallestIndex = largestIndex\n        elseif node > largest\n\
    \            largest = node\n            largestIndex = smallestIndex\n      \
    \  else\n            smallestIndex = smallestIndex + 1\n        end\n    end\n\
    \    return [ smallest, smallestIndex ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplawdl1dt.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplawdl1dt.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -1\n    smallest_index = 0\n\
    \    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    return smallest_value, smallest_index\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppnol1u4t.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppnol1u4t.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_sl8qo0i.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_sl8qo0i.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_sl8qo0i.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -1\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == -1 || node < smallest_value\n              \
    \  smallest_value = node\n                smallest_index = length(arr)\n     \
    \       end\n        end\n    end\n    \n    if length(even_values) == 0\n   \
    \     return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    return [ smallest_value,\
    \ smallest_index ]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcty7f016.jl:64\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2]\
    \ pluck(::Array{Int64,1}) at /tmp/tmpcty7f016.jl:42\n   [3] top-level scope at\
    \ /tmp/tmpcty7f016.jl:64\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcty7f016.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpcty7f016.jl:65\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpcty7f016.jl:42\n\
    \   [3] top-level scope at /tmp/tmpcty7f016.jl:65\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcty7f016.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpcty7f016.jl:67\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcty7f016.jl:42\n   [3] top-level scope at /tmp/tmpcty7f016.jl:67\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcty7f016.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpcty7f016.jl:68\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Any}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpcty7f016.jl:42\n   [3] top-level scope at /tmp/tmpcty7f016.jl:68\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcty7f016.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpcty7f016.jl:69\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpcty7f016.jl:42\n\
    \   [3] top-level scope at /tmp/tmpcty7f016.jl:69\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcty7f016.jl:63\n  \ntest set: Error During\
    \ Test at /tmp/tmpcty7f016.jl:70\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Any},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpcty7f016.jl:42\n\
    \   [3] top-level scope at /tmp/tmpcty7f016.jl:70\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcty7f016.jl:63\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcty7f016.jl:61\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 4\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0w21kq22.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0w21kq22.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    return smallest_value, smallest_even_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy620bulv.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpy620bulv.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:47\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:48\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:49\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:51\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpy620bulv.jl:53\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy620bulv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy620bulv.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy620bulv.jl:45\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy620bulv.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ Vector{Int64}([smallest_value, smallest_index])\n    end\nend\n</cell>\n<text>\n\
    Solution\nLet's see how we could solve this problem using Julia.\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl2lo8qtq.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl2lo8qtq.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpegyt2r_j.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpegyt2r_j.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb6ey_w8q.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpb6ey_w8q.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpb6ey_w8q.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        index = find(even_values == smallest_even_value)[1]\n\
    \        return [ smallest_even_value, index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph56i0f9o.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph56i0f9o.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp407bq22f.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp407bq22f.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp407bq22f.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptt6h9ff2.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptt6h9ff2.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = arr[smallest_index]\n    \n    return Vector{Int64}([smallest_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjd26pmik.jl:53\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjd26pmik.jl:53\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzohv0php.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzohv0php.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_i5d4iyg.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_i5d4iyg.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_i5d4iyg.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr).-arr\n    even_values = sort(even_values)\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1s9lp3vj.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp1s9lp3vj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp1s9lp3vj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprg0qranv.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprg0qranv.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf\n    smallest_index\
    \ = 0\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = i\n        end\n    end\n    if !isempty(even_values)\n\
    \        smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n    end\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgfv4ldsq.jl:53\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgfv4ldsq.jl:53\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpegvcrxzw.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpegvcrxzw.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3, 4]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 4, 5, 6]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,\
    \ 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n\
    </cell>\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy_tyuzbd.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy_tyuzbd.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [];\n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfn5osatc.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfn5osatc.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpj6f1z5d0.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Array has no field filter\n\
    \  Stacktrace:\n   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n\
    \   [2] pluck(::Array{Int64,1}) at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope\
    \ at /tmp/tmpj6f1z5d0.jl:48\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Array has no field filter\n  Stacktrace:\n   [1] getproperty(::Array{Int64,1},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpj6f1z5d0.jl:35\n\
    \   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:49\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:50\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  type Array has no field filter\n  Stacktrace:\n   [1]\
    \ getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:50\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:51\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:51\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:52\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Array has no field filter\n  Stacktrace:\n  \
    \ [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:53\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Array has no field filter\n  Stacktrace:\n   [1]\
    \ getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:54\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpj6f1z5d0.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpj6f1z5d0.jl:35\n   [3] top-level scope at /tmp/tmpj6f1z5d0.jl:55\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpj6f1z5d0.jl:47\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj6f1z5d0.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    return smallest_value, smallest_value_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqpusnfq8.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpqpusnfq8.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:47\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:48\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:49\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:51\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \ntest set: Error During\
    \ Test at /tmp/tmpqpusnfq8.jl:53\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqpusnfq8.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqpusnfq8.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqpusnfq8.jl:45\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqpusnfq8.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even.sort()\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"Test\" after end of expression\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprtau2zlc.jl:120\n [2] include(::Module,\
    \ ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n\
    \ [4] _start() at ./client.jl:484\nin expression starting at /tmp/tmprtau2zlc.jl:120\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=juli\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps6iung0v.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps6iung0v.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\
    \ || length(arr) == 0 \n        return [] \n    end\n    \n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp43biciew.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp43biciew.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_value_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa62y6q6q.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa62y6q6q.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpislfec85.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpislfec85.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n  \
    \  end\n    \n    smallest_value = smallest_value.value\n    smallest_index =\
    \ smallest_index.value\n    \n    even_values = Set()\n    \n    for node in arr\n\
    \        if node.even?\n            even_values.add(node.value)\n        end\n\
    \    end\n    \n    if !even_values\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = smallest_value.value\n    smallest_index = smallest_index.value\n\
    \    \n    even_values = Set()\n    \n    for node in arr\n        if node.even?\n\
    \            even_values.add(node.value)\n        end\n    end\n    \n    if !even_values\n\
    \        return Vector{Int64}()\n    end\n    \n    smallest_value = smallest_value.value\n\
    \    smallest_index = smallest_index.value\n    \n    even_values = Set()\n  \
    \  \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \        end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = smallest_value.value\n    smallest_index\
    \ = smallest_index.value\n    \n    even_values = Set()\n    \n    for node in\
    \ arr\n        if node.even?\n            even_values.add(node.value)\n      \
    \  end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n \
    \   end\n    \n    smallest_value = smallest_value.value\n    smallest_index =\
    \ smallest_index.value\n    \n    even_values = Set()\n    \n    for node in arr\n\
    \        if node.even?\n            even_values.add(node.value)\n        end\n\
    \    end\n    \n    if !even_values\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = smallest_value.value\n    smallest_index = smallest_index.value\n\
    \    \n    even_values = Set()\n    \n    for node in arr\n        if node.even?\n\
    \            even_values.add(node.value)\n        end\n    end\n    \n    if !even_values\n\
    \        return Vector{Int64}()\n    end\n    \n    smallest_value = smallest_value.value\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5h88yegd.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5h88yegd.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return smallest_value, smallest_index\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1,0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,2,3,0,4,2,1,0,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1,0,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0,1,0,1,0,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1,0,1,0,1,0,1,0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5t0cqmtd.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5t0cqmtd.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n  \
    \  end\n    \n    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    \n    return [ smallest_value, smallest_index ]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvfaofwvr.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvfaofwvr.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_index = smallest_even_index\n\
    \    \n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6dsbb8k6.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp6dsbb8k6.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp6dsbb8k6.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    if length(even_values) == 0\n     \
    \   return Vector{Int64}[]\n    else\n        smallest_value = even_values[1]\n\
    \        smallest_index = 1\n        for value in even_values\n            if\
    \ value < smallest_value\n                smallest_value = value\n           \
    \     smallest_index = index(value)\n            end\n        end\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfooz4h3z.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfooz4h3z.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if isempty(even_values)\n\
    \        return [];\n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=juli\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2ci6nmw3.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2ci6nmw3.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpadqjbmtd.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpadqjbmtd.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index =\
    \ -1\n    \n    for node in arr\n        if node.even\n            push!(even_values,\
    \ node.value)\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = i\n            end\n        end\n\
    \    end\n    \n    if !isempty(even_values)\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n    end\n  \
    \  \n    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx1z03spb.jl:56\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpx1z03spb.jl:56\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt58vboo2.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt58vboo2.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpabqnocmj.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpabqnocmj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpabqnocmj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpukj7om64.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpukj7om64.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp19fxsuxj.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2]\
    \ top-level scope at /tmp/tmp19fxsuxj.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp19fxsuxj.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp19fxsuxj.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp19fxsuxj.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp19fxsuxj.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp19fxsuxj.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    if smallest_index == nothing\n        return []\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 4\n\
    Given a binary tree, return the level order traversal of its nodes' values.\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv4pndq_y.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv4pndq_y.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8mjgoy3k.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp8mjgoy3k.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp8mjgoy3k.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp681yoyj8.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp681yoyj8.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp681yoyj8.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = index\n            end\n        end\n    end\n\
    \    if length(even_values) == 0\n        return Vector{Int64}()\n    end\n  \
    \  smallest_value = min(even_values)\n    smallest_index = index(smallest_value)\n\
    \    return [ smallest_value, smallest_index ]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp0dv0prmp.jl:59\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n  \
    \ [2] pluck(::Array{Int64,1}) at /tmp/tmp0dv0prmp.jl:40\n   [3] top-level scope\
    \ at /tmp/tmp0dv0prmp.jl:59\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0dv0prmp.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dv0prmp.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp0dv0prmp.jl:40\n\
    \   [3] top-level scope at /tmp/tmp0dv0prmp.jl:60\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0dv0prmp.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dv0prmp.jl:62\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmp0dv0prmp.jl:40\n   [3] top-level scope at /tmp/tmp0dv0prmp.jl:62\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0dv0prmp.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dv0prmp.jl:63\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmp0dv0prmp.jl:40\n   [3] top-level scope at /tmp/tmp0dv0prmp.jl:63\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0dv0prmp.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dv0prmp.jl:64\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp0dv0prmp.jl:40\n\
    \   [3] top-level scope at /tmp/tmp0dv0prmp.jl:64\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0dv0prmp.jl:58\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dv0prmp.jl:65\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmp0dv0prmp.jl:40\n\
    \   [3] top-level scope at /tmp/tmp0dv0prmp.jl:65\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0dv0prmp.jl:58\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0dv0prmp.jl:56\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = Int64(0)\n    smallest_index\
    \ = -1\n    smallest_even_value = Int64(0)\n    \n    for node in arr\n      \
    \  if node.even?\n            even_values.add(node.value)\n            if node.value\
    \ < smallest_value\n                smallest_value = node.value\n            \
    \    smallest_index = node\n            elseif node.value == smallest_value\n\
    \                if node.index < smallest_index\n                    smallest_value\
    \ = node.value\n                    smallest_index = node\n                end\n\
    \            end\n        else\n            if node.value < smallest_even_value\n\
    \                smallest_even_value = node.value\n            end\n        end\n\
    \    end\n    \n    if !even_values.empty?\n        smallest_value = smallest_value\
    \ + 1\n        smallest_index = smallest_index + 1\n    end\n    \n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplppokwik.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplppokwik.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\narr = [4,2,3]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n\
    </cell>\n<code language=julia-1.4>\narr = [1,2,3]\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = []\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n\
    <code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n\
    </cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n\
    <code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n\
    </cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.4>\npluck(arr)\n</cell>\n\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeppa6y4_.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpeppa6y4_.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppxklrhgh.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppxklrhgh.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbz0dr_7f.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpbz0dr_7f.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpbz0dr_7f.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpbz0dr_7f.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpbz0dr_7f.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbz0dr_7f.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbz0dr_7f.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprfyrxqj7.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprfyrxqj7.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeqac6d4x.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpeqac6d4x.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpeqac6d4x.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = unique(even)\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp66bc6myr.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp66bc6myr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp66bc6myr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, \nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb_kpuosp.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb_kpuosp.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nProblem 3\nGiven a binary\
    \ tree, return the level order traversal of its nodes' values. (i.e., the in-order\
    \ traversal of its nodes' values.)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz00qp0tz.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz00qp0tz.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    \n    smallest_index = findfirst(x->x==smallest_value, even_values)\n   \
    \ \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbufzqa4v.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbufzqa4v.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4rq4jzek.jl:82\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4rq4jzek.jl:82\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    plucked_value = arr[smallest_index]\n    \n    return Vector{Int64}([plucked_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph3pqplyj.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph3pqplyj.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for index in 2:length(arr)\n        if arr[index] % 2 == 0\n      \
    \      if smallest_value < arr[index]\n                smallest_value = arr[index]\n\
    \                smallest_index = index\n            end\n        end\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0,5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,5,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,5,0,5]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,2,3,0,4,2,1,0,5,0,5,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,5,0,5,0,5]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0,5,0,5,0,5,0]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuayveml0.jl:50\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuayveml0.jl:50\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu5vyhppv.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu5vyhppv.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = findall(x -> mod(x,2) == 0, arr)\n    \n    if isempty(even_values)\
    \ \n        return []\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=juli\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv_00tz2k.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv_00tz2k.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    if length(even_values) == 0\n     \
    \   return Vector{Int64}()\n    else\n        smallest_value = even_values[1]\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph3a618xl.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph3a618xl.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgte5599h.jl:82\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgte5599h.jl:82\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven an array\
    \ representing a branch of a tree that has non-negative integer nodes\nyour task\
    \ is to pluck one of the nodes and return it.\nThe plucked node should be the\
    \ node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr8iqpadn.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr8iqpadn.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [ smallest_value, smallest_index ]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpcdmv0ppn.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcdmv0ppn.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcdmv0ppn.jl:51\ntest set: Test Failed at /tmp/tmpcdmv0ppn.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpcdmv0ppn.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcdmv0ppn.jl:51\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcdmv0ppn.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = Int64(0)\n    smallest = Int64(0)\n    largestIndex = Int64(0)\n\
    \    smallestIndex = Int64(0)\n    largestEven = Int64(0)\n    smallestEven =\
    \ Int64(0)\n    largestEvenIndex = Int64(0)\n    smallestEvenIndex = Int64(0)\n\
    \    largestEvenValue = Int64(0)\n    smallestEvenValue = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    smallestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpimtcjr60.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpimtcjr60.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpimtcjr60.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3przzbtr.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3przzbtr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3przzbtr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index += 1\n    \n    return smallest_value, smallest_index\nend\n\
    </cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpal_eq1yl.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpal_eq1yl.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy9d18_jc.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy9d18_jc.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    return smallest_even_value,smallest_even_index\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpd37fg4hu.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpd37fg4hu.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpd37fg4hu.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpd37fg4hu.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpd37fg4hu.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd37fg4hu.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd37fg4hu.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0,\
    \ 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0,\
    \ 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0,\
    \ 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpym6ekhto.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpym6ekhto.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz6c0xx43.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz6c0xx43.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsppj3ze5.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpsppj3ze5.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3vfta3fw.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3vfta3fw.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3vfta3fw.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n    \n    \n    return [ smallest_even_value, smallest_index ]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpatr675i6.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpatr675i6.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [\
    \ smallest_value, smallest_index ]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpmfih610t.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpmfih610t.jl:39\n   [2]\
    \ top-level scope at /tmp/tmpmfih610t.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmfih610t.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpmfih610t.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpmfih610t.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpmfih610t.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmfih610t.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpmfih610t.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpmfih610t.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpmfih610t.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmfih610t.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpmfih610t.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpmfih610t.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpmfih610t.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmfih610t.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpmfih610t.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpmfih610t.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpmfih610t.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmfih610t.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpmfih610t.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpmfih610t.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpmfih610t.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmfih610t.jl:48\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmfih610t.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = index(even_values, smallest_even_value)\n\
    \    \n    if smallest_even_index == -1 || length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    else\n        return [smallest_even_value,smallest_even_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg2rswamo.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg2rswamo.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven a binary\
    \ tree and a node value, swap the node value with the node that results from traveling\
    \ down the tree starting from the given node. \nIf the given node has no children,\
    \ return the node unchanged.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5aa5to6s.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5aa5to6s.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3c2hngnn.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3c2hngnn.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8m9252nk.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8m9252nk.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = Int64(Inf)\n    smallest_index\
    \ = -1\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == Int64(Inf)\n                smallest_value =\
    \ node\n                smallest_index = -1\n            elseif node < smallest_value\n\
    \                smallest_value = node\n                smallest_index = -1\n\
    \            elseif node < smallest_value\n                smallest_index = smallest_index\
    \ + 1\n            end\n        end\n    end\n    \n    if smallest_value == Int64(Inf)\n\
    \        smallest_value = -1\n        smallest_index = -1\n    end\n    \n   \
    \ return smallest_value, smallest_index\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpvyjidux0.jl:67\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(::Float64) at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at\
    \ /tmp/tmpvyjidux0.jl:37\n   [3] top-level scope at /tmp/tmpvyjidux0.jl:67\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:68\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64(::Float64)\
    \ at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvyjidux0.jl:37\n\
    \   [3] top-level scope at /tmp/tmpvyjidux0.jl:68\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:69\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64(::Float64)\
    \ at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvyjidux0.jl:37\n\
    \   [3] top-level scope at /tmp/tmpvyjidux0.jl:69\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:70\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1]\
    \ Int64(::Float64) at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvyjidux0.jl:37\n\
    \   [3] top-level scope at /tmp/tmpvyjidux0.jl:70\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:71\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1]\
    \ Int64(::Float64) at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvyjidux0.jl:37\n\
    \   [3] top-level scope at /tmp/tmpvyjidux0.jl:71\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:72\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64(::Float64)\
    \ at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvyjidux0.jl:37\n\
    \   [3] top-level scope at /tmp/tmpvyjidux0.jl:72\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:73\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n   [1] Int64(::Float64)\
    \ at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvyjidux0.jl:37\n\
    \   [3] top-level scope at /tmp/tmpvyjidux0.jl:73\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \ntest set: Error During\
    \ Test at /tmp/tmpvyjidux0.jl:74\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(::Float64) at ./float.jl:710\n   [2] pluck(::Array{Int64,1}) at\
    \ /tmp/tmpvyjidux0.jl:37\n   [3] top-level scope at /tmp/tmpvyjidux0.jl:74\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvyjidux0.jl:66\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvyjidux0.jl:64\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy9f2tkjl.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy9f2tkjl.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_even_value, even_values)\n    return\
    \ Vector{Int64}([smallest_even_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnxqkqg1i.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnxqkqg1i.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxdrxrkon.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxdrxrkon.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpfa4t38j2.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfa4t38j2.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfa4t38j2.jl:48\ntest set: Test Failed at /tmp/tmpfa4t38j2.jl:53\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpfa4t38j2.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfa4t38j2.jl:48\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfa4t38j2.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwxw_e0bn.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwxw_e0bn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwxw_e0bn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0wahrekr.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0wahrekr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0wahrekr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \        return [smallest_even_value, smallest_even_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt_59dsie.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt_59dsie.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy9k7jq83.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpy9k7jq83.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpy9k7jq83.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpy9k7jq83.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpy9k7jq83.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy9k7jq83.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy9k7jq83.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    if\
    \ smallest_index == nothing\n        return Vector{Int64}()\n    end\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4mb5xma4.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4mb5xma4.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        smallest_index = []\n    end\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk4baibwn.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk4baibwn.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven a binary\
    \ tree, return the levels of the tree in order from top to bottom.\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw6baa9kv.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw6baa9kv.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxf2jlvrs.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxf2jlvrs.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = -1\n    smallestIndex\
    \ = -1\n    for index in 2:length(arr)\n        if arr[index] >= largest\n   \
    \         largest = arr[index]\n            largestIndex = index\n        elseif\
    \ arr[index] < smallest\n            smallest = arr[index]\n            smallestIndex\
    \ = index\n        end\n    end\n    \n    if largestIndex == -1\n        return\
    \ Vector{Int64}[]\n    end\n    \n    if smallestIndex == -1\n        return [largest,\
    \ largestIndex]\n    end\n    \n    if arr[largestIndex] == smallest\n       \
    \ return [largest, largestIndex]\n    end\n    \n    if arr[largestIndex] > smallest\n\
    \        return [largest, largestIndex]\n    end\n    \n    return [smallest,\
    \ smallestIndex]\nend\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpux96his3.jl:67\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpux96his3.jl:67\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1,2,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyp3s8fe7.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyp3s8fe7.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -1\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if even_values == Set()\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value_index = find(even_values, smallest_value)\n\
    \    \n    if smallest_value_index == nothing\n        return Vector{Int64}()\n\
    \    end\n    \n    return [smallest_value, smallest_value_index]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=juli\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpev31fze4.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpev31fze4.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqosj4yzv.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpqosj4yzv.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpqosj4yzv.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpqosj4yzv.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpqosj4yzv.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqosj4yzv.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqosj4yzv.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpoficvpny.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpoficvpny.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpoficvpny.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpoficvpny.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpoficvpny.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpoficvpny.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoficvpny.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6nzvj854.jl:82\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6nzvj854.jl:82\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    end\n    \n    return Vector{Int64}([smallest_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpykfz0icy.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpykfz0icy.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzmv_7_v8.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzmv_7_v8.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzmv_7_v8.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = index(even_values, smallest_even_value)\n    return\
    \ [smallest_even_value, smallest_even_index]\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4485ghp_.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4485ghp_.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nGiven an array representing a binary tree, return the number\
    \ of nodes in the tree.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxmazaqsu.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxmazaqsu.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value_index = find(even_values == smallest_value)[1]\n    \n   \
    \ smallest_value_index = smallest_value_index == length(even_values) ? 1 : smallest_value_index\n\
    \    \n    plucked_value = arr[smallest_value_index]\n    \n    return Vector{Int64}([plucked_value,\
    \ smallest_value_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6mrjr2bo.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6mrjr2bo.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb4edetin.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb4edetin.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    if smallest_index\
    \ == -1\n        return []\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (ie, from left to right, level by level).\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyx07dyvq.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyx07dyvq.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_value_index = arr.index(smallest_value)\n\
    \    return [smallest_value, smallest_value_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpf9jljl1z.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2]\
    \ top-level scope at /tmp/tmpf9jljl1z.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:48\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:49\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:51\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:53\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9jljl1z.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpf9jljl1z.jl:36\n   [2] top-level scope\
    \ at /tmp/tmpf9jljl1z.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9jljl1z.jl:46\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf9jljl1z.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    end\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj59iftyy.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj59iftyy.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp634fukss.jl:91\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp634fukss.jl:91\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6xu_h9nq.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6xu_h9nq.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        return Vector{Int64}()\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=juli\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxipm16o7.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxipm16o7.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = find(x -> x == smallest_even_value, even_values)\n\
    \    if smallest_index == -1 || smallest_index == length(even_values)\n      \
    \  return Vector{Int64}()\n    else\n        return [smallest_even_value, smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc8pzhf5t.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpc8pzhf5t.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = findfirst(x -> x % 2 == 0, arr)\n    if even != nothing\n     \
    \   smalest_value = arr[even]\n        smalest_index = even\n        \n      \
    \  for i in arr[even+1:end]\n            if i % 2 == 0\n                if smalest_value\
    \ < i\n                    smalest_value = i\n                    smalest_index\
    \ = i\n                end\n            end\n        end\n        \n        return\
    \ [smalest_value, smalest_index]\n    else\n        return []\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxh9tg4_i.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxh9tg4_i.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    smallest_index = 2\n    largest_index\
    \ = 1 \n    \n    for index in 2:length(arr)\n        if arr[index] >= largest\n\
    \            largest = arr[index]\n            largest_index = index\n       \
    \ elseif arr[index] < smallest\n            smallest = arr[index]\n          \
    \  smallest_index = index\n        end\n    end\n    \n    if smallest == largest\n\
    \        return smallest_index\n    else\n        return [smallest, smallest_index]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsyrm7450.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpsyrm7450.jl:61\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\ntest set: Test Failed at /tmp/tmpsyrm7450.jl:62\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 2] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsyrm7450.jl:62\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\ntest set: Error During Test at\
    \ /tmp/tmpsyrm7450.jl:63\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  BoundsError: attempt to access 0-element Array{Int64,1}\
    \ at index [1]\n  Stacktrace:\n   [1] getindex at ./array.jl:788 [inlined]\n \
    \  [2] pluck(::Array{Int64,1}) at /tmp/tmpsyrm7450.jl:35\n   [3] top-level scope\
    \ at /tmp/tmpsyrm7450.jl:63\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsyrm7450.jl:60\n  \ntest set: Test Failed at\
    \ /tmp/tmpsyrm7450.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n\
    \   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpsyrm7450.jl:64\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\ntest set: Test Failed at /tmp/tmpsyrm7450.jl:65\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpsyrm7450.jl:65\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\ntest set: Test Failed at /tmp/tmpsyrm7450.jl:66\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [4, 2] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpsyrm7450.jl:66\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\ntest set: Test Failed at /tmp/tmpsyrm7450.jl:67\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [1, 4] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpsyrm7450.jl:67\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\ntest set: Test Failed at /tmp/tmpsyrm7450.jl:68\n\
    \  Expression: candidate([7, 9, 7, 1]) == Vector{Int64}([])\n   Evaluated: [1,\
    \ 4] == Int64[]\nStacktrace:\n [1] top-level scope at /tmp/tmpsyrm7450.jl:68\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsyrm7450.jl:60\nTest Summary: | Fail  Error \
    \ Total\ntest set      |    7      1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsyrm7450.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4p3mfyss.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4p3mfyss.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_index = smallest_even_index\n\
    \    \n    if length(even_values) == 0\n        return Vector{Int64}()\n    elseif\
    \ length(even_values) == 1\n        return [smallest_value, smallest_index]\n\
    \    else\n        smallest_value = arr[smallest_even_index]\n        smallest_index\
    \ = smallest_even_index\n        \n        for index in 1:length(arr)\n      \
    \      if arr[index] == smallest_value\n                smallest_value = arr[index]\n\
    \                smallest_index = index\n            end\n        end\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqxyvsczz.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqxyvsczz.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2) == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_even_index = findfirst(x->mod(x,2) == 0, even_values)\n    \
    \    return [smallest_even_value,smallest_even_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\narr = [4,2,3]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = []\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpextvuz56.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpextvuz56.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_nhx4c_r.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_nhx4c_r.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = minimum(even_values)\n    smallest_index = find(even_values == smallest_even_value)\
    \ \n    \n    if smallest_index == length(even_values)\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = arr[smallest_index]\n    \n    index_of_smallest_value\
    \ = find(arr == smallest_value)\n    \n    return [smallest_value, index_of_smallest_value]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7k7qdmc9.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7k7qdmc9.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even\n            push!(even_values,\
    \ node.value)\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = node\n            end\n     \
    \   end\n    end\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value_index = find(even_values, smallest_value)\n\
    \    \n    if smallest_value_index == length(even_values)\n        return Vector{Int64}()\n\
    \    end\n    \n    return [ smallest_value, smallest_value_index ]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=juli\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpal6piw3q.jl:62\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpal6piw3q.jl:62\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0dcov2_3.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2]\
    \ top-level scope at /tmp/tmp0dcov2_3.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp0dcov2_3.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp0dcov2_3.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp0dcov2_3.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0dcov2_3.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0dcov2_3.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = 1\n    smallestIndex\
    \ = 1\n    for node in arr[2:end]\n        if node < smallest \n            smallest\
    \ = node\n            smallestIndex = largestIndex\n        elseif node > largest\n\
    \            largest = node\n            largestIndex = smallestIndex\n      \
    \  elseif smallestIndex == largestIndex\n            smallestIndex = smallestIndex\
    \ + 1\n        end\n    end\n    return [ smallest, smallestIndex ]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code\
    \ language=julia-1.5\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcjz9rm3h.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcjz9rm3h.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [] \n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=juli\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5weml64m.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5weml64m.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzkf65rs_.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzkf65rs_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzkf65rs_.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    return smallest_value, smallest_value_index\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpib4qs3tr.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpib4qs3tr.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_value_index\
    \ == length(even_values)\n        return smallest_value, smallest_index\n    else\n\
    \        return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd8jx2td8.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd8jx2td8.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ plucked_value = arr[smallest_index]\n    \n    return Vector{Int64}([plucked_value,\
    \ smallest_index])\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1khkyn6i.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1khkyn6i.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1khkyn6i.jl:53\ntest set: Test Failed at /tmp/tmp1khkyn6i.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [1, 1] == [2, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1khkyn6i.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1khkyn6i.jl:53\ntest set: Test Failed at /tmp/tmp1khkyn6i.jl:57\n\
    \  Expression: candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [5, 1] ==\
    \ [0, 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp1khkyn6i.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1khkyn6i.jl:53\ntest set: Test Failed at /tmp/tmp1khkyn6i.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [2, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp1khkyn6i.jl:58\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1khkyn6i.jl:53\ntest set: Test Failed at /tmp/tmp1khkyn6i.jl:59\n\
    \  Expression: candidate([5, 4, 8, 4, 8]) == [4, 1]\n   Evaluated: [5, 1] == [4,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp1khkyn6i.jl:59\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1khkyn6i.jl:53\ntest set: Test Failed at /tmp/tmp1khkyn6i.jl:60\n\
    \  Expression: candidate([7, 6, 7, 1]) == [6, 1]\n   Evaluated: [7, 1] == [6,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmp1khkyn6i.jl:60\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1khkyn6i.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1khkyn6i.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2) == 0, arr)\n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return [] \n    end\n    smallest_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x->x == smallest_value,\
    \ even_values)\n    return [ smallest_value, smallest_index ]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice Problems\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcpa6b_bt.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcpa6b_bt.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [4, 2, 3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,\
    \ 2, 3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n\
    <code language=julia-1.0>\npluck\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpih82x0dn.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpih82x0dn.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_even_value)[0]\n    return\
    \ [smallest_even_value,smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven an array\
    \ representing a branch of a tree that has non-negative integer nodes\nyour task\
    \ is to pluck one of the nodes and return it.\nThe plucked node should be the\
    \ node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqe_klxz0.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqe_klxz0.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> mod(x,2) == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5s37cizg.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5s37cizg.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdamm5pqq.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdamm5pqq.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,0,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,0,0,0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,0,0,0,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,0,0,0,0,0,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,0,0,0,0,0,0,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe9a5mu8t.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe9a5mu8t.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_index = find(x -> x == smallest_even_value,\
    \ even_values)\n        return [smallest_even_value, smallest_index]\n    end\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (ie, from left to right, level by level).\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi03ytwrw.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi03ytwrw.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = smallest_index\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptpay0ih8.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmptpay0ih8.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmptpay0ih8.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    smallest_value =\
    \ arr[smallest_index]\n    \n    if length(even_values) == 0 || smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbfs7ukd9.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbfs7ukd9.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdhbaomyg.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpdhbaomyg.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpdhbaomyg.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,6]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,5,6,7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,6,7,8]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,5,6,7,8,9]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpychn48d_.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpychn48d_.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function below\narr = [4,2,3]\nout = pluck(arr)\n@test out == [2,\
    \ 1]\n</cell>\n<text>\n4.3 Pluck all nodes with even values\nGiven an array representing\
    \ a branch of a tree that has non-negative integer nodes\nyour task is to pluck\
    \ all of the nodes and return them in a list.\nThe plucked nodes should be returned\
    \ in a list, [ smalest_value, its index ],\nIf there are no even values or the\
    \ given array is empty, return [].\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcry5e0x8.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcry5e0x8.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <text>\nSolution\nLet's see how we could solve this problem using a recursive\
    \ approach.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb4a4wgc1.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb4a4wgc1.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp3wdmif7l.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2]\
    \ top-level scope at /tmp/tmp3wdmif7l.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmp3wdmif7l.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp3wdmif7l.jl:36\n   [2] top-level scope\
    \ at /tmp/tmp3wdmif7l.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3wdmif7l.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3wdmif7l.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_unyzr2v.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_unyzr2v.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzrauozqg.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzrauozqg.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8n308qqq.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8n308qqq.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvezpbpo1.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Array has no field filter\n\
    \  Stacktrace:\n   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n\
    \   [2] pluck(::Array{Int64,1}) at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope\
    \ at /tmp/tmpvezpbpo1.jl:49\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Array has no field filter\n  Stacktrace:\n   [1] getproperty(::Array{Int64,1},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpvezpbpo1.jl:35\n\
    \   [3] top-level scope at /tmp/tmpvezpbpo1.jl:50\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:51\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  type Array has no field filter\n  Stacktrace:\n   [1]\
    \ getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope at /tmp/tmpvezpbpo1.jl:51\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope at /tmp/tmpvezpbpo1.jl:52\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope at /tmp/tmpvezpbpo1.jl:53\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Array has no field filter\n  Stacktrace:\n  \
    \ [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope at /tmp/tmpvezpbpo1.jl:54\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Array has no field filter\n  Stacktrace:\n   [1]\
    \ getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope at /tmp/tmpvezpbpo1.jl:55\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmpvezpbpo1.jl:56\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty(::Array{Int64,1}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpvezpbpo1.jl:35\n   [3] top-level scope at /tmp/tmpvezpbpo1.jl:56\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpvezpbpo1.jl:48\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvezpbpo1.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = find(even_values == smallest_even_value)[1]\n    \n\
    \    if smallest_even_index == 0 \n        return [] \n    end\n    \n    smallest_value\
    \ = arr[smallest_even_index]\n    \n    smallest_value_index = find(arr == smallest_value)[1]\n\
    \    \n    smallest_value_index_in_even_values = arr[smallest_value_index] .%\
    \ 2\n    \n    if smallest_value_index_in_even_values == 0 \n        return []\
    \ \n    end\n    \n    smallest_value_index_in_even_values_index = find(arr ==\
    \ smallest_value_index_in_even_values)[1]\n    \n    smallest_value_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index] .% 2\n    \n    if smallest_value_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index\
    \ = find(arr == smallest_value_index_in_even_values_index_in_even_values)[1]\n\
    \    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index_in_even_values_index] .% 2\n\
    \    \n    if smallest_value_index_in_even_values_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index]\
    \ .% 2\n    \n    if smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index]\
    \ .% 2\n    \n    if smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_value\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpj70ptvdl.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpj70ptvdl.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpj70ptvdl.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy23arci_.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpy23arci_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpy23arci_.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0w1juvag.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0w1juvag.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0w1juvag.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp41j78uva.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp41j78uva.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = findfirst(x -> x == smallest_even_value, even_values)\n\
    \    return smallest_even_index == nothing ? Vector{Int64}() : Vector{Int64}([smallest_even_value,smallest_even_index])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwe32f_vs.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmpwe32f_vs.jl:39\n   [2]\
    \ top-level scope at /tmp/tmpwe32f_vs.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwe32f_vs.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpwe32f_vs.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpwe32f_vs.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpwe32f_vs.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwe32f_vs.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpwe32f_vs.jl:51\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpwe32f_vs.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpwe32f_vs.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwe32f_vs.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpwe32f_vs.jl:52\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpwe32f_vs.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpwe32f_vs.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwe32f_vs.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpwe32f_vs.jl:53\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpwe32f_vs.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpwe32f_vs.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwe32f_vs.jl:47\n  \ntest set: Error During\
    \ Test at /tmp/tmpwe32f_vs.jl:54\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmpwe32f_vs.jl:39\n   [2] top-level scope\
    \ at /tmp/tmpwe32f_vs.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwe32f_vs.jl:47\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwe32f_vs.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    if smallest_index == nothing\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfdq6tdd1.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfdq6tdd1.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index =\
    \ -1\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value < node\n                smallest_value = node\n\
    \                smallest_index = node\n            end\n        end\n    end\n\
    \    if !even_values\n        return Vector{Int64}()\n    end\n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp99mywhvc.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp99mywhvc.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = Int64(Inf)\n    smallest_index\
    \ = -1\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n  \
    \  end\n    \n    smallest_value_index = -1\n    smallest_value_index = 0\n  \
    \  \n    for node in even_values\n        if node < smallest_value\n         \
    \   smallest_value_index = smallest_value_index + 1\n            smallest_value\
    \ = node\n        end\n    end\n    \n    smallest_value_index = smallest_value_index\
    \ + 1\n    \n    return Vector{Int64}([smallest_value, smallest_value_index])\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzqxhu61k.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzqxhu61k.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n        return [smallest_even_value,smallest_even_index]\n   \
    \ end\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm6k5xmn2.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm6k5xmn2.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -1\n    smallest_index = 0\n\
    \    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == -1 || node < smallest_value\n              \
    \  smallest_value = node\n                smallest_index = length(arr)\n     \
    \       end\n        end\n    end\n    \n    if length(even_values) == 0\n   \
    \     return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    \n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppfrk8fh5.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppfrk8fh5.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzyg39aa_.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzyg39aa_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzyg39aa_.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = 1\n    smallestIndex\
    \ = 1\n    \n    for i = 2:length(arr)\n        if arr[i] > largest\n        \
    \    largest = arr[i]\n            largestIndex = i\n        elseif arr[i] < smallest\n\
    \            smallest = arr[i]\n            smallestIndex = i\n        end\n \
    \   end\n    \n    if smallest == largest\n        return largest\n    end\n \
    \   \n    largestValue = arr[largestIndex]\n    smallestValue = arr[smallestIndex]\n\
    \    \n    if smallestValue % 2 == 0\n        return smallest\n    else\n    \
    \    return largest\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxu5zkyox.jl:63\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxu5zkyox.jl:63\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_value_index = arr.index(smallest_value)\n\
    \    return [smallest_value, smallest_value_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_8jlbgtw.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_8jlbgtw.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_even_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_even_value)[1]\n    \n    plucked_value = arr[smallest_index]\n\
    \    return Vector{Int64}([smallest_even_value,smallest_index])\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqnrvq31i.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqnrvq31i.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = Int64(0)\n    smallest = Int64(0)\n    largestIndex = 0\n  \
    \  smallestIndex = 0\n    for node in arr\n        if node % 2 == 0\n        \
    \    if node > largest\n                largest = node\n                largestIndex\
    \ = largestIndex + 1\n            elseif node < smallest\n                smallest\
    \ = node\n                smallestIndex = smallestIndex + 1\n        end\n   \
    \ end\n    return [smallest, smallestIndex]\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<text>\nProblem 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7x_2jla0.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7x_2jla0.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = minimum(arr)\n    smallest = maximum(arr)\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    \n    if length(evens) == 0\n        return []\n  \
    \  end\n    \n    smallest_even = minimum(evens)\n    smallest_index = index(evens,\
    \ smallest_even)\n    \n    if smallest_index == length(evens)\n        return\
    \ largest\n    end\n    \n    largest = arr[smallest_index]\n    \n    return\
    \ largest, smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj046_uk_.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj046_uk_.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2bufn59s.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2bufn59s.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpggusr2z1.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpggusr2z1.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpggusr2z1.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = Int64(0)\n    smallest_index\
    \ = -1\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value < node\n                smallest_value = node\n\
    \                smallest_index = length(arr)\n            end\n        end\n\
    \    end\n    if length(even_values) == 0\n        return Vector{Int64}()\n  \
    \  end\n    smallest_value_index = -1\n    for node in even_values\n        if\
    \ smallest_value_index == -1 || smallest_value < node\n            smallest_value_index\
    \ = node\n        end\n    end\n    return Vector{Int64}([smallest_value, smallest_value_index])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpevs3eg0b.jl:63\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n  \
    \ [2] pluck(::Array{Int64,1}) at /tmp/tmpevs3eg0b.jl:40\n   [3] top-level scope\
    \ at /tmp/tmpevs3eg0b.jl:63\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpevs3eg0b.jl:62\n  \ntest set: Error During\
    \ Test at /tmp/tmpevs3eg0b.jl:64\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpevs3eg0b.jl:40\n\
    \   [3] top-level scope at /tmp/tmpevs3eg0b.jl:64\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpevs3eg0b.jl:62\n  \ntest set: Error During\
    \ Test at /tmp/tmpevs3eg0b.jl:66\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpevs3eg0b.jl:40\n   [3] top-level scope at /tmp/tmpevs3eg0b.jl:66\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpevs3eg0b.jl:62\n  \ntest set: Error During\
    \ Test at /tmp/tmpevs3eg0b.jl:67\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stacktrace:\n   [1]\
    \ getproperty(::Set{Int64}, ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1})\
    \ at /tmp/tmpevs3eg0b.jl:40\n   [3] top-level scope at /tmp/tmpevs3eg0b.jl:67\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpevs3eg0b.jl:62\n  \ntest set: Error During\
    \ Test at /tmp/tmpevs3eg0b.jl:68\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpevs3eg0b.jl:40\n\
    \   [3] top-level scope at /tmp/tmpevs3eg0b.jl:68\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpevs3eg0b.jl:62\n  \ntest set: Error During\
    \ Test at /tmp/tmpevs3eg0b.jl:69\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  type Set has no field add\n  Stacktrace:\n   [1] getproperty(::Set{Int64},\
    \ ::Symbol) at ./Base.jl:33\n   [2] pluck(::Array{Int64,1}) at /tmp/tmpevs3eg0b.jl:40\n\
    \   [3] top-level scope at /tmp/tmpevs3eg0b.jl:69\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpevs3eg0b.jl:62\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpevs3eg0b.jl:60\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ \n    if smallest_index == nothing\n        return Vector{Int64}()\n    end\n\
    \    \n    \n    \n    \n    return Vector{Int64}([smallest_value, smallest_index])\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp83l7v5tx.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp83l7v5tx.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x->mod(x,2) == 0)\n    if isempty(even_values)\n\
    \        return [];\n    else\n        smallest_value = min(even_values)\n   \
    \     smallest_index = even_values.indexof(smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, \nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4jzfh0zj.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4jzfh0zj.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \        end\n    end\n    \n    if !isempty(even_values)\n        smallest_value\
    \ = min(even_values)\n        smallest_index = find(even_values == smallest_value)[1]\n\
    \    end\n    \n    if smallest_value == 0\n        return []\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp53qdyjsl.jl:57\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp53qdyjsl.jl:57\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even.sort()\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfz0n0itl.jl:89\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfz0n0itl.jl:89\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmph7l9yqin.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2]\
    \ top-level scope at /tmp/tmph7l9yqin.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:46\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:47\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:48\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:50\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:51\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmph7l9yqin.jl:52\n  Test threw exception\n  Expression: candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([])\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmph7l9yqin.jl:36\n   [2] top-level scope\
    \ at /tmp/tmph7l9yqin.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph7l9yqin.jl:44\n  \nTest Summary: | Error \
    \ Total\ntest set      |     8      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph7l9yqin.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2)==0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return [] \n    end\n    \n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpckrs1aj8.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpckrs1aj8.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp_jsodb7v.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Array{Int64,1})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at missing.jl:126\n    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any,\
    \ !Matched::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n\
    \  Stacktrace:\n   [1] pluck(::Array{Int64,1}) at /tmp/tmp_jsodb7v.jl:39\n   [2]\
    \ top-level scope at /tmp/tmp_jsodb7v.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_jsodb7v.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp_jsodb7v.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_jsodb7v.jl:39\n   [2] top-level scope\
    \ at /tmp/tmp_jsodb7v.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_jsodb7v.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp_jsodb7v.jl:52\n  Test threw exception\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_jsodb7v.jl:39\n   [2] top-level scope\
    \ at /tmp/tmp_jsodb7v.jl:52\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_jsodb7v.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp_jsodb7v.jl:53\n  Test threw exception\n  Expression: candidate([1,\
    \ 2, 3, 0, 5, 3]) == [0, 3]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_jsodb7v.jl:39\n   [2] top-level scope\
    \ at /tmp/tmp_jsodb7v.jl:53\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_jsodb7v.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp_jsodb7v.jl:54\n  Test threw exception\n  Expression: candidate([5,\
    \ 4, 8, 4, 8]) == [4, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_jsodb7v.jl:39\n   [2] top-level scope\
    \ at /tmp/tmp_jsodb7v.jl:54\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_jsodb7v.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp_jsodb7v.jl:55\n  Test threw exception\n  Expression: candidate([7,\
    \ 6, 7, 1]) == [6, 1]\n  MethodError: no method matching min(::Array{Int64,1})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at missing.jl:126\n\
    \    min(::Any, !Matched::Any) at operators.jl:422\n    min(::Any, !Matched::Any,\
    \ !Matched::Any, !Matched::Any...) at operators.jl:529\n    ...\n  Stacktrace:\n\
    \   [1] pluck(::Array{Int64,1}) at /tmp/tmp_jsodb7v.jl:39\n   [2] top-level scope\
    \ at /tmp/tmp_jsodb7v.jl:55\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_jsodb7v.jl:48\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      6      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_jsodb7v.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp755md0yj.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp755md0yj.jl:46\n"
  exit_code: 1
  status: Exception
