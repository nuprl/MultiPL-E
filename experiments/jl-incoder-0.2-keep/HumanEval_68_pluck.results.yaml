name: HumanEval_68_pluck
language: julia
results:
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == -1 || length(arr) == 0\n        return Vector{Int64}()\n    else\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcvpk456r.jl:45\nin expression starting at\
    \ /tmp/tmpcvpk456r.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    if even == []\n        return []\n    else\n     \
    \   return even\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpajsbq2ab.jl:44\nin expression starting at\
    \ /tmp/tmpajsbq2ab.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = arr[smallest_index]\n    \n    smallest_index = smallest_index\
    \ + 1\n    \n    smallest_value = arr[smallest_index]\n    \n    smallest_index\
    \ = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n    \n\
    \    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index + 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1sr_ozq3.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1sr_ozq3.jl:1\n\
    in expression starting at /tmp/tmp1sr_ozq3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = Int64(0)\n    smallest = Int64(0)\n    largestIndex = 0\n  \
    \  smallestIndex = 0\n    largestValue = Int64(0)\n    smallestValue = Int64(0)\n\
    \    largestEvenValue = Int64(0)\n    smallestEvenValue = Int64(0)\n    largestEvenIndex\
    \ = Int64(0)\n    smallestEvenIndex = Int64(0)\n    for node in arr\n        if\
    \ node.even\n            if node.value > largestValue\n                largestValue\
    \ = node.value\n                largestEvenValue = node.even\n               \
    \ largestEvenIndex = node.index\n            end\n            if node.value <\
    \ smallestValue\n                smallestValue = node.value\n                smallestEvenValue\
    \ = node.even\n                smallestEvenIndex = node.index\n            end\n\
    \        end\n    end\n    if largestEvenValue == 0\n        return []\n    else\n\
    \        return [largestEvenValue, largestEvenIndex]\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi7f3amuq.jl:70\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Int64 has no field even\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpi7f3amuq.jl:46\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi7f3amuq.jl:70 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi7f3amuq.jl:69\ntest set:\
    \ Error During Test at /tmp/tmpi7f3amuq.jl:71\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Int64 has no field even\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpi7f3amuq.jl:46\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi7f3amuq.jl:71 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi7f3amuq.jl:69\ntest set:\
    \ Error During Test at /tmp/tmpi7f3amuq.jl:73\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Int64 has no field even\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpi7f3amuq.jl:46\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi7f3amuq.jl:73 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi7f3amuq.jl:69\ntest set:\
    \ Error During Test at /tmp/tmpi7f3amuq.jl:74\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  type Int64 has no field e"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi7f3amuq.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,0,5]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,5,0,5,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,0,5,0,5]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,5,0,5,0,5,0]\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpau5or4au.jl:43\nin expression starting at\
    \ /tmp/tmpau5or4au.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = arr[smallest_index]\n    \n    return smallest_value, smallest_index\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiabht33_.jl:53\nin expression starting at\
    \ /tmp/tmpiabht33_.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy38mkn84.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy38mkn84.jl:1\n\
    in expression starting at /tmp/tmpy38mkn84.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = index(even_values, smallest_even_value)\n    if smallest_even_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_even_value,smallest_even_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 7: Given a binary tree, return the level order traversal of its\
    \ nodes' values. (i.e., the in-order traversal of its nodes' values.)\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0_ys0f26.jl:44\nin expression starting at\
    \ /tmp/tmp0_ys0f26.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ Vector{Int64}([smallest_value, smallest_index])\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\n4.3 Plucking Elements\
    \ from an Array\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzlxlg7fs.jl:44\nin expression starting at\
    \ /tmp/tmpzlxlg7fs.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    return\
    \ [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvf4eahj7.jl:43\nin expression starting at\
    \ /tmp/tmpvf4eahj7.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = unique(arr .% 2)\n    \n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return [] \n    end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpywa0wlzt.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpywa0wlzt.jl:1\n\
    in expression starting at /tmp/tmpywa0wlzt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    smallest_index = 2\n    for\
    \ index in 2:length(arr)\n        if arr[index] >= largest\n            largest\
    \ = arr[index]\n        elseif arr[index] < smallest && arr[index] % 2 == 0\n\
    \            smallest = arr[index]\n            smallest_index = index\n     \
    \   end\n    end\n    return smallest_index == 1 ? [smallest, smallest_index]\
    \ : []\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4hzo4mc9.jl:48\nin expression starting at\
    \ /tmp/tmp4hzo4mc9.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return Vector{Int64}([smallest_value,\
    \ index])\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven an array representing\
    \ a binary tree, return the number of nodes in the tree.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3uzb4qnu.jl:44\nin expression starting at\
    \ /tmp/tmp3uzb4qnu.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nProblem 7: Find all nodes\
    \ with value greater than a given value\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp44cuisep.jl:46\nin expression starting at\
    \ /tmp/tmp44cuisep.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    \n    smallest_even_value = minimum(even_values)\n\
    \    smallest_even_index = findfirst(x->x==smallest_even_value, even_values)\n\
    \    \n    return [smallest_even_value, smallest_even_index]\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptkqvmo43.jl:47\nin expression starting at\
    \ /tmp/tmptkqvmo43.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp_tctenw.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching min(::Vector{Int64})\\n  Closest candidates are:\\n    min(::Any,\
    \ !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\\\
    n    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\\\
    n    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp_tctenw.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpp_tctenw.jl:50 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpp_tctenw.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpp_tctenw.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching min(::Vector{Int64})\\\
    n  Closest candidates are:\\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\\\
    n    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\\\
    n    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp_tctenw.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpp_tctenw.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpp_tctenw.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpp_tctenw.jl:52\\n  Test threw exception\\n  Expression:\
    \ c"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = arr.index(node)\n            end\n        end\n\
    \    end\n    if !isempty(even_values)\n        smallest_value = min(even_values)\n\
    \        smallest_index = arr.index(smallest_value)\n    end\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2tb1nl9a.jl:53\nin expression starting at\
    \ /tmp/tmp2tb1nl9a.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice Problems\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmu4h7fjc.jl:45\nin expression starting at\
    \ /tmp/tmpmu4h7fjc.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = Int64(0)\n    smallest_index\
    \ = -1\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == 0\n                smallest_value = node\n \
    \               smallest_index = node\n            elseif node < smallest_value\n\
    \                smallest_value = node\n                smallest_index = node\n\
    \            end\n        end\n    end\n    if !even_values\n        return Vector{Int64}()\n\
    \    end\n    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    return smallest_value, smallest_index\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpdzoziru3.jl:62\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  type Set has no\
    \ field add\\n  Stacktrace:\\n   [1] getproperty\\n     @ ./Base.jl:42 [inlined]\\\
    n   [2] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpdzoziru3.jl:40\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpdzoziru3.jl:62 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpdzoziru3.jl:61\\ntest set:\
    \ Error During Test at /tmp/tmpdzoziru3.jl:63\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  type Set has no field add\\n  Stacktrace:\\\
    n   [1] getproperty\\n     @ ./Base.jl:42 [inlined]\\n   [2] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpdzoziru3.jl:40\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpdzoziru3.jl:63 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpdzoziru3.jl:61\\ntest set:\
    \ Error During Test at /tmp/tmpdzoziru3.jl:64\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\\n  MethodError: no method\
    \ matching !(::Set{Int64})\\n  Closest candidates are:\\n    !(!Matched::Function)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:1117\\n    !(!Matched::Bool)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/bool.jl:35\\n    !(!Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:101\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpdzoziru3.jl:50\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpdzoziru3.jl:64 [inlined]\\\
    n   [4] macro "
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = arr[smallest_index]\n    \n    return smallest_value, smallest_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgc9sde3u.jl:52\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching min(::Vector{Int64})\\n  Closest candidates are:\\n    min(::Any,\
    \ !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\\\
    n    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\\\
    n    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpgc9sde3u.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgc9sde3u.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgc9sde3u.jl:51\\ntest set:\
    \ Error During Test at /tmp/tmpgc9sde3u.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching min(::Vector{Int64})\\\
    n  Closest candidates are:\\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\\\
    n    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\\\
    n    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpgc9sde3u.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgc9sde3u.jl:53 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgc9sde3u.jl:51\\ntest set:\
    \ Error During Test at /tmp/tmpgc9sde3u.jl:54\\n  Test threw exception\\n  Expression:\
    \ c"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = node\n            end\n        end\n    end\n\
    \    \n    if !even_values\n        return Vector{Int64}[]\n    end\n    \n  \
    \  smallest_value_index = Set()\n    for node in even_values\n        if smallest_value\
    \ == node\n            smallest_value_index.add(smallest_index)\n        end\n\
    \    end\n    \n    return smallest_value_index\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmprvl6rupm.jl:68\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  type Set has no\
    \ field add\\n  Stacktrace:\\n   [1] getproperty\\n     @ ./Base.jl:42 [inlined]\\\
    n   [2] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmprvl6rupm.jl:42\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmprvl6rupm.jl:68 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmprvl6rupm.jl:67\\ntest set:\
    \ Error During Test at /tmp/tmprvl6rupm.jl:69\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  type Set has no field add\\n  Stacktrace:\\\
    n   [1] getproperty\\n     @ ./Base.jl:42 [inlined]\\n   [2] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmprvl6rupm.jl:42\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmprvl6rupm.jl:69 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmprvl6rupm.jl:67\\ntest set:\
    \ Error During Test at /tmp/tmprvl6rupm.jl:70\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\\n  MethodError: no method\
    \ matching !(::Set{Any})\\n  Closest candidates are:\\n    !(!Matched::Function)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:1117\\n    !(!Matched::Bool)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/bool.jl:35\\n    !(!Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:101\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmprvl6rupm.jl:50\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmprvl6rupm.jl:70 [inlined]\\\
    n   [4] macro ex"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptdu0p58i.jl:45\nin expression starting at\
    \ /tmp/tmptdu0p58i.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return Vector{Int64}([smallest_value, smallest_index])\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdj42an7m.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdj42an7m.jl:42\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdj42an7m.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdj42an7m.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpdj42an7m.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdj42an7m.jl:42\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdj42an7m.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdj42an7m.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpdj42an7m.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  Met"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdj42an7m.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2) == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x == smallest_value, even_values)\n    \n \
    \   if smallest_index == nothing\n        return Vector{Int64}()\n    end\n  \
    \  \n    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcp8l1q4p.jl:51\nin expression starting at\
    \ /tmp/tmpcp8l1q4p.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = length(arr)\n            end\n        end\n\
    \    end\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = min(even_values)\n    smallest_index = index(even_values,\
    \ smallest_value)\n    \n    return [ smallest_value, smallest_index ]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg0_hylv0.jl:64\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpg0_hylv0.jl:42\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpg0_hylv0.jl:64 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpg0_hylv0.jl:63\ntest set:\
    \ Error During Test at /tmp/tmpg0_hylv0.jl:65\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpg0_hylv0.jl:42\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpg0_hylv0.jl:65 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpg0_hylv0.jl:63\ntest set:\
    \ Error During Test at /tmp/tmpg0_hylv0.jl:67\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpg0_hylv0.jl:42\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpg0_hylv0.jl:67 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpg0_hylv0.jl:63\ntest set:\
    \ Error During Test at /tmp/tmpg0_hylv0.jl:68\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stackt"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg0_hylv0.jl:61\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2)==0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}[]\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvaii07rv.jl:46\nin expression starting at\
    \ /tmp/tmpvaii07rv.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnbxs42bf.jl:44\nin expression starting at\
    \ /tmp/tmpnbxs42bf.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even? \n            push!(even_values,\
    \ node.value)\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = node\n            end\n     \
    \   end\n    end\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    \n    return [ smallest_value, smallest_index ]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp23q3vb8m.jl:41\nin expression starting at\
    \ /tmp/tmp23q3vb8m.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \        return [ smallest_even_value, smallest_even_index ]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkw_tmc7k.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkw_tmc7k.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkw_tmc7k.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkw_tmc7k.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpkw_tmc7k.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkw_tmc7k.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkw_tmc7k.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkw_tmc7k.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpkw_tmc7k.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  Met"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkw_tmc7k.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = find(even_values == smallest_even_value)[0]\n\
    \    return smallest_even_value,smallest_index\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppywoxm6l.jl:40\nin expression starting at\
    \ /tmp/tmppywoxm6l.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = 1\n    smallestIndex\
    \ = 1\n    for node in arr[2:end]\n        if node < smallest \n            smallest\
    \ = node\n            smallestIndex = largestIndex\n        elseif node > largest\n\
    \            largest = node\n            largestIndex = smallestIndex\n      \
    \  else\n            smallestIndex = smallestIndex + 1\n        end\n    end\n\
    \    return [ smallest, smallestIndex ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpem9a6kky.jl:52\nin expression starting at\
    \ /tmp/tmpem9a6kky.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -1\n    smallest_index = 0\n\
    \    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    return smallest_value, smallest_index\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcpqi7qo9.jl:39\nin expression starting at\
    \ /tmp/tmpcpqi7qo9.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6__9onoq.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6__9onoq.jl:1\n\
    in expression starting at /tmp/tmp6__9onoq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -1\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == -1 || node < smallest_value\n              \
    \  smallest_value = node\n                smallest_index = length(arr)\n     \
    \       end\n        end\n    end\n    \n    if length(even_values) == 0\n   \
    \     return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    return [ smallest_value,\
    \ smallest_index ]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu93jqdmz.jl:64\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpu93jqdmz.jl:42\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpu93jqdmz.jl:64 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpu93jqdmz.jl:63\ntest set:\
    \ Error During Test at /tmp/tmpu93jqdmz.jl:65\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpu93jqdmz.jl:42\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpu93jqdmz.jl:65 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpu93jqdmz.jl:63\ntest set:\
    \ Error During Test at /tmp/tmpu93jqdmz.jl:67\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpu93jqdmz.jl:42\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpu93jqdmz.jl:67 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpu93jqdmz.jl:63\ntest set:\
    \ Error During Test at /tmp/tmpu93jqdmz.jl:68\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stackt"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu93jqdmz.jl:61\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 4\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmubyy8do.jl:45\nin expression starting at\
    \ /tmp/tmpmubyy8do.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    return smallest_value, smallest_even_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2iod46ze.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp2iod46ze.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2iod46ze.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2iod46ze.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp2iod46ze.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp2iod46ze.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2iod46ze.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2iod46ze.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp2iod46ze.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2iod46ze.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ Vector{Int64}([smallest_value, smallest_index])\n    end\nend\n</cell>\n<text>\n\
    Solution\nLet's see how we could solve this problem using Julia.\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp41k6o8d2.jl:45\nin expression starting at\
    \ /tmp/tmp41k6o8d2.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdm5yphoe.jl:44\nin expression starting at\
    \ /tmp/tmpdm5yphoe.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpd4h1ktm2.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpd4h1ktm2.jl:1\n\
    in expression starting at /tmp/tmpd4h1ktm2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        index = find(even_values == smallest_even_value)[1]\n\
    \        return [ smallest_even_value, index ]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0870ffim.jl:44\nin expression starting at\
    \ /tmp/tmp0870ffim.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpa838sqwt.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa838sqwt.jl:1\n\
    in expression starting at /tmp/tmpa838sqwt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp7_yx8d6.jl:45\nin expression starting at\
    \ /tmp/tmpp7_yx8d6.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value = arr[smallest_index]\n    \n    return Vector{Int64}([smallest_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptj2c60gx.jl:53\nin expression starting at\
    \ /tmp/tmptj2c60gx.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpns_2x65d.jl:43\nin expression starting at\
    \ /tmp/tmpns_2x65d.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfdyw32be.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfdyw32be.jl:1\n\
    in expression starting at /tmp/tmpfdyw32be.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr).-arr\n    even_values = sort(even_values)\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    \    even_values = even_values[even_values..end]\n    even_values = even_values[even_values..end]\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmph30t2o8f.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmph30t2o8f.jl:1\n\
    in expression starting at /tmp/tmph30t2o8f.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppi9iv115.jl:44\nin expression starting at\
    \ /tmp/tmppi9iv115.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf\n    smallest_index\
    \ = 0\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = i\n        end\n    end\n    if !isempty(even_values)\n\
    \        smallest_value = min(even_values)\n        smallest_index = find(even_values\
    \ == smallest_value)[1]\n    end\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgcgtp3ur.jl:53\nin expression starting at\
    \ /tmp/tmpgcgtp3ur.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp75y88jgd.jl:45\nin expression starting at\
    \ /tmp/tmp75y88jgd.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1, 2, 3, 4]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3, 4, 5, 6]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,\
    \ 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1, 2, 3, 4, 5, 6, 7]\n\
    </cell>\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7tkq3syt.jl:45\nin expression starting at\
    \ /tmp/tmp7tkq3syt.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [];\n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp9smjzqb.jl:43\nin expression starting at\
    \ /tmp/tmpp9smjzqb.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpizq8wkkf.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Array has no field filter\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpizq8wkkf.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpizq8wkkf.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpizq8wkkf.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpizq8wkkf.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpizq8wkkf.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpizq8wkkf.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpizq8wkkf.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpizq8wkkf.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  type Array has no field\
    \ filter\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n \
    \  [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpizq8wkkf.jl:35\n   [3] macro\
    \ expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpizq8wkkf.jl:50 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpizq8wkkf.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpizq8wkkf.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Arra"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpizq8wkkf.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    return smallest_value, smallest_value_index\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8nywduio.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8nywduio.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8nywduio.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8nywduio.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp8nywduio.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8nywduio.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8nywduio.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8nywduio.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp8nywduio.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8nywduio.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even.sort()\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n    even.push(0)\n\
    \    even.push(0)\n    even.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpdgtoiauh.jl:34 expected\
    \ \"end\", got \"Test\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdgtoiauh.jl:120\n\
    in expression starting at /tmp/tmpdgtoiauh.jl:120\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=juli\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprt6sf0td.jl:43\nin expression starting at\
    \ /tmp/tmprt6sf0td.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\
    \ || length(arr) == 0 \n        return [] \n    end\n    \n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbssmneki.jl:45\nin expression starting at\
    \ /tmp/tmpbssmneki.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_value_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9lvw64bp.jl:41\nin expression starting at\
    \ /tmp/tmp9lvw64bp.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpety3r09z.jl:40\nin expression starting at\
    \ /tmp/tmpety3r09z.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n  \
    \  end\n    \n    smallest_value = smallest_value.value\n    smallest_index =\
    \ smallest_index.value\n    \n    even_values = Set()\n    \n    for node in arr\n\
    \        if node.even?\n            even_values.add(node.value)\n        end\n\
    \    end\n    \n    if !even_values\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = smallest_value.value\n    smallest_index = smallest_index.value\n\
    \    \n    even_values = Set()\n    \n    for node in arr\n        if node.even?\n\
    \            even_values.add(node.value)\n        end\n    end\n    \n    if !even_values\n\
    \        return Vector{Int64}()\n    end\n    \n    smallest_value = smallest_value.value\n\
    \    smallest_index = smallest_index.value\n    \n    even_values = Set()\n  \
    \  \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \        end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = smallest_value.value\n    smallest_index\
    \ = smallest_index.value\n    \n    even_values = Set()\n    \n    for node in\
    \ arr\n        if node.even?\n            even_values.add(node.value)\n      \
    \  end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n \
    \   end\n    \n    smallest_value = smallest_value.value\n    smallest_index =\
    \ smallest_index.value\n    \n    even_values = Set()\n    \n    for node in arr\n\
    \        if node.even?\n            even_values.add(node.value)\n        end\n\
    \    end\n    \n    if !even_values\n        return Vector{Int64}()\n    end\n\
    \    \n    smallest_value = smallest_value.value\n    smallest_index = smallest_index.value\n\
    \    \n    even_values = Set()\n    \n    for node in arr\n        if node.even?\n\
    \            even_values.add(node.value)\n        end\n    end\n    \n    if !even_values\n\
    \        return Vector{Int64}()\n    end\n    \n    smallest_value = smallest_value.value\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj_aqvhcs.jl:41\nin expression starting at\
    \ /tmp/tmpj_aqvhcs.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return smallest_value, smallest_index\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1,0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,2,3,0,4,2,1,0,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1,0,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0,1,0,1,0,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,1,0,1,0,1,0,1,0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj215aybl.jl:46\nin expression starting at\
    \ /tmp/tmpj215aybl.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n  \
    \  end\n    \n    smallest_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_value)[1]\n    \n    return [ smallest_value, smallest_index ]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp31q398gi.jl:41\nin expression starting at\
    \ /tmp/tmp31q398gi.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_index = smallest_even_index\n\
    \    \n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n    smallest_value_index\
    \ = 0\n    smallest_value_index = 0\n    smallest_value_index = 0\n\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8popwjxf.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8popwjxf.jl:1\n\
    in expression starting at /tmp/tmp8popwjxf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    if length(even_values) == 0\n     \
    \   return Vector{Int64}[]\n    else\n        smallest_value = even_values[1]\n\
    \        smallest_index = 1\n        for value in even_values\n            if\
    \ value < smallest_value\n                smallest_value = value\n           \
    \     smallest_index = index(value)\n            end\n        end\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd8d7ik7z.jl:52\nin expression starting at\
    \ /tmp/tmpd8d7ik7z.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if isempty(even_values)\n\
    \        return [];\n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=juli\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmc7exgr2.jl:43\nin expression starting at\
    \ /tmp/tmpmc7exgr2.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptppb1ew9.jl:40\nin expression starting at\
    \ /tmp/tmptppb1ew9.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index =\
    \ -1\n    \n    for node in arr\n        if node.even\n            push!(even_values,\
    \ node.value)\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = i\n            end\n        end\n\
    \    end\n    \n    if !isempty(even_values)\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n    end\n  \
    \  \n    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbh5zj5uv.jl:56\nin expression starting at\
    \ /tmp/tmpbh5zj5uv.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps_vep7aw.jl:45\nin expression starting at\
    \ /tmp/tmps_vep7aw.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpib8glbxr.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpib8glbxr.jl:1\n\
    in expression starting at /tmp/tmpib8glbxr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp97usacqo.jl:43\nin expression starting at\
    \ /tmp/tmp97usacqo.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9iiejpwe.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp9iiejpwe.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9iiejpwe.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9iiejpwe.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp9iiejpwe.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp9iiejpwe.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9iiejpwe.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9iiejpwe.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp9iiejpwe.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9iiejpwe.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    if smallest_index == nothing\n        return []\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 4\n\
    Given a binary tree, return the level order traversal of its nodes' values.\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxz9sq4h5.jl:45\nin expression starting at\
    \ /tmp/tmpxz9sq4h5.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6ik42fob.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6ik42fob.jl:1\n\
    in expression starting at /tmp/tmp6ik42fob.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpl6vk8iof.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl6vk8iof.jl:1\n\
    in expression starting at /tmp/tmpl6vk8iof.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if node < smallest_value\n                smallest_value = node\n\
    \                smallest_index = index\n            end\n        end\n    end\n\
    \    if length(even_values) == 0\n        return Vector{Int64}()\n    end\n  \
    \  smallest_value = min(even_values)\n    smallest_index = index(smallest_value)\n\
    \    return [ smallest_value, smallest_index ]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp9g2gzhfe.jl:59\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp9g2gzhfe.jl:40\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp9g2gzhfe.jl:59 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp9g2gzhfe.jl:58\ntest set:\
    \ Error During Test at /tmp/tmp9g2gzhfe.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp9g2gzhfe.jl:40\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp9g2gzhfe.jl:60 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp9g2gzhfe.jl:58\ntest set:\
    \ Error During Test at /tmp/tmp9g2gzhfe.jl:62\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp9g2gzhfe.jl:40\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp9g2gzhfe.jl:62 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp9g2gzhfe.jl:58\ntest set:\
    \ Error During Test at /tmp/tmp9g2gzhfe.jl:63\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stackt"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9g2gzhfe.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = Int64(0)\n    smallest_index\
    \ = -1\n    smallest_even_value = Int64(0)\n    \n    for node in arr\n      \
    \  if node.even?\n            even_values.add(node.value)\n            if node.value\
    \ < smallest_value\n                smallest_value = node.value\n            \
    \    smallest_index = node\n            elseif node.value == smallest_value\n\
    \                if node.index < smallest_index\n                    smallest_value\
    \ = node.value\n                    smallest_index = node\n                end\n\
    \            end\n        else\n            if node.value < smallest_even_value\n\
    \                smallest_even_value = node.value\n            end\n        end\n\
    \    end\n    \n    if !even_values.empty?\n        smallest_value = smallest_value\
    \ + 1\n        smallest_index = smallest_index + 1\n    end\n    \n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptzs2n7tv.jl:41\nin expression starting at\
    \ /tmp/tmptzs2n7tv.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\narr = [4,2,3]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n\
    </cell>\n<code language=julia-1.4>\narr = [1,2,3]\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = []\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n\
    <code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n\
    </cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n\
    <code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.4>\npluck(arr)\n</cell>\n<code language=julia-1.4>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.4>\npluck(arr)\n\
    </cell>\n<code language=julia-1.4>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.4>\npluck(arr)\n</cell>\n\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpepk4uqgl.jl:45\nin expression starting at\
    \ /tmp/tmpepk4uqgl.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\nProblem 3\n\
    Given a binary tree, return the level order traversal of its nodes' values. (ie,\
    \ from left to right, level by level).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd8_dse57.jl:46\nin expression starting at\
    \ /tmp/tmpd8_dse57.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1b4g524s.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1b4g524s.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1b4g524s.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1b4g524s.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp1b4g524s.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1b4g524s.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1b4g524s.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1b4g524s.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp1b4g524s.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1b4g524s.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3i3zp9fu.jl:47\nin expression starting at\
    \ /tmp/tmp3i3zp9fu.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1lhgsdan.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1lhgsdan.jl:1\n\
    in expression starting at /tmp/tmp1lhgsdan.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = unique(even)\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_r29rsgg.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_r29rsgg.jl:1\n\
    in expression starting at /tmp/tmp_r29rsgg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, \nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3j5crcw1.jl:45\nin expression starting at\
    \ /tmp/tmp3j5crcw1.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nProblem 3\nGiven a binary\
    \ tree, return the level order traversal of its nodes' values. (i.e., the in-order\
    \ traversal of its nodes' values.)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjtz2svzx.jl:46\nin expression starting at\
    \ /tmp/tmpjtz2svzx.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    \n    smallest_index = findfirst(x->x==smallest_value, even_values)\n   \
    \ \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpre5j_rwv.jl:48\nin expression starting at\
    \ /tmp/tmpre5j_rwv.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd5xq7zgb.jl:82\nin expression starting at\
    \ /tmp/tmpd5xq7zgb.jl:82\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    plucked_value = arr[smallest_index]\n    \n    return Vector{Int64}([plucked_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nGiven a binary tree, return the level order traversal of its\
    \ nodes' values.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph7lfib57.jl:48\nin expression starting at\
    \ /tmp/tmph7lfib57.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    smallest_value::Int64 = arr[1]\n    smallest_index::Int64 = 1\n\
    \    \n    for index in 2:length(arr)\n        if arr[index] % 2 == 0\n      \
    \      if smallest_value < arr[index]\n                smallest_value = arr[index]\n\
    \                smallest_index = index\n            end\n        end\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0,5]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,5,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,5,0,5]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,2,3,0,4,2,1,0,5,0,5,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,2,3,0,4,2,1,0,5,0,5,0,5]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,2,3,0,4,2,1,0,5,0,5,0,5,0]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyhlp5vl4.jl:50\nin expression starting at\
    \ /tmp/tmpyhlp5vl4.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6akmr64z.jl:40\nin expression starting at\
    \ /tmp/tmp6akmr64z.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = findall(x -> mod(x,2) == 0, arr)\n    \n    if isempty(even_values)\
    \ \n        return []\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=juli\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjuirha_v.jl:47\nin expression starting at\
    \ /tmp/tmpjuirha_v.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    if length(even_values) == 0\n     \
    \   return Vector{Int64}()\n    else\n        smallest_value = even_values[1]\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjzyxl3l0.jl:46\nin expression starting at\
    \ /tmp/tmpjzyxl3l0.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnwjgmjk1.jl:82\nin expression starting at\
    \ /tmp/tmpnwjgmjk1.jl:82\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = minimum(even_values)\n\
    \        smallest_index = findfirst(x -> x == smallest_value, even_values)\n \
    \       return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven an array\
    \ representing a branch of a tree that has non-negative integer nodes\nyour task\
    \ is to pluck one of the nodes and return it.\nThe plucked node should be the\
    \ node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpquq1zyp6.jl:46\nin expression starting at\
    \ /tmp/tmpquq1zyp6.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [ smallest_value, smallest_index ]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprxj0tobq.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprxj0tobq.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprxj0tobq.jl:51\ntest set: Test\
    \ Failed at /tmp/tmprxj0tobq.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprxj0tobq.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprxj0tobq.jl:51\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprxj0tobq.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = Int64(0)\n    smallest = Int64(0)\n    largestIndex = Int64(0)\n\
    \    smallestIndex = Int64(0)\n    largestEven = Int64(0)\n    smallestEven =\
    \ Int64(0)\n    largestEvenIndex = Int64(0)\n    smallestEvenIndex = Int64(0)\n\
    \    largestEvenValue = Int64(0)\n    smallestEvenValue = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    smallestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int64(0)\n    largestEvenValueIndex = Int64(0)\n    largestEvenValueIndex\
    \ = Int\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjsdoj99o.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjsdoj99o.jl:1\n\
    in expression starting at /tmp/tmpjsdoj99o.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp79amxydp.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp79amxydp.jl:1\n\
    in expression starting at /tmp/tmp79amxydp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index += 1\n    \n    return smallest_value, smallest_index\nend\n\
    </cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7gcggh00.jl:48\nin expression starting at\
    \ /tmp/tmp7gcggh00.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpup2opl95.jl:44\nin expression starting at\
    \ /tmp/tmpup2opl95.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    return smallest_even_value,smallest_even_index\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp4w28vasy.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4w28vasy.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4w28vasy.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4w28vasy.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp4w28vasy.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4w28vasy.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4w28vasy.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4w28vasy.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp4w28vasy.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4w28vasy.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0,\
    \ 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0,\
    \ 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0,\
    \ 7, 8, 0, 9, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4, 2, 3, 0, 5, 1, 6, 0, 7, 8, 0, 9, 0]\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcxtog73b.jl:44\nin expression starting at\
    \ /tmp/tmpcxtog73b.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [ smallest_value, smallest_index ]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp9kvkqfn.jl:44\nin expression starting at\
    \ /tmp/tmpp9kvkqfn.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nGiven a binary tree, return the level order traversal of its nodes'\
    \ values. (ie, from left to right, level by level).\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2i4blaae.jl:45\nin expression starting at\
    \ /tmp/tmp2i4blaae.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    smallest_index = smallest_index - 1\n    \n    \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4dc4ma1w.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4dc4ma1w.jl:1\n\
    in expression starting at /tmp/tmp4dc4ma1w.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n    \n    \n    return [ smallest_even_value, smallest_index ]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0m4jqyyw.jl:46\nin expression starting at\
    \ /tmp/tmp0m4jqyyw.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = index(even_values, smallest_value)\n        return [\
    \ smallest_value, smallest_index ]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpgdx9b0p3.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgdx9b0p3.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgdx9b0p3.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgdx9b0p3.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpgdx9b0p3.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgdx9b0p3.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgdx9b0p3.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgdx9b0p3.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpgdx9b0p3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  Met"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgdx9b0p3.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = index(even_values, smallest_even_value)\n\
    \    \n    if smallest_even_index == -1 || length(even_values) == 0\n        return\
    \ Vector{Int64}()\n    else\n        return [smallest_even_value,smallest_even_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprzqelhou.jl:45\nin expression starting at\
    \ /tmp/tmprzqelhou.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = findfirst(x->x==smallest_value, even_values)\n     \
    \   return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven a binary\
    \ tree and a node value, swap the node value with the node that results from traveling\
    \ down the tree starting from the given node. \nIf the given node has no children,\
    \ return the node unchanged.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6vi05why.jl:46\nin expression starting at\
    \ /tmp/tmp6vi05why.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpij9io9u0.jl:43\nin expression starting at\
    \ /tmp/tmpij9io9u0.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpauwr3ur7.jl:40\nin expression starting at\
    \ /tmp/tmpauwr3ur7.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = Int64(Inf)\n    smallest_index\
    \ = -1\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == Int64(Inf)\n                smallest_value =\
    \ node\n                smallest_index = -1\n            elseif node < smallest_value\n\
    \                smallest_value = node\n                smallest_index = -1\n\
    \            elseif node < smallest_value\n                smallest_index = smallest_index\
    \ + 1\n            end\n        end\n    end\n    \n    if smallest_value == Int64(Inf)\n\
    \        smallest_value = -1\n        smallest_index = -1\n    end\n    \n   \
    \ return smallest_value, smallest_index\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp110mofus.jl:67\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(x::Float64)\n     @ Base ./float.jl:812\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp110mofus.jl:37\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp110mofus.jl:67 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp110mofus.jl:66\ntest set:\
    \ Error During Test at /tmp/tmp110mofus.jl:68\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(x::Float64)\n     @ Base ./float.jl:812\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp110mofus.jl:37\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp110mofus.jl:68 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp110mofus.jl:66\ntest set:\
    \ Error During Test at /tmp/tmp110mofus.jl:69\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  InexactError: Int64(Inf)\n\
    \  Stacktrace:\n   [1] Int64(x::Float64)\n     @ Base ./float.jl:812\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp110mofus.jl:37\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp110mofus.jl:69 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp110mofus.jl:66\ntest set:\
    \ Error During Test at /tmp/tmp110mofus.jl:70\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  InexactError: Int6"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp110mofus.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp62hp9ny3.jl:45\nin expression starting at\
    \ /tmp/tmp62hp9ny3.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_even_value, even_values)\n    return\
    \ Vector{Int64}([smallest_even_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2xo0v8jp.jl:43\nin expression starting at\
    \ /tmp/tmp2xo0v8jp.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcgos338n.jl:44\nin expression starting at\
    \ /tmp/tmpcgos338n.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ return [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpk46dlzfq.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46dlzfq.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46dlzfq.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpk46dlzfq.jl:53\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk46dlzfq.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk46dlzfq.jl:48\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk46dlzfq.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \n    smallest_value = arr[smallest_index]\n\
    \    \n    smallest_index = smallest_index - 1\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxk59wgr1.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxk59wgr1.jl:1\n\
    in expression starting at /tmp/tmpxk59wgr1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp29we83_i.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp29we83_i.jl:1\n\
    in expression starting at /tmp/tmp29we83_i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = find(even_values == smallest_even_value)[1]\n\
    \        return [smallest_even_value, smallest_even_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphdyb0qtw.jl:45\nin expression starting at\
    \ /tmp/tmphdyb0qtw.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgw79r3lr.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgw79r3lr.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgw79r3lr.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgw79r3lr.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpgw79r3lr.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgw79r3lr.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgw79r3lr.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgw79r3lr.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpgw79r3lr.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgw79r3lr.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    if\
    \ smallest_index == nothing\n        return Vector{Int64}()\n    end\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqu9cgrqj.jl:46\nin expression starting at\
    \ /tmp/tmpqu9cgrqj.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        smallest_index = []\n    end\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprx0yyzkx.jl:43\nin expression starting at\
    \ /tmp/tmprx0yyzkx.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    if smallest_index\
    \ == -1 || length(even_values) == 0\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven a binary\
    \ tree, return the levels of the tree in order from top to bottom.\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpucrjynse.jl:45\nin expression starting at\
    \ /tmp/tmpucrjynse.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 0]\n</cell\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz5f6f04m.jl:40\nin expression starting at\
    \ /tmp/tmpz5f6f04m.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = -1\n    smallestIndex\
    \ = -1\n    for index in 2:length(arr)\n        if arr[index] >= largest\n   \
    \         largest = arr[index]\n            largestIndex = index\n        elseif\
    \ arr[index] < smallest\n            smallest = arr[index]\n            smallestIndex\
    \ = index\n        end\n    end\n    \n    if largestIndex == -1\n        return\
    \ Vector{Int64}[]\n    end\n    \n    if smallestIndex == -1\n        return [largest,\
    \ largestIndex]\n    end\n    \n    if arr[largestIndex] == smallest\n       \
    \ return [largest, largestIndex]\n    end\n    \n    if arr[largestIndex] > smallest\n\
    \        return [largest, largestIndex]\n    end\n    \n    return [smallest,\
    \ smallestIndex]\nend\n</cell>\n<code language=julia-1.5>\narr = [4, 2, 3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1, 2, 3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 1, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_6vsb4qv.jl:67\nin expression starting at\
    \ /tmp/tmp_6vsb4qv.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1,2,0,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz0bknhjk.jl:40\nin expression starting at\
    \ /tmp/tmpz0bknhjk.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -1\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if even_values == Set()\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value_index = find(even_values, smallest_value)\n\
    \    \n    if smallest_value_index == nothing\n        return Vector{Int64}()\n\
    \    end\n    \n    return [smallest_value, smallest_value_index]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=juli\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8zuifyxk.jl:41\nin expression starting at\
    \ /tmp/tmp8zuifyxk.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwumzeu3a.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpwumzeu3a.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwumzeu3a.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwumzeu3a.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpwumzeu3a.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpwumzeu3a.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwumzeu3a.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwumzeu3a.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpwumzeu3a.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwumzeu3a.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2jgz1byx.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp2jgz1byx.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2jgz1byx.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2jgz1byx.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp2jgz1byx.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp2jgz1byx.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2jgz1byx.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2jgz1byx.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp2jgz1byx.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2jgz1byx.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even = sort(even)\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:end]\n    even =\
    \ even[even.first:end]\n    even = even[even.first:end]\n    even = even[even.first:end]\n\
    \    even = even[even.first:end]\n    even = even[even.first:\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb_448fp3.jl:82\nin expression starting at\
    \ /tmp/tmpb_448fp3.jl:82\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    end\n    \n    return Vector{Int64}([smallest_value,\
    \ smallest_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppdbyfnp6.jl:47\nin expression starting at\
    \ /tmp/tmppdbyfnp6.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2pc0ig31.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2pc0ig31.jl:1\n\
    in expression starting at /tmp/tmp2pc0ig31.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = index(even_values, smallest_even_value)\n    return\
    \ [smallest_even_value, smallest_even_index]\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_zc23r_t.jl:43\nin expression starting at\
    \ /tmp/tmp_zc23r_t.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nProblem 3\nGiven an array representing a binary tree, return the number\
    \ of nodes in the tree.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwh1423x3.jl:40\nin expression starting at\
    \ /tmp/tmpwh1423x3.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_value_index = find(even_values == smallest_value)[1]\n    \n   \
    \ smallest_value_index = smallest_value_index == length(even_values) ? 1 : smallest_value_index\n\
    \    \n    plucked_value = arr[smallest_value_index]\n    \n    return Vector{Int64}([plucked_value,\
    \ smallest_value_index])\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 6, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3sgspk0f.jl:51\nin expression starting at\
    \ /tmp/tmp3sgspk0f.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqiyaq7sl.jl:46\nin expression starting at\
    \ /tmp/tmpqiyaq7sl.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    if smallest_index\
    \ == -1\n        return []\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level\
    \ order traversal of its nodes' values. (ie, from left to right, level by level).\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpswl2ocpi.jl:44\nin expression starting at\
    \ /tmp/tmpswl2ocpi.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_value_index = arr.index(smallest_value)\n\
    \    return [smallest_value, smallest_value_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpb23a50p1.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpb23a50p1.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb23a50p1.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb23a50p1.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpb23a50p1.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpb23a50p1.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb23a50p1.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb23a50p1.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpb23a50p1.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb23a50p1.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    end\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbmwxa40r.jl:46\nin expression starting at\
    \ /tmp/tmpbmwxa40r.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(even_values)\n \
    \   even_values = even_values[2:end]\n    even_values = unique(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = sort(\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5t7p_kwu.jl:91\nin expression starting at\
    \ /tmp/tmp5t7p_kwu.jl:91\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpglpru2s3.jl:40\nin expression starting at\
    \ /tmp/tmpglpru2s3.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    if smallest_index\
    \ == length(even_values)\n        return Vector{Int64}()\n    else\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=juli\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5a38nz40.jl:44\nin expression starting at\
    \ /tmp/tmp5a38nz40.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_index = find(x -> x == smallest_even_value, even_values)\n\
    \    if smallest_index == -1 || smallest_index == length(even_values)\n      \
    \  return Vector{Int64}()\n    else\n        return [smallest_even_value, smallest_index]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpslszb3tr.jl:44\nin expression starting at\
    \ /tmp/tmpslszb3tr.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = findfirst(x -> x % 2 == 0, arr)\n    if even != nothing\n     \
    \   smalest_value = arr[even]\n        smalest_index = even\n        \n      \
    \  for i in arr[even+1:end]\n            if i % 2 == 0\n                if smalest_value\
    \ < i\n                    smalest_value = i\n                    smalest_index\
    \ = i\n                end\n            end\n        end\n        \n        return\
    \ [smalest_value, smalest_index]\n    else\n        return []\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptsf2brbb.jl:54\nin expression starting at\
    \ /tmp/tmptsf2brbb.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    smallest_index = 2\n    largest_index\
    \ = 1 \n    \n    for index in 2:length(arr)\n        if arr[index] >= largest\n\
    \            largest = arr[index]\n            largest_index = index\n       \
    \ elseif arr[index] < smallest\n            smallest = arr[index]\n          \
    \  smallest_index = index\n        end\n    end\n    \n    if smallest == largest\n\
    \        return smallest_index\n    else\n        return [smallest, smallest_index]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0vi61csq.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0vi61csq.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0vi61csq.jl:60\ntest set: Test\
    \ Failed at /tmp/tmp0vi61csq.jl:62\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0vi61csq.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0vi61csq.jl:60\ntest set: Error\
    \ During Test at /tmp/tmp0vi61csq.jl:63\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp0vi61csq.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0vi61csq.jl:63 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0vi61csq.jl:60\ntest set:\
    \ Test Failed at /tmp/tmp0vi61csq.jl:64\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0vi61csq.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0vi61csq.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt0a3q4cz.jl:40\nin expression starting at\
    \ /tmp/tmpt0a3q4cz.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_index = smallest_even_index\n\
    \    \n    if length(even_values) == 0\n        return Vector{Int64}()\n    elseif\
    \ length(even_values) == 1\n        return [smallest_value, smallest_index]\n\
    \    else\n        smallest_value = arr[smallest_even_index]\n        smallest_index\
    \ = smallest_even_index\n        \n        for index in 1:length(arr)\n      \
    \      if arr[index] == smallest_value\n                smallest_value = arr[index]\n\
    \                smallest_index = index\n            end\n        end\n      \
    \  return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy1u6ofq_.jl:58\nin expression starting at\
    \ /tmp/tmpy1u6ofq_.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2) == 0, arr)\n    if length(even_values)\
    \ == 0\n        return []\n    else\n        smallest_even_value = min(even_values)\n\
    \        smallest_even_index = findfirst(x->mod(x,2) == 0, even_values)\n    \
    \    return [smallest_even_value,smallest_even_index]\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\narr = [4,2,3]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = []\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <text>\nPractice 3\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcg2p2ryv.jl:44\nin expression starting at\
    \ /tmp/tmpcg2p2ryv.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp90dwkrk9.jl:46\nin expression starting at\
    \ /tmp/tmp90dwkrk9.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_even_value\
    \ = minimum(even_values)\n    smallest_index = find(even_values == smallest_even_value)\
    \ \n    \n    if smallest_index == length(even_values)\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value = arr[smallest_index]\n    \n    index_of_smallest_value\
    \ = find(arr == smallest_value)\n    \n    return [smallest_value, index_of_smallest_value]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp99os_zgi.jl:54\nin expression starting at\
    \ /tmp/tmp99os_zgi.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = -Inf\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node.even\n            push!(even_values,\
    \ node.value)\n            if node.value < smallest_value\n                smallest_value\
    \ = node.value\n                smallest_index = node\n            end\n     \
    \   end\n    end\n    \n    if length(even_values) == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    smallest_value_index = find(even_values, smallest_value)\n\
    \    \n    if smallest_value_index == length(even_values)\n        return Vector{Int64}()\n\
    \    end\n    \n    return [ smallest_value, smallest_value_index ]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=juli\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9y7mc6l9.jl:62\nin expression starting at\
    \ /tmp/tmp9y7mc6l9.jl:62\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxewv9rt0.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxewv9rt0.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxewv9rt0.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxewv9rt0.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpxewv9rt0.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxewv9rt0.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxewv9rt0.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxewv9rt0.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpxewv9rt0.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxewv9rt0.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = 1\n    smallestIndex\
    \ = 1\n    for node in arr[2:end]\n        if node < smallest \n            smallest\
    \ = node\n            smallestIndex = largestIndex\n        elseif node > largest\n\
    \            largest = node\n            largestIndex = smallestIndex\n      \
    \  elseif smallestIndex == largestIndex\n            smallestIndex = smallestIndex\
    \ + 1\n        end\n    end\n    return [ smallest, smallestIndex ]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 6, 0, 3, 0, 4, 2]\n</cell>\n<code\
    \ language=julia-1.5\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpduzhxgm7.jl:52\nin expression starting at\
    \ /tmp/tmpduzhxgm7.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return [] \n    end\n    smallest_value = min(even_values)\n    smallest_index\
    \ = find(even_values == smallest_value)[1]\n    return [smallest_value, smallest_index]\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    arr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=juli\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpho0w43o3.jl:43\nin expression starting at\
    \ /tmp/tmpho0w43o3.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphe7ghak8.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphe7ghak8.jl:1\n\
    in expression starting at /tmp/tmphe7ghak8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    return smallest_value, smallest_value_index\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, \nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplhyssyjg.jl:41\nin expression starting at\
    \ /tmp/tmplhyssyjg.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    smallest_value_index\
    \ = find(even_values == smallest_value)[1]\n    \n    if smallest_value_index\
    \ == length(even_values)\n        return smallest_value, smallest_index\n    else\n\
    \        return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplad8pons.jl:46\nin expression starting at\
    \ /tmp/tmplad8pons.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x -> x % 2 == 0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ plucked_value = arr[smallest_index]\n    \n    return Vector{Int64}([plucked_value,\
    \ smallest_index])\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7ufvorxt.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ufvorxt.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ufvorxt.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7ufvorxt.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7ufvorxt.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ufvorxt.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7ufvorxt.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [5, 1] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ufvorxt.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ufvorxt.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7ufvorxt.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ufvorxt.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ufvorxt.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7ufvorxt.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [5, 1] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7ufvorxt.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2) == 0, arr)\n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return [] \n    end\n    smallest_value\
    \ = minimum(even_values)\n    smallest_index = findfirst(x->x == smallest_value,\
    \ even_values)\n    return [ smallest_value, smallest_index ]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <text>\nPractice Problems\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1p_4_plo.jl:43\nin expression starting at\
    \ /tmp/tmp1p_4_plo.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    if smallest_index\
    \ == nothing\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [4, 2, 3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,\
    \ 2, 3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr\
    \ = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1, 2, 3, 0]\n</cell>\n\
    <code language=julia-1.0>\npluck\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2p6mu9vj.jl:44\nin expression starting at\
    \ /tmp/tmp2p6mu9vj.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_even_value)[0]\n    return\
    \ [smallest_even_value,smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<text>\nPractice 3\nGiven an array\
    \ representing a branch of a tree that has non-negative integer nodes\nyour task\
    \ is to pluck one of the nodes and return it.\nThe plucked node should be the\
    \ node with the smallest odd value.\nIf multiple nodes with the same smallest\
    \ odd value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps6rdj2j5.jl:43\nin expression starting at\
    \ /tmp/tmps6rdj2j5.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> mod(x,2) == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(x -> x == smallest_value, even_values)\n      \
    \  return smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf1c62xcs.jl:46\nin expression starting at\
    \ /tmp/tmpf1c62xcs.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    return smallest_value,\
    \ smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8sm0v1vy.jl:40\nin expression starting at\
    \ /tmp/tmp8sm0v1vy.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,0,0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,0,0,0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,0,0,0,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,0,0,0,0,0,0]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,0,0,0,0,0,0,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps_cregu_.jl:46\nin expression starting at\
    \ /tmp/tmps_cregu_.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_index = find(x -> x == smallest_even_value,\
    \ even_values)\n        return [smallest_even_value, smallest_index]\n    end\n\
    end\n</cell>\n<text>\nProblem 3\nGiven a binary tree, return the level order traversal\
    \ of its nodes' values. (ie, from left to right, level by level).\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_f10gvgx.jl:44\nin expression starting at\
    \ /tmp/tmp_f10gvgx.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = smallest_index\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplw1wlrta.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplw1wlrta.jl:1\n\
    in expression starting at /tmp/tmplw1wlrta.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    smallest_value =\
    \ arr[smallest_index]\n    \n    if length(even_values) == 0 || smallest_value\
    \ == 0\n        return Vector{Int64}()\n    else\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<text>\nProblem 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpizflkzlf.jl:46\nin expression starting at\
    \ /tmp/tmpizflkzlf.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbhwlgd34.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbhwlgd34.jl:1\n\
    in expression starting at /tmp/tmpbhwlgd34.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [5,0,3,0,4,2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,6]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5,0,3,0,4,2,1,0,5,6,7]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5,0,3,0,4,2,1,0,5,6,7,8]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5,0,3,0,4,2,1,0,5,6,7,8,9]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6tayv_y_.jl:44\nin expression starting at\
    \ /tmp/tmp6tayv_y_.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return [] \n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    # Test your function below\narr = [4,2,3]\nout = pluck(arr)\n@test out == [2,\
    \ 1]\n</cell>\n<text>\n4.3 Pluck all nodes with even values\nGiven an array representing\
    \ a branch of a tree that has non-negative integer nodes\nyour task is to pluck\
    \ all of the nodes and return them in a list.\nThe plucked nodes should be returned\
    \ in a list, [ smalest_value, its index ],\nIf there are no even values or the\
    \ given array is empty, return [].\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz_98zisb.jl:44\nin expression starting at\
    \ /tmp/tmpz_98zisb.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    \n    if\
    \ smallest_index == -1 || length(even_values) == 0\n        return Vector{Int64}()\n\
    \    else\n        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n\
    <text>\nSolution\nLet's see how we could solve this problem using a recursive\
    \ approach.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu02e7_2l.jl:45\nin expression starting at\
    \ /tmp/tmpu02e7_2l.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(x -> x == smallest_value, even_values)\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpzby6th04.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzby6th04.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzby6th04.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzby6th04.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpzby6th04.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzby6th04.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzby6th04.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzby6th04.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpzby6th04.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzby6th04.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp00bp7761.jl:44\nin expression starting at\
    \ /tmp/tmp00bp7761.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    elseif length(even_values) == 1\n\
    \        return even_values\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3qy0c5v7.jl:46\nin expression starting at\
    \ /tmp/tmp3qy0c5v7.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ smallest_value, smallest_index\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi90phw_n.jl:44\nin expression starting at\
    \ /tmp/tmpi90phw_n.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        index = find(even_values == smallest_value)[1]\n        return [smallest_value,\
    \ index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpht2wcz2g.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Array has no field filter\n\
    \  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpht2wcz2g.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpht2wcz2g.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpht2wcz2g.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpht2wcz2g.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Array has no field filter\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpht2wcz2g.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpht2wcz2g.jl:50 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpht2wcz2g.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpht2wcz2g.jl:51\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  type Array has no field\
    \ filter\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n \
    \  [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpht2wcz2g.jl:35\n   [3] macro\
    \ expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpht2wcz2g.jl:51 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpht2wcz2g.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpht2wcz2g.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Arra"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpht2wcz2g.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = unique(arr .% 2)\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = find(even_values == smallest_even_value)[1]\n    \n\
    \    if smallest_even_index == 0 \n        return [] \n    end\n    \n    smallest_value\
    \ = arr[smallest_even_index]\n    \n    smallest_value_index = find(arr == smallest_value)[1]\n\
    \    \n    smallest_value_index_in_even_values = arr[smallest_value_index] .%\
    \ 2\n    \n    if smallest_value_index_in_even_values == 0 \n        return []\
    \ \n    end\n    \n    smallest_value_index_in_even_values_index = find(arr ==\
    \ smallest_value_index_in_even_values)[1]\n    \n    smallest_value_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index] .% 2\n    \n    if smallest_value_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index\
    \ = find(arr == smallest_value_index_in_even_values_index_in_even_values)[1]\n\
    \    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index_in_even_values_index] .% 2\n\
    \    \n    if smallest_value_index_in_even_values_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index]\
    \ .% 2\n    \n    if smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ = arr[smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index]\
    \ .% 2\n    \n    if smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_values\
    \ == 0 \n        return [] \n    end\n    \n    smallest_value_index_in_even_values_index_in_even_values_index_in_even_values_index_in_even_value\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdb51mez2.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdb51mez2.jl:1\n\
    in expression starting at /tmp/tmpdb51mez2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return Vector{Int64}()\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmcrb2mdq.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmcrb2mdq.jl:1\n\
    in expression starting at /tmp/tmpmcrb2mdq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x->mod(x,2)==0, arr)\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    \    even_values = even_values[2:end]\n    even_values = even_values[even_values\
    \ mod 2 .== 0]\n    even_values = sort(even_values)\n    even_values = even_values[2:end]\n\
    \    even_values = even_values[even_values mod 2 .== 0]\n    even_values = sort(even_values)\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxtwixkad.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxtwixkad.jl:1\n\
    in expression starting at /tmp/tmpxtwixkad.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[1]\n        smallest_index = 1\n    end\n\
    \    \n    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\narr\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\narr\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe4q84sbu.jl:46\nin expression starting at\
    \ /tmp/tmpe4q84sbu.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_even_value = min(even_values)\n\
    \    smallest_even_index = findfirst(x -> x == smallest_even_value, even_values)\n\
    \    return smallest_even_index == nothing ? Vector{Int64}() : Vector{Int64}([smallest_even_value,smallest_even_index])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd58trngp.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpd58trngp.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd58trngp.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd58trngp.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpd58trngp.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpd58trngp.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd58trngp.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd58trngp.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpd58trngp.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  Met"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd58trngp.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = findfirst(x -> x == smallest_value, even_values)\n    \n\
    \    if smallest_index == nothing\n        return Vector{Int64}()\n    else\n\
    \        return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc9nvqndn.jl:45\nin expression starting at\
    \ /tmp/tmpc9nvqndn.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -Inf \n    smallest_index =\
    \ -1\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value < node\n                smallest_value = node\n\
    \                smallest_index = node\n            end\n        end\n    end\n\
    \    if !even_values\n        return Vector{Int64}()\n    end\n    smallest_value\
    \ = min(even_values)\n    smallest_index = find(even_values == smallest_value)[1]\n\
    \    return [ smallest_value, smallest_index ]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxbpgn88v.jl:54\nin expression starting at\
    \ /tmp/tmpxbpgn88v.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = Int64(Inf)\n    smallest_index\
    \ = -1\n    \n    for node in arr\n        if node.even?\n            even_values.add(node.value)\n\
    \            if node.value < smallest_value\n                smallest_value =\
    \ node.value\n                smallest_index = node\n            end\n       \
    \ end\n    end\n    \n    if !even_values\n        return Vector{Int64}()\n  \
    \  end\n    \n    smallest_value_index = -1\n    smallest_value_index = 0\n  \
    \  \n    for node in even_values\n        if node < smallest_value\n         \
    \   smallest_value_index = smallest_value_index + 1\n            smallest_value\
    \ = node\n        end\n    end\n    \n    smallest_value_index = smallest_value_index\
    \ + 1\n    \n    return Vector{Int64}([smallest_value, smallest_value_index])\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space required before \"?\" operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpltayo7us.jl:41\nin expression starting at\
    \ /tmp/tmpltayo7us.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_even_value\
    \ = min(even_values)\n        smallest_even_index = findfirst(x->x==smallest_even_value,\
    \ even_values)\n        return [smallest_even_value,smallest_even_index]\n   \
    \ end\nend\n</cell>\n<code language=julia-1.0>\narr = [4,2,3]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [1,2,3]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = []\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n\
    <code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.0>\npluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp22_q6q0q.jl:44\nin expression starting at\
    \ /tmp/tmp22_q6q0q.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set()\n    smallest_value = -1\n    smallest_index = 0\n\
    \    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value == -1 || node < smallest_value\n              \
    \  smallest_value = node\n                smallest_index = length(arr)\n     \
    \       end\n        end\n    end\n    \n    if length(even_values) == 0\n   \
    \     return Vector{Int64}()\n    end\n    \n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    \n    \n    return\
    \ Vector{Int64}([smallest_value, smallest_index])\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsnkgaybb.jl:58\nin expression starting at\
    \ /tmp/tmpsnkgaybb.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        return [] \n    else \n        return [smallest_value, smallest_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_ecv5o63.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_ecv5o63.jl:1\n\
    in expression starting at /tmp/tmp_ecv5o63.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = arr[1]\n    smallest = arr[1]\n    largestIndex = 1\n    smallestIndex\
    \ = 1\n    \n    for i = 2:length(arr)\n        if arr[i] > largest\n        \
    \    largest = arr[i]\n            largestIndex = i\n        elseif arr[i] < smallest\n\
    \            smallest = arr[i]\n            smallestIndex = i\n        end\n \
    \   end\n    \n    if smallest == largest\n        return largest\n    end\n \
    \   \n    largestValue = arr[largestIndex]\n    smallestValue = arr[smallestIndex]\n\
    \    \n    if smallestValue % 2 == 0\n        return smallest\n    else\n    \
    \    return largest\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplrzyrsa9.jl:63\nin expression starting at\
    \ /tmp/tmplrzyrsa9.jl:63\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_even_value =\
    \ min(even_values)\n    smallest_even_index = even_values.index(smallest_even_value)\n\
    \    smallest_value = arr[smallest_even_index]\n    smallest_value_index = arr.index(smallest_value)\n\
    \    return [smallest_value, smallest_value_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp80b52c8w.jl:42\nin expression starting at\
    \ /tmp/tmp80b52c8w.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = findall(x -> x % 2 == 0, arr)\n    if isempty(even_values)\
    \ || length(even_values) == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    smallest_even_value = min(even_values)\n    smallest_index = find(even_values\
    \ == smallest_even_value)[1]\n    \n    plucked_value = arr[smallest_index]\n\
    \    return Vector{Int64}([smallest_even_value,smallest_index])\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbiw4fob8.jl:46\nin expression starting at\
    \ /tmp/tmpbiw4fob8.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = Int64(0)\n    smallest = Int64(0)\n    largestIndex = 0\n  \
    \  smallestIndex = 0\n    for node in arr\n        if node % 2 == 0\n        \
    \    if node > largest\n                largest = node\n                largestIndex\
    \ = largestIndex + 1\n            elseif node < smallest\n                smallest\
    \ = node\n                smallestIndex = smallestIndex + 1\n        end\n   \
    \ end\n    return [smallest, smallestIndex]\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.0>\narr = [1,2,3]\n</cell>\n<code language=julia-1.0>\npluck(arr)\n\
    </cell>\n<code language=julia-1.0>\narr = []\n</cell>\n<code language=julia-1.0>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.0>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.0>\npluck(arr)\n</cell>\n<text>\nProblem 3\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpufcy3y8g.jl:51\nin expression starting at\
    \ /tmp/tmpufcy3y8g.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    largest = minimum(arr)\n    smallest = maximum(arr)\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    \n    if length(evens) == 0\n        return []\n  \
    \  end\n    \n    smallest_even = minimum(evens)\n    smallest_index = index(evens,\
    \ smallest_even)\n    \n    if smallest_index == length(evens)\n        return\
    \ largest\n    end\n    \n    largest = arr[smallest_index]\n    \n    return\
    \ largest, smallest_index\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    \nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2s_3yfsg.jl:54\nin expression starting at\
    \ /tmp/tmp2s_3yfsg.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if length(even_values)\
    \ == 0 || smallest_value == 0\n        return Vector{Int64}()\n    else\n    \
    \    return [smallest_value, smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppahevwi5.jl:45\nin expression starting at\
    \ /tmp/tmppahevwi5.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x -> x % 2 == 0)\n    smallest_value = min(even_values)\n\
    \    smallest_index = even_values.index(smallest_value)\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvnrg7f9n.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvnrg7f9n.jl:1\n\
    in expression starting at /tmp/tmpvnrg7f9n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = Set{Int64}()\n    smallest_value = Int64(0)\n    smallest_index\
    \ = -1\n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \            if smallest_value < node\n                smallest_value = node\n\
    \                smallest_index = length(arr)\n            end\n        end\n\
    \    end\n    if length(even_values) == 0\n        return Vector{Int64}()\n  \
    \  end\n    smallest_value_index = -1\n    for node in even_values\n        if\
    \ smallest_value_index == -1 || smallest_value < node\n            smallest_value_index\
    \ = node\n        end\n    end\n    return Vector{Int64}([smallest_value, smallest_value_index])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplji6885k.jl:63\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  type Set has no field add\n \
    \ Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmplji6885k.jl:40\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplji6885k.jl:63 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplji6885k.jl:62\ntest set:\
    \ Error During Test at /tmp/tmplji6885k.jl:64\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmplji6885k.jl:40\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplji6885k.jl:64 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplji6885k.jl:62\ntest set:\
    \ Error During Test at /tmp/tmplji6885k.jl:66\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  type Set has no field add\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmplji6885k.jl:40\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplji6885k.jl:66 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplji6885k.jl:62\ntest set:\
    \ Error During Test at /tmp/tmplji6885k.jl:67\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  type Set has no field add\n  Stackt"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplji6885k.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    end\n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ \n    if smallest_index == nothing\n        return Vector{Int64}()\n    end\n\
    \    \n    \n    \n    \n    return Vector{Int64}([smallest_value, smallest_index])\n\
    end\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwd5qem6y.jl:52\nin expression starting at\
    \ /tmp/tmpwd5qem6y.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = arr.filter(x->mod(x,2) == 0)\n    if isempty(even_values)\n\
    \        return [];\n    else\n        smallest_value = min(even_values)\n   \
    \     smallest_index = even_values.indexof(smallest_value)\n        return [smallest_value,\
    \ smallest_index]\n    end\nend\n</cell>\n<code language=julia-1.5>\narr = [4,2,3]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, \nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4d8_zn34.jl:44\nin expression starting at\
    \ /tmp/tmp4d8_zn34.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = Set()\n    smallest_value = 0\n    smallest_index\
    \ = 0\n    \n    for node in arr\n        if node % 2 == 0\n            even_values.add(node)\n\
    \        end\n    end\n    \n    if !isempty(even_values)\n        smallest_value\
    \ = min(even_values)\n        smallest_index = find(even_values == smallest_value)[1]\n\
    \    end\n    \n    if smallest_value == 0\n        return []\n    end\n    \n\
    \    return [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 0]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 0]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyvxiryx2.jl:57\nin expression starting at\
    \ /tmp/tmpyvxiryx2.jl:57\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> x % 2 == 0, arr)\n    even.sort()\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-even[end])\n    even.push(-even[end])\n    even.push(-even[end])\n\
    \    even.push(-\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp640v2hxj.jl:89\nin expression starting at\
    \ /tmp/tmp640v2hxj.jl:89\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = index(even_values, smallest_value)\n    return smallest_value,\
    \ smallest_index\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp99ywaill.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp99ywaill.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp99ywaill.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp99ywaill.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp99ywaill.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp99ywaill.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp99ywaill.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp99ywaill.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp99ywaill.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp99ywaill.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    even_values = filter(x->mod(x,2)==0, arr)\n    \n    if length(even_values)\
    \ == 0\n        return [] \n    end\n    \n    smallest_value = minimum(even_values)\n\
    \    smallest_index = findfirst(x->x==smallest_value, even_values)\n    \n   \
    \ if smallest_index == nothing\n        return [] \n    end\n    \n    return\
    \ [smallest_value, smallest_index]\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [4,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code\
    \ language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = []\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2]\n</cell>\n\
    <code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr\
    \ = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmf7wi1g9.jl:51\nin expression starting at\
    \ /tmp/tmpmf7wi1g9.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if length(even_values)\
    \ == 0\n        return Vector{Int64}()\n    else\n        smallest_value = min(even_values)\n\
    \        smallest_index = find(even_values == smallest_value)[1]\n        return\
    \ [smallest_value, smallest_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpcbhagnqa.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Int64})\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n    min(::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcbhagnqa.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcbhagnqa.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcbhagnqa.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpcbhagnqa.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Int64})\n\
    \  Closest candidates are:\n    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\n\
    \    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\n\
    \    min(::Any, !Matched::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcbhagnqa.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcbhagnqa.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcbhagnqa.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpcbhagnqa.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  Met"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcbhagnqa.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    smallest_value = min(even_values)\n\
    \    smallest_index = find(even_values == smallest_value)[1]\n    \n    if smallest_index\
    \ == 0 \n        smallest_value = arr[smallest_index]\n        smallest_index\
    \ = 1\n    end\n    \n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <code language=julia-1.5>\narr = [4,2,3]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [1,2,3]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = []\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n\
    <code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\n\
    pluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n\
    </cell>\n<code language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n\
    </cell>\n<code language=julia-1.5>\narr = [5, 0, 3, 0, 4, 2, 1]\n</cell>\n<code\
    \ language=julia-1.5>\npluck(arr)\n</cell>\n<code language=julia-1.5>\narr = [5,\
    \ 0, 3, 0, 4, 2, 1]\n</cell>\n<code language=julia-1.5>\npluck(arr)\n</cell\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz49hm6je.jl:46\nin expression starting at\
    \ /tmp/tmpz49hm6je.jl:46\n"
  exit_code: 1
  status: SyntaxError
