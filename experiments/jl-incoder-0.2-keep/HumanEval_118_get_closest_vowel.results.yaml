name: HumanEval_118_get_closest_vowel
language: julia
results:
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    if vowels_len == 0 \n        return \"\"\n    \n  \
    \  vowels_index = word[vowels_len]\n    \n    if vowels_index == \"a\" \n    \
    \    return \"a\"\n    \n    if vowels_index == \"e\" \n        return \"e\"\n\
    \    \n    if vowels_index == \"i\" \n        return \"i\"\n    \n    if vowels_index\
    \ == \"o\" \n        return \"o\"\n    \n    if vowels_index == \"u\" \n     \
    \   return \"u\"\n    \n    return \"\"\nend\n</cell>\n<code language=julia-1.4>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg5cxczx_.jl:41\nin expression starting at\
    \ /tmp/tmpg5cxczx_.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    vowels_count = vowels_count - 1\n    if vowels_count\
    \ < 0 \n        vowels_count = 0\n    \n    if vowels_count > 0 \n        vowels_count\
    \ = vowels_count - 1\n    \n    if vowels_count < 0 \n        vowels_count = 0\n\
    \    \n    if vowels_count > 0 \n        vowels_count = vowels_count - 1\n   \
    \ \n    if vowels_count < 0 \n        vowels_count = 0\n    \n    if vowels_count\
    \ > 0 \n        vowels_count = vowels_count - 1\n    \n    if vowels_count < 0\
    \ \n        vowels_count = 0\n    \n    if vowels_count > 0 \n        vowels_count\
    \ = vowels_count - 1\n    \n    if vowels_count < 0 \n        vowels_count = 0\n\
    \    \n    if vowels_count > 0 \n        vowels_count = vowels_count - 1\n   \
    \ \n    if vowels_count < 0 \n        vowels_count = 0\n    \n    if vowels_count\
    \ > 0 \n        vowels_count = vowels_count - 1\n    \n    if vowels_count < 0\
    \ \n        vowels_count = 0\n    \n    if vowels_count > 0 \n        vowels_count\
    \ = vowels_count - 1\n    \n    if vowels_count < 0 \n        vowels_count = 0\n\
    \    \n    if vowels_count > 0 \n        vowels_count = vowels_count - 1\n   \
    \ \n    if vowels_count < 0 \n        vowels_count = 0\n    \n    if vowels_count\
    \ > 0 \n        vowels_count = vowels_count - 1\n    \n    if vowels_count < 0\
    \ \n        vowels_count = 0\n    \n    if vowels_count > 0 \n        vowels_count\
    \ = vowels_count - 1\n    \n    if vowels_count < 0 \n        vowels_count = 0\n\
    \    \n    if vowels_count > 0 \n        vowels_count = vowels_count - 1\n   \
    \ \n    if vowels_count < 0 \n        vowels_count = 0\n    \n    if vowels_count\
    \ > 0 \n        vowels_count = vowels_count - 1\n    \n    if vowels_count < 0\
    \ \n        vowels_count = 0\n    \n    if vowels_count > 0 \n        vowels_count\
    \ = vowels_count - 1\n    \n    if vowels_count < 0 \n        vowels_count = 0\n\
    \    \n    if vowels_count > 0 \n        vowels_count = vowels_count - 1\n   \
    \ \n    if vowels_count < 0 \n        vowels_count = 0\n    \n    if vowels_count\
    \ > 0 \n        vowels_count = vowels_count - 1\n    \n    if vowels_count \n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbxaqdbpz.jl:1\nin expression starting at /tmp/tmpbxaqdbpz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    for char in word:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    if vowels_count == 0:\n     \
    \   return \"\"\n    vowels_count -= 1\n    vowels_count %= vowels_len\n    vowels_count\
    \ += vowels_len\n    vowels_count %= vowels_len\n    vowels_count += vowels_len\n\
    \    vowels_count %= vowels_len\n    vowels_count += vowels_len\n    vowels_count\
    \ %= vowels_len\n    vowels_count += vowels_len\n    vowels_count %= vowels_len\n\
    \    vowels_count += vowels_len\n    vowels_count %= vowels_len\n    vowels_count\
    \ += vowels_len\n    vowels_count %= vowels_len\n    vowels_count += vowels_len\n\
    \    vowels_count %= vowels_len\n    vowels_count += vowels_len\n    vowels_count\
    \ %= vowels_len\n    vowels_count += vowels_len\n    vowels_count %= vowels_len\n\
    \    vowels_count += vowels_len\n    vowels_count %= vowels_len\n    vowels_count\
    \ += vowels_len\n    vowels_count %= vowels_len\n    vowels_count += vowels_len\n\
    \    vowels_count %= vowels_len\n    vowels_count += vowels_len\n    vowels_count\
    \ %= vowels_len\n    vowels_count += vowels_len\n    vowels_count %= vowels_len\n\
    \    vowels_count += vowels_len\n    vowels_count %= vowels_len\n    vowels_count\
    \ += vowels_len\n    vowels_count %= vowels_len\n    vowels_count += vowels_len\n\
    \    vowels_count %= vowels_len\n    vowels_count += vowels_len\n    vowels_count\
    \ %= vowels_len\n    vowels_count += vowels_len\n    vowels_count %= vowels_len\n\
    \    vowels_count += vowels_len\n    vowels_count %= vowels_len\n    vowels_count\
    \ += vowels_len\n    vowels_count %= vowels_len\n    vowels_count += vowels_len\n\
    \    vowels_count %= vowels_len\n    vowels_count += vowels_len\n    vowels_count\
    \ %= vowels_len\n    vowels_count += vowels_len\n    vowels_count %= vowels_len\n\
    \    vowels_count += vowels_len\n    vowels_count %= vowels_len\n    \nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkw2_3pon.jl:20\nin expression starting at\
    \ /tmp/tmpkw2_3pon.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n\
    \    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count -= 1\n    vowels_count\
    \ -= 1\n    vowels_count -= 1\n    vowels_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpky7ww6d9.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpky7ww6d9.jl:1\n\
    in expression starting at /tmp/tmpky7ww6d9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    vowels_index_count\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp18xjq8qj.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp18xjq8qj.jl:1\n\
    in expression starting at /tmp/tmp18xjq8qj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = []\n    for index, letter in enumerate(word):\n\
    \        if letter in vowels:\n            vowels_index.append(index)\n    vowels_index.sort()\n\
    \    vowels_index.reverse()\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_len]\n    vowels_index = vowels_index[vowels_len-1:vowels_len]\n\
    \    vowels_index = vowels_index[vowels_len-1:vowels_len]\n    vowels_index =\
    \ vowels_index[vowels_len-1:vowels_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6hvcv8s6.jl:19\nin expression starting at\
    \ /tmp/tmp6hvcv8s6.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnd5ojb24.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnd5ojb24.jl:1\n\
    in expression starting at /tmp/tmpnd5ojb24.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1 \n      \
    \  return \"\"\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx < 0 \n        vowels_idx = vowels.length\n    vowels_idx\
    \ = vowels_idx - 1\n    if vowels_idx < 0 \n        vowels_idx = vowels.length\n\
    \    vowels_idx = vowels_idx + 1\n    if vowels_idx < 0 \n        vowels_idx =\
    \ vowels.length\n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0 \n   \
    \     vowels_idx = vowels.length\n    vowels_idx = vowels_idx + 1\n    if vowels_idx\
    \ < 0 \n        vowels_idx = vowels.length\n    vowels_idx = vowels_idx - 1\n\
    \    if vowels_idx < 0 \n        vowels_idx = vowels.length\n    vowels_idx =\
    \ vowels_idx + 1\n    if vowels_idx < 0 \n        vowels_idx = vowels.length\n\
    \    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0 \n        vowels_idx =\
    \ vowels.length\n    vowels_idx = vowels_idx + 1\n    if vowels_idx < 0 \n   \
    \     vowels_idx = vowels.length\n    vowels_idx = vowels_idx - 1\n    if vowels_idx\
    \ < 0 \n        vowels_idx = vowels.length\n    vowels_idx = vowels_idx + 1\n\
    \    if vowels_idx < 0 \n        vowels_idx = vowels.length\n    vowels_idx =\
    \ vowels_idx - 1\n    if vowels_idx < 0 \n        vowels_idx = vowels.length\n\
    \    vowels_idx = vowels_idx + 1\n    if vowels_idx < 0 \n        vowels_idx =\
    \ vowels.length\n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0 \n   \
    \     vowels_idx = vowels.length\n    vowels_idx = vowels_idx + 1\n    if vowels_idx\
    \ < 0 \n        vowels_idx = vowels.length\n    vowels_idx = vowels_idx - 1\n\
    \    if vowels_idx < 0 \n        vowels_idx = vowels.length\n    vowels_idx =\
    \ vowels_idx + 1\n    if vowels_idx < 0 \n        vowels_idx = vowels.length\n\
    \    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0 \n        vowels_idx =\
    \ vowels.length\n    vowels_idx = vowels_idx + 1\n    if vowels_idx < 0 \n   \
    \     vowels_idx = vowels.length\n    vowels_idx = vowels_idx - 1\n    if vowels_idx\
    \ < 0 \n        vowels_idx = vowels.length\n    vowels_idx = vowels_idx + 1\n\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp78fsmhca.jl:1\nin expression starting at /tmp/tmp78fsmhca.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels[vowels_idx]\
    \ == word[vowels_idx + 1]\n        return word[vowels_idx]\n    \n    if vowels[vowels_idx]\
    \ == word[vowels_idx - 1]\n        return word[vowels_idx]\n    \n    return \"\
    \"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<text>\nProblem 3\nWrite a function that takes a string as input\
    \ and returns a string with all the characters of the string in reverse order.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz8w0pmaj.jl:31\nin expression starting at\
    \ /tmp/tmpz8w0pmaj.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_idx == -1 \n        return\
    \ \"\"\n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0 \n        vowels_idx\
    \ = vowels.length\n    vowels_idx = vowels_idx + 1\n    if vowels_idx > vowels.length\
    \ \n        vowels_idx = 0\n    return vowels[vowels_idx]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string as input and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf6345_ah.jl:28\nin expression starting at\
    \ /tmp/tmpf6345_ah.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = count(vowels)\n    vowels_count = vowels_count\
    \ - 2\n    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n  \
    \  vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n  \
    \  vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count \nusing Test\n\n\
    @testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpylthl2ca.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpylthl2ca.jl:19\n\
    in expression starting at /tmp/tmpylthl2ca.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = findlastindex(word, vowels)\n    if vowels_index\
    \ == -1 \n        error(\"No vowel found\")\n    \n    vowels_index_2 = findlastindex(word[vowels_index+1:],\
    \ vowels)\n    if vowels_index_2 == -1\n        error(\"No vowel found\")\n  \
    \  \n    vowels_index_3 = findlastindex(word[vowels_index_2+1:], vowels)\n   \
    \ if vowels_index_3 == -1\n        error(\"No vowel found\")\n    \n    if vowels_index_3\
    \ > vowels_index_2\n        vowels_index_3 = vowels_index_3 - 1\n    \n    if\
    \ vowels_index_3 > vowels_index\n        vowels_index_3 = vowels_index_3 - 1\n\
    \    \n    if vowels_index_3 > vowels_index_2\n        vowels_index_3 = vowels_index_3\
    \ - 1\n    \n    if vowels_index_3 > vowels_index\n        vowels_index_3 = vowels_index_3\
    \ - 1\n    \n    if vowels_index_3 > vowels_index_2\n        vowels_index_3 =\
    \ vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index\n        vowels_index_3\
    \ = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index_2\n       \
    \ vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index_2\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index_2\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index_2\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index_2\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index\n\
    \        vowels_index_3 = vowels_index_3 - 1\n    \n    if vowels_index_3 > vowels_index_2\n\
    \        vowels_index_3 = vowels_index_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing last argument in \"(vowels_index + 1):\"\
    \ range expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2cf9driw.jl:22\n\
    in expression starting at /tmp/tmp2cf9driw.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains)\n    vowels_idx = vowels_idx + 1 if vowels_idx\
    \ < vowels.length - 1 else 0\n    vowels_idx = vowels_idx - 1 if vowels_idx >\
    \ 0 else vowels_idx - vowels.length\n    return word[vowels_idx]\nend\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"\
    FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"\
    ab\") ==> \"\"\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ and returns the number of vowels found in the string.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpvvpb5apd.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvvpb5apd.jl:18\n\
    in expression starting at /tmp/tmpvvpb5apd.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_idx = word.rfind(vowels)\n    if vowels_idx == -1:\n\
    \        return \"\"\n    \n    vowels_idx = vowels_idx - vowels_len\n    vowels_idx\
    \ = vowels_idx % vowels_len\n    \n    vowels_idx = vowels_idx + vowels_len\n\
    \    \n    vowel = vowels[vowels_idx]\n    return vowel\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj30v6cae.jl:20\nin expression starting at\
    \ /tmp/tmpj30v6cae.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowel_start = word[vowels_len]\n    vowel_end = word[vowels_len-1]\n\
    \    \n    vowel_start_index = vowels.index(vowel_start)\n    vowel_end_index\
    \ = vowels.index(vowel_end)\n    \n    if vowel_start_index == vowel_end_index:\n\
    \        return \"\"\n    \n    vowel_start_index += 1\n    vowel_end_index -=\
    \ 1\n    \n    vowel_start_index = vowels.index(vowel_start, vowel_start_index)\n\
    \    vowel_end_index = vowels.index(vowel_end, vowel_end_index)\n    \n    if\
    \ vowel_start_index == vowel_end_index:\n        return \"\"\n    \n    vowel_start_index\
    \ += 1\n    vowel_end_index -= 1\n    \n    vowel_start_index = vowels.index(vowel_start,\
    \ vowel_start_index)\n    vowel_end_index = vowels.index(vowel_end, vowel_end_index)\n\
    \    \n    if vowel_start_index == vowel_end_index:\n        return \"\"\n   \
    \ \n    vowel_start_index += 1\n    vowel_end_index -= 1\n    \n    vowel_start_index\
    \ = vowels.index(vowel_start, vowel_start_index)\n    vowel_end_index = vowels.index(vowel_end,\
    \ vowel_end_index)\n    \n    if vowel_start_index == vowel_end_index:\n     \
    \   return \"\"\n    \n    vowel_start_index += 1\n    vowel_end_index -= 1\n\
    \    \n    vowel_start_index = vowels.index(vowel_start, vowel_start_index)\n\
    \    vowel_end_index = vowels.index(vowel_end, vowel_end_index)\n    \n    if\
    \ vowel_start_index == vowel_end_index:\n        return \"\"\n    \n    vowel_start_index\
    \ += 1\n    vowel_end_index -= 1\n    \n    vowel_start_index = vowels.index(vowel_start,\
    \ vowel_start_index)\n    vowel_end_index = vowels.index(vowel_end, vowel_end_index)\n\
    \    \n    if vowel_start_index == vowel_end_index:\n        return \"\"\n   \
    \ \n    vowel_start_index += 1\n    vowel_end_index -= 1\n    \n    vowel_start_index\
    \ = vowels.index(vowel_start, vowel_start_index)\n    vowel_end_index = vowels.index(vowel_end,\
    \ vowel_end_index)\n    \n    if vowel_start_index == vowel_end_index:\n     \
    \   return \"\"\n    \n    vowel_start_index += 1\n    vowel_end_index -= 1\n\
    \    \n    vowel_start_index = vowels.index(vowel_start, vowel_start_index)\n\
    \    vowel_end_index = vowels.index(vowel_end, vowel_end_index)\nusing Test\n\n\
    @testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6aqvrvbr.jl:26\nin expression starting at\
    \ /tmp/tmp6aqvrvbr.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        return \"\"\n    \n\
    \    vowels_count = count(vowels, word[end])\n    if vowels_count > 1\n      \
    \  return \"\"\n    \n    vowels_count = count(vowels, word[end - 1])\n    if\
    \ vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[end - 2])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[end - 3])\n    if vowels_count > 1\n        return \"\"\
    \n    \n    vowels_count = count(vowels, word[end - 4])\n    if vowels_count >\
    \ 1\n        return \"\"\n    \n    vowels_count = count(vowels, word[end - 5])\n\
    \    if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[end - 6])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[end - 7])\n    if vowels_count > 1\n        return \"\"\
    \n    \n    vowels_count = count(vowels, word[end - 8])\n    if vowels_count >\
    \ 1\n        return \"\"\n    \n    vowels_count = count(vowels, word[end - 9])\n\
    \    if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[end - 10])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[end - 11])\n    if vowels_count > 1\n        return \"\"\
    \n    \n    vowels_count = count(vowels, word[end - 12])\n    if vowels_count\
    \ > 1\n        return \"\"\n    \n    vowels_count = count(vowels, word[end -\
    \ 13])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count =\
    \ count(vowels, word[end - 14])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[end - 15])\n    if vowels_count >\
    \ 1\n        return \"\"\n    \n    vowels_count = count(vowels, word[end - 16])\n\
    \    if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[end - 17])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[end - 18])\n    if vowels_count > 1\n        return \"\"\
    \n    \n    vowels_count = count(vowels, word[end - 19])\n    if vowel\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpago5tmcc.jl:1\nin expression starting at /tmp/tmpago5tmcc.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx < 0 \n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n\
    \    \n    if vowels_idx < 0 \n        vowels_idx = vowels.lenght - 1\n    \n\
    \    if vowels_idx >= vowels.lenght \n        vowels_idx = 0\n    \n    return\
    \ vowels[vowels_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbgxtrqg7.jl:1\nin expression starting at /tmp/tmpbgxtrqg7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = word.find_first_of(\"aeiouAEIOU\")\n    if vowels_idx == -1 \n        return\
    \ \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\")\n    if vowels_idx\
    \ == -1 \n        return \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\"\
    , vowels_idx + 1)\n    if vowels_idx == -1 \n        return \"\"\n    vowels_idx\
    \ = word.find_last_of(\"aeiouAEIOU\", vowels_idx - 1)\n    if vowels_idx == -1\
    \ \n        return \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\", vowels_idx\
    \ + 1)\n    if vowels_idx == -1 \n        return \"\"\n    vowels_idx = word.find_last_of(\"\
    aeiouAEIOU\", vowels_idx - 1)\n    if vowels_idx == -1 \n        return \"\"\n\
    \    vowels_idx = word.find_last_of(\"aeiouAEIOU\", vowels_idx + 1)\n    if vowels_idx\
    \ == -1 \n        return \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\"\
    , vowels_idx - 1)\n    if vowels_idx == -1 \n        return \"\"\n    vowels_idx\
    \ = word.find_last_of(\"aeiouAEIOU\", vowels_idx + 1)\n    if vowels_idx == -1\
    \ \n        return \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\", vowels_idx\
    \ - 1)\n    if vowels_idx == -1 \n        return \"\"\n    vowels_idx = word.find_last_of(\"\
    aeiouAEIOU\", vowels_idx + 1)\n    if vowels_idx == -1 \n        return \"\"\n\
    \    vowels_idx = word.find_last_of(\"aeiouAEIOU\", vowels_idx - 1)\n    if vowels_idx\
    \ == -1 \n        return \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\"\
    , vowels_idx + 1)\n    if vowels_idx == -1 \n        return \"\"\n    vowels_idx\
    \ = word.find_last_of(\"aeiouAEIOU\", vowels_idx - 1)\n    if vowels_idx == -1\
    \ \n        return \"\"\n    vowels_idx = word.find_last_of(\"aeiouAEIOU\", vowels_idx\
    \ + 1)\n    if vowels_idx == -1 \n        return \"\"\n    vowels_idx = word.find_last_of(\"\
    aeiouAEIOU\", vowels_idx - 1)\n    if vowels_idx == -1 \n        return \"\"\n\
    \    vowels_idx = word.find_last_of(\"aeiouAEIOU\", vowels_idx + 1)\n    if vowels_idx\
    \ == -1 \n        return \"\"\n\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7sozosei.jl:1\nin expression starting at /tmp/tmp7sozosei.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|x| word.ends_with?(x)}\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n\
    \    \n    if vowels[vowels_idx] == word[vowels_idx]\n        return word[vowels_idx]\n\
    \    else\n        return \"\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise\
    \ 2\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppe911eu6.jl:17\nin expression starting at\
    \ /tmp/tmppe911eu6.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1 \n      \
    \  return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0 \n        vowels_idx = vowels.length\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.length \n        vowels_idx = 0\n    \n\
    \    return vowels[vowels_idx]\nend\n</cell>\n<code language=julia-1.4>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nPart 2:\
    \ String Manipulation\nStrings are immutable data structures in Julia. Hence,\
    \ any operation that changes the string will create a new string and leave the\
    \ original untouched.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmasluhh0.jl:33\nin expression starting at\
    \ /tmp/tmpmasluhh0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = findfirst(vowels, word)\n    if vowels_index == -1\n        return \"\"\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = findfirst(vowels, word,\
    \ vowels_index)\n    if vowels_index == -1\n        return \"\"\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n    if vowels_index\
    \ == -1\n        return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = findfirst(vowels, word, vowels_index)\n    if vowels_index == -1\n       \
    \ return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index = findfirst(vowels,\
    \ word, vowels_index)\n    if vowels_index == -1\n        return \"\"\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n    if vowels_index\
    \ == -1\n        return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = findfirst(vowels, word, vowels_index)\n    if vowels_index == -1\n       \
    \ return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index = findfirst(vowels,\
    \ word, vowels_index)\n    if vowels_index == -1\n        return \"\"\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n    if vowels_index\
    \ == -1\n        return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = findfirst(vowels, word, vowels_index)\n    if vowels_index == -1\n       \
    \ return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index = findfirst(vowels,\
    \ word, vowels_index)\n    if vowels_index == -1\n        return \"\"\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = findfirst(vowels, word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = findfirst(vowels, word, \nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjvcximuq.jl:80\nin expression starting at\
    \ /tmp/tmpjvcximuq.jl:80\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains)\n    if vowels_index == -1 \n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.size - 1 \n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb_tj_cga.jl:1\nin expression starting at /tmp/tmpb_tj_cga.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = find(vowels, word) \n    if vowels_index == -1 \n        return \"\"\n   \
    \ \n    vowels_index = vowels_index + 1\n    \n    vowels_index_2 = find(vowels,\
    \ word, vowels_index)\n    if vowels_index_2 == -1 \n        return \"\"\n   \
    \ \n    vowels_index_2 = vowels_index_2 + 1\n    \n    if vowels_index_2 < vowels_index\
    \ \n        return \"\"\n    \n    vowels_index_3 = find(vowels, word, vowels_index_2)\n\
    \    if vowels_index_3 == -1 \n        return \"\"\n    \n    vowels_index_3 =\
    \ vowels_index_3 + 1\n    \n    if vowels_index_3 < vowels_index_2 \n        return\
    \ \"\"\n    \n    vowels_index_4 = find(vowels, word, vowels_index_3)\n    if\
    \ vowels_index_4 == -1 \n        return \"\"\n    \n    vowels_index_4 = vowels_index_4\
    \ + 1\n    \n    if vowels_index_4 < vowels_index_3 \n        return \"\"\n  \
    \  \n    vowels_index_5 = find(vowels, word, vowels_index_4)\n    if vowels_index_5\
    \ == -1 \n        return \"\"\n    \n    vowels_index_5 = vowels_index_5 + 1\n\
    \    \n    if vowels_index_5 < vowels_index_4 \n        return \"\"\n    \n  \
    \  vowels_index_6 = find(vowels, word, vowels_index_5)\n    if vowels_index_6\
    \ == -1 \n        return \"\"\n    \n    vowels_index_6 = vowels_index_6 + 1\n\
    \    \n    if vowels_index_6 < vowels_index_5 \n        return \"\"\n    \n  \
    \  vowels_index_7 = find(vowels, word, vowels_index_6)\n    if vowels_index_7\
    \ == -1 \n        return \"\"\n    \n    vowels_index_7 = vowels_index_7 + 1\n\
    \    \n    if vowels_index_7 < vowels_index_6 \n        return \"\"\n    \n  \
    \  vowels_index_8 = find(vowels, word, vowels_index_7)\n    if vowels_index_8\
    \ == -1 \n        return \"\"\n    \n    vowels_index_8 = vowels_index_8 + 1\n\
    \    \n    if vowels_index_8 < vowels_index_7 \n        return \"\"\n    \n  \
    \  vowels_index_9 = find(vowels, word, vowels_index_8)\n    if vowels_index_9\
    \ == -1 \n        return \"\"\n    \n    vowels_index_9 = vowels_index_9 + 1\n\
    \    \n    if vowels_index_9 < vowels_index_8 \n        return \"\"\n    \n  \
    \  vowels_index_10 = find(vowels, word, vowels_index_9)\n    if vowels_index_10\
    \ == -1 \n        return \"\"\n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc_tqer_u.jl:1\nin expression starting at /tmp/tmpc_tqer_u.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxw9scc8n.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxw9scc8n.jl:1\n\
    in expression starting at /tmp/tmpxw9scc8n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_index = 0\n    vowels_index_count\
    \ = 0\n    vowels_index_count_2 = 0\n    vowels_index_count_3 = 0\n    vowels_index_count_4\
    \ = 0\n    vowels_index_count_5 = 0\n    vowels_index_count_6 = 0\n    vowels_index_count_7\
    \ = 0\n    vowels_index_count_8 = 0\n    vowels_index_count_9 = 0\n    vowels_index_count_10\
    \ = 0\n    vowels_index_count_11 = 0\n    vowels_index_count_12 = 0\n    vowels_index_count_13\
    \ = 0\n    vowels_index_count_14 = 0\n    vowels_index_count_15 = 0\n    vowels_index_count_16\
    \ = 0\n    vowels_index_count_17 = 0\n    vowels_index_count_18 = 0\n    vowels_index_count_19\
    \ = 0\n    vowels_index_count_20 = 0\n    vowels_index_count_21 = 0\n    vowels_index_count_22\
    \ = 0\n    vowels_index_count_23 = 0\n    vowels_index_count_24 = 0\n    vowels_index_count_25\
    \ = 0\n    vowels_index_count_26 = 0\n    vowels_index_count_27 = 0\n    vowels_index_count_28\
    \ = 0\n    vowels_index_count_29 = 0\n    vowels_index_count_30 = 0\n    vowels_index_count_31\
    \ = 0\n    vowels_index_count_32 = 0\n    vowels_index_count_33 = 0\n    vowels_index_count_34\
    \ = 0\n    vowels_index_count_35 = 0\n    vowels_index_count_36 = 0\n    vowels_index_count_37\
    \ = 0\n    vowels_index_count_38 = 0\n    vowels_index_count_39 = 0\n    vowels_index_count_40\
    \ = 0\n    vowels_index_count_41 = 0\n    vowels_index_count_42 = 0\n    vowels_index_count_43\
    \ = 0\n    vowels_index_count_44 = 0\n    vowels_index_count_45 = 0\n    vowels_index_count_46\
    \ = 0\n    vowels_index_count_47 = 0\n    vowels_index_count_48 = 0\n    vowels_index_count_49\
    \ = 0\n    vowels_index_count_50 = 0\n    vowels_index_count_51 = 0\n    vowels_index_count_52\
    \ = 0\n    vowels_index_count_53 = 0\n    vowels_index_count_54 = 0\n    vowels_index_count_55\
    \ = 0\n    vowels_index_count_56 = 0\n    vowels_index_count_57 = 0\n    vowels_index_count_58\
    \ = 0\n    vowels_index_count_59 = 0\n    vowels_index_count_60 = 0\n    vowels_index_count_61\
    \ = 0\n    vowel\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprtj99lj7.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprtj99lj7.jl:1\n\
    in expression starting at /tmp/tmprtj99lj7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = count(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0\
    \ else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0\
    \ else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowel\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmphbaumsbn.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphbaumsbn.jl:18\n\
    in expression starting at /tmp/tmphbaumsbn.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowel_start = word.rfind(vowels)\n    vowel_end = word.rfind(vowels,\
    \ 0, vowel_start-1)\n    \n    if vowel_start == -1 or vowel_end == -1:\n    \
    \    return \"\"\n    \n    vowel_len = vowel_end - vowel_start + 1\n    \n  \
    \  if vowel_len == 1:\n        return word[vowel_start]\n    elif vowel_len ==\
    \ 2:\n        return word[vowel_start-1:vowel_start+1]\n    elif vowel_len ==\
    \ 3:\n        return word[vowel_start-1:vowel_start+2]\n    elif vowel_len ==\
    \ 4:\n        return word[vowel_start-1:vowel_start+3]\n    elif vowel_len ==\
    \ 5:\n        return word[vowel_start-1:vowel_start+4]\n    elif vowel_len ==\
    \ 6:\n        return word[vowel_start-1:vowel_start+5]\n    elif vowel_len ==\
    \ 7:\n        return word[vowel_start-1:vowel_start+6]\n    elif vowel_len ==\
    \ 8:\n        return word[vowel_start-1:vowel_start+7]\n    elif vowel_len ==\
    \ 9:\n        return word[vowel_start-1:vowel_start+8]\n    elif vowel_len ==\
    \ 10:\n        return word[vowel_start-1:vowel_start+9]\n    elif vowel_len ==\
    \ 11:\n        return word[vowel_start-1:vowel_start+10]\n    elif vowel_len ==\
    \ 12:\n        return word[vowel_start-1:vowel_start+11]\n    elif vowel_len ==\
    \ 13:\n        return word[vowel_start-1:vowel_start+12]\n    elif vowel_len ==\
    \ 14:\n        return word[vowel_start-1:vowel_start+13]\n    elif vowel_len ==\
    \ 15:\n        return word[vowel_start-1:vowel_start+14]\n    elif vowel_len ==\
    \ 16:\n        return word[vowel_start-1:vowel_start+15]\n    elif vowel_len ==\
    \ 17:\n        return word[vowel_start-1:vowel_start+16]\n    elif vowel_len ==\
    \ 18:\n        return word[vowel_start-1:vowel_start+17]\n    elif vowel_len ==\
    \ 19:\n        return word[vowel_start-1:vowel_start+18]\n    elif vowel_len ==\
    \ 20:\n        return word[vowel_start-1:vowel_start+19]\n    elif vowel_len ==\
    \ 21:\n        return word[vowel_start-1:vowel_start+20]\n    elif vowel_len ==\
    \ 22:\n        return word[vowel_start-1:vowel_start+21]\n    elif vowel_len ==\
    \ 23:\n        return word[vowel_start-1:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowel_end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfjhwgj2f.jl:22\nin expression starting at /tmp/tmpfjhwgj2f.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = 0\n    vowels_index_end = vowels_len - 1\n\
    \    vowels_index_start = vowels_len - 1\n    vowels_index_middle = vowels_len\
    \ - 1\n    \n    for char in word:\n        if char in vowels:\n            vowels_index\
    \ = vowels_index + 1\n            if vowels_index == vowels_len:\n           \
    \     vowels_index = vowels_index_start\n        elif char in \"AEIOU\":\n   \
    \         vowels_index_end = vowels_index_end - 1\n            if vowels_index_end\
    \ < 0:\n                vowels_index_end = vowels_index_start\n        elif char\
    \ in \"AEIOU\":\n            vowels_index_start = vowels_index_start - 1\n   \
    \         if vowels_index_start < 0:\n                vowels_index_start = vowels_index_end\n\
    \        elif char in \"AEIOU\":\n            vowels_index_middle = vowels_index_middle\
    \ - 1\n            if vowels_index_middle < 0:\n                vowels_index_middle\
    \ = vowels_index_end\n    \n    if vowels_index == vowels_len:\n        return\
    \ \"\"\n    elif vowels_index == 0:\n        return word[vowels_index_middle]\n\
    \    elif vowels_index == vowels_len - 1:\n        return word[vowels_index_end]\n\
    \    else:\n        return word[vowels_index_middle]\nend\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1jait6fi.jl:24\nin expression starting at\
    \ /tmp/tmp1jait6fi.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1\n       \
    \ return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0\n        vowels_idx = vowels.size - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = 0\n   \
    \ \n    return vowels[vowels_idx]\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels found\
    \ in it.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpimc5e_zt.jl:33\nin expression starting at\
    \ /tmp/tmpimc5e_zt.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 2\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count \n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpkmlstu_j.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkmlstu_j.jl:19\n\
    in expression starting at /tmp/tmpkmlstu_j.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_start = 0\n    vowels_count_end\
    \ = 0\n    vowels_count_start_end = 0\n    vowels_count_start_end_count = 0\n\
    \    vowels_count_start_end_count_start = 0\n    vowels_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end = 0\n    vowels_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start = 0\n    vowels_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end = 0\n    vowels_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_end =\
    \ 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb3hgqmly.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpb3hgqmly.jl:1\n\
    in expression starting at /tmp/tmpb3hgqmly.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    \n    for char in word:\n        if\
    \ char in vowels:\n            vowels_count += 1\n            if vowels_count\
    \ > vowels_count_left:\n                vowels_count_left = vowels_count\n   \
    \         if vowels_count > vowels_count_right:\n                vowels_count_right\
    \ = vowels_count\n            if vowels_count > vowels_count_left_right:\n   \
    \             vowels_count_left_right = vowels_count\n    \n    if vowels_count\
    \ > vowels_count_left:\n        return word[vowels_count_left]\n    elif vowels_count\
    \ > vowels_count_right:\n        return word[vowels_count_right]\n    elif vowels_count\
    \ > vowels_count_left_right:\n        return word[vowels_count_left_right]\n \
    \   else:\n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a string and returns the number of vowels present\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw9owkdjk.jl:23\nin expression starting at\
    \ /tmp/tmpw9owkdjk.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx > -1 && vowels_idx\
    \ < vowels.length - 1 \n        && vowels[vowels_idx + 1] == word[vowels_idx +\
    \ 1]\n        && vowels[vowels_idx - 1] == word[vowels_idx - 1]\n        && vowels[vowels_idx\
    \ + 2] == word[vowels_idx + 2]\n        && vowels[vowels_idx - 2] == word[vowels_idx\
    \ - 2]\n        && vowels[vowels_idx + 3] == word[vowels_idx + 3]\n        &&\
    \ vowels[vowels_idx - 3] == word[vowels_idx - 3]\n        && vowels[vowels_idx\
    \ + 4] == word[vowels_idx + 4]\n        && vowels[vowels_idx - 4] == word[vowels_idx\
    \ - 4]\n        && vowels[vowels_idx + 5] == word[vowels_idx + 5]\n        &&\
    \ vowels[vowels_idx - 5] == word[vowels_idx - 5]\n        && vowels[vowels_idx\
    \ + 6] == word[vowels_idx + 6]\n        && vowels[vowels_idx - 6] == word[vowels_idx\
    \ - 6]\n        && vowels[vowels_idx + 7] == word[vowels_idx + 7]\n        &&\
    \ vowels[vowels_idx - 7] == word[vowels_idx - 7]\n        && vowels[vowels_idx\
    \ + 8] == word[vowels_idx + 8]\n        && vowels[vowels_idx - 8] == word[vowels_idx\
    \ - 8]\n        && vowels[vowels_idx + 9] == word[vowels_idx + 9]\n        &&\
    \ vowels[vowels_idx - 9] == word[vowels_idx - 9]\n        && vowels[vowels_idx\
    \ + 10] == word[vowels_idx + 10]\n        && vowels[vowels_idx - 10] == word[vowels_idx\
    \ - 10]\n        && vowels[vowels_idx + 11] == word[vowels_idx + 11]\n       \
    \ && vowels[vowels_idx - 11] == word[vowels_idx - 11]\n        && vowels[vowels_idx\
    \ + 12] == word[vowels_idx + 12]\n        && vowels[vowels_idx - 12] == word[vowels_idx\
    \ - 12]\n        && vowels[vowels_idx + 13] == word[vowels_idx + 13]\n       \
    \ && vowels[vowels_idx - 13] == word[vowels_idx - 13]\n        && vowels[vowels_idx\
    \ + 14] == word[vowels_idx + 14]\n        && vowels[vowels_idx - 14] == word[vowels_idx\
    \ - 14]\n        && vowels[vowels_idx + 15] == word[vowels_idx + 15]\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"&&\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5rgys4by.jl:19\nin expression starting at\
    \ /tmp/tmp5rgys4by.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = []\n    \n    for char in word:\n        if\
    \ char in vowels:\n            vowels_index.append(vowels.index(char))\n    \n\
    \    vowels_index.sort()\n    \n    if vowels_index[0] < vowels_index[1]:\n  \
    \      return vowels[vowels_index[0]]\n    else:\n        return \"\"\nend\n</cell>\n\
    <code language=julia-1.4>\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"\
    FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"\
    ab\") ==> \"\"\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ and returns the number of vowels found in the string.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkamyu9vo.jl:21\nin expression starting at\
    \ /tmp/tmpkamyu9vo.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = find(vowels, word[end])\n    if vowels_index == -1 || vowels_index == length(word)\n\
    \        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = find(vowels, word[end - 1])\n    if vowels_index == -1 || vowels_index ==\
    \ length(word)\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n\
    \    vowels_index = find(vowels, word[end - 2])\n    if vowels_index == -1 ||\
    \ vowels_index == length(word)\n        return \"\"\n    \n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = find(vowels, word[end - 3])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 4])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 5])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 6])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 7])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 8])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 9])\n    if vowels_index\
    \ == -1 || vowels_index == length(word)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = find(vowels, word[end - 10])\n    if\
    \ vowels_index == -1 || vowels_index == length(word)\n        return \"\"\n  \
    \  \n    vowels_index = vowels_index + 1\n    vowels_index = find(vowels, word[end\
    \ - 11])\n    if vowels_index == -1 || vowels_index == length(word)\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = find(vowels,\
    \ word[end - 12])\n    if vowels_index == -1 \nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp5c2x0lu.jl:1\nin expression starting at /tmp/tmpp5c2x0lu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfrjgfcu0.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfrjgfcu0.jl:1\n\
    in expression starting at /tmp/tmpfrjgfcu0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        vowels_count = vowels_count\
    \ - 1\n        vowels_index = find(vowels, word)\n        vowels_index = vowels_index\
    \ + 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n        vowels_index = vowels_index\
    \ - 1\n        vowels_index = vowels_index - 1\n\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptpjzcz7h.jl:1\nin expression starting at /tmp/tmptpjzcz7h.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_total\
    \ = 0\n    vowels_count_total = 0\n    vowels_count_total = 0\n    vowels_count_\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgf1imtea.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgf1imtea.jl:1\n\
    in expression starting at /tmp/tmpgf1imtea.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = find(vowels, word) \n    if vowels_idx < length(word) - 1 \n        vowels_idx\
    \ = vowels_idx + 1\n        vowels_idx = find(vowels, word, vowels_idx)\n    \
    \    if vowels_idx < length(word) - 1 \n            return word[vowels_idx]\n\
    \        end\n    end\n    return \"\"\nend\n</cell>\n<code language=julia-1.0>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string as input and\
    \ returns the number of vowels present in the string.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp378m5mk0.jl:27\nin expression starting at\
    \ /tmp/tmp378m5mk0.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_counter\
    \ = 0\n    vowel_position = -1\n    \n    for char in word\n        if char in\
    \ vowels\n            vowel_counter += 1\n            if vowel_counter == 1\n\
    \                vowel_position = word.index(char)\n            end\n        end\n\
    \    end\n    \n    if vowel_position == -1\n        return \"\"\n    end\n  \
    \  \n    vowel_position -= 1\n    \n    if vowel_position < 0\n        vowel_position\
    \ += length(word)\n    end\n    \n    vowel_position -= 1\n    \n    if vowel_position\
    \ < 0\n        vowel_position += length(word)\n    end\n    \n    vowel_position\
    \ -= 1\n    \n    if vowel_position < 0\n        vowel_position += length(word)\n\
    \    end\n    \n    vowel_position -= 1\n    \n    if vowel_position < 0\n   \
    \     vowel_position += length(word)\n    end\n    \n    vowel_position -= 1\n\
    \    \n    if vowel_position < 0\n        vowel_position += length(word)\n   \
    \ end\n    \n    vowel_position -= 1\n    \n    if vowel_position < 0\n      \
    \  vowel_position += length(word)\n    end\n    \n    vowel_position -= 1\n  \
    \  \n    if vowel_position < 0\n        vowel_position += length(word)\n    end\n\
    \    \n    vowel_position -= 1\n    \n    if vowel_position < 0\n        vowel_position\
    \ += length(word)\n    end\n    \n    vowel_position -= 1\n    \n    if vowel_position\
    \ < 0\n        vowel_position += length(word)\n    end\n    \n    vowel_position\
    \ -= 1\n    \n    if vowel_position < 0\n        vowel_position += length(word)\n\
    \    end\n    \n    vowel_position -= 1\n    \n    if vowel_position < 0\n   \
    \     vowel_position += length(word)\n    end\n    \n    vowel_position -= 1\n\
    \    \n    if vowel_position < 0\n        vowel_position += length(word)\n   \
    \ end\n    \n    vowel_position -= 1\n    \n    if vowel_position < 0\n      \
    \  vowel_position += length(word)\n    end\n    \n    vowel_position -= 1\n  \
    \  \n    if vowel_position < 0\n        vowel_position += length(word)\n    end\n\
    \    \n    vowel_position -= 1\n    \n    if vowel_position < 0\n        vowel_position\
    \ += length(word)\n    end\n    \n    vowel_position -= 1\n    \n    if vowel_position\
    \ < 0\n        vowel_position += length(word)\n    end\n    \n    vowel_position\
    \ -= 1\n\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpub91g27v.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpub91g27v.jl:1\n\
    in expression starting at /tmp/tmpub91g27v.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.find{|x| word.ends_with?(x)}\n    vowels_index = if vowels_index ==\
    \ -1 then 0 else vowels_index\n    vowels_index = if vowels_index == -1 then 0\
    \ else vowels_index + 1\n    vowels_index = if vowels_index == -1 then 0 else\
    \ vowels_index\n    vowels_index = if vowels_index == -1 then 0 else vowels_index\
    \ + 1\n    vowels_index = if vowels_index == -1 then 0 else vowels_index + 1\n\
    \    vowels_index = if vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index\
    \ = if vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index = if\
    \ vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index = if vowels_index\
    \ == -1 then 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1\
    \ then 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1 then\
    \ 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1 then 0 else\
    \ vowels_index + 1\n    vowels_index = if vowels_index == -1 then 0 else vowels_index\
    \ + 1\n    vowels_index = if vowels_index == -1 then 0 else vowels_index + 1\n\
    \    vowels_index = if vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index\
    \ = if vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index = if\
    \ vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index = if vowels_index\
    \ == -1 then 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1\
    \ then 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1 then\
    \ 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1 then 0 else\
    \ vowels_index + 1\n    vowels_index = if vowels_index == -1 then 0 else vowels_index\
    \ + 1\n    vowels_index = if vowels_index == -1 then 0 else vowels_index + 1\n\
    \    vowels_index = if vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index\
    \ = if vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index = if\
    \ vowels_index == -1 then 0 else vowels_index + 1\n    vowels_index = if vowels_index\
    \ == -1 then 0 else vowels_index + 1\n    vowels_index = if vowels_index == -1\
    \ then 0 else vowels_index + 1\n    vowels_index = if vowels_index == \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbu7f2g2u.jl:17\nin expression starting at\
    \ /tmp/tmpbu7f2g2u.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 2\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    \n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    \n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    \n    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    \n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    \n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    \n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    \n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    \n    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    \n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    \n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    \n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    \n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    \n    vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpry5wqvgq.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpry5wqvgq.jl:19\n\
    in expression starting at /tmp/tmpry5wqvgq.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels)\
    \ else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count +\
    \ 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels)\
    \ else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count +\
    \ 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count \nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpevko5s9j.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpevko5s9j.jl:18\n\
    in expression starting at /tmp/tmpevko5s9j.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= 4\n    \n    if vowels_count == 0:\n        return \"\
    \"\n    elif vowels_count == 1:\n        return vowels[vowels_count]\n    elif\
    \ vowels_count == 2:\n        return vowels[vowels_count-1]\n    elif vowels_count\
    \ == 3:\n        return vowels[vowels_count-2]\n    else:\n        return \"\"\
    \nend\n</cell>\n<code language=julia-1.0>\nget_closest_vowel(\"yogurt\")\n</cell>\n\
    <code language=julia-1.0>\nget_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.0>\n\
    get_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.0>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7tvjffw4.jl:28\nin expression starting at\
    \ /tmp/tmp7tvjffw4.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowel_counter = 0\n    vowel_counter = vowels.count(word[vowel_counter])\n\
    \    if vowel_counter == 0 \n        vowel_counter = vowels.count(word[vowel_counter])\n\
    \    ending_vowel_counter = 0\n    ending_vowel_counter = vowels.count(word[ending_vowel_counter])\n\
    \    if ending_vowel_counter == 0 \n        ending_vowel_counter = vowels.count(word[ending_vowel_counter])\n\
    \    \n    if vowel_counter > ending_vowel_counter\n        closest_vowel = word[vowel_counter]\n\
    \    else\n        closest_vowel = word[ending_vowel_counter]\n    end\n    return\
    \ closest_vowel\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvrs5c1nn.jl:33\nin expression starting at\
    \ /tmp/tmpvrs5c1nn.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_index == -1 \n      \
    \  then return \"\"\n    else \n        vowels_index += end\n        vowels_index\
    \ %= vowels.length\n        return vowels[vowels_index]\nend\n</cell>\n<code language=julia-1.4>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpx0ihfvy8.jl:19\nin expression starting at /tmp/tmpx0ihfvy8.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n\
    \    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n\
    \    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n\
    \    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n\
    \    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n\
    \    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n\
    \    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + vowels_count\n    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n\
    \    vowels_count -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n\
    \    vowels_count %= vowels_count + vowels_count\n    vowels_count -= 1\n    vowels_\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8qo9uao7.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8qo9uao7.jl:1\n\
    in expression starting at /tmp/tmp8qo9uao7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    if vowels_count < 2:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_index = vowels.index(\"\
    u\")\n    vowels_index += vowels.index(\"o\")\n    vowels_index += vowels.index(\"\
    e\")\n    vowels_index += vowels.index(\"a\")\n    \n    vowels_index = vowels_index\
    \ - vowels_count if vowels_index > 0 else 0\n    \n    vowels_index = vowels_index\
    \ if vowels_index < len(vowels) else len(vowels)-1\n    \n    vowel = vowels[vowels_index]\n\
    \    \n    if vowel in word:\n        return vowel\n    \n    return \"\"\nend\n\
    </cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"u\"\n\
    get_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\n\
    get_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that takes a string and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp77ekjg5f.jl:24\nin expression starting at\
    \ /tmp/tmp77ekjg5f.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    if vowels_len == 0 \n        return \"\"\n    \n  \
    \  vowels_idx = word.rindex(vowels)\n    \n    if vowels_idx == -1 \n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels[vowels_idx]\
    \ == \"a\" \n        return \"a\"\n    \n    if vowels[vowels_idx] == \"e\" \n\
    \        return \"e\"\n    \n    if vowels[vowels_idx] == \"i\" \n        return\
    \ \"i\"\n    \n    if vowels[vowels_idx] == \"o\" \n        return \"o\"\n   \
    \ \n    if vowels[vowels_idx] == \"u\" \n        return \"u\"\n    \n    return\
    \ \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\"\
    )\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string and returns the number of vowels found in the string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdicar8i1.jl:46\nin expression starting at\
    \ /tmp/tmpdicar8i1.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(x => x == word[end])\n    if vowels_idx > -1 && vowels_idx\
    \ < word.length \n        && vowels[vowels_idx+1] == word[end+1]\n        then\
    \ word[end+1]\n        else \"\"\n    end\nend\n</cell>\n<text>\nSolution\nLet's\
    \ see how we implement this in Julia:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"&&\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvpjfa2_e.jl:19\nin expression starting at\
    \ /tmp/tmpvpjfa2_e.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5oghbx61.jl:1\nin expression starting at /tmp/tmp5oghbx61.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains)\n    vowels_idx = vowels_idx + 1\n \
    \   vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowel\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5w9zn2un.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5w9zn2un.jl:1\n\
    in expression starting at /tmp/tmp5w9zn2un.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfrdcmxou.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfrdcmxou.jl:1\n\
    in expression starting at /tmp/tmpfrdcmxou.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        vowels_index = find(vowels,\
    \ word, 1)\n        if vowels_index == length(word)\n            return \"\"\n\
    \        else\n            vowels_index = vowels_index + 1\n            vowels_index\
    \ = find(vowels, word, vowels_index)\n            if vowels_index == length(word)\n\
    \                return \"\"\n            else\n                return word[vowels_index]\n\
    \            end\n        end\n    else\n        return \"\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <text>\nProblem 2\nWrite a function that takes a string and returns the number\
    \ of vowels found in the string.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp23zv2fau.jl:35\nin expression starting at\
    \ /tmp/tmp23zv2fau.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    if vowels[vowels_idx] == word[vowels_idx + 1]\n        return\
    \ word[vowels_idx]\n    else\n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpekvk05h8.jl:33\nin expression starting at\
    \ /tmp/tmpekvk05h8.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1jw5io3n.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1jw5io3n.jl:1\n\
    in expression starting at /tmp/tmp1jw5io3n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(x => x == word)\n    if vowels_index == -1 \n        return\
    \ \"\"\n    \n    vowels_index_start = vowels_index + 1\n    vowels_index_end\
    \ = vowels_index + 2\n    \n    if vowels_index_start == vowels_index_end\n  \
    \      return \"\"\n    \n    vowels_index_start_2 = vowels_index_start + 1\n\
    \    vowels_index_end_2 = vowels_index_end + 1\n    \n    if vowels_index_start_2\
    \ == vowels_index_end_2\n        return \"\"\n    \n    vowels_index_start_3 =\
    \ vowels_index_start + 2\n    vowels_index_end_3 = vowels_index_end + 2\n    \n\
    \    if vowels_index_start_3 == vowels_index_end_3\n        return \"\"\n    \n\
    \    vowels_index_start_4 = vowels_index_start + 3\n    vowels_index_end_4 = vowels_index_end\
    \ + 3\n    \n    if vowels_index_start_4 == vowels_index_end_4\n        return\
    \ \"\"\n    \n    vowels_index_start_5 = vowels_index_start + 4\n    vowels_index_end_5\
    \ = vowels_index_end + 4\n    \n    if vowels_index_start_5 == vowels_index_end_5\n\
    \        return \"\"\n    \n    vowels_index_start_6 = vowels_index_start + 5\n\
    \    vowels_index_end_6 = vowels_index_end + 5\n    \n    if vowels_index_start_6\
    \ == vowels_index_end_6\n        return \"\"\n    \n    vowels_index_start_7 =\
    \ vowels_index_start + 6\n    vowels_index_end_7 = vowels_index_end + 6\n    \n\
    \    if vowels_index_start_7 == vowels_index_end_7\n        return \"\"\n    \n\
    \    vowels_index_start_8 = vowels_index_start + 7\n    vowels_index_end_8 = vowels_index_end\
    \ + 7\n    \n    if vowels_index_start_8 == vowels_index_end_8\n        return\
    \ \"\"\n    \n    vowels_index_start_9 = vowels_index_start + 8\n    vowels_index_end_9\
    \ = vowels_index_end + 8\n    \n    if vowels_index_start_9 == vowels_index_end_9\n\
    \        return \"\"\n    \n    vowels_index_start_10 = vowels_index_start + 9\n\
    \    vowels_index_end_10 = vowels_index_end + 9\n    \n    if vowels_index_start_10\
    \ == vowels_index_end_10\n        return \"\"\n    \n    vowels_index_start_11\
    \ = vowels_index_start + 10\n    vowels_index_end_11 = vowels_index_end + 10\n\
    \    \n    if vowels_index_start_11 == vowels_index_\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo2uwt47j.jl:1\nin expression starting at /tmp/tmpo2uwt47j.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|v| word =~ /[#{v}]/}\n    if vowels_idx == -1\n        return\
    \ \"\"\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[vowels_idx]}]+/\n        ending_vowel_idx += 1\n    ending_vowel\
    \ = vowels[ending_vowel_idx]\n    vowels_idx = vowels.find{|v| word =~ /[#{v}]/}\n\
    \    if vowels_idx == -1\n        return \"\"\n    vowels_idx = vowels_idx + 1\n\
    \    while vowels[vowels_idx] =~ /[#{vowels[ending_vowel_idx]}]+/\n        vowels_idx\
    \ += 1\n    vowel = vowels[vowels_idx]\n    if vowel =~ /[#{vowel}]/\n       \
    \ return vowel\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[vowels_idx]}]+/\n        ending_vowel_idx += 1\n    ending_vowel\
    \ = vowels[ending_vowel_idx]\n    if ending_vowel =~ /[#{vowel}]/\n        return\
    \ ending_vowel\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[vowels_idx]}]+/\n        ending_vowel_idx += 1\n    ending_vowel\
    \ = vowels[ending_vowel_idx]\n    if ending_vowel =~ /[#{vowel}]/\n        return\
    \ ending_vowel\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[vowels_idx]}]+/\n        ending_vowel_idx += 1\n    ending_vowel\
    \ = vowels[ending_vowel_idx]\n    if ending_vowel =~ /[#{vowel}]/\n        return\
    \ ending_vowel\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[vowels_idx]}]+/\n        ending_vowel_idx += 1\n    ending_vowel\
    \ = vowels[ending_vowel_idx]\n    if ending_vowel =~ /[#{vowel}]/\n        return\
    \ ending_vowel\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[vowels_idx]}]+/\n        ending_vowel_idx += 1\n    ending_vowel\
    \ = vowels[ending_vowel_idx]\n    if ending_vowel =~ /[#{vowel}]/\n        return\
    \ ending_vowel\n    ending_vowel_idx = vowels_idx + 1\n    while vowels[ending_vowel_idx]\
    \ =~ /[#{vowels[\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ltt3tpv.jl:17\nin expression starting at\
    \ /tmp/tmp6ltt3tpv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpv2c1xxrb.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpv2c1xxrb.jl:1\n\
    in expression starting at /tmp/tmpv2c1xxrb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 1\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 1\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 1\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 1\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 1\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 1\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 1\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 1\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 1\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 1\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 1\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 1\n    vowels_count = vowels_count if\
    \ \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp4iu4r7ib.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4iu4r7ib.jl:19\n\
    in expression starting at /tmp/tmp4iu4r7ib.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1 \n      \
    \  return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0 \n        vowels_idx = vowels.length\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.length \n        vowels_idx = 0\n    \n\
    \    vowel = vowels[vowels_idx]\n    \n    return vowel\nend\n</cell>\n<code language=julia-1.6>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.6>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.6>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.6>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoxrn9qxh.jl:35\nin expression starting at\
    \ /tmp/tmpoxrn9qxh.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    if vowels_len == 0 \n        error(\"vowels length\
    \ is zero\")\n    \n    if word.length == 0 \n        error(\"word length is zero\"\
    )\n    \n    vowels_count = 0\n    \n    for i in word\n        if vowels.contains(i)\n\
    \            vowels_count += 1\n    \n    if vowels_count == 0\n        error(\"\
    word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count\
    \ < 0\n        error(\"word doesn't contain any vowel\")\n    \n    vowels_count\
    \ -= 1\n    \n    if vowels_count < 0\n        error(\"word doesn't contain any\
    \ vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count < 0\n     \
    \   error(\"word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n \
    \   \n    if vowels_count < 0\n        error(\"word doesn't contain any vowel\"\
    )\n    \n    vowels_count -= 1\n    \n    if vowels_count < 0\n        error(\"\
    word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count\
    \ < 0\n        error(\"word doesn't contain any vowel\")\n    \n    vowels_count\
    \ -= 1\n    \n    if vowels_count < 0\n        error(\"word doesn't contain any\
    \ vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count < 0\n     \
    \   error(\"word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n \
    \   \n    if vowels_count < 0\n        error(\"word doesn't contain any vowel\"\
    )\n    \n    vowels_count -= 1\n    \n    if vowels_count < 0\n        error(\"\
    word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count\
    \ < 0\n        error(\"word doesn't contain any vowel\")\n    \n    vowels_count\
    \ -= 1\n    \n    if vowels_count < 0\n        error(\"word doesn't contain any\
    \ vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count < 0\n     \
    \   error(\"word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n \
    \   \n    if vowels_count < 0\n        error(\"word doesn't contain any vowel\"\
    )\n    \n    vowels_count -= 1\n    \n    if vowels_count < 0\n        error(\"\
    word doesn't contain any vowel\")\n    \n    vowels_count -= 1\n    \n    if vowels_count\
    \ < 0\n        error(\"word doesn't contain any vowel\")\n    \n    vowels_count\
    \ -= 1\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptsackz2g.jl:1\nin expression starting at /tmp/tmptsackz2g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|v| word.endwith?(v)} \n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    vowels_idx = vowels_idx - 1\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoqbefu4a.jl:17\nin expression starting at\
    \ /tmp/tmpoqbefu4a.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpl0y4l9lh.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl0y4l9lh.jl:19\n\
    in expression starting at /tmp/tmpl0y4l9lh.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6_4yvgmf.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6_4yvgmf.jl:1\n\
    in expression starting at /tmp/tmp6_4yvgmf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n       \
    \ vowels_idx = vowels.lenght - 1\n    \n    vowels_idx = vowels_idx + 1\n    if\
    \ vowels_idx > vowels.lenght - 1\n        vowels_idx = 0\n    \n    return vowels[vowels_idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfwxj8g2f.jl:1\nin expression starting at /tmp/tmpfwxj8g2f.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count += 2\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowels_count += 2\n    \n    vowels_count\
    \ %= len(vowels)\n    \n    vowels_count += 2\n    \n    vowels_count %= len(vowels)\n\
    \    \n    vowels_count += 2\n    \n    vowels_count %= len(vowels)\n    \n  \
    \  vowels_count += 2\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count\
    \ += 2\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count += 2\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count += 2\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowels_count += 2\n    \n    vowels_count\
    \ %= len(vowels)\n    \n    vowels_count += 2\n    \n    vowels_count %= len(vowels)\n\
    \    \n    vowels_count += 2\n    \n    vowels_count %= len(vowels)\n    \n  \
    \  vowels_count += 2\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count\
    \ += 2\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count += 2\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count += 2\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowels_count += 2\n    \n    vowels_count\
    \ %= len(vowels)\n    \n    vowels_count += 2\n    \n    vowels_count %= len(vowels)\n\
    \    \n    vowels_count += 2\n    \n    vowels_count %= len(vowels)\n    \n  \
    \  vowels_count += 2\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count\
    \ += 2\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count += 2\n \
    \   \n    vowels_count %= len(vowels)\n    \n\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbtb7wtg_.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbtb7wtg_.jl:1\n\
    in expression starting at /tmp/tmpbtb7wtg_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_total = 0\n    vowels_count_left\
    \ = 0\n    vowels_count_right = 0\n    vowels_count_left_total = 0\n    vowels_count_right_total\
    \ = 0\n    vowels_count_left_left = 0\n    vowels_count_left_right = 0\n    vowels_count_right_left\
    \ = 0\n    vowels_count_right_right = 0\n    \n    for char in word\n        if\
    \ char in vowels\n            vowels_count += 1\n            vowels_count_total\
    \ += 1\n            if vowels_count_total == 1\n                vowels_count_left\
    \ = vowels_count_right\n                vowels_count_left_total = vowels_count_right_total\n\
    \                vowels_count_left_left = vowels_count_right_left\n          \
    \      vowels_count_left_right = vowels_count_right_right\n            else\n\
    \                if vowels_count_left == 0\n                    vowels_count_left\
    \ = vowels_count_right\n                    vowels_count_left_total = vowels_count_right_total\n\
    \                    vowels_count_left_left = vowels_count_right_left\n      \
    \              vowels_count_left_right = vowels_count_right_right\n          \
    \      else\n                    if vowels_count_left_total == 0\n           \
    \             vowels_count_left_total = vowels_count_right_total\n           \
    \             vowels_count_left_left = vowels_count_right_left\n             \
    \           vowels_count_left_right = vowels_count_right_right\n             \
    \       else\n                        if vowels_count_left == vowels_count_left_total\n\
    \                            vowels_count_left_left = vowels_count_right_left\n\
    \                            vowels_count_left_right = vowels_count_right_right\n\
    \                        else\n                            if vowels_count_left\
    \ == vowels_count_left_left\n                                vowels_count_left_right\
    \ = vowels_count_right_left\n                                vowels_count_left_right\
    \ = vowels_count_right_right\n                            else\n             \
    \                   if vowels_count_left == vowels_count_left_right\n        \
    \                            vowels_count_left_right = vowels_count_right_left\n\
    \                                    vowels_count_left_right = vowels_count_right_right\n\
    \                                else\n                                    if\
    \ vowels_count_left == vowels_count_left_right\n                             \
    \           vowels_count_left_right = vowels_count_right_left\n              \
    \                          vowels_count_left_right = vowels_count_right_right\n\
    \                                    else\n                                  \
    \      if vowels_count_left == vowels_count_left_right\n                     \
    \                       vowels_count_left_right = vowels_count_right_left\n  \
    \                                          vowels_count_left_right = vowels_count_right_right\n\
    \                                        else\n                              \
    \              if vowels_count_left == vowels_count_left_right\n             \
    \                                   vowels_count_left_right = vowels_count_right_left\n\
    \                                                vowels_count_left_right = vowels_count_right_right\n\
    \                                            else\n                          \
    \                      if vowels_count_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdspmhi1j.jl:1\nin expression starting at /tmp/tmpdspmhi1j.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= 4\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    vowels_count -= 1\n    vowels_count %= \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxon3hlo7.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxon3hlo7.jl:1\n\
    in expression starting at /tmp/tmpxon3hlo7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = vowels.count(\"aeiou\")\n    vowels_count = vowels_count + vowels.count(\"\
    AEIOU\")\n    vowels_count = vowels_count + vowels.count(\"a\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"A\")\n    vowels_count = vowels_count + vowels.count(\"\
    e\")\n    vowels_count = vowels_count + vowels.count(\"E\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"i\")\n    vowels_count = vowels_count + vowels.count(\"\
    I\")\n    vowels_count = vowels_count + vowels.count(\"o\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"O\")\n    vowels_count = vowels_count + vowels.count(\"\
    u\")\n    vowels_count = vowels_count + vowels.count(\"U\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"y\")\n    vowels_count = vowels_count + vowels.count(\"\
    Y\")\n    vowels_count = vowels_count + vowels.count(\"r\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"R\")\n    vowels_count = vowels_count + vowels.count(\"\
    l\")\n    vowels_count = vowels_count + vowels.count(\"L\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"s\")\n    vowels_count = vowels_count + vowels.count(\"\
    S\")\n    vowels_count = vowels_count + vowels.count(\"c\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"C\")\n    vowels_count = vowels_count + vowels.count(\"\
    p\")\n    vowels_count = vowels_count + vowels.count(\"P\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"f\")\n    vowels_count = vowels_count + vowels.count(\"\
    F\")\n    vowels_count = vowels_count + vowels.count(\"v\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"V\")\n    vowels_count = vowels_count + vowels.count(\"\
    k\")\n    vowels_count = vowels_count + vowels.count(\"K\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"m\")\n    vowels_count = vowels_count + vowels.count(\"\
    M\")\n    vowels_count = vowels_count + vowels.count(\"b\")\n    vowels_count\
    \ = vowels_count + vowels.count(\"B\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: cannot juxtapose string literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4cqnfuks.jl:56\nin expression starting at\
    \ /tmp/tmp4cqnfuks.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n    vowels_count\
    \ %= len(vowels)\n    \n    vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n\
    \    \n    vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n    \n  \
    \  vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n    vowels_count\
    \ %= len(vowels)\n    \n    vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n\
    \    \n    vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n    \n  \
    \  vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n    vowels_count\
    \ %= len(vowels)\n    \n    vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n\
    \    \n    vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n    \n  \
    \  vowels_count -= 1\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= len(vowels)\n    \n    vowels_count -= 1\n    \n   \
    \ vowels_count %= len(vowels)\n    \n    vowel\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp99v6wbif.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp99v6wbif.jl:1\n\
    in expression starting at /tmp/tmp99v6wbif.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1\n       \
    \ return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0\n        vowels_idx = vowels.size - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = 0\n   \
    \ \n    return vowels[vowels_idx]\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nProblem 3\nWrite a function that takes\
    \ a string as input and returns the number of vowels present in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf7oebp73.jl:33\nin expression starting at\
    \ /tmp/tmpf7oebp73.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    \n    for letter\
    \ in word:\n        if letter in vowels:\n            vowels_count += 1\n    \
    \        vowels_index += 1\n            if vowels_index == vowels_len:\n     \
    \           return letter\n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\") ==> \"U\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\") ==> \"\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\"\
    ) ==> \"\"\n</cell>\n<text>\nProblem 3\nWrite a function that takes a string as\
    \ input and returns the number of vowels \n    in the string. \n    \n    Example:\n\
    \    count_vowels(\"yogurt\") ==> 2\n    count_vowels(\"FULL\") ==> 0\n    count_vowels(\"\
    quick\") ==> 0\n    count_vowels(\"ab\") ==> 0\n    count_vowels(\"a\") ==> 0\n\
    \    count_vowels(\"\") ==> 0\n    count_vowels(\" \") ==> 0\n    count_vowels(\"\
    aa \") ==> 0\n    count_vowels(\"aaa\") ==> 0\n    count_vowels(\"aaaa\") ==>\
    \ 0\n    count_vowels(\"aaaaa\") ==> 0\n    count_vowels(\"aaaaaa\") ==> 0\n \
    \   count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n   \
    \ count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"\
    aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\"\
    ) ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==>\
    \ 0\n    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n\
    \    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n  \
    \  count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"\
    aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\") ==> 0\n    count_vowels(\"aaaaaaa\"\
    ) ==> 0\n    count_vowels(\"aaaaaaa\") ==\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpls1xni5y.jl:22\nin expression starting at\
    \ /tmp/tmpls1xni5y.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowel_start = word[vowels_len-2]\n    vowel_end = word[vowels_len-1]\n\
    \    \n    if vowel_start in vowels and vowel_end in vowels:\n        return vowel_start\n\
    \    elif vowel_start in vowels and vowel_end not in vowels:\n        return vowel_end\n\
    \    elif vowel_start not in vowels and vowel_end in vowels:\n        return vowel_end\n\
    \    elif vowel_start not in vowels and vowel_end not in vowels:\n        return\
    \ \"\"\n    else:\n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowel_end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpk7gfa6pt.jl:22\nin expression starting at /tmp/tmpk7gfa6pt.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|v| word.ends_with?(v)} \n    vowels_idx == -1 ? \"\" : vowels[vowels_idx..-1]\n\
    end\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") \n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"FULL\") \n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"quick\") \n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\") \n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and\
    \ returns the number of vowels found in the string.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9ns2upqy.jl:17\nin expression starting at\
    \ /tmp/tmp9ns2upqy.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = find(vowels, word)\n    if vowels_index == -1\n        return \"\"\n    \n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > length(word) - 2\n        vowels_index = length(word)\
    \ - 2\n    \n    vowels_index = vowels_index + 1\n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcqtom2vs.jl:1\nin expression starting at /tmp/tmpcqtom2vs.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        return \"\"\n    \n\
    \    vowels_count = count(vowels, word[1:end-1])\n    if vowels_count > 1\n  \
    \      return \"\"\n    \n    vowels_count = count(vowels, word[2:end])\n    if\
    \ vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[3:end])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[4:end])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[5:end])\n    if vowels_count > 1\n\
    \        return \"\"\n    \n    vowels_count = count(vowels, word[6:end])\n  \
    \  if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[7:end])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[8:end])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[9:end])\n    if vowels_count > 1\n\
    \        return \"\"\n    \n    vowels_count = count(vowels, word[10:end])\n \
    \   if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[11:end])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[12:end])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[13:end])\n    if vowels_count > 1\n\
    \        return \"\"\n    \n    vowels_count = count(vowels, word[14:end])\n \
    \   if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[15:end])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[16:end])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[17:end])\n    if vowels_count > 1\n\
    \        return \"\"\n    \n    vowels_count = count(vowels, word[18:end])\n \
    \   if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[19:end])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu5zha9gx.jl:98\nin expression starting at\
    \ /tmp/tmpu5zha9gx.jl:98\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1\n       \
    \ return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if\
    \ vowels_idx >= length(vowels)\n        return \"\"\n    \n    return vowels[vowels_idx]\n\
    end\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"\
    u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\
    \"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw5emx41i.jl:33\nin expression starting at\
    \ /tmp/tmpw5emx41i.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count_right = count(vowels,1)\n    vowels_count_left\
    \ = count(vowels,-1)\n    \n    if vowels_count > 0 and vowels_count_right > 0\
    \ and vowels_count_left > 0:\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left - 1\n        \n        vowels_count_right\
    \ = vowels_count_right - 1\n        vowels_count_left = vowels_count_left - 1\n\
    \        \n        vowels_count_right = vowels_count_right - 1\n        vowels_count_left\
    \ = vowels_count_left - 1\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left - 1\n        \n        vowels_count_right\
    \ = vowels_count_right - 1\n        vowels_count_left = vowels_count_left - 1\n\
    \        \n        vowels_count_right = vowels_count_right - 1\n        vowels_count_left\
    \ = vowels_count_left - 1\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left - 1\n        \n        vowels_count_right\
    \ = vowels_count_right - 1\n        vowels_count_left = vowels_count_left - 1\n\
    \        \n        vowels_count_right = vowels_count_right - 1\n        vowels_count_left\
    \ = vowels_count_left - 1\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left - 1\n        \n        vowels_count_right\
    \ = vowels_count_right - 1\n        vowels_count_left = vowels_count_left - 1\n\
    \        \n        vowels_count_right = vowels_count_right - 1\n        vowels_count_left\
    \ = vowels_count_left - 1\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left - 1\n        \n        vowels_count_right\
    \ = vowels_count_right - 1\n        vowels_count_left = vowels_count_left - 1\n\
    \        \n        vowels_count_right = vowels_count_right - 1\n        vowels_count_left\
    \ = vowels_count_left - 1\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left - 1\n        \n        vowels_count_right\
    \ = vowels_count_right - 1\n        vowels_count_left = vowels_count_left - 1\n\
    \        \n        vowels_count_right = vowels_count_right - 1\n        vowels_count_left\
    \ = vowels_count_left - 1\n        \n        vowels_count_right = vowels_count_right\
    \ - 1\n        vowels_count_left = vowels_count_left \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowels_count_right\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpau77q0qt.jl:21\nin expression starting at\
    \ /tmp/tmpau77q0qt.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count\
    \ %= vowels_count + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count\
    \ + 1\n    vowels_count -= 1\n    vowels_count %= vowels_count + 1\n    vowels_count\
    \ -= 1\n    vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz20n7ds1.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz20n7ds1.jl:1\n\
    in expression starting at /tmp/tmpz20n7ds1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_pos\
    \ = word.rfindAll(vowels)\n    if vowel_pos == -1\n        return \"\"\n    \n\
    \    vowel_pos = vowel_pos[-1]\n    vowel_pos = vowel_pos - 1\n    \n    vowel_pos_2\
    \ = word.rfindAll(vowels, vowel_pos)\n    if vowel_pos_2 == -1\n        return\
    \ \"\"\n    \n    vowel_pos_2 = vowel_pos_2[-1]\n    vowel_pos_2 = vowel_pos_2\
    \ - 1\n    \n    if vowel_pos > vowel_pos_2\n        return \"\"\n    \n    if\
    \ vowel_pos < vowel_pos_2\n        return \"\"\n    \n    vowel_pos_3 = word.rfindAll(vowels,\
    \ vowel_pos_2)\n    if vowel_pos_3 == -1\n        return \"\"\n    \n    vowel_pos_3\
    \ = vowel_pos_3[-1]\n    vowel_pos_3 = vowel_pos_3 - 1\n    \n    if vowel_pos\
    \ == vowel_pos_2 and vowel_pos == vowel_pos_3\n        return \"\"\n    \n   \
    \ if vowel_pos == vowel_pos_2 and vowel_pos > vowel_pos_3\n        return \"\"\
    \n    \n    if vowel_pos == vowel_pos_2 and vowel_pos < vowel_pos_3\n        return\
    \ \"\"\n    \n    if vowel_pos == vowel_pos_3 and vowel_pos == vowel_pos_2\n \
    \       return \"\"\n    \n    if vowel_pos == vowel_pos_3 and vowel_pos > vowel_pos_2\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_3 and vowel_pos < vowel_pos_2\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_2 and vowel_pos == vowel_pos_3\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_2 and vowel_pos > vowel_pos_3\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_2 and vowel_pos < vowel_pos_3\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_3 and vowel_pos == vowel_pos_2\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_3 and vowel_pos > vowel_pos_2\n\
    \        return \"\"\n    \n    if vowel_pos == vowel_pos_3 and vowel_pos < vowel_pos_2\n\
    \        return \"\"\n    \n    return word[vowel_pos]\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowel_pos\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnp9pwfzv.jl:44\nin expression starting at /tmp/tmpnp9pwfzv.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_left = 0\n    vowels_count_left_right = 0\n    vowels_count_right_left\
    \ = 0\n    vowels_count_right_right = 0\n    for letter in word\n        if letter\
    \ in vowels\n            vowels_count += 1\n            if vowels_count > 1\n\
    \                vowels_count_left += 1\n                if vowels_count_left\
    \ > 1\n                    vowels_count_left_left += 1\n                    if\
    \ vowels_count_left_left > 1\n                        vowels_count_left_right\
    \ += 1\n                        if vowels_count_left_right > 1\n             \
    \               vowels_count_right_left += 1\n                            if vowels_count_right_left\
    \ > 1\n                                vowels_count_right_right += 1\n       \
    \                         if vowels_count_right_right > 1\n                  \
    \                  return letter\n                            end\n          \
    \              end\n                    end\n                end\n           \
    \ end\n        end\n    end\n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of vowels\
    \ found in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwv7kutc6.jl:48\nin expression starting at\
    \ /tmp/tmpwv7kutc6.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowel_start = 0\n    vowel_end = vowels_len\n    \n\
    \    vowel_found = False\n    \n    for char in word:\n        if char in vowels:\n\
    \            vowel_start = char\n            vowel_end = char\n            vowel_found\
    \ = True\n            break\n    \n    if vowel_found:\n        vowel_start +=\
    \ 1\n        vowel_end -= 1\n        \n        if vowel_start > vowel_end:\n \
    \           vowel_start = vowel_end\n            vowel_end = vowel_start\n   \
    \         \n        vowel_mid = vowel_start + (vowel_end - vowel_start) / 2\n\
    \        \n        if vowel_mid < vowel_end:\n            return vowels[vowel_mid]\n\
    \        else:\n            return \"\"\n    else:\n        return \"\"\nend\n\
    </cell>\n<code language=julia-1.3>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code\
    \ language=julia-1.3>\nget_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.3>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.3>\nget_closest_vowel(\"\
    ab\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdpo02jyx.jl:25\nin expression starting at\
    \ /tmp/tmpdpo02jyx.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowel_counter = 0\n    vowel_counter = vowels.count(\"a\"\
    )\n    vowel_counter = vowel_counter + vowels.count(\"e\")\n    vowel_counter\
    \ = vowel_counter + vowels.count(\"i\")\n    vowel_counter = vowel_counter + vowels.count(\"\
    o\")\n    vowel_counter = vowel_counter + vowels.count(\"u\")\n    \n    if vowel_counter\
    \ == 4:\n        return \"u\"\n    elif vowel_counter == 3:\n        return \"\
    u\"\n    elif vowel_counter == 2:\n        return \"u\"\n    elif vowel_counter\
    \ == 1:\n        return \"u\"\n    elif vowel_counter == 0:\n        return \"\
    \"\n    else:\n        return \"\"\nend\n</cell>\n<code language=julia-1.1>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplzrjys8r.jl:25\nin expression starting at\
    \ /tmp/tmplzrjys8r.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp53_kqp1.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpp53_kqp1.jl:1\n\
    in expression starting at /tmp/tmpp53_kqp1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_index == -1\n       \
    \ return \"\"\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index -\
    \ 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index +\
    \ 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n\
    \    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n  \
    \  vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index -\
    \ 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index +\
    \ 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n\
    \    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n  \
    \  vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    vowels_index = vowels_index + 1\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppes_zro1.jl:1\nin expression starting at /tmp/tmppes_zro1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_index == -1\n     \
    \   return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    \n    if vowels_index > 0\n        return word[vowels_index]\n\
    \    \n    if vowels_index < len(word)\n        return word[vowels_index]\n  \
    \  \n    return \"\"\nend\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3zljhqad.jl:1\nin expression starting at /tmp/tmp3zljhqad.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_start = 0\n    vowels_count_end\
    \ = 0\n    vowels_count_start_end = 0\n    vowels_count_start_end_count = 0\n\
    \    vowels_count_start_end_count_start = 0\n    vowels_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end = 0\n    vowels_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start = 0\n    vowels_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end = 0\n    vowels_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_end =\
    \ 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnjhhh5m9.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnjhhh5m9.jl:1\n\
    in expression starting at /tmp/tmpnjhhh5m9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0ntp5twz.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0ntp5twz.jl:1\n\
    in expression starting at /tmp/tmp0ntp5twz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_counter\
    \ = 0\n    vowel_position = 0\n    \n    for letter in word\n        if letter\
    \ in vowels\n            vowel_counter += 1\n            vowel_position = vowel_counter\n\
    \        else\n            break\n    end\n    \n    if vowel_position == 0\n\
    \        return \"\"\n    end\n    \n    vowel_position -= 1\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n    end\n    \n    if vowel_position\
    \ < 0\n        vowel_position += vowel_counter\n\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjli2b5uh.jl:1\nin expression starting at /tmp/tmpjli2b5uh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(w => w == word)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.length\n        return \"\"\n    \n    vowels_index = vowels_index -\
    \ 1\n    \n    if vowels_index < 0\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    \n    if vowels_index > vowels.length\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index <\
    \ 0\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n  \
    \  if vowels_index > vowels.length\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index < 0\n        return \"\"\n   \
    \ \n    vowels_index = vowels_index + 1\n    \n    if vowels_index > vowels.length\n\
    \        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if\
    \ vowels_index < 0\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > vowels.length\n        return \"\"\n    \n\
    \    vowels_index = vowels_index - 1\n    \n    if vowels_index < 0\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ vowels.length\n        return \"\"\n    \n    vowels_index = vowels_index -\
    \ 1\n    \n    if vowels_index < 0\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    \n    if vowels_index > vowels.length\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index <\
    \ 0\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n  \
    \  if vowels_index > vowels.length\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index < 0\n        return \"\"\n   \
    \ \n    vowels_index = vowels_index + 1\n    \n    if vowels_index > vowels.length\n\
    \        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if\
    \ vowels_index < 0\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > vowels.length\n        return \"\"\n    \n\
    \    vowels_index = vowels_index - 1\n    \n    if vowels_index < 0\n        return\
    \ \"\"\n    \n    vowels_index = vowels_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptj726vt4.jl:1\nin expression starting at /tmp/tmptj726vt4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6hu_l_7i.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6hu_l_7i.jl:1\n\
    in expression starting at /tmp/tmp6hu_l_7i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    if vowels_len == 0 \n        return \"No vowels found\"\
    \n    \n    vowels_index = -1\n    \n    for index in (word.length() - 1)::-1\
    \ \n        if vowels[index] == word[index + 1]\n            vowels_index = index\n\
    \            break\n    \n    if vowels_index == -1\n        return \"No vowels\
    \ found\"\n    \n    vowels_index_2 = -1\n    \n    for index in (word.length()\
    \ - 1)::-1 \n        if vowels[index] == word[index + vowels_len]\n          \
    \  vowels_index_2 = index\n            break\n    \n    if vowels_index_2 == -1\n\
    \        return \"No vowels found\"\n    \n    if vowels_index == vowels_index_2\n\
    \        return \"\"\n    \n    vowels_index_3 = -1\n    \n    for index in (word.length()\
    \ - 1)::-1 \n        if vowels[index] == word[index + 2 * vowels_len]\n      \
    \      vowels_index_3 = index\n            break\n    \n    if vowels_index_3\
    \ == -1\n        return \"No vowels found\"\n    \n    if vowels_index == vowels_index_3\n\
    \        return \"\"\n    \n    vowels_index_4 = -1\n    \n    for index in (word.length()\
    \ - 1)::-1 \n        if vowels[index] == word[index + 3 * vowels_len]\n      \
    \      vowels_index_4 = index\n            break\n    \n    if vowels_index_4\
    \ == -1\n        return \"No vowels found\"\n    \n    if vowels_index == vowels_index_4\n\
    \        return \"\"\n    \n    vowels_index_5 = -1\n    \n    for index in (word.length()\
    \ - 1)::-1 \n        if vowels[index] == word[index + 4 * vowels_len]\n      \
    \      vowels_index_5 = index\n            break\n    \n    if vowels_index_5\
    \ == -1\n        return \"No vowels found\"\n    \n    if vowels_index == vowels_index_5\n\
    \        return \"\"\n    \n    vowels_index_6 = -1\n    \n    for index in (word.length()\
    \ - 1)::-1 \n        if vowels[index] == word[index + 5 * vowels_len]\n      \
    \      vowels_index_6 = index\n            break\n    \n    if vowels_index_6\
    \ == -1\n        return \"No vowels found\"\n    \n    if vowels_index == vowels_index_6\n\
    \        return \"\"\n    \n    vowels_index_7 = -1\n    \n    for index in (word.length()\
    \ - 1)::-1 \n        if vowels[index] == word[index + 6 * vowels_len]\n      \
    \      vowels_index_7 = index\n            break\n    \n    if vowels_index_7\
    \ == -1\n        return \"No \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: cannot juxtapose string literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8g78_5bu.jl:111\nin expression starting at\
    \ /tmp/tmp8g78_5bu.jl:111\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    if vowels_count > 0 and\
    \ vowels_count < 4:\n        return \"\"\n    \n    vowels_count = 0\n    vowels_count\
    \ += vowels.count(\"A\")\n    vowels_count += vowels.count(\"E\")\n    vowels_count\
    \ += vowels.count(\"I\")\n    vowels_count += vowels.count(\"O\")\n    vowels_count\
    \ += vowels.count(\"U\")\n    \n    if vowels_count > 0 and vowels_count < 4:\n\
    \        return \"\"\n    \n    vowels_count = 0\n    vowels_count += vowels.count(\"\
    a\")\n    vowels_count += vowels.count(\"e\")\n    vowels_count += vowels.count(\"\
    i\")\n    vowels_count += vowels.count(\"o\")\n    vowels_count += vowels.count(\"\
    u\")\n    \n    if vowels_count > 0 and vowels_count < 4:\n        return \"\"\
    \n    \n    vowels_count = 0\n    vowels_count += vowels.count(\"A\")\n    vowels_count\
    \ += vowels.count(\"E\")\n    vowels_count += vowels.count(\"I\")\n    vowels_count\
    \ += vowels.count(\"O\")\n    vowels_count += vowels.count(\"U\")\n    \n    if\
    \ vowels_count > 0 and vowels_count < 4:\n        return \"\"\n    \n    vowels_count\
    \ = 0\n    vowels_count += vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    if vowels_count > 0 and\
    \ vowels_count < 4:\n        return \"\"\n    \n    vowels_count = 0\n    vowels_count\
    \ += vowels.count(\"A\")\n    vowels_count += vowels.count(\"E\")\n    vowels_count\
    \ += vowels.count(\"I\")\n    vowels_count += vowels.count(\"O\")\n    vowels_count\
    \ += vowels.count(\"U\")\n    \n    if vowels_count > 0 and vowels_count < 4:\n\
    \        return \"\"\n    \n    vowels_count = 0\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowels_count\"\nStacktrace:\n [1]\
    \ top-level scope\n   @ /tmp/tmpdm3pt4bb.jl:23\nin expression starting at /tmp/tmpdm3pt4bb.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    \n    for char\
    \ in word:\n        if char in vowels:\n            vowels_count += 1\n      \
    \      if vowels_count > vowels_len:\n                vowels_index = vowels_count\
    \ - 1\n                break\n        else:\n            vowels_count = 0\n  \
    \          vowels_index += 1\n    \n    if vowels_index == 0:\n        return\
    \ \"\"\n    else:\n        return vowels[vowels_index - 1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <text>\nProblem 4\nWrite a function that takes a string as input and returns the\
    \ number of vowels \n    in the string. \n    \n    Example:\n    count_vowels(\"\
    yogurt\") ==> 3\n    count_vowels(\"FULL\") ==> 0\n    count_vowels(\"quick\"\
    ) ==> 0\n    count_vowels(\"ab\") ==> 0\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp591mccsl.jl:22\nin expression starting at\
    \ /tmp/tmp591mccsl.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_from_right = 0\n    vowels_count_from_left\
    \ = 0\n    vowels_count_from_both = 0\n    vowels_count_from_both_from_right =\
    \ 0\n    vowels_count_from_both_from_left = 0\n    vowels_count_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_right = 0\n    vowels_count_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_left = 0\n    vowels_count_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_right = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowel\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4r1vzjjm.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4r1vzjjm.jl:1\n\
    in expression starting at /tmp/tmp4r1vzjjm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx >= vowels.length\n        return \"\"\n    \n \
    \   vowel = vowels[vowels_idx]\n    \n    if vowel == word[vowels_idx + 1]\n \
    \       return vowel\n    \n    if vowel == word[vowels_idx - 1]\n        return\
    \ vowel\n    \n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string and returns the number of vowels found in the string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeih77eck.jl:38\nin expression starting at\
    \ /tmp/tmpeih77eck.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    \n    for char\
    \ in word:\n        if char in vowels:\n            vowels_count += 1\n      \
    \      if vowels_count == vowels_len:\n                vowels_index = vowels_count\n\
    \                break\n    \n    if vowels_index == 0:\n        return \"\"\n\
    \    \n    vowels_index -= 1\n    \n    vowels_index = vowels_index if vowels_index\
    \ >= 0 else vowels_index+vowels_len\n    \n    vowels_index = vowels_index if\
    \ vowels_index < 0 else vowels_index+vowels_len\n    \n    vowels_index = vowels_index\
    \ if vowels_index >= 0 else vowels_index+vowels_len\n    \n    vowel = vowels[vowels_index]\n\
    \    \n    return vowel\n</cell>\n<cell>\nget_closest_vowel(\"yogurt\")\n</cell>\n\
    <cell>\nget_closest_vowel(\"FULL\")\n</cell>\n<cell>\nget_closest_vowel(\"quick\"\
    )\n</cell>\n<cell>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that takes a string as input and returns the number of vowels present\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbrfvift0.jl:22\nin expression starting at\
    \ /tmp/tmpbrfvift0.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx+1\n    \n    vowels_idx = vowels_idx-1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx+1\n\
    \    \n    vowels_idx = vowels_idx-1\n    \n    if vowels_idx < 0\n        return\
    \ \"\"\n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4wihv4ci.jl:1\nin expression starting at /tmp/tmp4wihv4ci.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_index == -1 \n    \
    \    return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index\
    \ >= len(vowels)\n        return \"\"\n    \n    vowels_index = vowels_index -\
    \ 1\n    \n    if vowels_index < 0\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    \n    if vowels_index >= len(vowels)\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index <\
    \ 0\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n  \
    \  if vowels_index >= len(vowels)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index < 0\n        return \"\"\n   \
    \ \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >= len(vowels)\n\
    \        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if\
    \ vowels_index < 0\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index >= len(vowels)\n        return \"\"\n    \n \
    \   vowels_index = vowels_index - 1\n    \n    if vowels_index < 0\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >=\
    \ len(vowels)\n        return \"\"\n    \n    vowels_index = vowels_index - 1\n\
    \    \n    if vowels_index < 0\n        return \"\"\n    \n    vowels_index =\
    \ vowels_index + 1\n    \n    if vowels_index >= len(vowels)\n        return \"\
    \"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index < 0\n\
    \        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if\
    \ vowels_index >= len(vowels)\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index < 0\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    \n    if vowels_index >= len(vowels)\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index <\
    \ 0\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n  \
    \  if vowels_index >= len(vowels)\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index < 0\n        return \"\"\n   \
    \ \n    vowels_index = vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyp3pncq8.jl:1\nin expression starting at /tmp/tmpyp3pncq8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    for char in word:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count = 0\n\
    \    for char in word[::-1]:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count = 0\n    for char in word[::-1]:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count = 0\n\
    \    for char in word[::-1]:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count = 0\n    for char in word[::-1]:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count = 0\n\
    \    for char in word[::-1]:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count = 0\n    for char in word[::-1]:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count = 0\n\
    \    for char in word[::-1]:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count = 0\n    for char in word[::-1]:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count = 0\n\
    \    for char in word[::-1]:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count = 0\n    for char in word[::-1]:\n        if char\
    \ in vowels:\n            vowels_count += 1\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count = 0\n\
    \    for char in word[::-1]:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp82omfikb.jl:19\nin expression starting at\
    \ /tmp/tmp82omfikb.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_max = 0\n    vowels_count_min\
    \ = 0\n    vowels_count_max = 0\n    vowels_count_min = 0\n    for letter in word:\n\
    \        if letter in vowels:\n            vowels_count += 1\n            if vowels_count\
    \ > vowels_count_max:\n                vowels_count_max = vowels_count\n     \
    \       if vowels_count < vowels_count_min:\n                vowels_count_min\
    \ = vowels_count\n        else:\n            vowels_count = 0\n    if vowels_count_min\
    \ == vowels_count_max:\n        return \"\"\n    else:\n        return vowels[vowels_count_min\
    \ - 1]\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\ndef vowel_finder(word):\n\
    \    vowels = ['a','e','i','o','u']\n    vowel_count = 0\n    vowel_count_max\
    \ = 0\n    vowel_count_min = 0\n    vowel_count_max = 0\n    vowel_count_min =\
    \ 0\n    for letter in word:\n        if letter in vowels:\n            vowel_count\
    \ += 1\n            if vowel_count > vowel_count_max:\n                vowel_count_max\
    \ = vowel_count\n            if vowel_count < vowel_count_min:\n             \
    \   vowel_count_min = vowel_count\n        else:\n            vowel_count = 0\n\
    \    if vowel_count_min == vowel_count_max:\n        return \"\"\n    else:\n\
    \        return vowels[vowel_count_min - 1]\n</code>\n<|/ a tags=python,python-3.x\
    \ |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation\
    \ of what your code does and how it solves the problem of the question. Answers\
    \ with an explanation are usually more helpful and of better quality, and are\
    \ more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ndef vowel_finder(word):\n\
    \    vowels = ['a','e','i','o','u']\n    vowel_count = 0\n    vowel_count_max\
    \ = 0\n    vowel_count_min = 0\n    vowel_count_max = 0\n    vowel_count_min =\
    \ 0\n    for letter in word:\n        if letter in vowels:\n            vowel_count\
    \ += 1\n            if vowel_count > vowel_count_max:\n                vowel_count_max\
    \ = vowel_count\n            if vowel_count < vowel_count_min:\n             \
    \   vowel_count_min = vowel_count\n        else:\n            vowel_count = 0\n\
    \    if vowel_count_min == vowel_count_max:\n        return \"\"\n    else:\n\
    \        return vowels[vowel\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy42m6wx7.jl:23\nin expression starting at\
    \ /tmp/tmpy42m6wx7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n\
    \    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count\
    \ += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n\
    \    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count\
    \ %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n\
    \    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count\
    \ += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n\
    \    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count\
    \ %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n\
    \    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count\
    \ += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n\
    \    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count\
    \ %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n\
    \    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count\
    \ += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count %= 4\n\
    \    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n    vowels_count\
    \ %= 4\n    vowels_count += 2\n    vowels_count %= 4\n    vowels_count += 2\n\
    \    vowels_count %= 4\n    vowels_count += 2\n    \nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5xpiyczh.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5xpiyczh.jl:1\n\
    in expression starting at /tmp/tmp5xpiyczh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = find(vowels, word) \n    if vowels_index == -1 \n        \"\"\n    elseif\
    \ vowels_index > length(word)-1 \n        \"\"\n    elseif vowels_index == length(word)-1\
    \ \n        word[vowels_index]\n    else\n        word[vowels_index+1]\n    end\n\
    end\n</cell>\n<text>\nExercise 4\nWrite a Julia function that takes a string as\
    \ input and returns the number of vowels \n    in the string. \n    \n    Example:\n\
    \    count_vowels(\"yogurt\") ==> 3\n    count_vowels(\"FULL\") ==> 2\n    count_vowels(\"\
    quick\") ==> 0\n    count_vowels(\"ab\") ==> 0\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph998hm3u.jl:28\nin expression starting at\
    \ /tmp/tmph998hm3u.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx < 0 \n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if vowels_idx < vowels.length\n\
    \        return vowels[vowels_idx]\n    \n    vowels_idx = vowels_idx - 1\n  \
    \  if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx < vowels.length\n        return vowels[vowels_idx]\n  \
    \  \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx + 1\n    if vowels_idx < vowels.length\n\
    \        return vowels[vowels_idx]\n    \n    vowels_idx = vowels_idx - 1\n  \
    \  if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx < vowels.length\n        return vowels[vowels_idx]\n  \
    \  \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx + 1\n    if vowels_idx < vowels.length\n\
    \        return vowels[vowels_idx]\n    \n    vowels_idx = vowels_idx - 1\n  \
    \  if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx < vowels.length\n        return vowels[vowels_idx]\n  \
    \  \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx + 1\n    if vowels_idx < vowels.length\n\
    \        return vowels[vowels_idx]\n    \n    vowels_idx = vowels_idx - 1\n  \
    \  if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx < vowels.length\n        return vowels[vowels_idx]\n  \
    \  \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx + 1\n    if vowels_idx < vowels.length\n\
    \        return vowels[vowels_idx]\n    \n    vowels_idx = vowels_idx - 1\n  \
    \  if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx < vowels.length\n        return vowels[vowels_idx]\n  \
    \  \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowel\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdkyu8wz6.jl:1\nin expression starting at /tmp/tmpdkyu8wz6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5wtdhuar.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5wtdhuar.jl:1\n\
    in expression starting at /tmp/tmp5wtdhuar.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(x -> x == word[end])\n    if vowels_idx == -1\n     \
    \   return \"\"\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx\
    \ - 1\n    if vowels_idx < 0\n        return \"\"\n    return vowels[vowels_idx]\n\
    end\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"\
    u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\
    \"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp70pq20xb.jl:26\nin expression starting at\
    \ /tmp/tmp70pq20xb.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp0avw6c6a.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0avw6c6a.jl:19\n\
    in expression starting at /tmp/tmp0avw6c6a.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = 0\n    vowels_count_max = 0\n    vowels_count_min\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index\
    \ = 0\n    vowels_count_max_index = 0\n    vowels_count_min_index = 0\n    vowels_count_max_index\
    \ = 0\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps5yq90pu.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmps5yq90pu.jl:1\n\
    in expression starting at /tmp/tmps5yq90pu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.find{|vowel| vowel == word[vowels.rindex(\"A\")..-1]}\n    if vowels_index\
    \ != -1 \n        vowels_index = vowels.rindex(\"A\")\n    else\n        vowels_index\
    \ = vowels.rindex(\"E\")\n    end\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index -\
    \ 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index +\
    \ 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n\
    \    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n  \
    \  vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index -\
    \ 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index +\
    \ 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n\
    \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxskh6h9c.jl:17\nin expression starting at\
    \ /tmp/tmpxskh6h9c.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 1\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    \n    vowels_index = find(vowels,\
    \ word[vowels_count:])\n    vowels_index = vowels_index if vowels_index > 0 else\
    \ len(word)\n    vowels_index = vowels_index if vowels_index < len(word) else\
    \ 0\n    \n    vowels_index = vowels_index - vowels_count if vowels_index > 0\
    \ else 0\n    vowels_index = vowels_index - vowels_count if vowels_index < 0 else\
    \ 0\n    \n    vowels_index = vowels_index if vowels_index > 0 else 0\n    vowels_index\
    \ = vowels_index if vowels_index < 0 else 0\n    \n    vowels_index = vowels_index\
    \ if vowels_index > 0 else 0\n    vowels_index = vowels_index if vowels_index\
    \ < 0 else 0\n    \n    vowels_index = vowels_index if vowels_index > 0 else 0\n\
    \    vowels_index = vowels_index if vowels_index < 0 else 0\n    \n    vowels_index\
    \ = vowels_index if vowels_index > 0 else 0\n    vowels_index = vowels_index if\
    \ vowels_index < 0 else 0\n    \n    vowels_index = vowels_index if vowels_index\
    \ > 0 else 0\n    vowels_index = vowels_index if vowels_index < 0 else 0\n   \
    \ \n    vowels_index = vowels_index if vowels_index > 0 else 0\n    vowels_index\
    \ = vowels_index if vowels_index < 0 else 0\n    \n    vowels_index = vowels_index\
    \ if vowels_index > 0 else 0\n    vowels_index = vowels_index if vowels_index\
    \ < 0 else 0\n    \n    vowels_index = vowels_index if vowels_index > 0 else 0\n\
    \    vowels_index = vowels_index if vowels_index < 0 else 0\n    \n    vowels_index\
    \ = vowels_index if vowels_index > 0 else 0\n    vowels_index = vowels_index if\
    \ vowels_index < 0 else 0\n    \n    vowels_index = vowels_index if vowels_index\
    \ > 0 else 0\n    vowels_index = vowels_index if vowels_index < 0 else 0\n   \
    \ \n    vowels_index = vowels_index if vowels_index > 0 else 0\n    vowels_index\
    \ = vowels_index if vowels_index < 0 else 0\n    \n    vowels_index = vowels_index\
    \ if vowels_index > 0 else 0\n    vowels_index = vowels_index\nusing Test\n\n\
    @testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp3v175oyo.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3v175oyo.jl:19\n\
    in expression starting at /tmp/tmp3v175oyo.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = find(vowels, word[end])\n    if vowels_index == -1\n        return \"\"\n\
    \    \n    vowels_index = vowels_index + 1\n    \n    vowels_index_2 = find(vowels,\
    \ word[end - 1])\n    if vowels_index_2 == -1\n        return \"\"\n    \n   \
    \ if vowels_index > vowels_index_2\n        return word[end - 1]\n    \n    return\
    \ word[end - 1]\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string and returns the number of vowels found in the string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx5rsoxkz.jl:32\nin expression starting at\
    \ /tmp/tmpx5rsoxkz.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_index = 0\n    vowels_index_count\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index = 0\n    vowels_index_count_min_index\
    \ = 0\n    vowels_index_count_max_index\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4kg6r70w.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4kg6r70w.jl:1\n\
    in expression starting at /tmp/tmp4kg6r70w.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowel_counter = 0\n    vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    if vowel_counter == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    vowel_counter = vowels.count(word[vowel_counter:])\n    if vowel_counter\
    \ == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n    vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    if vowel_counter == 0 \n        vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    if vowel_counter == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    vowel_counter = vowels.count(word[vowel_counter:])\n    if vowel_counter\
    \ == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n    vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    if vowel_counter == 0 \n        vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    if vowel_counter == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    vowel_counter = vowels.count(word[vowel_counter:])\n    if vowel_counter\
    \ == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n    vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    if vowel_counter == 0 \n        vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    if vowel_counter == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    vowel_counter = vowels.count(word[vowel_counter:])\n    if vowel_counter\
    \ == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n    vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    if vowel_counter == 0 \n        vowel_counter\
    \ = vowels.count(word[vowel_counter:])\n    vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    if vowel_counter == 0 \n        vowel_counter = vowels.count(word[vowel_counter:])\n\
    \    vowel_counter = vowels.count(word[vowel_counter\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing last argument in \"vowel_counter:\" range\
    \ expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx_w8uecy.jl:18\n\
    in expression starting at /tmp/tmpx_w8uecy.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = 0\n    vowels_index_end = 0\n    vowels_index_start\
    \ = 0\n    vowels_index_end_start = 0\n    \n    for letter in word:\n       \
    \ if letter in vowels:\n            vowels_index = vowels_index + 1\n        \
    \    if vowels_index == vowels_len:\n                vowels_index_end = vowels_index_end\
    \ + 1\n                if vowels_index_end == vowels_len:\n                  \
    \  vowels_index_start = vowels_index_start + 1\n                    if vowels_index_start\
    \ == vowels_len:\n                        return \"\"\n                    else:\n\
    \                        return vowels[vowels_index_start]\n                else:\n\
    \                    return vowels[vowels_index_end]\n            else:\n    \
    \            return vowels[vowels_index]\n        else:\n            return \"\
    \"\n    \nend\n</cell>\n<text>\nProblem 3\nWrite a function that takes a string\
    \ and returns the number of vowels present in the string.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp4n7s7fw.jl:24\nin expression starting at\
    \ /tmp/tmpp4n7s7fw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = count(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowel\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpx3952vty.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx3952vty.jl:1\n\
    in expression starting at /tmp/tmpx3952vty.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains(word))\n    if vowels_idx == -1\n   \
    \     return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx < 0\n        vowels_idx = vowels.lenght - 1\n \
    \   \n    vowel = vowels[vowels_idx]\n    \n    return vowel\nend\n</cell>\n<code\
    \ language=julia-1.4>\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"\
    FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"\
    ab\") ==> \"\"\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ as input and returns the number of vowels present in the string.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps3tgoz68.jl:31\nin expression starting at\
    \ /tmp/tmps3tgoz68.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    \n    for char in word\n        if char in vowels\n            vowels_count\
    \ += 1\n            if vowels_count > 1\n                vowels_count_left +=\
    \ 1\n            if vowels_count < 1\n                vowels_count_right += 1\n\
    \    \n    if vowels_count_left == 0 and vowels_count_right == 0\n        return\
    \ \"\"\n    \n    if vowels_count_left == 0 and vowels_count_right == 1\n    \
    \    return word[word.index(vowels[vowels_count_right])+1:]\n    \n    if vowels_count_left\
    \ == 1 and vowels_count_right == 0\n        return word[word.index(vowels[vowels_count_left])+1:]\n\
    \    \n    if vowels_count_left == 1 and vowels_count_right == 1\n        return\
    \ word[word.index(vowels[vowels_count_left])+1:word.index(vowels[vowels_count_right])]\n\
    \    \n    if vowels_count_left == 0 and vowels_count_right == 1\n        return\
    \ word[word.index(vowels[vowels_count_right])+1:]\n    \n    if vowels_count_left\
    \ == 1 and vowels_count_right == 1\n        return word[word.index(vowels[vowels_count_left])+1:word.index(vowels[vowels_count_right])]\n\
    \    \n    if vowels_count_left == 1 and vowels_count_right == 0\n        return\
    \ word[word.index(vowels[vowels_count_left])+1:]\n    \n    if vowels_count_left\
    \ == 0 and vowels_count_right == 1\n        return word[word.index(vowels[vowels_count_right])+1:]\n\
    \    \n    if vowels_count_left == 1 and vowels_count_right == 0\n        return\
    \ word[word.index(vowels[vowels_count_left])+1:]\n    \n    if vowels_count_left\
    \ == 0 and vowels_count_right == 0\n        return \"\"\n    \n    if vowels_count_left\
    \ == 0 and vowels_count_right == 1\n        return word[word.index(vowels[vowels_count_right])+1:]\n\
    \    \n    if vowels_count_left == 1 and vowels_count_right == 0\n        return\
    \ word[word.index(vowels[vowels_count_left])+1:]\n    \n    if vowels_count_left\
    \ == 1 and vowels_count_right == 1\n        return word[word.index(vowels[vowels_count_left])+1:word.index(vowels[vowels_count_right])]\n\
    \    \n    if vowels_count_left == 0 and vowels_count_right == 1\n        return\
    \ word[word.index(vowels[vowels_count_right\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowels_count_right\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo7qgkm5g.jl:29\nin expression starting at\
    \ /tmp/tmpo7qgkm5g.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = count(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0\
    \ else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0\
    \ else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowel\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpr3rql45y.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpr3rql45y.jl:18\n\
    in expression starting at /tmp/tmpr3rql45y.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_index == -1\n       \
    \ return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end -\
    \ 1])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 2])\n    if vowels_index == -1\n   \
    \     return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 3])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 4])\n    if vowels_index == -1\n   \
    \     return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 5])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 6])\n    if vowels_index == -1\n   \
    \     return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 7])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 8])\n    if vowels_index == -1\n   \
    \     return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 9])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 10])\n    if vowels_index == -1\n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 11])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 12])\n    if vowels_index == -1\n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 13])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 14])\n    if vowels_index == -1\n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 15])\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 16])\n    if vowels_index == -1\n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 17])\n    if \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing condition in \"if\" at /tmp/tmppd79z8ob.jl:86\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmppd79z8ob.jl:87\nin expression\
    \ starting at /tmp/tmppd79z8ob.jl:87\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_positions\
    \ = find_vowel_positions(word)\n    \n    if vowel_positions == []\n        return\
    \ \"\"\n    \n    vowel_positions = vowel_positions[1..end]\n    \n    closest_vowel\
    \ = vowels[minimum(vowel_positions)]\n    \n    return closest_vowel\nend\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <text>\nProblem 2\nWrite a function that takes a string and returns the number\
    \ of vowels found in it.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpumpnepni.jl:28\nin expression starting at\
    \ /tmp/tmpumpnepni.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(x => x == word)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    \n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == -1\n        return \"\"\n \
    \   \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    \n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    \n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == -1\n        return \"\"\n \
    \   \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    \n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    \n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == -1\n        return \"\"\n \
    \   \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    \n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    \n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == -1\n        return \"\"\n \
    \   \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    \n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    \n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == -1\n        return \"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfu5fh8e4.jl:1\nin expression starting at /tmp/tmpfu5fh8e4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx == -1\n        return\
    \ \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx = vowels.find{|v|\
    \ word.starts_with?(v)} \n    if vowels_idx == -1\n        return \"\"\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels_idx - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx\
    \ - 1\n    vowels_idx = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwtsygr58.jl:17\nin expression starting at\
    \ /tmp/tmpwtsygr58.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx < 0\n        vowels_idx = vowels.length\n    \n\
    \    vowel = vowels[vowels_idx]\n    \n    if vowel == word[vowels_idx + 1]\n\
    \        return vowel\n    \n    if vowel == word[vowels_idx - 1]\n        return\
    \ vowel\n    \n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nProblem 3\nWrite a function that takes\
    \ a string and returns the number of vowels present in the string.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0krhlv6x.jl:38\nin expression starting at\
    \ /tmp/tmp0krhlv6x.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_index == -1 \n      \
    \  return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end -\
    \ 1])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 2])\n    if vowels_index == -1 \n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 3])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 4])\n    if vowels_index == -1 \n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 5])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 6])\n    if vowels_index == -1 \n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 7])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 8])\n    if vowels_index == -1 \n  \
    \      return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 9])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 10])\n    if vowels_index == -1 \n \
    \       return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 11])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 12])\n    if vowels_index == -1 \n \
    \       return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 13])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 14])\n    if vowels_index == -1 \n \
    \       return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 15])\n    if vowels_index == -1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels.findIndex(x -> x == word[end - 16])\n    if vowels_index == -1 \n \
    \       return \"\"\n    \n    vowels_index = vowels.findIndex(x -> x == word[end\
    \ - 17])\n    if \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing condition in \"if\" at /tmp/tmpcam6oxsa.jl:86\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpcam6oxsa.jl:87\nin expression\
    \ starting at /tmp/tmpcam6oxsa.jl:87\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index >\
    \ 0\n        vowels_index = vowels_index - 1\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > len(word) - 2\n        vowels_index = len(word)\
    \ - 2\n    \n    vowels_index = vowels_index - 1\n\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpek1j312u.jl:1\nin expression starting at /tmp/tmpek1j312u.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_max = 0\n    vowels_count_min\
    \ = 0\n    vowels_count_max = 0\n    vowels_count_min = 0\n    for letter in word\n\
    \        if letter in vowels\n            vowels_count += 1\n            if vowels_count\
    \ > vowels_count_max\n                vowels_count_max = vowels_count\n      \
    \      if vowels_count < vowels_count_min\n                vowels_count_min =\
    \ vowels_count\n            vowels_count = 0\n        end\n    end\n    if vowels_count_min\
    \ == vowels_count_max\n        return \"\"\n    elseif vowels_count_min == vowels_count_max\n\
    \        return vowels[vowels_count_min]\n    elseif vowels_count_min > vowels_count_max\n\
    \        return vowels[vowels_count_min]\n    else\n        return vowels[vowels_count_max]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg6mzcfa_.jl:42\nin expression starting at\
    \ /tmp/tmpg6mzcfa_.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowels_count = 0\n    \n    for char in word:\n   \
    \     if char in vowels:\n            vowels_count += 1\n    \n    if vowels_count\
    \ > vowels_len:\n        return \"\"\n    \n    vowels_count = 0\n    \n    for\
    \ char in word:\n        if char in vowels:\n            vowels_count += 1\n \
    \   \n    if vowels_count < vowels_len:\n        return \"\"\n    \n    vowels_count\
    \ = 0\n    \n    for char in word:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count == vowels_len:\n        return \"\"\n    \n\
    \    vowels_count = 0\n    \n    for char in word:\n        if char in vowels:\n\
    \            vowels_count += 1\n    \n    if vowels_count > vowels_len:\n    \
    \    return \"\"\n    \n    vowels_count = 0\n    \n    for char in word:\n  \
    \      if char in vowels:\n            vowels_count += 1\n    \n    if vowels_count\
    \ < vowels_len:\n        return \"\"\n    \n    vowels_count = 0\n    \n    for\
    \ char in word:\n        if char in vowels:\n            vowels_count += 1\n \
    \   \n    if vowels_count == vowels_len:\n        return \"\"\n    \n    vowels_count\
    \ = 0\n    \n    for char in word:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count > vowels_len:\n        return \"\"\n    \n \
    \   vowels_count = 0\n    \n    for char in word:\n        if char in vowels:\n\
    \            vowels_count += 1\n    \n    if vowels_count < vowels_len:\n    \
    \    return \"\"\n    \n    vowels_count = 0\n    \n    for char in word:\n  \
    \      if char in vowels:\n            vowels_count += 1\n    \n    if vowels_count\
    \ == vowels_len:\n        return \"\"\n    \n    vowels_count = 0\n    \n    for\
    \ char in word:\n        if char in vowels:\n            vowels_count += 1\n \
    \   \n    if vowels_count > vowels_len:\n        return \"\"\n    \n    vowels_count\
    \ = 0\n    \n    for char in word:\n        if char in vowels:\n            vowels_count\
    \ += 1\n    \n    if vowels_count < vowels_len:\n        return \"\"\n    \n \
    \   vowels_count = 0\n    \n    for char in word:\n        if char in vowels:\n\
    \            vowels_count += 1\n    \n    if vowels_count == vowels_len:\n   \
    \     return \"\"\n    \n    vowels_count = 0\n    \n    for char in word:\n \
    \       if char in vowels:\n            vowels_count += 1\n    \n    if vowels_count\
    \ > vowels_len:\n        return \"\"\n    \n    vowels_\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_4dlko17.jl:22\nin expression starting at\
    \ /tmp/tmp_4dlko17.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowels_count = 0\n    \n    for char in word:\n   \
    \     if char in vowels:\n            vowels_count += 1\n    \n    if vowels_count\
    \ == 0:\n        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_index\
    \ = vowels_count % vowels_len\n    \n    vowel_start = vowels_len - vowels_index\n\
    \    \n    vowel_end = vowels_len + vowels_index\n    \n    vowel_char = word[vowel_start:vowel_end]\n\
    \    \n    return vowel_char\n    \nend\n</cell>\n<code language=julia-1.4>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string as input and\
    \ returns the number of vowels present in the string.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppjo2dzrc.jl:22\nin expression starting at\
    \ /tmp/tmppjo2dzrc.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels)\
    \ else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels)\
    \ else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpsz7hoe_x.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsz7hoe_x.jl:18\n\
    in expression starting at /tmp/tmpsz7hoe_x.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    \n    vowels_count -= 1\n \
    \   \n    vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n\
    \    vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n   \
    \ vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n    vowels_count\
    \ %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n    vowels_count %=\
    \ vowels_count + 1\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count\
    \ + 1\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n\
    \    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n   \
    \ \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n    \n\
    \    vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n    \n   \
    \ vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_count + 1\n    \n    vowels_count -=\
    \ 1\n    \n    vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n\
    \    \n    vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n   \
    \ \n    vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n\
    \    vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n   \
    \ vowels_count %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n    vowels_count\
    \ %= vowels_count + 1\n    \n    vowels_count -= 1\n    \n    vowels_count %=\
    \ vowels_count + 1\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count\
    \ + 1\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n\
    \    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_count + 1\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqlssfj_n.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqlssfj_n.jl:1\n\
    in expression starting at /tmp/tmpqlssfj_n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    word = word.lower()\n    \n    vowel_start = word[vowels_len]\n\
    \    vowel_end = word[vowels_len-1]\n    \n    if vowel_start == vowel_end:\n\
    \        return \"\"\n    \n    vowel_start_idx = word.index(vowel_start)\n  \
    \  vowel_end_idx = word.index(vowel_end)\n    \n    if vowel_start_idx < vowel_end_idx:\n\
    \        vowel_start_idx += 1\n    else:\n        vowel_end_idx -= 1\n    \n \
    \   vowel_start_idx = vowel_start_idx%vowels_len\n    vowel_end_idx = vowel_end_idx%vowels_len\n\
    \    \n    if vowel_start_idx == vowel_end_idx:\n        return \"\"\n    \n \
    \   return vowels[vowel_start_idx:vowel_end_idx]\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqv5jvphi.jl:25\nin expression starting at\
    \ /tmp/tmpqv5jvphi.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_idx = word.rindex(vowels)\n    if vowels_idx < 0 \n\
    \        error(\"No vowel found\")\n    ending_vowel_idx = vowels_idx + vowels_len\n\
    \    if ending_vowel_idx > len(word)\n        error(\"No vowel found\")\n    \n\
    \    vowel_start = word.rindex(vowels, 0, ending_vowel_idx)\n    vowel_end = word.rindex(vowels,\
    \ ending_vowel_idx, len(word))\n    \n    if vowel_start == -1 or vowel_end ==\
    \ -1\n        error(\"No vowel found\")\n    \n    vowel = word[vowel_start:vowel_end]\n\
    \    return vowel\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string and returns the number of vowels found in the string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowel_end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5xwt4j1r.jl:28\nin expression starting at /tmp/tmp5xwt4j1r.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels)\
    \ else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels)\
    \ else len(vowels)\n    vowels_count = vowels_count - 1 if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count - 1 if vowels_count > 0 else 0\n    vowels_count = vowels_count\
    \ + 1 if vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ - 1 if vowels_count > \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp626dv5g4.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp626dv5g4.jl:18\n\
    in expression starting at /tmp/tmp626dv5g4.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = word.index(vowels)\n    vowels_index_right\
    \ = word.rindex(vowels)\n    \n    if vowels_index == -1 or vowels_index_right\
    \ == -1:\n        return \"\"\n    \n    if vowels_index > vowels_index_right:\n\
    \        vowels_index_right = vowels_index\n    \n    vowels_index_left = word.rindex(vowels,\
    \ 0, vowels_index_right + 1)\n    \n    if vowels_index_left == -1:\n        return\
    \ \"\"\n    \n    if vowels_index_left > vowels_index_right:\n        vowels_index_left\
    \ = vowels_index_right\n    \n    vowels_index_left_right = word.rindex(vowels,\
    \ 0, vowels_index_left + 1)\n    \n    if vowels_index_left_right == -1:\n   \
    \     return \"\"\n    \n    if vowels_index_left_right > vowels_index_right:\n\
    \        vowels_index_left_right = vowels_index_right\n    \n    vowels_index_right_left\
    \ = word.rindex(vowels, 0, vowels_index_right + 1)\n    \n    if vowels_index_right_left\
    \ == -1:\n        return \"\"\n    \n    if vowels_index_right_left > vowels_index_right:\n\
    \        vowels_index_right_left = vowels_index_right\n    \n    vowels_index_right_left_right\
    \ = word.rindex(vowels, 0, vowels_index_right_left + 1)\n    \n    if vowels_index_right_left_right\
    \ == -1:\n        return \"\"\n    \n    if vowels_index_right_left_right > vowels_index_right:\n\
    \        vowels_index_right_left_right = vowels_index_right\n    \n    vowels_index_right_left_right_right\
    \ = word.rindex(vowels, 0, vowels_index_right_left_right + 1)\n    \n    if vowels_index_right_left_right_right\
    \ == -1:\n        return \"\"\n    \n    if vowels_index_right_left_right_right\
    \ > vowels_index_right:\n        vowels_index_right_left_right_right = vowels_index_right\n\
    \    \n    vowels_index_right_left_right_right_right = word.rindex(vowels, 0,\
    \ vowels_index_right_left_right_right + 1)\n    \n    if vowels_index_right_left_right_right_right\
    \ == -1:\n        return \"\"\n    \n    if vowels_index_right_left_right_right_right\
    \ > vowels_index_right:\n        vowels_index_right_left_right_right_right = vowels_index_right\n\
    \    \n    vowels_index_right_left_right_right_right_right = word.rindex(vowels,\
    \ 0, vowels_index_right_left_right_right_right + 1)\n    \n    if vowels_index_right_left_right_right_right_right\
    \ == -1:\n        return \"\"\n    \n    if vowels_index_right_left_right_\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowels_index_right\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx2ew_hx1.jl:21\nin expression starting at\
    \ /tmp/tmpx2ew_hx1.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_positions\
    \ = []\n    for letter in word\n        if letter in vowels\n            vowel_positions.append(vowels.index(letter))\n\
    \    vowel_positions.sort()\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1]\
    \ == len(vowels)-1\n        return \"\"\n    \n    if vowel_positions[0] == 0\
    \ and vowel_positions[-1] == len(vowels)-1\n        return \"\"\n    \n    if\
    \ vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n        return\
    \ \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n\
    \        return \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1]\
    \ == len(vowels)-1\n        return \"\"\n    \n    if vowel_positions[0] == 0\
    \ and vowel_positions[-1] == len(vowels)-1\n        return \"\"\n    \n    if\
    \ vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n        return\
    \ \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n\
    \        return \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1]\
    \ == len(vowels)-1\n        return \"\"\n    \n    if vowel_positions[0] == 0\
    \ and vowel_positions[-1] == len(vowels)-1\n        return \"\"\n    \n    if\
    \ vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n        return\
    \ \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n\
    \        return \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1]\
    \ == len(vowels)-1\n        return \"\"\n    \n    if vowel_positions[0] == 0\
    \ and vowel_positions[-1] == len(vowels)-1\n        return \"\"\n    \n    if\
    \ vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n        return\
    \ \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n\
    \        return \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1]\
    \ == len(vowels)-1\n        return \"\"\n    \n    if vowel_positions[0] == 0\
    \ and vowel_positions[-1] == len(vowels)-1\n        return \"\"\n    \n    if\
    \ vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n        return\
    \ \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1] == len(vowels)-1\n\
    \        return \"\"\n    \n    if vowel_positions[0] == 0 and vowel_positions[-1]\
    \ == len(vowels)-1\n        return \"\"\n    \n    if vowel_positions[0]\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowel_positions\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgtk16byy.jl:23\nin expression starting at\
    \ /tmp/tmpgtk16byy.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1 \n      \
    \  return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx\
    \ + 1\n    if vowels_idx >= vowels.length \n        return \"\"\n    \n    vowel\
    \ = vowels[vowels_idx]\n    return vowel\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nPart 2\nThe second part of this problem is to find the closest\
    \ vowel from the given word that stands between two consonants from the left side\
    \ of the word. \n    \n    You may assume that the given string contains English\
    \ letter only.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr6yv57zp.jl:29\nin expression starting at\
    \ /tmp/tmpr6yv57zp.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = count(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowel\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvts1ubym.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvts1ubym.jl:1\n\
    in expression starting at /tmp/tmpvts1ubym.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    \n    for char\
    \ in word:\n        if char in vowels:\n            vowels_count += 1\n      \
    \      if vowels_count > vowels_len:\n                vowels_index = vowels_count\
    \ - 1\n                break\n        else:\n            vowels_count = 0\n  \
    \          vowels_index += 1\n    \n    if vowels_index == 0:\n        return\
    \ \"\"\n    else:\n        return vowels[vowels_index - 1]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string as input and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzeb5bb78.jl:22\nin expression starting at\
    \ /tmp/tmpzeb5bb78.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyr8i9wi1.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyr8i9wi1.jl:1\n\
    in expression starting at /tmp/tmpyr8i9wi1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_counter\
    \ = 0\n    vowel_found = False\n    \n    for char in word:\n        if char in\
    \ vowels:\n            vowel_counter += 1\n            if vowel_counter == 2:\n\
    \                vowel_found = True\n                break\n    \n    if vowel_found:\n\
    \        return word[vowel_counter:]\n    else:\n        return \"\"\nend\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    quick\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string and returns the number\
    \ of vowels found in the string.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvj924k9r.jl:21\nin expression starting at\
    \ /tmp/tmpvj924k9r.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.find{|vowel| vowel in word}\n    if vowels_index == -1\n        return\
    \ \"\"\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index -\
    \ 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index +\
    \ 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n\
    \    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n  \
    \  vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index -\
    \ 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n  \
    \  vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index =\
    \ vowels_index + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index +\
    \ 1\n    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n\
    \    vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n  \
    \  vowels_index = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index\
    \ - 1\n    vowels_index = vowels_index + 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsngs7ts6.jl:17\nin expression starting at\
    \ /tmp/tmpsngs7ts6.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = 0\n    vowels_count_right = 0\n    vowels_count_left\
    \ = 0\n    vowels_count_both = 0\n    vowels_count_right_left = 0\n    vowels_count_right_both\
    \ = 0\n    vowels_count_left_both = 0\n    vowels_count_both_right = 0\n    vowels_count_both_left\
    \ = 0\n    vowels_count_both_both = 0\n    vowels_count_right_left_both = 0\n\
    \    vowels_count_right_both_left = 0\n    vowels_count_left_both_right = 0\n\
    \    vowels_count_left_both_both = 0\n    vowels_count_both_right_left = 0\n \
    \   vowels_count_both_right_both = 0\n    vowels_count_both_left_left = 0\n  \
    \  vowels_count_both_left_both = 0\n    vowels_count_left_right_left = 0\n   \
    \ vowels_count_left_right_both = 0\n    vowels_count_left_both_right = 0\n   \
    \ vowels_count_left_both_left = 0\n    vowels_count_right_left_left = 0\n    vowels_count_right_left_both\
    \ = 0\n    vowels_count_right_both_left = 0\n    vowels_count_right_both_both\
    \ = 0\n    vowels_count_left_right_left = 0\n    vowels_count_left_right_both\
    \ = 0\n    vowels_count_left_both_right = 0\n    vowels_count_left_both_left =\
    \ 0\n    vowels_count_right_left_left = 0\n    vowels_count_right_left_both =\
    \ 0\n    vowels_count_right_both_left = 0\n    vowels_count_right_both_both =\
    \ 0\n    vowels_count_left_right_left = 0\n    vowels_count_left_right_both =\
    \ 0\n    vowels_count_left_both_right = 0\n    vowels_count_left_both_left = 0\n\
    \    vowels_count_right_left_left = 0\n    vowels_count_right_left_both = 0\n\
    \    vowels_count_right_both_left = 0\n    vowels_count_right_both_both = 0\n\
    \    vowels_count_left_right_left = 0\n    vowels_count_left_right_both = 0\n\
    \    vowels_count_left_both_right = 0\n    vowels_count_left_both_left = 0\n \
    \   vowels_count_right_left_left = 0\n    vowels_count_right_left_both = 0\n \
    \   vowels_count_right_both_left = 0\n    vowels_count_right_both_both = 0\n \
    \   vowels_count_left_right_left = 0\n    vowels_count_left_right_both = 0\n \
    \   vowels_count_left_both_right = 0\n    vowels_count_left_both_left = 0\n\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4uhu4_3t.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4uhu4_3t.jl:1\n\
    in expression starting at /tmp/tmp4uhu4_3t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = count(vowels)\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = \nusing Test\n\n\
    @testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgywftots.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgywftots.jl:1\n\
    in expression starting at /tmp/tmpgywftots.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    vowels_index_count\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\
    \ = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max\
    \ = 0\n    vowels_index_count_min = 0\n    vowels_index_count_max = 0\n    vowels_index_count_min\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1exv_mvm.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1exv_mvm.jl:1\n\
    in expression starting at /tmp/tmp1exv_mvm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.length - 1 \n        return \"\"\n   \
    \ \n    vowel = vowels[vowels_idx]\n    \n    if vowel in \"aeiouAEIOU\"\n   \
    \     return vowel\n    \n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqeztr85y.jl:35\nin expression starting at\
    \ /tmp/tmpqeztr85y.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowels_count = 0\n    \n    for char in word:\n   \
    \     if char in vowels:\n            vowels_count += 1\n    \n    if vowels_count\
    \ > 0:\n        vowels_count -= 1\n    \n    vowels_count %= vowels_len\n    \n\
    \    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count -= 1\n\
    \    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n     \
    \   return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= vowels_len\n    \n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    \n    vowels_count %= vowels_len\n\
    \    \n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    \n    vowels_count %= \nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbo2rw8fp.jl:22\nin expression starting at\
    \ /tmp/tmpbo2rw8fp.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp06vz6cuc.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp06vz6cuc.jl:1\n\
    in expression starting at /tmp/tmp06vz6cuc.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains)\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.size - 1\n        vowels_idx = vowels.size\
    \ - 1\n    \n    vowels_idx = \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxuu0a1mu.jl:1\nin expression starting at /tmp/tmpxuu0a1mu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_index == -1\n     \
    \   return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index\
    \ > len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index >\
    \ len(vowels)\n        vowels_index = 0\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    vowels_index = vowels_index + 1\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9kt0g426.jl:1\nin expression starting at /tmp/tmp9kt0g426.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = -1\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index\
    \ = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_index = 0\n    vowels_\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfz4kk8z6.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfz4kk8z6.jl:1\n\
    in expression starting at /tmp/tmpfz4kk8z6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    if vowels_len == 0 \n        return \"\"\n    \n  \
    \  vowels_index = 0\n    \n    for char in word\n        if char in vowels\n \
    \           vowels_index = vowels_index + 1\n    \n    if vowels_index == 0 \n\
    \        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if\
    \ vowels_index >= vowels_len\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index >= vowels_len\n        return \"\"\n    \n  \
    \  vowels_index = vowels_index - 1\n    \n    if vowels_index >= vowels_len\n\
    \        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if\
    \ vowels_index >= vowels_len\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index >= vowels_len\n        return \"\"\n    \n  \
    \  vowels_index = vowels_index + 1\n    \n    if vowels_index >= vowels_len\n\
    \        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if\
    \ vowels_index >= vowels_len\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index >= vowels_len\n        return \"\"\n    \n  \
    \  vowels_index = vowels_index - 1\n    \n    if vowels_index >= vowels_len\n\
    \        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if\
    \ vowels_index >= vowels_len\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index >= vowels_len\n        return \"\"\n    \n  \
    \  vowels_index = vowels_index + 1\n    \n    if vowels_index >= vowels_len\n\
    \        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if\
    \ vowels_index >= vowels_len\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index >= vowels_len\n        return \"\"\n    \n  \
    \  vowels_index = vowels_index - 1\n    \n    if vowels_index >= vowels_len\n\
    \        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if\
    \ vowels_index >= vowels_len\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index >= vowels_len\n        return \"\"\n    \n  \
    \  vowels_index = vowels_index + 1\n    \n    if vowels_index >= \nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz4gvx03t.jl:1\nin expression starting at /tmp/tmpz4gvx03t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpg81yunhm.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpg81yunhm.jl:1\n\
    in expression starting at /tmp/tmpg81yunhm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxqh3mgf5.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxqh3mgf5.jl:1\n\
    in expression starting at /tmp/tmpxqh3mgf5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains)\n    \n    if vowels_idx < 0 \n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if vowels_idx == vowels.length\n\
    \        return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if\
    \ vowels_idx == vowels.length\n        return \"\"\n    \n    vowels_idx = vowels_idx\
    \ - 1\n    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx\
    \ = vowels_idx + 1\n    \n    if vowels_idx == vowels.length\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx < 0\n     \
    \   return \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if vowels_idx\
    \ == vowels.length\n        return \"\"\n    \n    vowels_idx = vowels_idx - 1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx == vowels.length\n        return \"\"\n    \n \
    \   vowels_idx = vowels_idx - 1\n    \n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if vowels_idx == vowels.length\n\
    \        return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if\
    \ vowels_idx == vowels.length\n        return \"\"\n    \n    vowels_idx = vowels_idx\
    \ - 1\n    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx\
    \ = vowels_idx + 1\n    \n    if vowels_idx == vowels.length\n        return \"\
    \"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx < 0\n     \
    \   return \"\"\n    \n    vowels_idx = vowels_idx + 1\n    \n    if vowels_idx\
    \ == vowels.length\n        return \"\"\n    \n    vowels_idx = vowels_idx - 1\n\
    \    \n    if vowels_idx < 0\n        return \"\"\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx == vowels.length\n        return \"\"\n    \n \
    \   vowels_idx = vowels_idx - 1\n    \n    if vowels_idx < 0\n        return \"\
    \"\n    \n    vowels_idx = vowels_id\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptfy0smsd.jl:1\nin expression starting at /tmp/tmptfy0smsd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_positions\
    \ = findall(x->x in vowels, word)\n    vowel_positions = sort(vowel_positions)\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:end]\n\
    \    vowel_positions = vowel_positions[2:end]\n    vowel_positions = vowel_positions[2:\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw2admwtv.jl:59\nin expression starting at\
    \ /tmp/tmpw2admwtv.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_positions\
    \ = [i for i,v in enumerate(vowels) if v == word[end-1:end]]\n    closest_vowel\
    \ = vowels[min(vowel_positions)]\n    return closest_vowel\nend\n</cell>\n<code\
    \ language=julia-1.3>\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"\
    FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"\
    ab\") ==> \"\"\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ and returns the number of vowels present in the string. \n    \n    Example:\n\
    \    count_vowels(\"yogurt\") ==> 3\n    count_vowels(\"ab\") ==> 0\n    count_vowels(\"\
    abba\") ==> 2\n    count_vowels(\"abbaab\") ==> 4\n    count_vowels(\"abbaabb\"\
    ) ==> 5\n    count_vowels(\"abbaabbb\") ==> 6\n    count_vowels(\"abbaabbbc\"\
    ) ==> 7\n    count_vowels(\"abbaabbbbc\") ==> 8\n    count_vowels(\"abbaabbbbcc\"\
    ) ==> 9\n    count_vowels(\"abbaabbbbccc\") ==> 10\n    count_vowels(\"abbaabbbbcccc\"\
    ) ==> 11\n    count_vowels(\"abbaabbbbccccc\") ==> 12\n    count_vowels(\"abbaabbbbcccccc\"\
    ) ==> 13\n    count_vowels(\"abbaabbbbccccccc\") ==> 14\n    count_vowels(\"abbaabbbbcccccccd\"\
    ) ==> 15\n    count_vowels(\"abbaabbbbcccccccdd\") ==> 16\n    count_vowels(\"\
    abbaabbbbcccccccddd\") ==> 17\n    count_vowels(\"abbaabbbbcccccccdddd\") ==>\
    \ 18\n    count_vowels(\"abbaabbbbcccccccddddd\") ==> 19\n    count_vowels(\"\
    abbaabbbbcccccccdddddd\") ==> 20\n    count_vowels(\"abbaabbbbcccccccddddddd\"\
    ) ==> 21\n    count_vowels(\"abbaabbbbcccccccdddddddd\") ==> 22\n    count_vowels(\"\
    abbaabbbbcccccccdddddddddd\") ==> 23\n    count_vowels(\"abbaabbbbcccccccddddddddddd\"\
    ) \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpja6wsn__.jl:17\nin expression starting at\
    \ /tmp/tmpja6wsn__.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1\n       \
    \ return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    if vowels_idx\
    \ < 0\n        vowels_idx = vowels.lenght - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx > vowels.lenght - 1\n        vowels_idx = 0\n \
    \   \n    return vowels[vowels_idx]\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of vowels found in the string.\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9y12v9n0.jl:33\nin expression starting at\
    \ /tmp/tmp9y12v9n0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_from_right = 0\n    vowels_count_from_left\
    \ = 0\n    vowels_count_from_middle = 0\n    vowels_count_from_middle2 = 0\n \
    \   vowels_count_from_middle3 = 0\n    vowels_count_from_middle4 = 0\n    vowels_count_from_middle5\
    \ = 0\n    vowels_count_from_middle6 = 0\n    vowels_count_from_middle7 = 0\n\
    \    vowels_count_from_middle8 = 0\n    vowels_count_from_middle9 = 0\n    vowels_count_from_middle10\
    \ = 0\n    vowels_count_from_middle11 = 0\n    vowels_count_from_middle12 = 0\n\
    \    vowels_count_from_middle13 = 0\n    vowels_count_from_middle14 = 0\n    vowels_count_from_middle15\
    \ = 0\n    vowels_count_from_middle16 = 0\n    vowels_count_from_middle17 = 0\n\
    \    vowels_count_from_middle18 = 0\n    vowels_count_from_middle19 = 0\n    vowels_count_from_middle20\
    \ = 0\n    vowels_count_from_middle21 = 0\n    vowels_count_from_middle22 = 0\n\
    \    vowels_count_from_middle23 = 0\n    vowels_count_from_middle24 = 0\n    vowels_count_from_middle25\
    \ = 0\n    vowels_count_from_middle26 = 0\n    vowels_count_from_middle27 = 0\n\
    \    vowels_count_from_middle28 = 0\n    vowels_count_from_middle29 = 0\n    vowels_count_from_middle30\
    \ = 0\n    vowels_count_from_middle31 = 0\n    vowels_count_from_middle32 = 0\n\
    \    vowels_count_from_middle33 = 0\n    vowels_count_from_middle34 = 0\n    vowels_count_from_middle35\
    \ = 0\n    vowels_count_from_middle36 = 0\n    vowels_count_from_middle37 = 0\n\
    \    vowels_count_from_middle38 = 0\n    vowels_count_from_middle39 = 0\n    vowels_count_from_middle40\
    \ = 0\n    vowels_count_from_middle41 = 0\n    vowels_count_from_middle42 = 0\n\
    \    vowels_count_from_middle43 = 0\n    vowels_count_from_middle44 = 0\n    vowels_count_from_middle45\
    \ = 0\n    vowels_count_from_middle46 = 0\n    vowels_count_from_middle47 = 0\n\
    \    vowels_count_from_middle48 = 0\n    vowels_count_from_middle49 = 0\n    vowels_count_from_middle50\
    \ = 0\n    vowels_count_from_middle51 = 0\n    vowels_count_from_middle52 = 0\n\
    \    vowels_count_from_middle53 = 0\n    vowel\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjgu5iy52.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjgu5iy52.jl:1\n\
    in expression starting at /tmp/tmpjgu5iy52.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_positions\
    \ = find_vowel_positions(word)\n    \n    if vowel_positions == []\n        return\
    \ \"\"\n    \n    closest_vowel = find_closest_vowel(vowel_positions)\n    \n\
    \    return closest_vowel\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise 2\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_norg2t0.jl:26\nin expression starting at\
    \ /tmp/tmp_norg2t0.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findLastIndex(vowels.contains)\n    if vowels_idx == -1 \n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    \n    vowels_idx = vowels_idx\
    \ + 1\n    \n    if vowels_idx < 0 \n        vowels_idx = vowels.length\n    \n\
    \    vowel = vowels[vowels_idx]\n    \n    if vowel == word[vowels_idx + 1]\n\
    \        return vowel\n    \n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp079ukgqy.jl:35\nin expression starting at\
    \ /tmp/tmp079ukgqy.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_end = 0\n    vowels_count_start\
    \ = 0\n    vowels_count_start_end = 0\n    vowels_count_start_end_count = 0\n\
    \    vowels_count_start_end_count_end = 0\n    vowels_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count = 0\n    vowels_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end = 0\n    vowels_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_end =\
    \ 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end_count_start_end\
    \ = 0\n    vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp44n2rgdt.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp44n2rgdt.jl:1\n\
    in expression starting at /tmp/tmp44n2rgdt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count % len(vowels)\n    vowels_index = vowels_count - 1\n    \n  \
    \  if vowels_index == -1:\n        return \"\"\n    \n    vowel_start = vowels[vowels_index]\n\
    \    vowel_end = vowels[vowels_index + 1]\n    \n    if vowel_start == vowel_end:\n\
    \        return vowel_start\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = vowel_start_index\
    \ + 1\n    vowel_end_index = vowel_end_index - 1\n    \n    if vowel_start_index\
    \ > vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    \    vowel_end_index = word.index(vowel_end)\n    \n    if vowel_start_index >\
    \ vowel_end_index:\n        return \"\"\n    \n    vowel_start_index = word.index(vowel_start)\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7xu0jai5.jl:23\nin expression starting at\
    \ /tmp/tmp7xu0jai5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeuhupa_s.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpeuhupa_s.jl:1\n\
    in expression starting at /tmp/tmpeuhupa_s.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(w => w == word[end])\n    if vowels_idx == -1\n        return\
    \ \"\"\n    \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n       \
    \ vowels_idx = vowels.length - 1\n    \n    vowels_idx = vowels_idx + 1\n    if\
    \ vowels_idx >= vowels.length\n        vowels_idx = 0\n    \n    return vowels[vowels_idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyohw3a0i.jl:1\nin expression starting at /tmp/tmpyohw3a0i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_index == -1\n     \
    \   return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index =\
    \ vowels_index - 1\n    \n    if vowels_index > 0\n        return word[vowels_index]\n\
    \    \n    if vowels_index < len(word)\n        return word[vowels_index]\n  \
    \  \n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a string and returns the number of vowels present\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7z58yy93.jl:32\nin expression starting at\
    \ /tmp/tmp7z58yy93.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        return \"\"\n    \n\
    \    vowels_count = count(vowels, word[::-1])\n    if vowels_count > 1\n     \
    \   return \"\"\n    \n    vowels_count = count(vowels, word[1:-1])\n    if vowels_count\
    \ > 1\n        return \"\"\n    \n    vowels_count = count(vowels, word[2:])\n\
    \    if vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[:-2])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[2:-1])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[:1])\n    if vowels_count > 1\n \
    \       return \"\"\n    \n    vowels_count = count(vowels, word[2:])\n    if\
    \ vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[:-2])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[1:-1])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[:1])\n    if vowels_count > 1\n \
    \       return \"\"\n    \n    vowels_count = count(vowels, word[2:])\n    if\
    \ vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[:-2])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[1:-1])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[:1])\n    if vowels_count > 1\n \
    \       return \"\"\n    \n    vowels_count = count(vowels, word[2:])\n    if\
    \ vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[:-2])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[1:-1])\n    if vowels_count > 1\n        return \"\"\n\
    \    \n    vowels_count = count(vowels, word[:1])\n    if vowels_count > 1\n \
    \       return \"\"\n    \n    vowels_count = count(vowels, word[2:])\n    if\
    \ vowels_count > 1\n        return \"\"\n    \n    vowels_count = count(vowels,\
    \ word[:-2])\n    if vowels_count > 1\n        return \"\"\n    \n    vowels_count\
    \ = count(vowels, word[1:-1])\n    if vowels_count > \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"\
    u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\
    \")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\"\
    )\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\"\
    )\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t\
    @test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t\
    @test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: expected \"]\" or separator in arguments to \"\
    [ ]\"; got \"::-1\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9a5jzk7m.jl:21\n\
    in expression starting at /tmp/tmp9a5jzk7m.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1\n       \
    \ return \"\"\n    vowels_idx = vowels_idx - 1\n    vowels_idx = vowels_idx +\
    \ 1\n    if vowels_idx >= length(word)\n        return \"\"\n    vowel = vowels[vowels_idx]\n\
    \    if vowel == word[vowels_idx]\n        return vowel\n    return \"\"\nend\n\
    </cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"u\"\n\
    get_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\n\
    get_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpveim8eti.jl:29\nin expression starting at\
    \ /tmp/tmpveim8eti.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 2\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count if\
    \ vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word)\
    \ else len(word)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n\
    \    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count if\
    \ vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word)\
    \ else len(word)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n\
    \    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count if\
    \ vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word)\
    \ else len(word)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n\
    \    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpinhz1urr.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpinhz1urr.jl:19\n\
    in expression starting at /tmp/tmpinhz1urr.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1\n       \
    \ return \"\"\n    \n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0\n\
    \        vowels_idx = vowels.lenght - 1\n    \n    vowels_idx = vowels_idx + 1\n\
    \    if vowels_idx > vowels.lenght - 1\n        vowels_idx = 0\n    \n    return\
    \ vowels[vowels_idx]\nend\n</cell>\n<code language=julia-1.4>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi_n6icsz.jl:31\nin expression starting at\
    \ /tmp/tmpi_n6icsz.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n   \
    \     return \"\"\n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count\
    \ == 0:\n        return \"\"\n    vowels_count -= 1\n    vowels_count %= 4\n \
    \   if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n   \
    \     return \"\"\n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count\
    \ == 0:\n        return \"\"\n    vowels_count -= 1\n    vowels_count %= 4\n \
    \   if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n\
    \    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n   \
    \     return \"\"\n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count\
    \ == 0:\n        return \"\"\n    vowels_count -= 1\n    vowels_count %= 4\n \
    \   if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    if vowels_count == 0:\n        return \"\"\n    vowels_count -= 1\n\
    \    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n    \n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcxfv8op2.jl:25\nin expression starting at\
    \ /tmp/tmpcxfv8op2.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw1ro54gq.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw1ro54gq.jl:1\n\
    in expression starting at /tmp/tmpw1ro54gq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(word) else len(word)\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(word) else len(word)\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count if vowels_count > 0 else\
    \ 0\n    vowels_count = vowels_count if vowels_count < len(word) else len(word)\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(word) else\
    \ len(word)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(word) else len(word)\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpblugbmy_.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpblugbmy_.jl:19\n\
    in expression starting at /tmp/tmpblugbmy_.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    vowel_start = vowels[(vowels.size - vowels_len)::-1]\n\
    \    vowel_end = vowels[-1:1:-1]\n    \n    vowel_start_idx = word.index(vowel_start)\n\
    \    vowel_end_idx = word.index(vowel_end)\n    \n    if vowel_start_idx < 0 or\
    \ vowel_end_idx < 0:\n        return \"\"\n    \n    if vowel_start_idx > vowel_end_idx:\n\
    \        return word[vowel_end_idx:vowel_start_idx]\n    \n    return word[vowel_start_idx:vowel_end_idx]\n\
    end\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"\
    u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\
    \"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that takes a string and returns the number of vowels present in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: expected \"]\" or separator in arguments to \"\
    [ ]\"; got \"(vowels.size - vowels_len)::-1\"\nStacktrace:\n [1] top-level scope\n\
    \   @ /tmp/tmpggs7ym0u.jl:19\nin expression starting at /tmp/tmpggs7ym0u.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    \n    for char in word:\n        if char in vowels:\n            vowels_count\
    \ += 1\n            if vowels_count > vowels_count_left:\n                vowels_count_left\
    \ = vowels_count\n            if vowels_count < vowels_count_right:\n        \
    \        vowels_count_right = vowels_count\n        else:\n            vowels_count\
    \ = 0\n    \n    if vowels_count_left == vowels_count_right:\n        return \"\
    \"\n    else:\n        return vowels[vowels_count_right - vowels_count_left +\
    \ 1]\nend\n</cell>\n<text>\nSolution\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpur5yq8df.jl:22\nin expression starting at\
    \ /tmp/tmpur5yq8df.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(x -> x == word[end])\n    if vowels_idx == -1 \n        \"\
    \"\n    else\n        vowels[vowels_idx + 1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\") \n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\") \n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\") \n\
    </cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\") \n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a string as input and returns the number\
    \ of vowels found in the string.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb8w33s3n.jl:24\nin expression starting at\
    \ /tmp/tmpb8w33s3n.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_from_right = 0\n    vowels_count_from_left\
    \ = 0\n    vowels_count_from_both = 0\n    vowels_count_from_both_from_right =\
    \ 0\n    vowels_count_from_both_from_left = 0\n    vowels_count_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_right = 0\n    vowels_count_from_both_from_both_from_left\
    \ = 0\n    vowels_count_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_left = 0\n    vowels_count_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_right = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both_from_right\
    \ = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_left = 0\n\
    \    vowels_count_from_both_from_both_from_both_from_both_from_both = 0\n    vowels_count_from_both_from_both_from_both_from_both_from_both\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7skn3lcd.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7skn3lcd.jl:1\n\
    in expression starting at /tmp/tmp7skn3lcd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_index\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_index == -1 \n    \
    \    return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index\
    \ > vowels.size - 1 \n        return \"\"\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index == 0 \n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    \n    if vowels_index > vowels.size - 1 \n        return\
    \ \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index ==\
    \ 0 \n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n \
    \   if vowels_index > vowels.size - 1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == 0 \n        return \"\"\n \
    \   \n    vowels_index = vowels_index + 1\n    \n    if vowels_index > vowels.size\
    \ - 1 \n        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n\
    \    if vowels_index == 0 \n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > vowels.size - 1 \n        return \"\"\n   \
    \ \n    vowels_index = vowels_index - 1\n    \n    if vowels_index == 0 \n   \
    \     return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n    if vowels_index\
    \ > vowels.size - 1 \n        return \"\"\n    \n    vowels_index = vowels_index\
    \ - 1\n    \n    if vowels_index == 0 \n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    \n    if vowels_index > vowels.size - 1 \n        return\
    \ \"\"\n    \n    vowels_index = vowels_index - 1\n    \n    if vowels_index ==\
    \ 0 \n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    \n \
    \   if vowels_index > vowels.size - 1 \n        return \"\"\n    \n    vowels_index\
    \ = vowels_index - 1\n    \n    if vowels_index == 0 \n        return \"\"\n \
    \   \n    vowels_index = vowels_index + 1\n    \n    if vowels_index > vowels.size\
    \ - 1 \n        return \"\"\n    \n    vowels_index = vowels_index - 1\n    \n\
    \    if vowels_index == 0 \n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    \n    if vowels_index > vowels.size - 1 \n        return \"\"\n   \
    \ \n    vowels_index = vowels_index - 1\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq_gzfm3p.jl:1\nin expression starting at /tmp/tmpq_gzfm3p.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkcncsgq1.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkcncsgq1.jl:1\n\
    in expression starting at /tmp/tmpkcncsgq1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = -1\n    vowels_index = get_vowels_index(word,\
    \ vowels_index)\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = get_vowels_index(word, vowels_index)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = get_vowels_index(word,\
    \ vowels_index)\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = get_vowels_index(word, vowels_index)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = get_vowels_index(word,\
    \ vowels_index)\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n    if vowels_index\
    \ == -1\n        return \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index\
    \ = get_vowels_index(word, vowels_index)\n    if vowels_index == -1\n        return\
    \ \"\"\n    \n    vowels_index = vowels_index + 1\n    vowels_index = get_vowels_index(word,\
    \ vowels_index)\n    if vowels_index == -1\n        return \"\"\n    \n    vowels_index\
    \ = vowels_index + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n\
    \    if vowels_index == -1\n        return \"\"\n    \n    vowels_index = vowels_index\
    \ + 1\n    vowels_index = get_vowels_index(word, vowels_index)\n\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg0yz_ghf.jl:1\nin expression starting at /tmp/tmpg0yz_ghf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        vowels_index = find(vowels,\
    \ word, 1)\n        if vowels_index > 0\n            vowels_index = vowels_index\
    \ - 1\n            vowels_index = vowels_index - 1\n            vowels_index =\
    \ vowels_index - 1\n            vowels_index = vowels_index - 1\n            vowels_index\
    \ = vowels_index - 1\n            vowels_index = vowels_index - 1\n          \
    \  vowels_index = vowels_index - 1\n            vowels_index = vowels_index -\
    \ 1\n            vowels_index = vowels_index - 1\n            vowels_index = vowels_index\
    \ - 1\n            vowels_index = vowels_index - 1\n            vowels_index =\
    \ vowels_index - 1\n            vowels_index = vowels_index - 1\n            vowels_index\
    \ = vowels_index - 1\n            vowels_index = vowels_index - 1\n          \
    \  vowels_index = vowels_index - 1\n            vowels_index = vowels_index -\
    \ 1\n            vowels_index = vowels_index - 1\n            vowels_index = vowels_index\
    \ - 1\n            vowels_index = vowels_index - 1\n            vowels_index =\
    \ vowels_index - 1\n            vowels_index = vowels_index - 1\n            vowels_index\
    \ = vowels_index - 1\n            vowels_index = vowels_index - 1\n          \
    \  vowels_index = vowels_index - 1\n            vowels_index = vowels_index -\
    \ 1\n            vowels_index = vowels_index - 1\n            vowels_index = vowels_index\
    \ - 1\n            vowels_index = vowels_index - 1\n            vowels_index =\
    \ vowels_index - 1\n            vowels_index = vowels_index - 1\n            vowels_index\
    \ = vowels_index - 1\n            vowels_index = vowels_index - 1\n          \
    \  vowels_index = vowels_index - 1\n            vowels_index = vowels_index -\
    \ 1\n            vowels_index = vowels_index - 1\n            vowels_index = vowels_index\
    \ - 1\n            vowels_index = vowels_index - 1\n            vowels_index =\
    \ vowels_index - 1\n            vowels_index = vowels_index - 1\n            vowels_index\
    \ = vowels_index - 1\n            vowels_index = vowels_index - 1\n          \
    \  vowels_index = vowels_index - 1\n            vowels_index = vowels_index -\
    \ 1\n            vowels_index = vowels_index - 1\n            vowels_index = vowels_index\
    \ - 1\n            vowels_index = vowels_index - 1\n            vowels_index =\
    \ vowels_index - 1\n            vowels_index = vowels_index - 1\n            vowels_index\
    \ = vowels_index - 1\n            vowels_index = vowels_index - 1\n          \
    \  vowels_index = vowels_index - 1\n            \nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcvbzjjk3.jl:1\nin expression starting at /tmp/tmpcvbzjjk3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|v| v == word[word.length-1]}\n    if vowels_idx == -1\n     \
    \   return \"\"\n    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n\
    \    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx\
    \ = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n\
    \    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx\
    \ = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n\
    \    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx\
    \ = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n\
    \    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx\
    \ = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n\
    \    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx\
    \ = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n\
    \    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx\
    \ = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n\
    \    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx\
    \ = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n\
    \    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx\
    \ = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n\
    \    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx\
    \ = vowels_idx+1\n    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n\
    \    vowels_idx = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx\
    \ = vowels_idx-1\n    vowels_idx = vowels_idx+1\n    vowels_idx = vowels_idx-1\n\
    \    vowels_idx = \nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy3go_94u.jl:17\nin expression starting at\
    \ /tmp/tmpy3go_94u.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ %= 4\n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count\
    \ -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n\
    \    \n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    vowels_count %= 4\n   \
    \ if vowels_count == 0:\n        return \"\"\n    \n    vowels_count -= 1\n  \
    \  vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n    \n \
    \   vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n    \
    \    return \"\"\n    \n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count\
    \ == 0:\n        return \"\"\n    \n    vowels_count -= 1\n    vowels_count %=\
    \ 4\n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count -=\
    \ 1\n    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n \
    \   \n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    vowels_count %= 4\n   \
    \ if vowels_count == 0:\n        return \"\"\n    \n    vowels_count -= 1\n  \
    \  vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n    \n \
    \   vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n    \
    \    return \"\"\n    \n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count\
    \ == 0:\n        return \"\"\n    \n    vowels_count -= 1\n    vowels_count %=\
    \ 4\n    if vowels_count == 0:\n        return \"\"\n    \n    vowels_count -=\
    \ 1\n    vowels_count %= 4\n    if vowels_count == 0:\n        return \"\"\n \
    \   \n    vowels_count -= 1\n    vowels_count %= 4\n    if vowels_count == 0:\n\
    \        return \"\"\n    \n    vowels_count -= 1\n    vowels_count %= 4\n   \
    \ if vowels_count == 0:\n        return \"\"\n    \n    vowels_count -= 1\n  \
    \  vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t\
    @test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\
    \t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t\
    @test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"\
    most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\"\
    ) == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn1hu2ct6.jl:25\nin expression starting at\
    \ /tmp/tmpn1hu2ct6.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = 0\n    vowels_index2 = vowels_len\n    \n\
    \    for char in word:\n        if char in vowels:\n            vowels_index =\
    \ vowels_index + 1\n            if vowels_index == vowels_len:\n             \
    \   vowels_index = 0\n        if char in vowels:\n            vowels_index2 =\
    \ vowels_index2 + 1\n            if vowels_index2 == vowels_len:\n           \
    \     vowels_index2 = 0\n    \n    vowels_index = vowels_index - vowels_index2\n\
    \    \n    if vowels_index == 0:\n        return \"\"\n    elif vowels_index ==\
    \ 1:\n        return word[vowels_index:]\n    elif vowels_index == 2:\n      \
    \  return word[vowels_index-1:vowels_index+2]\n    elif vowels_index == 3:\n \
    \       return word[vowels_index-2:vowels_index+3]\n    elif vowels_index == 4:\n\
    \        return word[vowels_index-3:vowels_index+4]\n    elif vowels_index ==\
    \ 5:\n        return word[vowels_index-4:vowels_index+5]\n    elif vowels_index\
    \ == 6:\n        return word[vowels_index-5:vowels_index+6]\n    elif vowels_index\
    \ == 7:\n        return word[vowels_index-6:vowels_index+7]\n    elif vowels_index\
    \ == 8:\n        return word[vowels_index-7:vowels_index+8]\n    elif vowels_index\
    \ == 9:\n        return word[vowels_index-8:vowels_index+9]\n    elif vowels_index\
    \ == 10:\n        return word[vowels_index-9:vowels_index+10]\n    elif vowels_index\
    \ == 11:\n        return word[vowels_index-10:vowels_index+11]\n    elif vowels_index\
    \ == 12:\n        return word[vowels_index-11:vowels_index+12]\n    elif vowels_index\
    \ == 13:\n        return word[vowels_index-12:vowels_index+13]\n    elif vowels_index\
    \ == 14:\n        return word[vowels_index-13:vowels_index+14]\n    elif vowels_index\
    \ == 15:\n        return word[vowels_index-14:vowels_index+15]\n    elif vowels_index\
    \ == 16:\n        return word[vowels_index-15:vowels_index+16]\n    elif vowels_index\
    \ == 17:\n        return word[vowels_index-16:vowels_index+17]\n    elif vowels_index\
    \ == 18:\n        return word[vowels_index-17:vowels_index+18]\n    elif vowels_index\
    \ == 19:\n        return word\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyaiusk76.jl:22\nin expression starting at\
    \ /tmp/tmpyaiusk76.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count +\
    \ 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n\
    \    vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n  \
    \  vowels_count = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count\
    \ = vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count =\
    \ vowels_count - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count\
    \ - 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count -\
    \ 1\n    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n\
    \    vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n  \
    \  vowels_count = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count\
    \ = vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count =\
    \ vowels_count + 1\n    vowels_count = vowels_count - 1\n    vowels_count = vowels_count\
    \ + 1\n    vowels_count = vowels_count - 1\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpidoeo461.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpidoeo461.jl:1\n\
    in expression starting at /tmp/tmpidoeo461.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        vowels_index = find(vowels,\
    \ word)\n        vowels_index = vowels_index - vowels_count + 1\n        vowel\
    \ = vowels[vowels_index]\n        return vowel\n    else\n        return \"\"\n\
    end\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"\
    u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\
    \"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a string and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbs7iyn5r.jl:26\nin expression starting at\
    \ /tmp/tmpbs7iyn5r.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = word.rindex(vowels)\n    if vowels_index ==\
    \ -1 or vowels_index == len(word) - vowels_len + 1:\n        return \"\"\n   \
    \ \n    vowels_index = vowels_index + 1\n    vowels_index = vowels_index - 1\n\
    \    \n    if vowels[vowels_index] == word[vowels_index]:\n        return vowels[vowels_index]\n\
    \    else:\n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of vowels\
    \ present in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowels_index\"\nStacktrace:\n [1]\
    \ top-level scope\n   @ /tmp/tmp6dofdw1n.jl:19\nin expression starting at /tmp/tmp6dofdw1n.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz1s72hh1.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz1s72hh1.jl:1\n\
    in expression starting at /tmp/tmpz1s72hh1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.findIndex(vowels.contains(word))\n    if vowels_idx == -1 \n      \
    \  return \"\"\n    vowels_idx = vowels_idx - 1\n    if vowels_idx < 0 \n    \
    \    vowels_idx = vowels.length\n    vowels_idx = vowels_idx + 1\n    if vowels_idx\
    \ > vowels.length \n        vowels_idx = 0\n    return vowels[vowels_idx]\nend\n\
    </cell>\n<code language=julia-1.5>\nget_closest_vowel(\"yogurt\") ==> \"u\"\n\
    get_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\n\
    get_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and returns the number of vowels found in the string.\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpilqe5pf0.jl:28\nin expression starting at\
    \ /tmp/tmpilqe5pf0.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n    vowels_count = vowels.count(\"a\")\n    vowels_count += vowels.count(\"\
    e\")\n    vowels_count += vowels.count(\"i\")\n    vowels_count += vowels.count(\"\
    o\")\n    vowels_count += vowels.count(\"u\")\n    vowels_count -= 1\n    vowels_count\
    \ /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n\
    \    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count\
    \ -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n\
    \    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count\
    \ /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n\
    \    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count\
    \ -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n\
    \    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count\
    \ /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n\
    \    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count\
    \ -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n\
    \    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count\
    \ /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n\
    \    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count\
    \ -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n\
    \    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count\
    \ /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n\
    \    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= 2\n    vowels_count\
    \ -= 1\n    vowels_count /= 2\n    vowels_count -= 1\n    vowels_count /= \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwv3_2g96.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwv3_2g96.jl:1\n\
    in expression starting at /tmp/tmpwv3_2g96.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels)\n    vowels_count = vowels_count - 2\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n  \
    \  vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n  \
    \  vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowels) else len(vowels)\n    vowels_count\
    \ = vowels_count if vowels_count > 0 else 0\n    vowels_count = vowels_count if\
    \ vowels_count < len(vowels) else len(vowels)\n    vowels_count = vowels_count\
    \ if vowels_count > 0 else 0\n    vowels_count = vowels_count if vowels_count\
    \ < len(vowels) else len(vowels)\n    vowels_count = vowels_count if vowels_count\
    \ > 0 else 0\n    vowels_count = vowels_count if vowels_count < len(vowels) else\
    \ len(vowels)\n    vowels_count = vowels_count if vowels_count > 0 else 0\n  \
    \  vowels_count = vowels_count if vowels_count < len(vowels) else len(vowels)\n\
    \    vowels_count = vowels_count if vowels_count > 0 else 0\n    vowels_count\
    \ = vowels_count if vowels_count < len(vowel\nusing Test\n\n@testset begin\n\n\
    candidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"\
    full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"\
    eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\"\
    ) == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\")\
    \ == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\") ==\
    \ \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\") ==\
    \ \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpunp7nlbh.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpunp7nlbh.jl:19\n\
    in expression starting at /tmp/tmpunp7nlbh.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowel_counter\
    \ = 0\n    vowel_counter = vowels.count(word[vowel_counter:])\n    if vowel_counter\
    \ > 0 \n        vowel_counter = vowels.count(word[vowel_counter-1:])\n       \
    \ if vowel_counter > 0 \n            vowel_counter = vowels.count(word[vowel_counter-2:])\n\
    \            if vowel_counter > 0 \n                vowel_counter = vowels.count(word[vowel_counter-3:])\n\
    \                if vowel_counter > 0 \n                    vowel_counter = vowels.count(word[vowel_counter-4:])\n\
    \                    if vowel_counter > 0 \n                        vowel_counter\
    \ = vowels.count(word[vowel_counter-5:])\n                        if vowel_counter\
    \ > 0 \n                            vowel_counter = vowels.count(word[vowel_counter-6:])\n\
    \                            if vowel_counter > 0 \n                         \
    \       vowel_counter = vowels.count(word[vowel_counter-7:])\n               \
    \                 if vowel_counter > 0 \n                                    vowel_counter\
    \ = vowels.count(word[vowel_counter-8:])\n                                   \
    \ if vowel_counter > 0 \n                                        vowel_counter\
    \ = vowels.count(word[vowel_counter-9:])\n                                   \
    \     if vowel_counter > 0 \n                                            vowel_counter\
    \ = vowels.count(word[vowel_counter-10:])\n                                  \
    \          if vowel_counter > 0 \n                                           \
    \     vowel_counter = vowels.count(word[vowel_counter-11:])\n                \
    \                                if vowel_counter > 0 \n                     \
    \                               vowel_counter = vowels.count(word[vowel_counter-12:])\n\
    \                                                    if vowel_counter > 0 \n \
    \                                                       vowel_counter = vowels.count(word[vowel_counter-13:])\n\
    \                                                        if vowel_counter > 0\
    \ \n                                                            vowel_counter\
    \ = vowels.count(word[vowel_counter-14:])\n                                  \
    \                              if vowel_counter > 0 \n                       \
    \                                             vowel_counter = vowels.count(word[vowel_counter-15:])\n\
    \                                                                        if vowel_counter\
    \ > 0 \n                                                                     \
    \       vowel_counter = vowels.count(word[vowel_counter-16:])\n              \
    \                                                                  if vowel_counter\
    \ > 0 \n                                                                     \
    \               vowel_counter = vowels.count(word[vowel_counter-17:])\n      \
    \                                                                            \
    \      if vowel_counter > 0 \n                                               \
    \                                             vowel_counter = vowels.count(word[vowel_counter-18:])\n\
    \                                                                            \
    \                    if vowel_counter > 0 \n                                 \
    \                                                                   vowel_counter\
    \ = vowels.count(word[vowel_counter-19:])\n                                  \
    \                                                                      if vowel_counter\
    \ > 0 \n                                                                     \
    \                                       vowel_counter = vowels.count(word[vowel_counter-20:])\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing last argument in \"vowel_counter:\" range\
    \ expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkz_pko0e.jl:18\n\
    in expression starting at /tmp/tmpkz_pko0e.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_idx\
    \ = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx == -1\n        return\
    \ \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx = vowels.find{|v|\
    \ word.ends_with?(v)} \n    if vowels_idx == -1\n        return \"\"\n    ending_vowel_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels.find{|v| word.ends_with?(v)} \n  \
    \  if vowels_idx == -1\n        return \"\"\n    ending_vowel_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx\
    \ == -1\n        return \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx == -1\n        return\
    \ \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx = vowels.find{|v|\
    \ word.ends_with?(v)} \n    if vowels_idx == -1\n        return \"\"\n    ending_vowel_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels.find{|v| word.ends_with?(v)} \n  \
    \  if vowels_idx == -1\n        return \"\"\n    ending_vowel_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx\
    \ == -1\n        return \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx == -1\n        return\
    \ \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx = vowels.find{|v|\
    \ word.ends_with?(v)} \n    if vowels_idx == -1\n        return \"\"\n    ending_vowel_idx\
    \ = vowels_idx + 1\n    vowels_idx = vowels.find{|v| word.ends_with?(v)} \n  \
    \  if vowels_idx == -1\n        return \"\"\n    ending_vowel_idx = vowels_idx\
    \ + 1\n    vowels_idx = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx\
    \ == -1\n        return \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx\
    \ = vowels.find{|v| word.ends_with?(v)} \n    if vowels_idx == -1\n        return\
    \ \"\"\n    ending_vowel_idx = vowels_idx + 1\n    vowels_idx = vowels.find{\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphpbbc1oq.jl:17\nin expression starting at\
    \ /tmp/tmphpbbc1oq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    \n    if vowels_len == 0 \n        return \"\"\n    \n  \
    \  vowels_idx = word.rindex(vowels)\n    \n    if vowels_idx == -1 \n        return\
    \ \"\"\n    \n    vowels_idx_2 = vowels_idx + vowels_len\n    \n    if vowels_idx_2\
    \ > len(word)\n        return \"\"\n    \n    vowels_idx_3 = vowels_idx_2 + vowels_len\n\
    \    \n    if vowels_idx_3 > len(word)\n        return \"\"\n    \n    vowels_idx_4\
    \ = vowels_idx_3 + vowels_len\n    \n    if vowels_idx_4 > len(word)\n       \
    \ return \"\"\n    \n    vowels_idx_5 = vowels_idx_4 + vowels_len\n    \n    if\
    \ vowels_idx_5 > len(word)\n        return \"\"\n    \n    vowels_idx_6 = vowels_idx_5\
    \ + vowels_len\n    \n    if vowels_idx_6 > len(word)\n        return \"\"\n \
    \   \n    vowels_idx_7 = vowels_idx_6 + vowels_len\n    \n    if vowels_idx_7\
    \ > len(word)\n        return \"\"\n    \n    vowels_idx_8 = vowels_idx_7 + vowels_len\n\
    \    \n    if vowels_idx_8 > len(word)\n        return \"\"\n    \n    vowels_idx_9\
    \ = vowels_idx_8 + vowels_len\n    \n    if vowels_idx_9 > len(word)\n       \
    \ return \"\"\n    \n    vowels_idx_10 = vowels_idx_9 + vowels_len\n    \n   \
    \ if vowels_idx_10 > len(word)\n        return \"\"\n    \n    vowels_idx_11 =\
    \ vowels_idx_10 + vowels_len\n    \n    if vowels_idx_11 > len(word)\n       \
    \ return \"\"\n    \n    vowels_idx_12 = vowels_idx_11 + vowels_len\n    \n  \
    \  if vowels_idx_12 > len(word)\n        return \"\"\n    \n    vowels_idx_13\
    \ = vowels_idx_12 + vowels_len\n    \n    if vowels_idx_13 > len(word)\n     \
    \   return \"\"\n    \n    vowels_idx_14 = vowels_idx_13 + vowels_len\n    \n\
    \    if vowels_idx_14 > len(word)\n        return \"\"\n    \n    vowels_idx_15\
    \ = vowels_idx_14 + vowels_len\n    \n    if vowels_idx_15 > len(word)\n     \
    \   return \"\"\n    \n    vowels_idx_16 = vowels_idx_15 + vowels_len\n    \n\
    \    if vowels_idx_16 > len(word)\n        return \"\"\n    \n    vowels_idx_17\
    \ = vowels_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t\
    @test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\
    \t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t\
    @test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"\
    most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\"\
    ) == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5uatx_a_.jl:1\nin expression starting at /tmp/tmp5uatx_a_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowels_count = 0\n    vowels_count_left = 0\n    vowels_count_right\
    \ = 0\n    vowels_count_left_right = 0\n    vowels_count_left_right_count = 0\n\
    \    vowels_count_left_right_count_left = 0\n    vowels_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right = 0\n    vowels_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left = 0\n    vowels_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right = 0\n   \
    \ vowels_count_left_right_count_left_right_count_left_right_count = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count\
    \ = 0\n    vowels_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left_right_count_left\
    \ = 0\n    vowels_count_\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdxk3l7yb.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdxk3l7yb.jl:1\n\
    in expression starting at /tmp/tmpdxk3l7yb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_idx = 1\n    vowels_idx_end = vowels_len\n    vowels_idx_start\
    \ = vowels_len\n    vowels_idx_mid = 0\n    \n    while vowels_idx < vowels_idx_end\
    \ do\n        if word[vowels_idx] == vowels[vowels_idx_start] then\n         \
    \   vowels_idx_start = vowels_idx\n        elseif word[vowels_idx] == vowels[vowels_idx_end]\
    \ then\n            vowels_idx_end = vowels_idx\n        elseif word[vowels_idx]\
    \ == vowels[vowels_idx_mid] then\n            vowels_idx_mid = vowels_idx\n  \
    \      end\n        vowels_idx = vowels_idx + 1\n    end\n    \n    if vowels_idx_start\
    \ > vowels_idx_mid then\n        return \"\"\n    elseif vowels_idx_end < vowels_idx_mid\
    \ then\n        return \"\"\n    elseif vowels_idx_start < vowels_idx_mid then\n\
    \        return vowels[vowels_idx_mid]\n    else\n        return vowels[vowels_idx_start]\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ as input and returns the number of vowels present in the string.\nusing Test\n\
    \n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\"\
    ) == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\"\
    ) == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") ==\
    \ \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\") ==\
    \ \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\"\
    )\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") == \"i\"\
    )\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") == \"o\"\
    )\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid \"do\" syntax\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprxoqf59i.jl:23\nin expression starting at /tmp/tmprxoqf59i.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowel_counter = 0\n    vowel_counter = vowels.count(\"a\"\
    )\n    vowel_counter = vowels.count(\"e\")\n    vowel_counter = vowels.count(\"\
    i\")\n    vowel_counter = vowels.count(\"o\")\n    vowel_counter = vowels.count(\"\
    u\")\n    \n    if vowel_counter > 0 and vowel_counter < 4:\n        return word[word.rfind(\"\
    -\") + 1]\n    elif vowel_counter == 4:\n        return word[word.rfind(\"-\"\
    ) + 1]\n    elif vowel_counter == 3:\n        return word[word.rfind(\"-\") +\
    \ 1]\n    elif vowel_counter == 2:\n        return word[word.rfind(\"-\") + 1]\n\
    \    elif vowel_counter == 1:\n        return word[word.rfind(\"-\") + 1]\n  \
    \  else:\n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"FULL\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    ab\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<code language=juli\n\
    using Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\t@test(candidate(\"\
    yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"\
    easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\"\
    ) == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t@test(candidate(\"most\")\
    \ == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"ba\") ==\
    \ \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\") ==\
    \ \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\") ==\
    \ \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"vowel_counter\"\nStacktrace:\n [1]\
    \ top-level scope\n   @ /tmp/tmp29k8oxwz.jl:24\nin expression starting at /tmp/tmp29k8oxwz.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_count = 0\n    vowels_index = 0\n    \n    for char\
    \ in word:\n        if char in vowels:\n            vowels_count += 1\n      \
    \      vowels_index = vowels_count - 1\n    \n    if vowels_count == 0:\n    \
    \    return \"\"\n    \n    if vowels_index == 0:\n        return word[vowels_index:]\n\
    \    \n    if vowels_index == vowels_len - 1:\n        return word[:vowels_index]\n\
    \    \n    return word[vowels_index-1:vowels_index+1]\nend\n</cell>\n<code language=julia-1.4>\n\
    get_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\
    \nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string as input and\
    \ returns the number of vowels found in the string.\nusing Test\n\n@testset begin\n\
    \ncandidate = get_closest_vowel;\n\t@test(candidate(\"yogurt\") == \"u\")\n\t\
    @test(candidate(\"full\") == \"u\")\n\t@test(candidate(\"easy\") == \"\")\n\t\
    @test(candidate(\"eAsy\") == \"\")\n\t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"\
    bad\") == \"a\")\n\t@test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"\
    ab\") == \"\")\n\t@test(candidate(\"ba\") == \"\")\n\t@test(candidate(\"quick\"\
    ) == \"\")\n\t@test(candidate(\"anime\") == \"i\")\n\t@test(candidate(\"Asia\"\
    ) == \"\")\n\t@test(candidate(\"Above\") == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsjnrcdbu.jl:22\nin expression starting at\
    \ /tmp/tmpsjnrcdbu.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_len\
    \ = len(vowels)\n    vowels_index = -1\n    \n    for index in (word.end-1)::-1\
    \ do \n        if vowels[index] == vowels[vowels_index] then \n            vowels_index\
    \ = index\n            break\n    end\n    \n    if vowels_index == -1 then \n\
    \        return \"\"\n    end\n    \n    vowels_index += 1 \n    \n    if vowels[vowels_index]\
    \ == vowels[vowels_index+1] then \n        return vowels[vowels_index]\n    end\n\
    \    \n    return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"\
    quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels present\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpusr_xzxe.jl:20 expected \"\
    end\", got \"do\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpusr_xzxe.jl:20\n\
    in expression starting at /tmp/tmpusr_xzxe.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"You are given a word. Your task is to find the closest vowel that\
    \ stands between \n    two consonants from the right side of the word (case sensitive).\n\
    \    \n    Vowels in the beginning and ending doesn't count. Return empty string\
    \ if you didn't\n    find any vowel met the above condition. \n\n    You may assume\
    \ that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"\
    quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\nfunction\
    \ get_closest_vowel(word::String)::String \n    vowels = \"aeiouAEIOU\"\n    vowels_count\
    \ = count(vowels, word)\n    if vowels_count > 1\n        vowels_index = find_index(vowels,\
    \ word)\n        vowels_index_2 = find_index(vowels, word, 2)\n        if vowels_index\
    \ == vowels_index_2\n            return word[vowels_index+1]\n        elseif vowels_index\
    \ > vowels_index_2\n            return word[vowels_index-1]\n        else\n  \
    \          return word[vowels_index]\n    elseif vowels_count == 1\n        return\
    \ word[vowels_index+1]\n    else\n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    FULL\")\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"quick\")\n</cell>\n\
    <code language=julia-1.5>\nget_closest_vowel(\"ab\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of vowels found\
    \ in the string.\nusing Test\n\n@testset begin\n\ncandidate = get_closest_vowel;\n\
    \t@test(candidate(\"yogurt\") == \"u\")\n\t@test(candidate(\"full\") == \"u\"\
    )\n\t@test(candidate(\"easy\") == \"\")\n\t@test(candidate(\"eAsy\") == \"\")\n\
    \t@test(candidate(\"ali\") == \"\")\n\t@test(candidate(\"bad\") == \"a\")\n\t\
    @test(candidate(\"most\") == \"o\")\n\t@test(candidate(\"ab\") == \"\")\n\t@test(candidate(\"\
    ba\") == \"\")\n\t@test(candidate(\"quick\") == \"\")\n\t@test(candidate(\"anime\"\
    ) == \"i\")\n\t@test(candidate(\"Asia\") == \"\")\n\t@test(candidate(\"Above\"\
    ) == \"o\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmphngov89q.jl:23 expected \"\
    end\", got \"elseif\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphngov89q.jl:27\n\
    in expression starting at /tmp/tmphngov89q.jl:27\n"
  exit_code: 1
  status: SyntaxError
