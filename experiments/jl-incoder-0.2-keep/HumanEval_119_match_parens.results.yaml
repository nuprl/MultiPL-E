name: HumanEval_119_match_parens
language: julia
results:
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that checks if a number is prime. \nA prime number\
    \ is a natural number greater than 1 that has no positive divisors other than\
    \ 1 and itself.\nA prime number is a natural number greater than 1 that has no\
    \ positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors other than 1 and itself.\nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nA prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors other than 1 and itself.\nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nA prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors other than 1 and itself.\nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nA prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors other than 1 and itself.\nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nA prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors other than 1 and itself.\nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nA prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors other than 1 and itself.\nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nA prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself.\nA prime number is a natural number\
    \ greater than 1 that has no positive divisors \nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp0u7705qh.jl:22\nin expression\
    \ starting at /tmp/tmp0u7705qh.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime or not.\
    \ Your function should take in a single number as an argument and return a boolean.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpr4hkqi_4.jl:22\nin expression\
    \ starting at /tmp/tmpr4hkqi_4.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime. Your function\
    \ should take one integer number as input, and return 'Yes' if it is prime and\
    \ 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpb9g7ulqn.jl:22\nin expression\
    \ starting at /tmp/tmpb9g7ulqn.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n\
    \        elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\",\
    \ \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\",\
    \ \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\",\
    \ \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf0yv7jpn.jl:30\nin expression starting at\
    \ /tmp/tmpf0yv7jpn.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for s in lst[2:end]\n       \
    \ if s == \"(\"\n            stack.append(s)\n        elseif s == \")\"\n    \
    \        if stack.length() == 0\n                return \"No\"\n            else\n\
    \                popped = stack.pop()\n                if popped != s\n      \
    \              return \"No\"\n                else\n                    stack.append(s)\n\
    \                end\n            end\n        end\n    end\n    return \"Yes\"\
    \nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"(\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplaizlld5.jl:38\nin expression starting at\
    \ /tmp/tmplaizlld5.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime. \nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nFor example, 5 is a prime number, because all positive divisors\
    \ are 1, 2, and 5.\nWrite a function that checks if a number is prime.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpk477kukd.jl:24\nin expression\
    \ starting at /tmp/tmpk477kukd.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpt02vahcn.jl:24\nin expression\
    \ starting at /tmp/tmpt02vahcn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n\
    \        elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     else\n            if isempty(stack)\n                return \"No\"\n   \
    \         else\n                pop!(stack)\n            end\n        end\n  \
    \  end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()', ')'])\n</cell>\n\
    <code language=julia-1.4>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.4>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.4>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.4>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.4>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyiz9uglr.jl:36\nin expression starting at\
    \ /tmp/tmpyiz9uglr.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', \nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpjmrxy7re.jl:22\nin expression\
    \ starting at /tmp/tmpjmrxy7re.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for i = 2:length(lst)\n     \
    \   if lst[i] == '('\n            stack.append(lst[i])\n        elseif lst[i]\
    \ == ')'\n            if length(stack) == 0 \n                return 'No'\n  \
    \          elseif length(stack) == 1 \n                stack.pop()\n         \
    \   else\n                stack.pop()\n                stack.append(lst[i])\n\
    \            end\n        else\n            if length(stack) == 0 \n         \
    \       return 'No'\n            elseif length(stack) == 1 \n                stack.pop()\n\
    \            else\n                stack.pop()\n                stack.append(lst[i])\n\
    \            end\n        end\n    end\n    \n    if length(stack) == 0 \n   \
    \     return 'Yes'\n    elseif length(stack) == 1 \n        stack.pop()\n    else\n\
    \        stack.pop()\n        stack.append(lst[end])\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzon3v3zi.jl:25\nin expression\
    \ starting at /tmp/tmpzon3v3zi.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        else\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    , \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd4pl4fkm.jl:36\nin expression starting at\
    \ /tmp/tmpd4pl4fkm.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == \"(\"\n        \
    \    push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp3ynyzfa.jl:43\nin expression starting at\
    \ /tmp/tmpp3ynyzfa.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime or not.\
    \ You may use the\nfollowing algorithm:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpruccet2c.jl:22\nin expression\
    \ starting at /tmp/tmpruccet2c.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp4_ixlnqr.jl:24\nin expression\
    \ starting at /tmp/tmp4_ixlnqr.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        else\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphvg3vy74.jl:43\nin expression starting at\
    \ /tmp/tmphvg3vy74.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp05ceabsj.jl:22\nin expression\
    \ starting at /tmp/tmp05ceabsj.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a given string is a valid\
    \ mathematical expression. \nThe string should only consist of numbers, +, -,\
    \ *, /, ^, and parentheses.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpg1ghgxso.jl:22\nin expression\
    \ starting at /tmp/tmpg1ghgxso.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n\
    \        elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_paren\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd2q8sp1p.jl:30\nin expression starting at\
    \ /tmp/tmpd2q8sp1p.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that checks if a binary tree is balanced.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmtcth_ok.jl:22\nin expression\
    \ starting at /tmp/tmpmtcth_ok.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqf7y0j6a.jl:22\nin expression\
    \ starting at /tmp/tmpqf7y0j6a.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ Your function should take one number as input and return 'Yes' if it's prime\
    \ and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpipbkb5ug.jl:22\nin expression\
    \ starting at /tmp/tmpipbkb5ug.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a given\
    \ string is a valid phone number.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpatekexea.jl:24\nin expression\
    \ starting at /tmp/tmpatekexea.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ lst.size == 0\n        return 'No'\n    \n    if lst.size == 1\n        if lst[0]\
    \ == '('\n            return 'Yes'\n        else\n            return 'No'\n  \
    \  end\n    \n    stack = Stack()\n    \n    for s in lst\n        if s == '('\n\
    \            push!(stack, s)\n        elseif s == ')'\n            if !isempty(stack)\n\
    \                if pop!(stack) == '('\n                    return 'Yes'\n   \
    \             else\n                    return 'No'\n                end\n   \
    \         else\n                return 'No'\n            end\n        end\n  \
    \  end\n    \n    return 'No'\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp70kqk5pu.jl:18\nin expression\
    \ starting at /tmp/tmp70kqk5pu.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_zuqssoi.jl:24\nin expression\
    \ starting at /tmp/tmp_zuqssoi.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string and returns a new string\
    \ where all occurrences of '(' and ')' have been replaced by '-'.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpx7lmv3e6.jl:23\nin expression\
    \ starting at /tmp/tmpx7lmv3e6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string as input and returns\
    \ a string with all the characters in lowercase and with all the characters in\
    \ uppercase.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpkhr1ku2r.jl:23\nin expression\
    \ starting at /tmp/tmpkhr1ku2r.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['())',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()()()()'])\n\
    </cell\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmhkbpbrn.jl:24\nin expression\
    \ starting at /tmp/tmpmhkbpbrn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    stack = push!(stack, \"\
    \")\n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n  \
    \      elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     else\n            if isempty(stack)\n                return \"No\"\n   \
    \         else\n                pop!(stack)\n            end\n        end\n  \
    \  end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnv36xos3.jl:38\nin expression starting at\
    \ /tmp/tmpnv36xos3.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes a string as input and returns\
    \ a string with all the letters in lower case.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpiqqwvegn.jl:23\nin expression\
    \ starting at /tmp/tmpiqqwvegn.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdylbdhmr.jl:22\nin expression\
    \ starting at /tmp/tmpdylbdhmr.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise\nWrite a function that takes a string as input and returns the\
    \ number of parentheses in the string.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp7k006it3.jl:23\nin expression\
    \ starting at /tmp/tmp7k006it3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for s in lst\n       \
    \ if s == '('\n            push!(stack, s)\n        elseif s == ')'\n        \
    \    if isempty(stack)\n                return \"No\"\n            else\n    \
    \            pop!(stack)\n            end\n        end\n    end\n    return \"\
    Yes\"\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,julia |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpftoqugbc.jl:31\nin expression starting at\
    \ /tmp/tmpftoqugbc.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string and returns a new string\
    \ where every character is capitalized.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpofqjufax.jl:24\nin expression\
    \ starting at /tmp/tmpofqjufax.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp5f407scw.jl:24\nin expression\
    \ starting at /tmp/tmp5f407scw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpabus7r0_.jl:22\nin expression\
    \ starting at /tmp/tmpabus7r0_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    stack.append(lst[2])\n    \n    for paren\
    \ in lst[1]\n        if paren == '('\n            stack.pop()\n        elseif\
    \ paren == ')'\n            if stack.length() == 0\n                return 'No'\n\
    \            else\n                stack.pop()\n            end\n        else\n\
    \            stack.append(paren)\n        end\n    end\n    return 'Yes'\nend\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', \nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp64pv71qi.jl:25\nin expression\
    \ starting at /tmp/tmp64pv71qi.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime. You may\
    \ use any number as input.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp6lw3bnj6.jl:22\nin expression\
    \ starting at /tmp/tmp6lw3bnj6.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime. Your function\
    \ should take in a number as an argument and return a boolean indicating whether\
    \ the number is prime or not.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpeobrq760.jl:22\nin expression\
    \ starting at /tmp/tmpeobrq760.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdqnifeoz.jl:23\nin expression\
    \ starting at /tmp/tmpdqnifeoz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\n@assert match_parens(['()(',\
    \ ')']) == 'Yes'\n@assert match_parens([')', ')']) == 'No'\n</cell>\n<text>\n\
    Part III. Longest Palindromic Substring\nGiven a string S, find the longest palindromic\
    \ substring in S. You may assume that the given string consists of only lowercase\
    \ English letters (a-z).\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpn4mqw404.jl:22\nin expression\
    \ starting at /tmp/tmpn4mqw404.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(',\
    \ '(', '(', '(', '(', '(', ')', '(', ')', '(', ')', '(', ')\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpaud39wwm.jl:22\nin expression\
    \ starting at /tmp/tmpaud39wwm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqulplu8v.jl:24\nin expression\
    \ starting at /tmp/tmpqulplu8v.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_u62y_yi.jl:22\nin expression\
    \ starting at /tmp/tmp_u62y_yi.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n        if\
    \ i == '('\n            stack.append(i)\n        elseif i == ')'\n           \
    \ if stack.length() == 0\n                return 'No'\n            else\n    \
    \            stack.pop()\n            end\n        end\n    end\n    return 'Yes'\n\
    end\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmps8ba5g9g.jl:24\nin expression\
    \ starting at /tmp/tmps8ba5g9g.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n       \
    \ if i == '('\n            stack.append(i)\n        elseif i == ')'\n        \
    \    if stack.length() == 0\n                return 'No'\n            else\n \
    \               stack.pop()\n            end\n        end\n    end\n    \n   \
    \ if stack.length() == 0\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmppka31237.jl:25\nin expression\
    \ starting at /tmp/tmppka31237.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ \nA number is prime if and only if it is not divisible by any number between\
    \ 2 and its square root. \nThe function should return 'Yes' if a number is prime\
    \ and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpv_mcfv7n.jl:22\nin expression\
    \ starting at /tmp/tmpv_mcfv7n.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_paren\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpsxzh30f_.jl:24\nin expression\
    \ starting at /tmp/tmpsxzh30f_.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp3r7aawpe.jl:22\nin expression\
    \ starting at /tmp/tmp3r7aawpe.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpbx8j593_.jl:22\nin expression\
    \ starting at /tmp/tmpbx8j593_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpo1ieu4n1.jl:22\nin expression\
    \ starting at /tmp/tmpo1ieu4n1.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a given\
    \ string is a palindrome.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmph_89y72m.jl:22\nin expression\
    \ starting at /tmp/tmph_89y72m.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nA number is prime if and only if it is a whole number greater\
    \ than 1 and not a perfect square. \nA perfect square is a number that is the\
    \ product of two whole numbers. \nFor example: 6 is a perfect square, because\
    \ it is the product of 3 and 5.\nWrite a function that checks if a number is prime\
    \ or not. \nA number is prime if and only if it is a whole number greater than\
    \ 1 and not a perfect square. \nA perfect square is a number that is the product\
    \ of two whole numbers. \nFor example: 6 is a perfect square, because it is the\
    \ product of 3 and 5.\nWrite a function that checks if a number is prime or not.\
    \ \nA number is prime if and only if it is a whole number greater than 1 and not\
    \ a perfect square. \nA perfect square is a number that is the product of two\
    \ whole numbers. \nFor example: 6 is a perfect square, because it is the product\
    \ of 3 and 5.\nWrite a function that checks if a number is prime or not. \nA number\
    \ is prime if and only if it is a whole number greater than 1 and not a perfect\
    \ square. \nA perfect square is a number that is the product of two whole numbers.\
    \ \nFor example: 6 is a perfect square, because it is the product of 3 and 5.\n\
    Write a function that checks if a number is prime or not. \nA number is prime\
    \ if and only if it is a whole number greater than 1 and not a perfect square.\
    \ \nA perfect square is a number that is the product of two whole numbers. \n\
    For example: 6 is a perfect square, because it is the product of 3 and 5.\nWrite\
    \ a function that checks if a number is prime or not. \nA number is prime if and\
    \ only if it is a whole number greater than 1 and not a perfect square. \nA perfect\
    \ square is a number that is the product of two whole numbers. \nFor example:\
    \ 6 is a perfect square, because it is the product of 3 and 5.\nWrite a function\
    \ that checks if a number is prime or not. \nA number is prime if and only if\
    \ it is a whole number greater than 1 and not a perfe\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmnlcam92.jl:24\nin expression\
    \ starting at /tmp/tmpmnlcam92.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpd4xxjqsx.jl:24\nin expression\
    \ starting at /tmp/tmpd4xxjqsx.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ \nThe function should take one integer number as an argument and return a boolean.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpkbeuc2_9.jl:22\nin expression\
    \ starting at /tmp/tmpkbeuc2_9.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '()', '()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '()', '()', '()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '()', '()', '()', '()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '()', '()', '()', '()', '()', '()', '()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '()', '()', '()', '()', '()', '()', '()', '()', '()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '()', '()', '()', '()', '()', '()',\
    \ '()', '()', '()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()', '()', '()', '()', '()',\
    \ '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()',\
    \ '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()',\
    \ '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()', '()',\
    \ '()', '()', '()\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpgrkqk1i6.jl:22\nin expression\
    \ starting at /tmp/tmpgrkqk1i6.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime. \nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpn7_5ayp5.jl:22\nin expression\
    \ starting at /tmp/tmpn7_5ayp5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmprd24h84y.jl:22\nin expression\
    \ starting at /tmp/tmprd24h84y.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime (up to 10^9).\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpc369343x.jl:22\nin expression\
    \ starting at /tmp/tmpc369343x.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime. \nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself.\nThe number 2 is the only even prime number.\nThe number\
    \ 5 is the only odd prime number.\nThe number 7 is the only prime number.\nThe\
    \ number 11 is the only prime number.\nThe number 13 is the only prime number.\n\
    The number 17 is the only prime number.\nThe number 19 is the only prime number.\n\
    The number 23 is the only prime number.\nThe number 29 is the only prime number.\n\
    The number 31 is prime since it has no positive divisors other than 1 and itself.\n\
    The number 37 is the only prime number.\nThe number 41 (the sum of two primes\
    \ next to each other) is the only prime number.\nThe number 43 is the only prime\
    \ number.\nThe number 47 is the only prime number.\nThe number 53 is the only\
    \ prime number.\nThe number 59 is the only prime number.\nThe number 61 (the sum\
    \ of two primes next to each other) is the only prime number.\nThe number 67 (the\
    \ sum of two primes next to each other) is the only prime number.\nThe number\
    \ 71 (the sum of two primes next to each other) is the only prime number.\nThe\
    \ number 73 (the sum of two primes next to each other) is the only prime number.\n\
    The number 79 (the sum of two primes next to each other) is the only prime number.\n\
    The number 83 (the sum of two primes next to each other) is the only prime number.\n\
    The number 89 (the sum of two primes next to each other) is the only prime number.\n\
    The number 97 (the sum of two primes next to each other) is the only prime number.\n\
    The number 101 (the sum of two primes next to each other) is the only prime number.\n\
    The number 103 (the sum of two primes next to \nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpfwelvaz8.jl:24\nin expression\
    \ starting at /tmp/tmpfwelvaz8.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    return 'Yes'\nend\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpra0fx64r.jl:22\nin expression\
    \ starting at /tmp/tmpra0fx64r.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        else\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp411tcp98.jl:24\nin expression\
    \ starting at /tmp/tmp411tcp98.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for s in lst\n       \
    \ if s == '('\n            push!(stack, s)\n        elseif s == ')'\n        \
    \    if isempty(stack)\n                return \"No\"\n            else\n    \
    \            pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([')', ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks\
    \ if a binary tree is a valid binary search tree. \nA binary search tree is a\
    \ binary tree in which all nodes are sorted in ascending order.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3rz7a72b.jl:37\nin expression starting at\
    \ /tmp/tmp3rz7a72b.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for s in lst\n       \
    \ if s == \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n    \
    \        if isempty(stack)\n                return \"No\"\n            else\n\
    \                pop!(stack)\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens([\"()\", \"()\"])\n</cell\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkoi3c4w6.jl:31\nin expression starting at\
    \ /tmp/tmpkoi3c4w6.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst)\n    \n    while !isempty(stack)\n        str\
    \ = pop!(stack)\n        if str == '('\n            push!(stack, str)\n      \
    \  elseif str == ')'\n            if isempty(stack)\n                return 'No'\n\
    \            else\n                pop!(stack)\n            end\n        end\n\
    \    end\n    \n    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpd6u9sno6.jl:26\nin expression\
    \ starting at /tmp/tmpd6u9sno6.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return \"No\"\n    \n    if length(lst) == 1 \n \
    \       if lst[1] == \"(\" \n            return \"Yes\"\n        else \n     \
    \       return \"No\"\n    end\n    \n    stack = Stack()\n    \n    for x in\
    \ lst\n        if x == \"(\" \n            push!(stack, x)\n        else \n  \
    \          if stack.length > 0 \n                if stack[length(stack)-1] ==\
    \ \"(\" \n                    pop!(stack)\n                elseif stack[length(stack)-1]\
    \ == \")\" \n                    push!(stack, x)\n                else\n     \
    \               return \"No\"\n                end\n            else\n       \
    \         return \"No\"\n            end\n        end\n    end\n    return \"\
    Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\",\
    \ \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxnq0zra.jl:48\nin expression starting at\
    \ /tmp/tmpnxnq0zra.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime or not.\
    \ You may want to use the sieve of Eratosthenes algorithm.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpb569bw3j.jl:23\nin expression\
    \ starting at /tmp/tmpb569bw3j.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdziddv28.jl:23\nin expression\
    \ starting at /tmp/tmpdziddv28.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime. Your function\
    \ should take in a number as input and output 'Yes' if it's a prime number, and\
    \ 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpcj6c31lm.jl:22\nin expression\
    \ starting at /tmp/tmpcj6c31lm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpsns7cu8c.jl:22\nin expression\
    \ starting at /tmp/tmpsns7cu8c.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n       \
    \ if i == '('\n            stack.append(i)\n        elseif i == ')'\n        \
    \    if stack.pop() != i\n                return \"No\"\n            else\n  \
    \              return \"Yes\"\n            end\n        end\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([')', ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a string and returns the number of characters in it.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpci72c7q8.jl:32\nin expression starting at\
    \ /tmp/tmpci72c7q8.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ You may use the\nfollowing definition of a prime:\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_zw5q0v4.jl:22\nin expression\
    \ starting at /tmp/tmp_zw5q0v4.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return 'No'\n    end\n    \n    if lst[1] == '('\n\
    \        \n        if lst[2] == ')'\n            return 'Yes'\n        else\n\
    \            return 'No'\n        end\n    else\n        \n        if lst[1] ==\
    \ ')'\n            return 'No'\n        else\n            return 'Yes'\n     \
    \   end\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert match_parens(['()(',\
    \ ')']) == 'Yes'\n@assert match_parens([')', ')']) == 'No'\n</cell>\n<text>\n\
    Part III. Palindrome check\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdko7ospm.jl:18\nin expression\
    \ starting at /tmp/tmpdko7ospm.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.3>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.3>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqjz6eldm.jl:22\nin expression\
    \ starting at /tmp/tmpqjz6eldm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp84chev52.jl:24\nin expression\
    \ starting at /tmp/tmp84chev52.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '()', '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp89k4a40a.jl:23\nin expression\
    \ starting at /tmp/tmp89k4a40a.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    stack = push!(stack, \"\
    \")\n    for s in lst\n        if s == '('\n            push!(stack, s)\n    \
    \    elseif s == ')'\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ elseif isempty(stack)\n            return \"No\"\n        else\n           \
    \ pop!(stack)\n            push!(stack, s)\n        end\n    end\n    return \"\
    Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl8k5wcgj.jl:37\nin expression starting at\
    \ /tmp/tmpl8k5wcgj.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for elem in lst[2:end]\n    \
    \    if elem == \"(\"\n            stack.append(elem)\n        elseif elem ==\
    \ \")\"\n            if stack.pop() == \"(\"\n                stack.append(elem)\n\
    \            else\n                return \"No\"\n            end\n        end\n\
    \    end\n    \n    if stack.pop() == \"(\"\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \")(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\"\
    , \")(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"\
    )(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\"\
    , \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \")(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \")(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\"\
    , \")(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"\
    )(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\"\
    , \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")(\", \")\"])\n</cell>\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbejxyiu4.jl:38\nin expression starting at\
    \ /tmp/tmpbejxyiu4.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ You may assume that the number is an integer and greater than 1.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpn72www58.jl:22\nin expression\
    \ starting at /tmp/tmpn72www58.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')('])\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpztqt2hxp.jl:22\nin expression\
    \ starting at /tmp/tmpztqt2hxp.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for s in lst\n       \
    \ if s == '('\n            push!(stack, s)\n        elseif s == ')'\n        \
    \    if isempty(stack)\n                return \"No\"\n            else\n    \
    \            pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \")\")])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_paren\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpst55m2xj.jl:37\nin expression starting at\
    \ /tmp/tmpst55m2xj.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise\nWrite a function that checks if a number is prime or not. \n\
    The function should take one argument, an integer $n$, and return 'Yes' if $n$\
    \ is prime and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpipfll_c6.jl:22\nin expression\
    \ starting at /tmp/tmpipfll_c6.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for x in lst[2:end]\n        if\
    \ x == '('\n            stack.append(x)\n        elseif x == ')'\n           \
    \ if stack.length() == 0\n                return 'No'\n            else\n    \
    \            stack.pop()\n            end\n        end\n    end\n    return 'Yes'\n\
    end\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['))', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    \nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpgh6t43nk.jl:24\nin expression\
    \ starting at /tmp/tmpgh6t43nk.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for x in lst[2:end]\n        if\
    \ x == '('\n            stack.append(x)\n        elseif x == ')'\n           \
    \ if stack.length() == 0\n                return 'No'\n            else\n    \
    \            popped = stack.pop()\n                if popped != '('\n        \
    \            return 'No'\n                end\n            end\n        else\n\
    \            if stack.length() == 0\n                return 'No'\n           \
    \ else\n                popped = stack.pop()\n                if popped != '('\n\
    \                    return 'No'\n                end\n            end\n     \
    \   end\n    end\n    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')', '(', ')', '(', ')', '(', ')', '\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_gluefo0.jl:24\nin expression\
    \ starting at /tmp/tmp_gluefo0.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for paren in lst[1]\n       \
    \ if paren == '('\n            stack.append(paren)\n        elseif paren == ')'\n\
    \            if stack.length() == 0\n                return 'No'\n           \
    \ else\n                stack.pop()\n            end\n        end\n    end\n \
    \   \n    if stack.length() == 0\n        return 'Yes'\n    else\n        return\
    \ 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp4ddz11uh.jl:25\nin expression\
    \ starting at /tmp/tmp4ddz11uh.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp4li5kwxh.jl:22\nin expression\
    \ starting at /tmp/tmp4li5kwxh.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for char in lst[1]\n        if\
    \ char == '('\n            stack.append(char)\n        elseif char == ')'\n  \
    \          if stack.length() == 0\n                return 'No'\n            else\n\
    \                stack.pop()\n            end\n        end\n    end\n    \n  \
    \  if stack.length() == 0\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string and returns the number of characters\
    \ in it.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqr2pastj.jl:25\nin expression\
    \ starting at /tmp/tmpqr2pastj.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime. You may\
    \ use any number as input.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpa0eyfbwf.jl:22\nin expression\
    \ starting at /tmp/tmpa0eyfbwf.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nThe function should take one integer number as an argument\
    \ and should return 'Yes' if it's prime and 'No' otherwise.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp66_1j60m.jl:37\nin expression starting at\
    \ /tmp/tmp66_1j60m.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a given\
    \ string is a palindrome or not.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp8p_pb60r.jl:24\nin expression\
    \ starting at /tmp/tmp8p_pb60r.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for s in lst[2:end]\n        if\
    \ s == '('\n            stack.append(s)\n        elseif s == ')'\n           \
    \ if stack.length() == 0\n                return 'No'\n            else\n    \
    \            stack.pop()\n            end\n        else\n            if stack.length()\
    \ == 0\n                return 'No'\n            else\n                stack.pop()\n\
    \            end\n        end\n    end\n    return 'Yes'\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpglfzv5_m.jl:24\nin expression\
    \ starting at /tmp/tmpglfzv5_m.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpcfl84khv.jl:24\nin expression\
    \ starting at /tmp/tmpcfl84khv.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ Your function should take in a number as input and return a boolean value indicating\
    \ whether it is prime or not.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp4wqku4e6.jl:22\nin expression\
    \ starting at /tmp/tmp4wqku4e6.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp3voyowo_.jl:22\nin expression\
    \ starting at /tmp/tmp3voyowo_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst)\n    \n    while !isempty(stack)\n        str\
    \ = pop!(stack)\n        if str == '('\n            push!(stack, ')')\n      \
    \  elseif str == ')'\n            if isempty(stack)\n                return 'No'\n\
    \            else\n                pop!(stack)\n            end\n        else\n\
    \            push!(stack, str)\n        end\n    end\n    return 'Yes'\nend\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a string as input and returns a string with all the\
    \ letters capitalized.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpj2cag8j7.jl:25\nin expression\
    \ starting at /tmp/tmpj2cag8j7.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string as\
    \ input and returns the number of occurrences of 'a' in that string.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpg06qh6uo.jl:24\nin expression\
    \ starting at /tmp/tmpg06qh6uo.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpce7mve96.jl:24\nin expression\
    \ starting at /tmp/tmpce7mve96.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime. \nA prime number is a natural number greater than 1 that has no positive\
    \ divisors other than 1 and itself.\nThe function should take one argument, an\
    \ integer. \nIt should return 'Yes' if it's a prime number, and 'No' otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp876pwiq7.jl:24\nin expression\
    \ starting at /tmp/tmp876pwiq7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert match_parens(['()(', ')']) == 'Yes'\n@assert match_parens([')', ')'])\
    \ == 'No'\n</cell>\n<text>\nPart II: Parsing and Manipulating Strings\nIn this\
    \ section, we will learn how to parse strings into numbers, booleans, etc.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpxguncaal.jl:24\nin expression\
    \ starting at /tmp/tmpxguncaal.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for s in lst\n       \
    \ if s == ')'\n            if length(stack) == 0\n                return \"No\"\
    \n            else\n                pop!(stack)\n        end\n        if s ==\
    \ '('\n            push!(stack, s)\n        end\n    end\n    return \"Yes\"\n\
    end\n</code>\n<|/ a tags=string,julia,recursion |>\n<| c |>\nThank you for your\
    \ answer. I am not allowed to use any packages other than Base.\n<|/ c |>\n<|\
    \ c |>\nI edited my answer to include a solution that does not use any packages.\n\
    <|/ c |>\n<| c |>\nThank you for your answer. I tried your solution and it works\
    \ perfectly fine. I am still trying to understand how it works. I appreciate your\
    \ help.\n<|/ c |>\n<| c |>\nI added some comments to my answer, hope it helps.\n\
    <|/ c |>\n<| c |>\nThank you for your answer. I tried your solution and it works\
    \ perfectly fine. I am still trying to understand how it works. I appreciate your\
    \ help.\n<|/ c |>\n<| a dscore=0 |>\nI wrote a recursive solution that uses no\
    \ packages. I used a stack to keep track of the parentheses levels. I used a while\
    \ loop to keep track of the parentheses levels. I used a recursive function to\
    \ check if a pair of parentheses balanced or not, and I used a base case to exit\
    \ the while loop if there are no more parentheses to balance.\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp01dyf5ch.jl:31\nin expression starting at\
    \ /tmp/tmp01dyf5ch.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ \nThe function should take one integer as an argument and return a boolean.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmphf45nqls.jl:22\nin expression\
    \ starting at /tmp/tmphf45nqls.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n\
    \        elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     else\n            if isempty(stack)\n                return \"No\"\n   \
    \         else\n                pop!(stack)\n            end\n        end\n  \
    \  end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    , \"(\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"\
    ))\", \"(\", \"))\", \"(\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"\
    (\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    , \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"))\"\
    , \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"))\"\
    , \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"\
    (\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    , \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"\
    (\", \"))\", \"(\", \"))\", \"(\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"\
    (\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\"\
    , \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\",\
    \ \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"(\", \"))\", \"\
    (\", \"))\", \"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpddttfq9z.jl:36\nin expression starting at\
    \ /tmp/tmpddttfq9z.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert match_parens(['()(',\
    \ ')']) == 'Yes'\n@assert match_parens([')', ')']) == 'No'\n@assert match_parens(['(',\
    \ ')']) == 'No'\n@assert match_parens(['(', '(', ')']) == 'No'\n@assert match_parens(['(',\
    \ '(', '(', ')']) == 'Yes'\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp0a_xw88h.jl:24\nin expression\
    \ starting at /tmp/tmp0a_xw88h.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        else\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfwxrilp4.jl:43\nin expression starting at\
    \ /tmp/tmpfwxrilp4.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        else\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpd3_ej_dp.jl:24\nin expression\
    \ starting at /tmp/tmpd3_ej_dp.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and\
    \ returns a string where all occurrences of '(' and ')' have been replaced by\
    \ '-'.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp3487vd__.jl:24\nin expression\
    \ starting at /tmp/tmp3487vd__.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    return 'Yes'\nend\n</cell>\n<code language=julia-1.4>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime (ie. divisible only by 1 and itself).\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpr2egm1v5.jl:22\nin expression\
    \ starting at /tmp/tmpr2egm1v5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is even.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp91djztun.jl:24\nin expression\
    \ starting at /tmp/tmp91djztun.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string as input and returns\
    \ the number of occurrences of '(' and ')' in the string.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpner0s97r.jl:22\nin expression\
    \ starting at /tmp/tmpner0s97r.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is a binary\
    \ search tree.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdv3r3nh_.jl:24\nin expression\
    \ starting at /tmp/tmpdv3r3nh_.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(', ')\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmg9xt8uv.jl:23\nin expression\
    \ starting at /tmp/tmpmg9xt8uv.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpif5t3kic.jl:22\nin expression\
    \ starting at /tmp/tmpif5t3kic.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        else\n            return 'No'\n        end\n    end\n\
    \    \n    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that checks if a number is prime or not. \nThe function\
    \ should take one integer number as an argument and return a boolean.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp20tjy97k.jl:24\nin expression\
    \ starting at /tmp/tmp20tjy97k.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpcbsq6iqr.jl:23\nin expression\
    \ starting at /tmp/tmpcbsq6iqr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp3_bbd33_.jl:23\nin expression\
    \ starting at /tmp/tmp3_bbd33_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', \nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp616t2z_l.jl:24\nin expression\
    \ starting at /tmp/tmp616t2z_l.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nPart 2: Matching Parentheses\nNow that you've seen how to match parentheses,\
    \ let's see how to match them in Julia.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpna0ghlof.jl:24\nin expression\
    \ starting at /tmp/tmpna0ghlof.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp0vq507yf.jl:22\nin expression\
    \ starting at /tmp/tmp0vq507yf.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpfon2e3pc.jl:24\nin expression\
    \ starting at /tmp/tmpfon2e3pc.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp9ri_w77c.jl:22\nin expression\
    \ starting at /tmp/tmp9ri_w77c.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.4>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.4>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp6w8om4ow.jl:22\nin expression\
    \ starting at /tmp/tmp6w8om4ow.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.3>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp24z__ypx.jl:22\nin expression\
    \ starting at /tmp/tmp24z__ypx.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime or not.\
    \ You may want to use the following formula to determine if a number is prime:\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpwk4drvb0.jl:24\nin expression\
    \ starting at /tmp/tmpwk4drvb0.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ You may use the\nfollowing rules:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpptvz5btl.jl:23\nin expression\
    \ starting at /tmp/tmpptvz5btl.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime. \nA prime\
    \ number is a natural number greater than 1 that has no positive divisors other\
    \ than 1 and itself. \nA prime number is a natural number greater than 1 that\
    \ has no positive divisors other than 1 and itself.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpsheru05w.jl:22\nin expression\
    \ starting at /tmp/tmpsheru05w.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return \"No\"\n    end\n    \n    if length(lst)\
    \ == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\n    \n    stack = Stack()\n    \n    for\
    \ s in lst \n        if s == \"(\" \n            push!(stack, s)\n        else\
    \ \n            pop!(stack)\n            if stack == [] \n                return\
    \ \"No\"\n            end\n        end\n    end\n    \n    return \"Yes\"\nend\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"(\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\",\
    \ \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\",\
    \ \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7wnda89w.jl:43\nin expression starting at\
    \ /tmp/tmp7wnda89w.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp1txqcyxj.jl:22\nin expression\
    \ starting at /tmp/tmp1txqcyxj.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            push!(stack, s)\n        end\n    end\n    if isempty(stack)\n\
    \        return 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpfeu2f8pd.jl:22\nin expression\
    \ starting at /tmp/tmpfeu2f8pd.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for elem in lst[2:end]\n    \
    \    if elem == \"(\"\n            stack.append(elem)\n        elseif elem ==\
    \ \")\"\n            if stack.size == 0\n                return \"No\"\n     \
    \       else\n                stack.pop()\n            end\n        else\n   \
    \         if stack.size == 0\n                return \"No\"\n            else\n\
    \                stack.pop()\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\"])\n</\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt0r0v5ws.jl:39\nin expression starting at\
    \ /tmp/tmpt0r0v5ws.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for i in lst\n       \
    \ if i == \"(\"\n            push!(stack, \"\")\n        elseif i == \")\"\n \
    \           if isempty(stack)\n                return \"No\"\n            else\n\
    \                pop!(stack)\n            end\n        else\n            push!(stack,\
    \ i[1])\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\nmatch_\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5k1j4lez.jl:33\nin expression starting at\
    \ /tmp/tmp5k1j4lez.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpeysrvc_h.jl:22\nin expression\
    \ starting at /tmp/tmpeysrvc_h.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpufgq5s38.jl:22\nin expression\
    \ starting at /tmp/tmpufgq5s38.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()', '(', ')',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpvlr5mrxi.jl:22\nin expression\
    \ starting at /tmp/tmpvlr5mrxi.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for elem in lst[2:end]\n      \
    \  if elem == ')'\n            stack.pop()\n        elseif elem == '('\n     \
    \       stack.append(elem)\n        else\n            return false\n    end\n\
    \    return true\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp1ml29x7.jl:29\nin expression starting at\
    \ /tmp/tmpp1ml29x7.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    stack = push!(stack, \"\
    \")\n    for s in lst\n        if s == '('\n            push!(stack, s)\n    \
    \    elseif s == ')'\n            if isempty(stack)\n                return 'No'\n\
    \            else\n                pop!(stack)\n            end\n        end\n\
    \    end\n    if isempty(stack)\n        return 'No'\n    else\n        return\
    \ 'Yes'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpr_lll6me.jl:24\nin expression\
    \ starting at /tmp/tmpr_lll6me.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.3>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nPart III: Palindrome Strings\nA palindrome is a string that reads the\
    \ same backward as forward, for example:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpg27zjdst.jl:22\nin expression\
    \ starting at /tmp/tmpg27zjdst.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ Your function should take one number as input and return 'Yes' if it's prime\
    \ and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpjcsn3ycm.jl:22\nin expression\
    \ starting at /tmp/tmpjcsn3ycm.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime. \nA prime number is a natural number greater than 1 that has no positive\
    \ divisors other than 1 and itself.\nFor example 5 is a prime number, but 2 is\
    \ not because 2 has only 1 divisor, which is itself.\nWrite a function that checks\
    \ if a number is prime.\nFor example 5 is a prime number, but 2 is not because\
    \ 2 has only 1 divisor, which is itself.\nWrite a function that checks if a number\
    \ is prime.\nFor example 5 is a prime number, but 2 is not because 2 has only\
    \ 1 divisor, which is itself.\nWrite a function that checks if a number is prime.\n\
    For example 5 is a prime number, but 2 is not because 2 has only 1 divisor, which\
    \ is itself.\nWrite a function that checks if a number is prime.\nFor example\
    \ 5 is a prime number, but 2 is not because 2 has only 1 divisor, which is itself.\n\
    Write a function that checks if a number is prime.\nFor example 5 is a prime number,\
    \ but 2 is not because 2 has only 1 divisor, which is itself.\nWrite a function\
    \ that checks if a number is prime.\nFor example 5 is a prime number, but 2 is\
    \ not because 2 has only 1 divisor, which is itself.\nWrite a function that checks\
    \ if a number is prime.\nFor example 5 is a prime number, but 2 is not because\
    \ 2 has only 1 divisor, which is itself.\nWrite a function that checks if a number\
    \ is prime.\nFor example 5 is a prime number, but 2 is not because 2 has only\
    \ 1 divisor, which is itself.\nWrite a function that checks if a number is prime.\n\
    For example 5 is a prime number, but 2 is not because 2 has only 1 divisor, which\
    \ is itself.\nWrite a function that checks if a number is prime.\nFor example\
    \ 5 is a prime number, but 2 is not because 2 has only 1 divisor, which is itself.\n\
    Write a function that checks if a number is prime.\nFor example 5 is a prime number,\
    \ but 2 is not because 2 has only 1 divisor, which is itself.\nWrite a function\
    \ that checks if a number is prime.\nFor example 5 is a prime number, but 2\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpd79so85x.jl:24\nin expression\
    \ starting at /tmp/tmpd79so85x.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is a binary\
    \ search tree.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpw5t__5n1.jl:22\nin expression\
    \ starting at /tmp/tmpw5t__5n1.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp8uemz92c.jl:24\nin expression\
    \ starting at /tmp/tmp8uemz92c.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a given string is a palindrome\
    \ or not.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzxecenut.jl:22\nin expression\
    \ starting at /tmp/tmpzxecenut.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()('])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()('])\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmphe0qiruk.jl:24\nin expression\
    \ starting at /tmp/tmphe0qiruk.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmppfzwvk8p.jl:22\nin expression\
    \ starting at /tmp/tmppfzwvk8p.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        else\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\",\
    \ \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsjnsp4p2.jl:39\nin expression starting at\
    \ /tmp/tmpsjnsp4p2.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpthsnm0yr.jl:22\nin expression\
    \ starting at /tmp/tmpthsnm0yr.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp7y62b4w_.jl:23\nin expression\
    \ starting at /tmp/tmp7y62b4w_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return 'No'\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqdd9zrsf.jl:18\nin expression\
    \ starting at /tmp/tmpqdd9zrsf.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()('])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()('])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()('])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()()()()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp795_n9fl.jl:24\nin expression\
    \ starting at /tmp/tmp795_n9fl.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for elem in lst[2:end]\n    \
    \    if elem == '('\n            stack.append(elem)\n        elseif elem == ')'\n\
    \            if stack.size == 0\n                return \"No\"\n            else\n\
    \                stack.pop()\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"(\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\",\
    \ \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\",\
    \ \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiccxcr0l.jl:33\nin expression starting at\
    \ /tmp/tmpiccxcr0l.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n\
    \        elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\",\
    \ \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpho36d9d1.jl:30\nin expression starting at\
    \ /tmp/tmpho36d9d1.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            push!(stack, s)\n        end\n    end\n    if isempty(stack)\n\
    \        return 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([')', ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks\
    \ if a number is prime. Your function should take in a number as input and return\
    \ 'Yes' if it's prime and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp5e2z47c5.jl:22\nin expression\
    \ starting at /tmp/tmp5e2z47c5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for s in lst[2:end]\n        if\
    \ s == \"(\"\n            stack.append(s)\n        elseif s == \")\"\n       \
    \     if stack.pop() == \"(\"\n                stack.pop()\n            else\n\
    \                return \"No\"\n            end\n        else\n            if\
    \ stack.pop() != s\n                return \"No\"\n            end\n        end\n\
    \    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"(\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"(\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"(\"\
    , \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\",\
    \ \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"((\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoxvphhol.jl:36\nin expression starting at\
    \ /tmp/tmpoxvphhol.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        else\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    ()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    ()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    ()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    ()\"])\n</\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_bvnoter.jl:43\nin expression starting at\
    \ /tmp/tmp_bvnoter.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for paren in lst[1]\n        if\
    \ paren == '('\n            stack.append(paren)\n        elseif paren == ')'\n\
    \            if stack.length() == 0\n                return \"No\"\n         \
    \   else\n                stack.pop()\n            end\n        end\n    end\n\
    \    \n    if stack.length() == 0\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"\
    ])\n</cell\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpta79mkoj.jl:37\nin expression starting at\
    \ /tmp/tmpta79mkoj.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime or not.\
    \ \nA number is prime if and only if it is a whole number greater than 1.\nThe\
    \ function should take one number as input and return a boolean value.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpu405_56c.jl:22\nin expression\
    \ starting at /tmp/tmpu405_56c.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', \nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpio4fj1nd.jl:24\nin expression\
    \ starting at /tmp/tmpio4fj1nd.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp6qy5l7su.jl:22\nin expression\
    \ starting at /tmp/tmp6qy5l7su.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp8vti4xvl.jl:22\nin expression\
    \ starting at /tmp/tmp8vti4xvl.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp6c3_0ix6.jl:24\nin expression\
    \ starting at /tmp/tmp6c3_0ix6.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.0>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp1g_mc97c.jl:22\nin expression\
    \ starting at /tmp/tmp1g_mc97c.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is a binary\
    \ search tree.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp26gn4ett.jl:24\nin expression\
    \ starting at /tmp/tmp26gn4ett.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return \"No\"\n    \n    if length(lst) == 1 \n \
    \       return match_parens(lst[1:end-1]) + lst[end]\n    \n    stack = Vector{String}(lst)\n\
    \    \n    stack = stack[1:end-1]\n    \n    if length(stack) == 0 \n        return\
    \ \"No\"\n    \n    if length(stack) == 1 \n        return match_parens(stack)\
    \ + stack[end]\n    \n    stack = stack[1:end-1]\n    \n    if length(stack) ==\
    \ 0 \n        return \"No\"\n    \n    if length(stack) == 1 \n        return\
    \ match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n    \n \
    \   if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack)\
    \ == 1 \n        return match_parens(stack) + stack[end]\n    \n    stack = stack[1:end-1]\n\
    \    \n    if length(stack) == 0 \n        return \"No\"\n    \n    if length(stack\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvnbblaos.jl:119\nin expression starting at\
    \ /tmp/tmpvnbblaos.jl:119\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime. Your function should take one number as input and return 'Yes' if\
    \ it is prime and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmvlct3_7.jl:24\nin expression\
    \ starting at /tmp/tmpmvlct3_7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', ')\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmptnpnrtbr.jl:22\nin expression\
    \ starting at /tmp/tmptnpnrtbr.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    for char in lst[1]\n        if char ==\
    \ '('\n            stack.append(char)\n        elseif char == ')'\n          \
    \  if stack.pop() != char\n                return \"No\"\n            else\n \
    \               stack.pop()\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"(())\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(()())\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (())()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(()())()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"(())()()()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"(())()()()()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    (())()()()()()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()()()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(())()()()()()()()()()()()\"\
    ])\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp77aae06n.jl:31\nin expression starting at\
    \ /tmp/tmp77aae06n.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            push!(stack, s)\n        end\n    end\n    \n    if\
    \ isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()', '(())'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(())',\
    \ '()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()', '(())', '()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(())', '(())', '()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(())', '(())', '(())'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(())', '(())', '(())', '(())'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(())', '(())', '(())', '(())', '(())'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(())', '(())', '(())', '(())',\
    \ '(())', '(())', '(())'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(())',\
    \ '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())',\
    \ '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())',\
    \ '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())',\
    \ '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())',\
    \ '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())',\
    \ '(())', '(())', '(())', '(())', '(())', '(\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp7jcl4ai2.jl:24\nin expression\
    \ starting at /tmp/tmp7jcl4ai2.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return 'No'\n    \n    if length(lst) == 1 \n   \
    \     return match_parens(lst[1]) \n    \n    stack = Vector{String}(lst)\n  \
    \  \n    while length(stack) > 1 \n        \n        if stack[1] == '(' and stack[2]\
    \ == ')' \n            return 'Yes'\n        \n        if stack[1] == '(' and\
    \ stack[2] != '('\n            return 'No'\n        \n        if stack[1] != '('\
    \ and stack[2] != '('\n            return 'No'\n        \n        popped = stack.pop\n\
    \        \n        if stack[1] == '(' and stack[2] == ')' \n            push!(stack,\
    \ popped) \n        elseif stack[1] == '(' and stack[2] != '('\n            push!(stack,\
    \ popped) \n        elseif stack[1] != '(' and stack[2] != '('\n            push!(stack,\
    \ popped) \n        end\n    end\n    \n    return 'No'\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp900ddwkt.jl:18\nin expression\
    \ starting at /tmp/tmp900ddwkt.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpxu0dy_6z.jl:24\nin expression\
    \ starting at /tmp/tmpxu0dy_6z.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return \"No\"\n    end\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3avz22jr.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3avz22jr.jl:1\n\
    in expression starting at /tmp/tmp3avz22jr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['))', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(()', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(()', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(()',\
    \ ')('])\n\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp8qvr6us6.jl:22\nin expression\
    \ starting at /tmp/tmp8qvr6us6.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.0>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.0>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmgy2terx.jl:23\nin expression\
    \ starting at /tmp/tmpmgy2terx.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.3>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes a string and returns a string\
    \ where all occurrences of '(' and ')' have been replaced by '-'.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpgzykib0h.jl:22\nin expression\
    \ starting at /tmp/tmpgzykib0h.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == \"(\"\n        \
    \    push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime. \nA number is prime if and only if it is a prime number or is a perfect\
    \ square. \nA perfect square is a number that is the product of two integers,\
    \ \nand each integer is greater than 1. \nA prime number is a natural number greater\
    \ than 1 that has no positive divisors other than 1 and itself.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpikktpvf0.jl:38\nin expression starting at\
    \ /tmp/tmpikktpvf0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            push!(stack, s)\n        end\n    end\n    \n    if\
    \ isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['))', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpro7v_h4s.jl:24\nin expression\
    \ starting at /tmp/tmpro7v_h4s.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpw6hi314n.jl:22\nin expression\
    \ starting at /tmp/tmpw6hi314n.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. Your function should take in a single number as an argument,\
    \ and return 'Yes' if it's prime and 'No' otherwise.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpekbwt0rn.jl:24\nin expression\
    \ starting at /tmp/tmpekbwt0rn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp2jil_n3i.jl:24\nin expression\
    \ starting at /tmp/tmp2jil_n3i.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        else\n            if isempty(stack)\n                return 'No'\n  \
    \          else\n                pop!(stack)\n            end\n        end\n \
    \   end\n    \n    if isempty(stack)\n        return 'Yes'\n    else\n       \
    \ return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime (ie. divisible\
    \ only by 1 and itself).\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpguc_sqiw.jl:24\nin expression\
    \ starting at /tmp/tmpguc_sqiw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    stack.append(lst[1])\n    \n    for elem in lst[2:end]\n      \
    \  if elem == '('\n            stack.append(elem)\n        elseif elem == ')'\n\
    \            if stack.size == 0\n                return \"No\"\n            else\n\
    \                stack.pop()\n            end\n        else\n            if stack.size\
    \ == 0\n                return \"No\"\n            else\n                stack.pop()\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpykvgms9w.jl:38\nin expression starting at\
    \ /tmp/tmpykvgms9w.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ \nA number is prime if and only if it is a whole number greater than 1.\nThe\
    \ function should take one integer as input, and return 'Yes' if it is prime and\
    \ 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpecabupaz.jl:22\nin expression\
    \ starting at /tmp/tmpecabupaz.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', \nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzrn8asj8.jl:22\nin expression\
    \ starting at /tmp/tmpzrn8asj8.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpk64cv72x.jl:24\nin expression\
    \ starting at /tmp/tmpk64cv72x.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Vector{String}()\n    \n    for s in lst\n        if s == '('\n          \
    \  push!(stack, s)\n        elseif s == ')'\n            if isempty(stack)\n \
    \               return 'No'\n            else\n                pop!(stack)\n \
    \           end\n        else\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzukkhkyj.jl:24\nin expression\
    \ starting at /tmp/tmpzukkhkyj.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpuhq1l7gp.jl:24\nin expression\
    \ starting at /tmp/tmpuhq1l7gp.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpp5_ofxn_.jl:22\nin expression\
    \ starting at /tmp/tmpp5_ofxn_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ lst.length == 2\n        return match_parens(lst[1]) == match_parens(lst[0])\
    \ ? 'Yes' : 'No'\n    end\n    \n    stack = Stack()\n    \n    for s in lst\n\
    \        if s == '('\n            push!(stack, s)\n        elseif s == ')'\n \
    \           if !isempty(stack)\n                pop!(stack)\n            else\n\
    \                return 'No'\n            end\n        else\n            if isempty(stack)\n\
    \                return 'No'\n            end\n        end\n    end\n    \n  \
    \  if isempty(stack)\n        return 'Yes'\n    end\n    \n    return 'No'\nend\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()('])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()('])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')()()()()()'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')()()()()()('])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()('])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')()()()()()()()'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')()()()()()()\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdz8l5exg.jl:18\nin expression\
    \ starting at /tmp/tmpdz8l5exg.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    return 'Yes'\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp6i_l6jxf.jl:22\nin expression\
    \ starting at /tmp/tmp6i_l6jxf.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ You may use the\nfollowing algorithm:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdth3hi7o.jl:22\nin expression\
    \ starting at /tmp/tmpdth3hi7o.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for char in lst[1]\n        if\
    \ char == '('\n            stack.append(char)\n        elseif char == ')'\n  \
    \          if stack.length() == 0\n                return 'No'\n            else\n\
    \                popped = stack.pop()\n                if popped != '('\n    \
    \                return 'No'\n                end\n            end\n        end\n\
    \    end\n    \n    if stack.length() != 0\n        return 'No'\n    else\n  \
    \      return 'Yes'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp8yn2i0h4.jl:25\nin expression\
    \ starting at /tmp/tmp8yn2i0h4.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return \"No\"\n    \n    if length(lst) == 1 \n \
    \       if lst[1] == \"(\" \n            return \"Yes\"\n        else \n     \
    \       return \"No\"\n    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp53_6fonm.jl:1\nin expression starting at /tmp/tmp53_6fonm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    stack.append(lst[1])\n    \n    for elem in lst[2:end]\n    \
    \    if elem == ')'\n            stack.pop()\n        elseif elem == '('\n   \
    \         stack.append(elem)\n        else\n            return false\n    end\n\
    \    \n    return stack.length == 1\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['))',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', '(', '(', '(', '(', '(', '(', '(',\
    \ '(', '(', '(', '(', '(', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ '(', '(', '(', '(', '(', '(', '(', '(', '(', '(\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9idqvmm4.jl:31\nin expression starting at\
    \ /tmp/tmp9idqvmm4.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ \nThe function should take one integer number as input, and return 'Yes' if\
    \ it is prime and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpi6_6dk0p.jl:22\nin expression\
    \ starting at /tmp/tmpi6_6dk0p.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    if\
    \ length(lst) == 0 \n        return \"No\"\n    \n    stack = Stack()\n    \n\
    \    for x in lst\n        if x == '('\n            push!(stack, x)\n        elseif\
    \ x == ')'\n            if isempty(stack)\n                return \"No\"\n   \
    \         else\n                pop!(stack)\n            end\n        end\n  \
    \  end\n    \n    if isempty(stack)\n        return \"Yes\"\n    else\n      \
    \  return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfixiqwed.jl:40\nin expression starting at\
    \ /tmp/tmpfixiqwed.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert match_parens(['()(', ')']) == 'Yes'\n@assert match_parens([')', ')'])\
    \ == 'No'\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime. Recall that prime numbers are only divisible by 1 and themselves.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_ufesybe.jl:24\nin expression\
    \ starting at /tmp/tmp_ufesybe.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')',\
    \ ')'])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime or not. \nThe function should take one number as an argument and return\
    \ a boolean value.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmplw9jfqzo.jl:24\nin expression\
    \ starting at /tmp/tmplw9jfqzo.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    match_parens(['()(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['())',\
    \ ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')'])\n</cell>\n<code language=julia-1.3>\nmatch_parens(['(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.3>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmped6ey0v6.jl:23\nin expression\
    \ starting at /tmp/tmped6ey0v6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   else\n            if isempty(stack)\n                return 'No'\n       \
    \     else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    if isempty(stack)\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['()', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpd0lx38ym.jl:22\nin expression\
    \ starting at /tmp/tmpd0lx38ym.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    stack\
    \ = Stack()\n    \n    for s in lst\n        if s == '('\n            push!(stack,\
    \ s)\n        elseif s == ')'\n            if isempty(stack)\n               \
    \ return 'No'\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return 'Yes'\n   \
    \ else\n        return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert match_parens(['()(', ')']) == 'Yes'\n@assert match_parens([')', ')'])\
    \ == 'No'\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzt08_r8w.jl:24\nin expression\
    \ starting at /tmp/tmpzt08_r8w.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')'])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmptns4oths.jl:22\nin expression\
    \ starting at /tmp/tmptns4oths.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Vector{String}()\n    stack = push!(stack, \"\")\n    for s in lst\n       \
    \ if s == \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n    \
    \        if isempty(stack)\n                return \"No\"\n            else\n\
    \                pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \"))\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"((\", \"\
    ))\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"((\", \"))\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"((\", \"))\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ((\", \"))\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9unjjaw1.jl:37\nin expression starting at\
    \ /tmp/tmp9unjjaw1.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ Stack()\n    for s in lst\n        if s == '('\n            push!(stack, s)\n\
    \        elseif s == ')'\n            if isempty(stack)\n                return\
    \ 'No'\n            else\n                pop!(stack)\n            end\n     \
    \   end\n    end\n    if isempty(stack)\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens(['()(',\
    \ ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens([')', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens(['(', ')', '(', ')', '(', ')', '(', ')',\
    \ '(', ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\n\
    match_parens(['(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')'])\n</cell>\n<code language=julia-1.5>\nmatch_parens(['(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(', ')', '(',\
    \ ')', '(', ')', '(', ')', '(', ')', '(', \nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqaicrk_r.jl:22\nin expression\
    \ starting at /tmp/tmpqaicrk_r.jl:22\n"
  exit_code: 1
  status: SyntaxError
