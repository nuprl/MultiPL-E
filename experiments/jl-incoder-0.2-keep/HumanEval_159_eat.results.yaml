name: HumanEval_159_eat
language: julia
results:
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2]\
    \ = remaining\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1]\
    \ = number\n    carrots_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc9lxcm9w.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpc9lxcm9w.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpc9lxcm9w.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([remaining,\
    \ remaining - need])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpssh4xi6h.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpssh4xi6h.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    if need < 0 || need > 1000 \n        error(\"need must be\
    \ between 0 and 1000\")\n    if remaining < 0 || remaining > 1000 \n        error(\"\
    remaining must be between 0 and 1000\")\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbwnbt2ll.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbwnbt2ll.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return error(\"Invalid\
    \ input\")\n    end\n    if number == 0 && need == 0 && remaining == 0\n     \
    \   return Vector{Int64}()\n    end\n    if number == 0 && need == 0 && remaining\
    \ > 0\n        return Vector{Int64}(remaining)\n    end\n    if number == 0 &&\
    \ need > 0 && remaining == 0\n        return Vector{Int64}()\n    end\n    if\
    \ number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}()\n \
    \   end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    if number > 0 && need > 0 && remaining\
    \ == 0\n        return Vector{Int64}(need, 0)\n    end\n    if number > 0 && need\
    \ > 0 && remaining > 0\n        return Vector{Int64}(need, 0)\n    end\n    if\
    \ number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ need)\n    end\n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(number, need)\n    end\n    if number > 0 && need > 0 && remaining\
    \ == 0\n        return Vector{Int64}(need, number)\n    end\n    if number > 0\
    \ && need > 0 && remaining > 0\n        return Vector{Int64}(need, number)\n \
    \   end\n    return error(\"Invalid input\")\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpww_2dwyh.jl:71\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpww_2dwyh.jl:71\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number-need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after your\
    \ meals.\nIf there are not enough carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\nThe function should take two arguments:\n@number\
    \ : integer\n    the number of carrots that you have eaten.\n@need : integer\n\
    \    the number of carrots that you need to eat.\nThe function should return an\
    \ array of two integers:\n@left : integer\n    the number of carrots left after\
    \ your meals.\n@remaining : integer\n    the number of remaining carrots thet\
    \ exist in stock\nVariables:\n@number : integer\n    the number of carrots that\
    \ you have eaten.\n@need : integer\n    the number of carrots that you need to\
    \ eat.\n@remaining : integer\n    the number of remaining carrots thet exist in\
    \ stock\nConstraints:\n0 <= number <= 1000\n0 <= need <= 1000\n0 <= remaining\
    \ <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpczuku14o.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpczuku14o.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots\
    \ > 0 \n            carrots_left -= 1\n            carrots -= 1\n            push!(answer,\
    \ carrots)\n        end\n        push!(answer, carrots_left)\n        return answer\n\
    \    else\n        return [0, 0]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange a collection of n integers such that the sum of the integers\
    \ is exactly k.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpng0ttckl.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpng0ttckl.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots_left\
    \ > 0 && carrots > 0\n            carrots_left -= 1\n            carrots -= 1\n\
    \            push!(answer, carrots)\n        end\n        \n        push!(answer,\
    \ carrots)\n        \n        return answer\n    else\n        return nothing\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function called hungry that takes two integers representing\
    \ a number of carrots left and number of carrots eaten, and returns true if there\
    \ are enough carrots left and enough carrots eaten. Otherwise, return false.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk7glcxey.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk7glcxey.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpncaqd2_e.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpncaqd2_e.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpncaqd2_e.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  answer = []\n        if number == 0\n            answer[1] = remaining\n  \
    \      else\n            answer[1] = number\n            answer[2] = need\n  \
    \          answer[3] = remaining\n        end\n        answer\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp27ucri6s.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp27ucri6s.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    if number == 0\n        return [need, remaining]\n    end\n  \
    \  if remaining < need\n        error(\"not enough carrots to eat\")\n    end\n\
    \    \n    carrots = zeros(Int64, 2)\n    carrots[1] = remaining\n    carrots[2]\
    \ = need\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrot\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpugcmo5fj.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpugcmo5fj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpugcmo5fj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > remaining \n        number = remaining\n    end\n    if need\
    \ > remaining \n        need = remaining\n    end\n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptxrg4zg5.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmptxrg4zg5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmptxrg4zg5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number,\
    \ need])\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzi70detp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [5, 6] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzi70detp.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzi70detp.jl:40\ntest set: Test Failed at /tmp/tmpzi70detp.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [4, 8] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzi70detp.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzi70detp.jl:40\ntest set: Test Failed at /tmp/tmpzi70detp.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [1, 10] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpzi70detp.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzi70detp.jl:40\ntest set: Test Failed at /tmp/tmpzi70detp.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [2, 11] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzi70detp.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzi70detp.jl:40\ntest set: Test Failed at /tmp/tmpzi70detp.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [4, 5] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzi70detp.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzi70detp.jl:40\ntest set: Test Failed at /tmp/tmpzi70detp.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [4, 5] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzi70detp.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzi70detp.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzi70detp.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        local carrots = number\n\
    \        local carrots_left = remaining\n        local meals = 0\n        local\
    \ meals_left = 0\n        while carrots > 0 && meals_left > 0 \n            carrots_left\
    \ = carrots_left - 1\n            meals_left = meals_left - 1\n            meals\
    \ = meals + 1\n        end\n        \n        if carrots_left == 0\n         \
    \   carrots = number\n        else\n            carrots = carrots - meals\n  \
    \      end\n        \n        return [meals, carrots_left]\n    end\n    return\
    \ [0, 0]\nend\n</cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of cards.\nThe cards are represented as an array of integers representing\
    \ the ranks of the cards, and the number of cards left over for each rank. \n\
    The function should return an array of integers representing the number of ways\
    \ to arrange the cards.\nThe function should return an array of integers representing\
    \ the number of ways to arrange the cards.\nThe function should return an array\
    \ of integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp19e8dq89.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp19e8dq89.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    if number == 0\n        return [need, remaining]\n    end\n\
    \    \n    if remaining < need\n        return [number, 0]\n    end\n    \n  \
    \  if number > remaining\n        return [need, 0]\n    end\n    \n    if number\
    \ == remaining\n        return [need, 0]\n    end\n    \n    return [number, need]\n\
    end\n</cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways you can reach a target number from any given\
    \ starting number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq0hiq9o7.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq0hiq9o7.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   meals = zeros(Int64, 2)\n    meals[1] = number\n    meals[2] = need\n    \n\
    \    carrots = zeros(Int64, 2)\n    carrots[1] = remaining\n    \n    meals_left\
    \ = zeros(Int64, 2)\n    meals_left[1] = remaining\n    \n    meals_left_carrots\
    \ = zeros(Int64, 2)\n    meals_left_carrots[1] = remaining\n    \n    meals_left_carrots_left\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left[1] = remaining\n    \n    meals_left_carrots_left_carrots\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots[1] = remaining\n    \n\
    \    meals_left_carrots_left_carrots_left = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left[1]\
    \ = remaining\n    \n    meals_left_carrots_left_carrots_left_carrots = zeros(Int64,\
    \ 2)\n    meals_left_carrots_left_carrots_left_carrots[1] = remaining\n    \n\
    \    meals_left_carrots_left_carrots_left_carrots_left = zeros(Int64, 2)\n   \
    \ meals_left_carrots_left_carrots_left_carrots_left[1] = remaining\n    \n   \
    \ meals_left_carrots_left_carrots_left_carrots_left_carrots = zeros(Int64, 2)\n\
    \    meals_left_carrots_left_carrots_left_carrots_left_carrots[1] = remaining\n\
    \    \n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left = zeros(Int64,\
    \ 2)\n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left[1] =\
    \ remaining\n    \n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots[1]\
    \ = remaining\n    \n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left_carrots_left_\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpacjs5086.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpacjs5086.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpacjs5086.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppikcjxul.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppikcjxul.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpry1wsqyx.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpry1wsqyx.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpry1wsqyx.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 \n        error(\"number should be less than 1000\")\n\
    \    else if need > 1000 \n        error(\"need should be less than 1000\")\n\
    \    else if remaining > 1000 \n        error(\"remaining should be less than\
    \ 1000\")\n    else if number < need \n        error(\"number should be greater\
    \ than need\")\n    else if number == need \n        Vector{Int64}([number, 0])\n\
    \    else if number > remaining \n        error(\"number should be greater than\
    \ remaining\")\n    else if number == remaining \n        Vector{Int64}([number,\
    \ 0])\n    else \n        Vector{Int64}([number, need-number])\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    You have a number of carrots, and you know\
    \ that there are a certain number of carrots left\n    in stock. You need to eat\
    \ as many carrots as you can, but you only have one meal left\n    to eat. You\
    \ are hungry if you eat all the carrots left, but you still have some carrots\
    \ left\n    in stock. You are hungry if you eat all the carrots left, but you\
    \ still have some carrots left\n    in stock. You are hungry if you eat all the\
    \ carrots left, but you still have some carrots left\n    in stock. You are hungry\
    \ if you eat all the carrots left, but you still have some carrots left\n    in\
    \ stock. You are hungry if you eat all the carrots left, but you still have some\
    \ carrots left\n    in stock. You are hungry if you eat all the carrots left,\
    \ but you still have some carrots left\n    in stock. You are hungry if you eat\
    \ all the carrots left, but you still have some carrots left\n    in stock. You\
    \ are hungry if you eat all the carrots left, but you still have some carrots\
    \ left\n    in stock. You are hungry if you eat all the carrots left, but you\
    \ still have some carrots left\n    in stock. You are hungry if you eat all the\
    \ carrots left, but you still have some carrots left\n    in stock. You are hungry\
    \ if you eat all the carrots left, but you still have some carrots left\n    in\
    \ stock. You are hungry if you eat all the carrots left, but you still have some\
    \ carrots left\n    in stock. You are hungry if you \nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_0vpg_vm.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_0vpg_vm.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining == 0\n        return Vector{Int64}([number, need])\n    end\n\
    \    \n    if number > remaining\n        return Vector{Int64}([number, need])\n\
    \    end\n    \n    if need == 0\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    \n    if number > need\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    \n    return Vector{Int64}([number, need])\nend\n</cell>\n<code\
    \ language=julia-1.3>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.3>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.3>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.3>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nProblem 7: Sum square difference\nThe sum of the\
    \ squares of the first ten natural numbers is,\n1^2 + 2^2 + ... + 10^2 = 385\n\
    The square of the sum of the first ten natural numbers is,\n(1 + 2 + ... + 10)^2\
    \ = 55^2 = 3025\nHence the difference between the sum of the squares of the first\
    \ ten natural numbers and the square of the sum is 3025 - 385 = 2640.\nFind the\
    \ difference between the sum of the squares of the first one hundred natural numbers\
    \ and the square of the sum.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2je7v_uv.jl:53\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2je7v_uv.jl:53\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    if number < 0 || need < 0 || remaining < 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0rkl2b9k.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0rkl2b9k.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0rkl2b9k.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < 0\n  \
    \      Vector{Int64}()\n    elseif remaining == 0\n        Vector{Int64}([need])\n\
    \    elseif remaining < need\n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    You have a certain number of carrots, and you know that there are\
    \ only two types of carrots:\n    \n    carrots and vegetables.\n    \n    You\
    \ want to eat as many carrots as possible, but you only have one type of carrots.\n\
    \    \n    You want to eat as many vegetables as possible, but you only have one\
    \ type of vegetables.\n    \n    You want to eat as many carrots and vegetables\
    \ as possible, but you only have one type of carrots and one type of vegetables.\n\
    \    \n    You want to eat as many carrots and vegetables as possible, but you\
    \ only have one type of carrots and one type of vegetables.\n    \n    You want\
    \ to eat as many carrots and vegetables as possible, but you only have one type\
    \ of carrots and one type of vegetables.\n    \n    You want to eat as many carrots\
    \ and vegetables as possible, but you only have one type of carrots and one type\
    \ of vegetables.\n    \n    You want to eat as many carrots and vegetables as\
    \ possible, but you only have one type of carrots and one type of vegetables.\n\
    \    \n    You want to eat as many carrots and vegetables as possible, but you\
    \ only have one type of carrots and one type of vegetables.\n    \n    You want\
    \ to eat as many carrots and vegetables as possible, but you only have one type\
    \ of carrots and one type of vegetables.\n    \n    You want to eat as many carrots\
    \ and vegetables as possible, but you only have one type of carrots and one type\
    \ of vegetables.\n    \n    You want to eat as many carrots and vegetables as\
    \ possible, but you only have one type of carrots and one type of vegetables.\n\
    \    \n    You want to eat as many carrots and vegetables as possible, but you\
    \ only have one type of carrots and one type of vegetables.\n    \n    You want\
    \ to eat as many carrot\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjw9nzoai.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjw9nzoai.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([remaining,\
    \ remaining - number])\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpseyrd57a.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 5] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpseyrd57a.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpseyrd57a.jl:40\ntest set: Test Failed at /tmp/tmpseyrd57a.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 5] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpseyrd57a.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpseyrd57a.jl:40\ntest set: Test Failed at /tmp/tmpseyrd57a.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 9] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpseyrd57a.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpseyrd57a.jl:40\ntest set: Test Failed at /tmp/tmpseyrd57a.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 3] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpseyrd57a.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpseyrd57a.jl:40\ntest set: Test Failed at /tmp/tmpseyrd57a.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 3] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpseyrd57a.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpseyrd57a.jl:40\ntest set: Test Failed at /tmp/tmpseyrd57a.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, -3] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpseyrd57a.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpseyrd57a.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpseyrd57a.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4w7znxan.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp4w7znxan.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp4w7znxan.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    \n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    if number == 0 && need == 0 && remaining\
    \ > 0\n        return Vector{Int64}([need, remaining])\n    end\n    \n    if\
    \ number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\n    \n    if number == 0 && need > 0 && remaining > 0\n\
    \        return Vector{Int64}([need, remaining])\n    end\n    \n    if number\
    \ > 0 && need == 0 && remaining == 0\n        return Vector{Int64}([number, 0])\n\
    \    end\n    \n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}([number, 0])\n    end\n    \n    if number > 0 && need > 0 &&\
    \ remaining == 0\n        return Vector{Int64}([number, 0])\n    end\n    \n \
    \   if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}([number,\
    \ 0])\n    end\n    \n    if number > 0 && need == 0 && remaining == 0\n     \
    \   return Vector{Int64}([number, 0])\n    end\n    \n    if number > 0 && need\
    \ == 0 && remaining > 0\n        return Vector{Int64}([number, 0])\n    end\n\
    \    \n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}([number,\
    \ 0])\n    end\n    \n    if number > 0 && need > 0 && remaining > 0\n       \
    \ return Vector{Int64}([number, 0])\n    end\n    \n    return Vector{Int64}()\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnrnvt675.jl:85\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnrnvt675.jl:85\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    # Your code here\n    \n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # run your function with the example inputs\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange n integers\
    \ in ascending order without duplicates.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplq4_osxd.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplq4_osxd.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptaoq5fm5.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmptaoq5fm5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmptaoq5fm5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number == need\n \
    \       Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([number,\
    \ need])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after a meal\
    \ is complete.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpey5dilgu.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpey5dilgu.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpndc51tbf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpndc51tbf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpndc51tbf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6x4vpjoj.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp6x4vpjoj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp6x4vpjoj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > need || number < 0 || remaining < 0 || remaining > 1000 ||\
    \ number > remaining\n        return Vector{Int64}()\n    end\n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpaznqckpw.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpaznqckpw.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpaznqckpw.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpe9194cdr.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpe9194cdr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpe9194cdr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n   \
    \ carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n    if carrots[1]\
    \ > 0\n        carrots[1] -= carrots[2]\n        carrots[2] = 0\n    end\n   \
    \ \n    if carrots[1] == 0\n        carrots[1] = remaining\n        carrots[2]\
    \ = 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppstmmru2.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppstmmru2.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = number\n    meals_left[2]\
    \ = remaining\n    \n    meals_left_left = zeros(Int64, 2)\n    meals_left_left[1]\
    \ = number\n    meals_left_left[2] = remaining\n    \n    meals_left_right = zeros(Int64,\
    \ 2)\n    meals_left_right[1] = number\n    meals_left_right[2] = remaining\n\
    \    \n    meals_right = zeros(Int64, 2)\n    meals_right[1] = number\n    meals_right[2]\
    \ = remaining\n    \n    meals_right_left = zeros(Int64, 2)\n    meals_right_left[1]\
    \ = number\n    meals_right_left[2] = remaining\n    \n    meals_right_right =\
    \ zeros(Int64, 2)\n    meals_right_right[1] = number\n    meals_right_right[2]\
    \ = remaining\n    \n    meals_left_left_left = zeros(Int64, 2)\n    meals_left_left_left[1]\
    \ = number\n    meals_left_left_left[2] = remaining\n    \n    meals_left_left_right\
    \ = zeros(Int64, 2)\n    meals_left_left_right[1] = number\n    meals_left_left_right[2]\
    \ = remaining\n    \n    meals_left_right_left = zeros(Int64, 2)\n    meals_left_right_left[1]\
    \ = number\n    meals_left_right_left[2] = remaining\n    \n    meals_left_right_right\
    \ = zeros(Int64, 2)\n    meals_left_right_right[1] = number\n    meals_left_right_right[2]\
    \ = remaining\n    \n    meals_right_left_left = zeros(Int64, 2)\n    meals_right_left_left[1]\
    \ = number\n    meals_right_left_left[2] = remaining\n    \n    meals_right_left_right\
    \ = zeros(Int64, 2)\n    meals_right_left_right[1] = number\n    meals_right_left_right[2]\
    \ = remaining\n    \n    meals_right_right_left = zeros(Int64, 2)\n    meals_right_right_left[1]\
    \ = number\n    meals_right_right_left[2] = remaining\n    \n    meals_right_right_right\
    \ = zeros(Int64, 2)\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpydb7e7q6.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpydb7e7q6.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpydb7e7q6.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    if need < 0 || need > 1000 \n        error(\"need must be\
    \ between 0 and 1000\")\n    if remaining < 0 || remaining > 1000 \n        error(\"\
    remaining must be between 0 and 1000\")\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrot\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkq8_jb0e.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkq8_jb0e.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    need = need\n    remaining = remaining\n\
    \    \n    carrots_left = number\n    \n    while carrots_left > 0 && need > 0\
    \ && remaining > 0\n        if carrots_left >= remaining\n            carrots_left\
    \ -= remaining\n            need -= 1\n            remaining -= 1\n        else\n\
    \            carrots_left -= 1\n            need -= 1\n            remaining -=\
    \ 1\n        end\n    end\n    \n    if carrots_left == 0\n        carrots = remaining\n\
    \    end\n    \n    return Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test your code\n@test eat(5, 6, 10) == [11, 4]\n\
    @test eat(4, 8, 9) == [12, 1]\n@test eat(1, 10, 10) == [11, 0]\n@test eat(2, 11,\
    \ 5) == [7, 0]\n</cell>\n<text>\nProblem 8\nWrite a function that returns the\
    \ number of prime numbers less than a given integer $n$ (where $n$ is also a positive\
    \ integer). You may wish to use the Sieve of Eratosthenes or the Sieve of Atkin's\
    \ algorithm (which was the first time I heard of either one).\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph626ognk.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph626ognk.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # run your function with the example inputs to see what it does\neat(5, 6, 10)\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns the number of carrots\
    \ left after eating a certain number of carrots.\nThe function should take in\
    \ two integer arguments: the number of carrots you have eaten and the number of\
    \ carrots left after your meals.\nThe function should return an array of two integers,\
    \ the first integer is the number of carrots left after your meals, and the second\
    \ integer is the total number of carrots you have eaten.\nIf there are not enough\
    \ carrots left after your meals, you will eat all remaining carrots, but will\
    \ still be hungry.\nIf there are not enough carrots left after your meals, you\
    \ will eat all remaining carrots, but will still be hungry.\nIf there are not\
    \ enough carrots left after your meals, you will eat all remaining carrots, but\
    \ will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrot\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_4hbf5sa.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_4hbf5sa.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvzqcr15n.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpvzqcr15n.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpvzqcr15n.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0\n        error(\"number must be positive\")\n    end\n\
    \    if need <= 0\n        error(\"need must be positive\")\n    end\n    if remaining\
    \ <= 0\n        error(\"remaining must be positive\")\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxui_c8re.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpxui_c8re.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpxui_c8re.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining]) \n    else \n\
    \        Vector{Int64}([need, number-remaining]) \n    end\nend\n</cell>\n<code\
    \ language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<code language=julia-0.6>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-0.6>\neat(1, 10, 10)\n</cell>\n<code language=julia-0.6>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-0.6>\neat(10, 10, 10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the number of carrots left after\
    \ a meal is complete.\nIf there are not enough carrots left after a meal, you\
    \ should eat all remaining carrots.\nIf there are not enough carrots left after\
    \ a meal, you should eat all remaining carrots.\nIf there are not enough carrots\
    \ left after a meal, you should eat all remaining carrots.\nIf there are not enough\
    \ carrots left after a meal, you should eat all remaining carrots.\nIf there are\
    \ not enough carrots left after a meal, you should eat all remaining carrots.\n\
    If there are not enough carrots left after a meal, you should eat all remaining\
    \ carrots.\nIf there are not enough carrots left after a meal, you should eat\
    \ all remaining carrots.\nIf there are not enough carrots left after a meal, you\
    \ should eat all remaining carrots.\nIf there are not enough carrots left after\
    \ a meal, you should eat all remaining carrots.\nIf there are not enough carrots\
    \ left after a meal, you should eat all remaining carrots.\nIf there are not enough\
    \ carrots left after a meal, you should eat all remaining carrots.\nIf there are\
    \ not enough carrots left after a meal, you should eat all remaining carrots.\n\
    If there are not enough carrots left after a meal, you should eat all remaining\
    \ carrots.\nIf there are not enough carrots left after a meal, you should eat\
    \ all remaining carrots.\nIf there are not enough carrots left after a meal, you\
    \ should eat all remaining carrots.\nIf there are not enough carrots left after\
    \ a meal, you should eat all remaining carrots.\nIf there are not enough carrots\
    \ left after a meal, you should eat all remaining carrots.\nIf there are not enough\
    \ carrots left after a me\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjkce3ryy.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjkce3ryy.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp53s4nlhi.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp53s4nlhi.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp53s4nlhi.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0\n        error(\"number must be positive\")\n    end\n\
    \    if need <= 0\n        error(\"need must be positive\")\n    end\n    if remaining\
    \ <= 0\n        error(\"remaining must be positive\")\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3o6dlv8r.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3o6dlv8r.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3o6dlv8r.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return Vector{Int64}()\n    \n    if remaining\
    \ < need\n        return Vector{Int64}()\n    \n    carrots = number\n    \n \
    \   carrots = carrots - need\n    \n    if carrots < 0\n        carrots = 0\n\
    \    end\n    \n    return Vector{Int64}(carrots, remaining)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcix9na84.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcix9na84.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk8b37ikz.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpk8b37ikz.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpk8b37ikz.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if number == 0 && remaining == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2]\
    \ = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = number\n    meals[2]\
    \ = remaining\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] =\
    \ remaining\n    carrots_left[2] = need\n    \n    meals_left = zeros(Int64, 2)\n\
    \    meals_left[1] = remaining\n    meals_left[2] = number\n    \n    carrots_left_meals\
    \ = zeros(Int64, 2)\n    carrots_left_meals[1] = remaining\n    carrots_left_meals[2]\
    \ = number\n    \n    meals_left_carrots = zeros(Int64, 2)\n    meals_left_carrots[1]\
    \ = number\n    meals_left_carrots[2] = remaining\n    \n    carrots_left_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_meals_left[1] = remaining\n    carrots_left_meals_left[2]\
    \ = number\n    \n    meals_left_carrots_left = zeros(Int64, 2)\n    meals_left_carrots_left[1]\
    \ = number\n    meals_left_carrots_left[2] = remaining\n    \n    carrots_left_meals_left_meals\
    \ = zeros(Int64, 2)\n    carrots_left_meals_left_meals[1] = remaining\n    carrots_left_meals_left_meals[2]\
    \ = number\n    \n    meals_left_carrots_left_carrots = zeros(Int64, 2)\n    meals_left_carrots_left_carrots[1]\
    \ = number\n    meals_left_carrots_left_carrots[2] = remaining\n    \n    carrots_left_meals_left_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_meals_left_meals_left[1] = remaining\n \
    \   carrots_left_meals_left_meals_left[2] = number\n    \n    meals_left_carrots_left_carrots_left\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left[1] = number\n  \
    \  meals_left_carrots_left_carrots_left[2] = remaining\n    \n    carrots_left_meals_left_meal\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0q68zypo.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0q68zypo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0q68zypo.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2vsbkb72.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp2vsbkb72.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp2vsbkb72.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    # Test your code\n@assert eat(5, 6, 10) == [11, 4]\n@assert eat(4, 8, 9) == [12,\
    \ 1]\n@assert eat(1, 10, 10) == [11, 0]\n@assert eat(2, 11, 5) == [7, 0]\n</cell>\n\
    <text>\nProblem 3\nWrite a function that takes in an array of integers and returns\
    \ true if there are two numbers whose sum is equal to the given number. For example,\
    \ the following array should return true:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzo48j86p.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzo48j86p.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of days left until Christmas.\nThe Christmas day is the last day of every month\
    \ that is at least 4 days long.\nIf Christmas falls on a weekend, return that\
    \ week's number of days.\nIf Christmas falls on a Saturday, return that Saturday's\
    \ number of days.\nIf Christmas falls on a Friday, return that Friday's number\
    \ of days.\nIf Christmas falls on a Thursday, return that Thursday's number of\
    \ days.\nIf Christmas falls on a Wednesday, return that Wednesday's number of\
    \ days.\nIf Christmas falls on a Tuesday, return that Tuesday's number of days.\n\
    If Christmas falls on a Monday, return that Monday's number of days.\nIf Christmas\
    \ falls on a Sunday, return that Sunday's number of days.\nIf Christmas falls\
    \ on a Friday or Saturday, return that Friday's number of days.\nIf Christmas\
    \ falls on a Thursday or Sunday, return that Thursday's number of days.\nIf Christmas\
    \ falls on a Wednesday or Monday, return that Wednesday's number of days.\nIf\
    \ Christmas falls on a Tuesday or Wednesday, return that Tuesday's number of days.\n\
    If Christmas falls on a Tuesday or Thursday, return that Tuesday's number of days.\n\
    If Christmas falls on a Tuesday or Friday, return that Tuesday's number of days.\n\
    If Christmas falls on a Tuesday or Saturday, return that Tuesday's number of days.\n\
    If Christmas falls on a Wednesday or Thursday, return that Wednesday's number\
    \ of days.\nIf Christmas falls on a Wednesday or Friday, return that Wednesday's\
    \ number of days.\nIf Christmas falls on a Wednesday or Saturday, return that\
    \ Wednesday's number of days.\nIf Christmas falls on a Thurs\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1103q79z.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1103q79z.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgioyo480.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpgioyo480.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpgioyo480.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        return Vector{Int64}(undef,\
    \ 0)\n    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n\
    \    while carrots_left > 0\n        carrots_left -= 1\n        carrots += need\n\
    \    end\n    \n    return Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of times a given word appears in a given string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiaaesswy.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiaaesswy.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7irc473l.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp7irc473l.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp7irc473l.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number > 1000 || need > 1000 || remaining > 1000\n        return\
    \ Vector{Int64}()\n    end\n    \n    carrots = Vector{Int64}()\n    \n    carrots\
    \ = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n\
    \    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    car\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppi38yj5p.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmppi38yj5p.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmppi38yj5p.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots_left = number - need\n    carrots_eaten = need - remaining\n    \n \
    \   if carrots_left == 0\n        return Vector{Int64}(carrots_eaten, remaining)\n\
    \    else\n        return Vector{Int64}(carrots_eaten, carrots_left)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpho4_87f_.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpho4_87f_.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif number == need\n        Vector{Int64}([number,\
    \ 0])\n    else\n        Vector{Int64}([number, need-number])\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    You have a certain number of carrots,\
    \ and you know that you have eaten a certain number of carrots.\n    You now need\
    \ to eat some more carrots to complete the day's meals.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpujvvayqj.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpujvvayqj.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    if number == 0\n        return Vector{Int64}([need, remaining])\n\
    \    end\n    if remaining == 0\n        return Vector{Int64}([number, 0])\n \
    \   end\n    if number > remaining\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    return Vector{Int64}([number, remaining - number])\nend\n</cell>\n\
    <code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ called hungry_rabbit that takes two integers representing a person's age, and\
    \ a person's hungry status (true or false). It should return true if the person\
    \ is hungry, and false otherwise.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzt912ai_.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzt912ai_.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([remaining,\
    \ remaining - need])\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of times a given value appears\
    \ in a given array.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzq6a4law.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzq6a4law.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining < need\n        return Vector{Int64}()\n    end\n    \n    if\
    \ number < need\n        return Vector{Int64}([number, need])\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpep62glzk.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpep62glzk.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpep62glzk.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots[2] = remaining - carrots[2]\n    \n\
    \    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after a meal.\n\
    The function should take 3 arguments: number of carrots eaten, number of carrots\
    \ left after meal, and number of carrots left after meal (again).\nThe function\
    \ should return an array of two elements: number of carrots left after meal, and\
    \ number of carrots left after meal (again).\nThe function should return an array\
    \ of two elements: number of carrots left after meal, and number of carrots left\
    \ after meal (again).\nThe function should return an array of two elements: number\
    \ of carrots left after meal, and number of carrots left after meal (again).\n\
    The function should return an array of two elements: number of carrots left after\
    \ meal, and number of carrots left after meal (again).\nThe function should return\
    \ an array of two elements: number of carrots left after meal, and number of carrots\
    \ left after meal (again).\nThe function should return an array of two elements:\
    \ number of carrots left after meal, and number of carrots left after meal (again).\n\
    The function should return an array of two elements: number of carrots left after\
    \ meal, and number of carrots left after meal (again).\nThe function should return\
    \ an array of two elements: number of carrots left after meal, and number of carrots\
    \ left after meal (again).\nThe function should return an array of two elements:\
    \ number of carrots left after meal, and number of carrots left after meal (again).\n\
    The function should return an array of two elements: number of carrots left after\
    \ meal, and number of carrots left after meal (again).\nThe function should return\
    \ an array of two elements: number of carrots left after meal, and number of carrots\
    \ left after meal (again).\nThe function should return an array of two element\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1bmr2wfj.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1bmr2wfj.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else\n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfqnf0ldt.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfqnf0ldt.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfsyjemkj.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfsyjemkj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfsyjemkj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = remaining\n    \n    meals = Vector{Int64}()\n\
    \    \n    while carrots_left > 0\n        meals = meals + 1\n        carrots_left\
    \ = carrots_left - need\n    end\n    \n    return meals, carrots - meals\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways you can reach a certain sum from any given number\
    \ in a given number of steps.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjp47nt69.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjp47nt69.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots\
    \ > 0 && carrots_left > 0 \n            carrots_left -= 1\n            carrots\
    \ -= 1\n            push!(answer, carrots)\n        end\n        return answer\n\
    \    else\n        return [0, 0]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 4\nWrite a function that takes in an array\
    \ of integers and returns the number of positive integers that are less than or\
    \ equal to each other.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplyb3_m5d.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplyb3_m5d.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of days until a rabbit eats another rabbit.\nThe rabbit eats another rabbit\
    \ if and only if it has eaten at least 1 carrot in the last 7 days.\nThe rabbit\
    \ eats another rabbit if and only if it has eaten at least 2 carrots in the last\
    \ 7 days.\nThe rabbit eats another rabbit if and only if it has eaten at least\
    \ 3 carrots in the last 7 days.\nThe rabbit eats another rabbit if and only if\
    \ it has eaten at least 4 carrots in the last 7 days.\nThe rabbit eats another\
    \ rabbit if and only if it has eaten at least 5 carrots in the last 7 days.\n\
    The rabbit eats another rabbit if and only if it has eaten at least 6 carrots\
    \ in the last 7 days.\nThe rabbit eats another rabbit if and only if it has eaten\
    \ at least 7 carrots in the last 7 days.\nThe rabbit eats another rabbit if and\
    \ only if it has eaten at least 8 carrots in the last 7 days.\nThe rabbit eats\
    \ another rabbit if and only if it has eaten at least 9 carrots in the last 7\
    \ days.\nThe rabbit eats another rabbit if and only if it has eaten at least 10\
    \ carrots in the last 7 days.\nThe rabbit eats another rabbit if and only if it\
    \ has eaten at least 11 carrots in the last 7 days.\nThe rabbit eats another rabbit\
    \ if and only if it has eaten at least 12 carrots in the last 7 days.\nThe rabbit\
    \ eats another rabbit if and only if it has eaten at least 13 carrots in the last\
    \ 7 days.\nThe rabbit eats another rabbit if and only if it has eaten at least\
    \ 14 carrots in the \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg03smi9m.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg03smi9m.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # Run this cell to check your answer\n@assert eat(5, 6, 10) == [11, 4]\n@assert\
    \ eat(4, 8, 9) == [12, 1]\n@assert eat(1, 10, 10) == [11, 0]\n@assert eat(2, 11,\
    \ 5) == [7, 0]\n</cell>\n<text>\nPart B\nNow that you've seen how to use @assert\
    \ to check your code, let's see if you can solve the problem using Julia's built-in\
    \ assert function.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpebpx069x.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpebpx069x.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n   \
    \ carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n    if carrots[1]\
    \ > 0\n        carrots[1] = carrots[1] - carrots[2]\n        carrots[2] = 0\n\
    \    end\n    \n    if carrots[1] == 0\n        carrots[1] = remaining\n    end\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 1)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 2)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 3)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 4)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 6)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 7)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 8)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 9)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 11)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 12)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 13)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 14)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 15)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 16)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 17)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 18)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 19)\n\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_dfbf6wn.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_dfbf6wn.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number-need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    You\
    \ have a certain number of carrots, and you know that you need to eat some carrots\
    \ to complete the day's meals.\n    You want to know how many carrots you will\
    \ need to eat to complete the day's meals.\n    \n    Example:\n    * meals(5,\
    \ 6, 10) -> [11, 4]\n    * meals(4, 8, 9) -> [12, 1]\n    * meals(1, 10, 10) ->\
    \ [11, 0]\n    * meals(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmqzm9p1n.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmqzm9p1n.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd6iogqg3.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd6iogqg3.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n   \
    \ while carrots > 0\n        if carrots_left <= 0\n            carrots_left =\
    \ remaining\n            carrots = number\n        else\n            carrots_left\
    \ -= 1\n        end\n    end\n    \n    return Vector{Int64}(carrots, carrots_left)\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways to arrange n integers in an array, such that\
    \ the total sum is exactly k.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbwj6pwhs.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbwj6pwhs.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    # Your code here\n    \n    return Vector{Int64}([number,\
    \ need-number])\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7: Meet and Greet\nYou are a hungry rabbit who has decided to eat some\
    \ carrots. You want to greet everyone in the rabbit who has eaten carrots. You\
    \ will greet everyone in the rabbit who has eaten carrots at least once.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprdkvlcy3.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprdkvlcy3.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     \n        carrots_left = remaining\n        carrots_eaten = number\n   \
    \     \n        while carrots_left > 0 && carrots_eaten > 0 \n            carrots_left\
    \ -= 1\n            carrots_eaten -= 1\n            \n            push!(answer,\
    \ carrots_eaten)\n        end\n        \n        push!(answer, carrots_left)\n\
    \        \n        return answer\n    else\n        error(\"Not enough carrots\
    \ left\")\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4geo9jlm.jl:50\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4geo9jlm.jl:50\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    else\n        Vector{Int64}([number, need-number])\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    You have a list\
    \ of numbers, each number in the list represents how many carrots you have eaten\
    \ so far.\n    You have a list of numbers, each number in the list represents\
    \ how many carrots you have left after your meals.\n    \n    You want to know\
    \ how many carrots you will need to eat to complete the meals.\n    \n    Example:\n\
    \    * meals([5, 6, 10], [4, 8, 9], [1, 10, 10]) -> [11, 4]\n    * meals([4, 8,\
    \ 9], [1, 10, 10], [2, 11, 5]) -> [12, 1]\n    * meals([1, 10, 10], [2, 11, 5],\
    \ [3, 12, 6]) -> [11, 0]\n    * meals([2, 11, 5], [3, 12, 6], [4, 13, 7]) -> [7,\
    \ 0]\n    \n    Variables:\n    @meals : array of integers\n        the meals\
    \ you have eaten\n    @left : array of integers\n        the carrots you have\
    \ left after your meals\n    \n    Constrain:\n    * 0 <= meals[i] <= 1000\n \
    \   * 0 <= left[i] <= 1000\n    \n    Have fun :)\n    \"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgyob1vph.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgyob1vph.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else if number ==\
    \ 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    meals() -> a function\
    \ that returns the number of carrots left after your meals.\n    \n    Example:\n\
    \    * meals() -> 11\n    * meals() -> 12\n    * meals() -> 11\n    * meals()\
    \ -> 7\n    \n    Variables:\n    no input\n    \n    Constrain:\n    no constraints\n\
    \    \n    Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgxf7yr7p.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgxf7yr7p.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] =\
    \ remaining\n    meals_left[2] = 0\n    \n    meals_left_after_meals = zeros(Int64,\
    \ 2)\n    meals_left_after_meals[1] = remaining\n    meals_left_after_meals[2]\
    \ = 0\n    \n    meals_left_after_meals_2 = zeros(Int64, 2)\n    meals_left_after_meals_2[1]\
    \ = remaining\n    meals_left_after_meals_2[2] = 0\n    \n    meals_left_after_meals_3\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_3[1] = remaining\n    meals_left_after_meals_3[2]\
    \ = 0\n    \n    meals_left_after_meals_4 = zeros(Int64, 2)\n    meals_left_after_meals_4[1]\
    \ = remaining\n    meals_left_after_meals_4[2] = 0\n    \n    meals_left_after_meals_5\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_5[1] = remaining\n    meals_left_after_meals_5[2]\
    \ = 0\n    \n    meals_left_after_meals_6 = zeros(Int64, 2)\n    meals_left_after_meals_6[1]\
    \ = remaining\n    meals_left_after_meals_6[2] = 0\n    \n    meals_left_after_meals_7\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_7[1] = remaining\n    meals_left_after_meals_7[2]\
    \ = 0\n    \n    meals_left_after_meals_8 = zeros(Int64, 2)\n    meals_left_after_meals_8[1]\
    \ = remaining\n    meals_left_after_meals_8[2] = 0\n    \n    meals_left_after_meals_9\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_9[1] = remaining\n    meals_left_after_meals_9[2]\
    \ = 0\n    \n    meals_left_after_meals_10 = zeros(Int64, 2)\n    meals_left_after_meals_10[1]\
    \ = remaining\n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpifs_qvue.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpifs_qvue.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpifs_qvue.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\")\n    else\n     \
    \   Vector{Int64}([number, need, remaining])\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzqubu_f7.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [5, 6, 10] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzqubu_f7.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqubu_f7.jl:40\ntest set: Test Failed at /tmp/tmpzqubu_f7.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [4, 8, 9] == [12,\
    \ 1]\nStacktrace:\n [1] top-level scope at /tmp/tmpzqubu_f7.jl:42\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqubu_f7.jl:40\ntest set: Test Failed at /tmp/tmpzqubu_f7.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [1, 10, 10] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpzqubu_f7.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqubu_f7.jl:40\ntest set: Test Failed at /tmp/tmpzqubu_f7.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [2, 11, 5] == [7,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpzqubu_f7.jl:44\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqubu_f7.jl:40\ntest set: Test Failed at /tmp/tmpzqubu_f7.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [4, 5, 7] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzqubu_f7.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqubu_f7.jl:40\ntest set: Test Failed at /tmp/tmpzqubu_f7.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [4, 5, 1] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzqubu_f7.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzqubu_f7.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzqubu_f7.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp84v06_yy.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp84v06_yy.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp84v06_yy.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps0jm3awr.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmps0jm3awr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmps0jm3awr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots[2] = carrots[2] - 1\n    \n    if carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2]\
    \ - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] > 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] == 0 && carrots[2] < 0\n        carrots[1] = carrots[1] - 1\n   \
    \     carrots[2] = carrots[2] - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2]\
    \ < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2] -\
    \ 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] == 0 && carrots[2] < 0\n        carrots[1] = carrots[1] - 1\n   \
    \     carrots[2] = carrots[2] - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2]\
    \ < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2] -\
    \ 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] == 0 && carrots[2] < 0\n        carrots[1] = carrots[1] - 1\n   \
    \     carrots[2] = carrots[2] - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2]\
    \ < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2] -\
    \ 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvbcuzme9.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvbcuzme9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif number == remaining\n        Vector{Int64}([need,\
    \ remaining])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"\n    rabbit(number::Int64, need::Int64,\
    \ remaining::Int64)::Bool\n    \n    Determine whether you have a rabbit or not.\n\
    \    \n    Variables:\n    @number : integer\n        the number of carrots that\
    \ you have eaten.\n    @need : integer\n        the number of carrots that you\
    \ need to eat.\n    @remaining : integer\n        the number of remaining carrots\
    \ thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    *\
    \ 0 <= need <= 1000\n    * 0 <= remaining <= 1000\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz32wh0ob.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz32wh0ob.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0\n        return Vector{Int64}[], remaining\n    end\n\
    \    if remaining < need\n        return Vector{Int64}[], 0\n    end\n    \n \
    \   carrots = Vector{Int64}[]\n    carrots = carrots + [number]\n    carrots =\
    \ carrots + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots\
    \ + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n\
    \    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots\
    \ = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots\
    \ + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n\
    \    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots\
    \ = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots\
    \ + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n\
    \    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots\
    \ = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots\
    \ + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n\
    \    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots\
    \ = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots\
    \ + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n\
    \    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots\
    \ = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots\
    \ + [need]\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphaktf834.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmphaktf834.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmphaktf834.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps6fv4260.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmps6fv4260.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number < 0 || need < 0 || remaining < 0\n        return error(\"\
    Invalid input\")\n    end\n    \n    if remaining == 0\n        return [number,\
    \ 0]\n    end\n    \n    carrots = number\n    \n    if number > need\n      \
    \  carrots = number-need\n    end\n    \n    if remaining < carrots\n        carrots\
    \ = remaining\n    end\n    \n    return [carrots, carrots-number]\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns the number of prime numbers less than a given number. \nThe function\
    \ should take in a single integer and return the number of prime numbers less\
    \ than that number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1yn33q9n.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1yn33q9n.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9pxb_erh.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9pxb_erh.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9pxb_erh.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = 0\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = 0\n    carrots_left_after_meals[2] = 0\n\
    \    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals[1] =\
    \ 0\n    carrots_left_after_meals_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals_after_meals_after_meals[2] = 0\n\
    \    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp8smfmsv.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpp8smfmsv.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpp8smfmsv.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n   \
    \ while carrots_left > 0\n        carrots_left -= 1\n        carrots += need\n\
    \    end\n    \n    return Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7: Write a function\
    \ that returns the number of ways to arrange n people into k groups of people.\n\
    The function should take in two integers n and k and return an integer that represents\
    \ the number of ways to arrange n people into k groups of people.\nThe function\
    \ should return 0 if there are not enough people to fill the groups.\nThe function\
    \ should return -1 if there are not enough people to fill the groups.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpot7wlyk1.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpot7wlyk1.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 && number <= need && number\
    \ <= remaining \n        then return [number, remaining - number]\n    else return\
    \ [0, 0]\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: extra token \"return\" after end of expression\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfp2fer08.jl:31\n [2] include(::Module,\
    \ ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n\
    \ [4] _start() at ./client.jl:484\nin expression starting at /tmp/tmpfp2fer08.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots[2] = carrots[2] - (carrots[1] - carrots[2])\n    \n    if carrots[2]\
    \ < 0\n        carrots[2] = 0\n    end\n    \n    if carrots[1] < 0\n        carrots[1]\
    \ = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n\
    \    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1]\
    \ = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1] < 0\n    \
    \    carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgwd7ehqn.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpgwd7ehqn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2]\
    \ = remaining\n    \n    while carrots_left[2] > 0\n        carrots_left[2] -=\
    \ 1\n        meals[2] += 1\n    end\n    \n    while meals[2] > 0\n        meals[2]\
    \ -= 1\n        carrots[1] += 1\n    end\n    \n    return carrots\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ called hungry_rabbit that takes three integers as inputs:\n    \n    Your age\n\
    \    Your weight in kilograms\n    Your height in centimeters\n    \n    Your\
    \ function should return true if the rabbit is hungry, false otherwise.\n    \n\
    \    Your function should return false if any of the inputs are less than 0 or\
    \ greater than 1000.\n    \n    Your function should return false if any of the\
    \ inputs are negative.\n    \n    Your function should return false if any of\
    \ the inputs are greater than 1000.\n    \n    Your function should return false\
    \ if any of the inputs are equal to 0.\n    \n    Your function should return\
    \ false if any of the inputs are greater than or equal to 100.\n    \n    Your\
    \ function should return false if any of the inputs are greater than or equal\
    \ to 200.\n    \n    Your function should return false if any of the inputs are\
    \ greater than or equal to 300.\n    \n    Your function should return false if\
    \ any of the inputs are greater than or equal to 400.\n    \n    Your function\
    \ should return false if any of the inputs are greater than or equal to 500.\n\
    \    \n    Your function should return false if any of the inputs are greater\
    \ than or equal to 600.\n    \n    Your function should return false if any of\
    \ the inputs are greater than or equal to 700.\n    \n    Your function should\
    \ return false if any of the inputs are greater than or equal to 800.\n    \n\
    \    Your function should return \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfqln3jie.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfqln3jie.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    meals = need\n    carrots_left = remaining\n\
    \    \n    carrots_left_after_meals = carrots - meals\n    carrots_after_meals\
    \ = carrots - carrots_left\n    \n    return Vector{Int64}(carrots_after_meals,\
    \ carrots_left_after_meals)\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function named is_hungry that takes three integers as input,\
    \ and returns true if the number is hungry, false otherwise.\nThe function should\
    \ return false for negative numbers, zero, and positive numbers.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq84tfgt6.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq84tfgt6.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"eat(number,\
    \ need, remaining) called with invalid parameters\")\n    end\n    if number ==\
    \ 0 && remaining == 0\n        return Vector{Int64}[]\n    end\n    if number\
    \ == 0 && remaining > 0\n        return Vector{Int64}[]\n    end\n    if need\
    \ == 0 && remaining > 0\n        return Vector{Int64}[]\n    end\n    if number\
    \ == 0 && need == 0 && remaining > 0\n        return Vector{Int64}[]\n    end\n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_vhx8tz9.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_vhx8tz9.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_vhx8tz9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif remaining == 0\n        Vector{Int64}([number,\
    \ 0])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    meals() -> a function that returns an array\
    \ of meals you can make.\n    \n    Example:\n    * meals() -> [ \"breakfast\"\
    , \"lunch\", \"dinner\" ]\n    \n    Variables:\n    no input\n    \n    Constrain:\n\
    \    no output\n    \n    Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_zlebakb.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_zlebakb.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4l2qt06u.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp4l2qt06u.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp4l2qt06u.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0 && need == 0 && remaining == 0\n        Vector{Int64}()\n\
    \    elseif number == 0 && need == 0 && remaining > 0\n        Vector{Int64}(remaining,\
    \ 0)\n    elseif number == 0 && need > 0 && remaining == 0\n        Vector{Int64}(0,\
    \ need)\n    elseif number > 0 && need == 0 && remaining == 0\n        Vector{Int64}(number,\
    \ 0)\n    elseif number > 0 && need == 0 && remaining > 0\n        Vector{Int64}(number,\
    \ need)\n    elseif number > 0 && need > 0 && remaining == 0\n        Vector{Int64}(number,\
    \ need)\n    elseif number > 0 && need > 0 && remaining > 0\n        Vector{Int64}(number,\
    \ need)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    findMeals(meals::Vector{Int64},\
    \ need::Int64, remaining::Int64)::Vector{Int64}\n    \n    You have a meal plan,\
    \ and you need to eat as many carrots as possible.\n    \n    Variables:\n   \
    \ @meals : Vector{Int64}\n        the meals that you have planned for the day\n\
    \    @need : integer\n        the number of carrots that you need to eat.\n  \
    \  @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzm1t61u7.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzm1t61u7.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining\
    \ > 0 && remaining <= 1000\n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkjzqwrio.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkjzqwrio.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = need\n    \n    while\
    \ carrots_left > 0\n        carrots_left -= 1\n        carrots += 1\n    end\n\
    \    \n    return Vector{Int64}(carrots, carrots-1)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0omop0ah.jl:49\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: no method matching\
    \ Array{Int64,1}(::Int64, ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmp0omop0ah.jl:42\n   [2] top-level scope at /tmp/tmp0omop0ah.jl:49\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0omop0ah.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp0omop0ah.jl:50\n  Test threw exception\n  Expression: candidate(4,\
    \ 8, 9) == [12, 1]\n  MethodError: no method matching Array{Int64,1}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmp0omop0ah.jl:42\n   [2] top-level scope at /tmp/tmp0omop0ah.jl:50\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0omop0ah.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp0omop0ah.jl:51\n  Test threw exception\n  Expression: candidate(1,\
    \ 10, 10) == [11, 0]\n  MethodError: no method matching Array{Int64,1}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmp0omop0ah.jl:42\n   [2] top-level scope at /tmp/tmp0omop0ah.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0omop0ah.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp0omop0ah.jl:52\n  Test threw exception\n  Expression: candidate(2,\
    \ 11, 5) == [7, 0]\n  MethodError: no method matching Array{Int64,1}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmp0omop0ah.jl:42\n   [2] top-level scope at /tmp/tmp0omop0ah.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0omop0ah.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp0omop0ah.jl:53\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 7) == [9, 2]\n  MethodError: no method matching Array{Int64,1}(::Int64, ::Int64)\n\
    \  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64)\
    \ where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64...)\
    \ where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmp0omop0ah.jl:42\n   [2] top-level scope at /tmp/tmp0omop0ah.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0omop0ah.jl:48\n  \ntest set: Error During\
    \ Test at /tmp/tmp0omop0ah.jl:54\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 1) == [5, 0]\n  MethodError: no method matching Array{Int64,1}(::Int64, ::Int64)\n\
    \  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64)\
    \ where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64...)\
    \ where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmp0omop0ah.jl:42\n   [2] top-level scope at /tmp/tmp0omop0ah.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0omop0ah.jl:48\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0omop0ah.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\")\n    else \n    \
    \    \n        carrots = zeros(Int64, 2)\n        carrots[1] = number\n      \
    \  carrots[2] = need\n        \n        carrots_left = zeros(Int64, 2)\n     \
    \   carrots_left[1] = remaining\n        carrots_left[2] = need\n        \n  \
    \      carrots_left = carrots_left\n        carrots_left[1] = carrots_left[1]\
    \ - 1\n        carrots_left[2] = carrots_left[2] - 1\n        \n        carrots_left\
    \ = carrots_left\n        carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2]\
    \ = carrots_left[2] - 1\n        \n        carrots_left = carrots_left\n     \
    \   carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2]\
    \ - 1\n        \n        carrots_left = carrots_left\n        carrots_left[1]\
    \ = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2] - 1\n     \
    \   \n        carrots_left = carrots_left\n        carrots_left[1] = carrots_left[1]\
    \ - 1\n        carrots_left[2] = carrots_left[2] - 1\n        \n        carrots_left\
    \ = carrots_left\n        carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2]\
    \ = carrots_left[2] - 1\n        \n        carrots_left = carrots_left\n     \
    \   carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2]\
    \ - 1\n        \n        carrots_left = carrots_left\n        carrots_left[1]\
    \ = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2] - 1\n     \
    \   \n        carrots_left = carrots_left\n        carrots_left[1] = carrots_left[1]\
    \ - 1\n        carrots_left[2] = carrots_left[2] - 1\n        \n        carrots_left\
    \ = carrots_left\n        carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2]\
    \ = carrots_left[2] - 1\n        \n        carrots_left = carrots_left\n     \
    \   carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2]\
    \ - 1\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpijj8ogc7.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpijj8ogc7.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpijj8ogc7.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9hjt_lqr.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9hjt_lqr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9hjt_lqr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    meals_left = zeros(Int64, 2)\n\
    \    meals_left[1] = 0\n    meals_left[2] = 0\n    \n    while meals[1] > 0\n\
    \        carrots_left[1] -= meals[1]\n        meals_left[1] -= meals[1]\n    \
    \    \n        if carrots_left[1] < 0\n            carrots_left[1] = 0\n     \
    \   end\n        \n        if meals_left[1] < 0\n            meals_left[1] = 0\n\
    \        end\n        \n        if carrots_left[1] > 0\n            carrots[1]\
    \ += carrots_left[1]\n        end\n        \n        if meals_left[1] > 0\n  \
    \          meals[1] += meals_left[1]\n        end\n        \n        if carrots[1]\
    \ > 0\n            carrots[2] += 1\n        end\n        \n        if meals[1]\
    \ > 0\n            meals[2] += 1\n        end\n    end\n    \n    return carrots\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your code\n@test eat(5, 6, 10)\
    \ == [11, 4]\n@test eat(4, 8, 9) == [12, 1]\n@test eat(1, 10, 10) == [11, 0]\n\
    @test eat(2, 11, 5) == [7, 0]\n</cell>\n<text>\nProblem 3\nThe Fibonacci sequence\
    \ is defined by the formula:\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8rlnlmiw.jl:81\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8rlnlmiw.jl:81\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining < 0\n        return Vector{Int64}()\n    end\n    \n    if number\
    \ > remaining\n        number = remaining\n    end\n    \n    if need == 0\n \
    \       return Vector{Int64}([number, 0])\n    end\n    \n    if number > need\n\
    \        number = need\n    end\n    \n    return Vector{Int64}([number, number-number])\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjsnle9ty.jl:53\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjsnle9ty.jl:53\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkbw4srii.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpkbw4srii.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpkbw4srii.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining < need\n        return Vector{Int64}()\n    end\n    \n    carrots\
    \ = Vector{Int64}()\n    \n    if number < need\n        carrots = Vector{Int64}([number])\n\
    \    end\n    \n    carrots = carrots + eat(number - need, need, remaining)\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp67u4qq93.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp67u4qq93.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqsdjpn37.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpqsdjpn37.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpqsdjpn37.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    car\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpze0ah8db.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpze0ah8db.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpze0ah8db.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number should be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need should\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining should be between 0 and 1000\")\n    else \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7khrjwhe.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7khrjwhe.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \nend\n</cell>\n<text>\nProblem 3\nWrite a\
    \ function that takes an array of integers and returns the number of positive\
    \ integers that are less than the given number.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp36c8szv2.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp36c8szv2.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"invalid\
    \ input\")\n    end\n    \n    carrots = number\n    left  = need\n    \n    while\
    \ left > 0\n        carrots = carrots + 1\n        left = left - 1\n    end\n\
    \    \n    carrots = carrots - remaining\n    \n    return Vector{Int64}(carrots,\
    \ left)\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of items in an array. \nThe function should take in an array of integers\
    \ and an integer $k$ as input, and output the number of ways to arrange the items\
    \ in $k$ containers.\nThe function should return an array of integers containing\
    \ the number of ways to arrange the items in $k$ containers.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpblwkrc6n.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpblwkrc6n.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        error(\"\
    invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1]\
    \ = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n  \
    \  meals[1] = need\n    meals[2] = remaining\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = number\n    carrots_left[2] = remaining\n    \n  \
    \  while carrots_left[2] > 0 && meals[2] > 0\n        carrots_left[2] = carrots_left[2]\
    \ - 1\n        meals[2] = meals[2] - 1\n    end\n    \n    if carrots_left[2]\
    \ > 0 || meals[2] > 0\n        carrots_left[2] = carrots_left[2] - 1\n       \
    \ meals[2] = meals[2] - 1\n    end\n    \n    carrots_left[1] = carrots_left[1]\
    \ - carrots[1]\n    carrots_left[2] = carrots_left[2] - carrots[2]\n    \n   \
    \ if carrots_left[1] < 0 || carrots_left[2] < 0\n        carrots_left[1] = carrots_left[1]\
    \ + 1\n        carrots_left[2] = carrots_left[2] + 1\n    end\n    \n    return\
    \ carrots_left\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprprcukq4.jl:66\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprprcukq4.jl:66\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = need\n    \n    while carrots > 0\n   \
    \     carrots_left -= 1\n        carrots -= 1\n    end\n    \n    carrots_left\
    \ = carrots - remaining\n    \n    return Vector{Int64}(carrots_left, carrots)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpv8l6ca1u.jl:51\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: no method matching\
    \ Array{Int64,1}(::Int64, ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmpv8l6ca1u.jl:44\n   [2] top-level scope at /tmp/tmpv8l6ca1u.jl:51\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8l6ca1u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8l6ca1u.jl:52\n  Test threw exception\n  Expression: candidate(4,\
    \ 8, 9) == [12, 1]\n  MethodError: no method matching Array{Int64,1}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmpv8l6ca1u.jl:44\n   [2] top-level scope at /tmp/tmpv8l6ca1u.jl:52\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8l6ca1u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8l6ca1u.jl:53\n  Test threw exception\n  Expression: candidate(1,\
    \ 10, 10) == [11, 0]\n  MethodError: no method matching Array{Int64,1}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmpv8l6ca1u.jl:44\n   [2] top-level scope at /tmp/tmpv8l6ca1u.jl:53\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8l6ca1u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8l6ca1u.jl:54\n  Test threw exception\n  Expression: candidate(2,\
    \ 11, 5) == [7, 0]\n  MethodError: no method matching Array{Int64,1}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64) where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Int64...) where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmpv8l6ca1u.jl:44\n   [2] top-level scope at /tmp/tmpv8l6ca1u.jl:54\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8l6ca1u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8l6ca1u.jl:55\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 7) == [9, 2]\n  MethodError: no method matching Array{Int64,1}(::Int64, ::Int64)\n\
    \  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64)\
    \ where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64...)\
    \ where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmpv8l6ca1u.jl:44\n   [2] top-level scope at /tmp/tmpv8l6ca1u.jl:55\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8l6ca1u.jl:50\n  \ntest set: Error During\
    \ Test at /tmp/tmpv8l6ca1u.jl:56\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 1) == [5, 0]\n  MethodError: no method matching Array{Int64,1}(::Int64, ::Int64)\n\
    \  Closest candidates are:\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64)\
    \ where T at boot.jl:405\n    Array{Int64,1}(!Matched::UndefInitializer, ::Int64...)\
    \ where {T, N} at boot.jl:411\n    Array{Int64,1}(!Matched::UndefInitializer,\
    \ ::Integer) where T at baseext.jl:12\n    ...\n  Stacktrace:\n   [1] eat(::Int64,\
    \ ::Int64, ::Int64) at /tmp/tmpv8l6ca1u.jl:44\n   [2] top-level scope at /tmp/tmpv8l6ca1u.jl:56\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv8l6ca1u.jl:50\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv8l6ca1u.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = 0\n    \n    while meals[1] > 0\n        carrots_left[1]\
    \ -= 1\n        meals[1] -= 1\n        carrots[1] -= carrots[2]\n        carrots[2]\
    \ = 0\n    end\n    \n    while carrots_left[1] > 0\n        meals[1] -= 1\n \
    \       carrots[1] -= carrots[2]\n        carrots[2] = 0\n    end\n    \n    return\
    \ carrots\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6gtnbyap.jl:61\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6gtnbyap.jl:61\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n# Test your code\n\
    @test eat(5, 6, 10) == [11, 4]\n@test eat(4, 8, 9) == [12, 1]\n@test eat(1, 10,\
    \ 10) == [11, 0]\n@test eat(2, 11, 5) == [7, 0]\n</cell>\n<text>\nProblem 7\n\
    Write a function that returns the number of prime numbers less than a given integer\
    \ $n$, where $n$ is also a prime.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1zigd9i9.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1zigd9i9.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8wl6s187.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8wl6s187.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else if number ==\
    \ 0 && need == 0 && remaining == 0 \n        return Vector{Int64}()\n    else\
    \ if number == 0 && need == 0 && remaining > 0 \n        return Vector{Int64}(remaining)\n\
    \    else if number == 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(need)\n\
    \    else if number == 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number,\
    \ need)\n    else if number > 0 && need == 0 && remaining == 0 \n        return\
    \ Vector{Int64}(number, need)\n    else if number > 0 && need == 0 && remaining\
    \ > 0 \n        return Vector{Int64}(number, need, remaining)\n    else if number\
    \ > 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(number, need)\n\
    \    else if number > 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number,\
    \ need, remaining)\n    else if number > 0 && need > 0 && remaining == 0 \n  \
    \      return Vector{Int64}(number, need)\n    else if number > 0 && need > 0\
    \ && remaining > 0 \n        return Vector{Int64}(number, need, remaining)\n \
    \   else if number > 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(number,\
    \ need)\n    else if number > 0 && need > 0 && remaining > 0 \n        return\
    \ Vector{Int64}(number, need, remaining)\n    else if number > 0 && need > 0 &&\
    \ remaining == 0 \n        return Vector{Int64}(number, need)\n    else if number\
    \ > 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number, need,\
    \ remaining)\n    else if number > 0 && need > 0 && remaining == 0 \n        return\
    \ Vector{Int64}(number, need)\n    else if number > 0 && need > 0 && remaining\
    \ > 0 \n        return Vector{Int64}(number, need, remaining)\n    else if number\
    \ > 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(number, need)\n\
    \    else if number > 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number,\
    \ need, remaining)\n    else if number > 0 && need > 0 && remaining == 0 \n  \
    \      return Vector{Int64}(number, need)\n    else if number > 0 && need > 0\
    \ && remaining > 0 \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7y68jwy7.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7y68jwy7.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkdw1vm39.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkdw1vm39.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4jtmyvvu.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4jtmyvvu.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    if number == 0\n        return Vector{Int64}([need, remaining])\n\
    \    end\n    if remaining == 0\n        return Vector{Int64}([number, 0])\n \
    \   end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpl0emha0c.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpl0emha0c.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpl0emha0c.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     \n        carrots_left = number - need\n        carrots_eaten = remaining\n\
    \        \n        while carrots_eaten > 0 \n            carrots_left -= 1\n \
    \           carrots_eaten -= 1\n            push!(answer, carrots_eaten)\n   \
    \     end\n        \n        push!(answer, carrots_left)\n        \n        return\
    \ answer\n    end\n    return []\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of prime numbers less than\
    \ a given number. \nThe function should take in a single integer and output a\
    \ vector of integers \nthat represent the number of prime numbers less than that\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpir_l9vbb.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpir_l9vbb.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = number\n    meals_left[2]\
    \ = remaining\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] =\
    \ number\n    carrots_left[2] = remaining\n    \n    carrots_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals[1] = number\n    carrots_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n   \
    \ carrots_left_after_meals_left[1] = number\n    carrots_left_after_meals_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_left_after_meals[1] = number\n    carrots_left_after_meals_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_left_after_meals_left[1] = number\n    carrots_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmp1fo0sf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpmp1fo0sf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpmp1fo0sf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = remaining\n    \n    while carrots_left\
    \ > 0\n        if carrots_left > need\n            carrots_left -= need\n    \
    \        carrots += need\n        else\n            carrots_left -= carrots_left\n\
    \            carrots += 1\n        end\n    end\n    \n    return Vector{Int64}(carrots,\
    \ carrots_left)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp78s4c2t9.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp78s4c2t9.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplxnqv5vg.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplxnqv5vg.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = 0\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots_left[1] += meals[1]\n   \
    \     meals[1] -= carrots[1]\n        carrots[1] -= carrots[2]\n        carrots[2]\
    \ += meals[2]\n        meals[2] -= carrots[2]\n    end\n    \n    return carrots_left\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns the number of ways you can reach a target number from any given\
    \ starting number by adding or subtracting one to that starting number. For example,\
    \ if you start at 5 and want to reach 10, you can either add one to 5 or subtract\
    \ one from 5, and you can add one to 10 or subtract one from 10. Write a recursive\
    \ function that returns the number of ways you can reach the target number from\
    \ any given starting number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp46f1hc0y.jl:56\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp46f1hc0y.jl:56\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return error(\"Invalid input\")\n    end\n\
    \    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2]\
    \ = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2]\
    \ = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n\
    \    carrots_left[2] = 0\n    \n    while carrots_left[2] > 0 && meals[2] > 0\n\
    \        if carrots[1] > 0\n            carrots[1] -= meals[1]\n            meals[1]\
    \ = 0\n        end\n        if carrots[2] > 0\n            carrots[2] -= meals[2]\n\
    \            meals[2] = 0\n        end\n        \n        if carrots_left[1] >\
    \ 0\n            carrots_left[1] -= meals[1]\n            meals[1] = 0\n     \
    \   end\n        if carrots_left[2] > 0\n            carrots_left[2] -= meals[2]\n\
    \            meals[2] = 0\n        end\n    end\n    \n    if carrots_left[2]\
    \ > 0\n        carrots_left[2] -= meals[2]\n        meals[2] = 0\n    end\n  \
    \  \n    if carrots[1] > 0\n        carrots[1] -= meals[1]\n        meals[1] =\
    \ 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\ne\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppm0cnjre.jl:78\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppm0cnjre.jl:78\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        if remaining\
    \ < need\n            Vector{Int64}(remaining, 0)\n        else\n            Vector{Int64}(number,\
    \ need - remaining)\n        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function called hungry that returns\
    \ true if the number of carrots left after your meals is less than or equal to\
    \ zero, and false otherwise.\nHint: You will need to use the eat function you\
    \ wrote in the previous exercise.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkq9cwi26.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkq9cwi26.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > remaining \n        number = remaining\n    end\n    if number\
    \ == 0 \n        Vector{Int64}([need, remaining])\n    elseif number < need \n\
    \        Vector{Int64}([number, remaining])\n    elseif number == need \n    \
    \    Vector{Int64}([number, 0])\n    elseif number > need \n        Vector{Int64}([need,\
    \ 0])\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 1)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 2)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 3)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 4)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 5)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 6)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 7)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 8)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 9)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 11)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 12)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 13)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 14)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 15)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 16)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 17)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 18)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 19)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 20)\n</cell>\n<code language=julia-1.0>\neat(10, 10, \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_kh2jrdv.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_kh2jrdv.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppkn0mn7a.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmppkn0mn7a.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmppkn0mn7a.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    meals_left = zeros(Int64, 2)\n\
    \    meals_left[1] = 0\n    meals_left[2] = 0\n    \n    carrots_left[1] = carrots[1]\n\
    \    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n    meals_left[2]\
    \ = meals[2]\n    \n    carrots_left[1] = carrots[1]\n    carrots_left[2] = carrots[2]\n\
    \    \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n    \n    carrots_left[1]\
    \ = carrots[1]\n    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n\
    \    meals_left[2] = meals[2]\n    \n    carrots_left[1] = carrots[1]\n    carrots_left[2]\
    \ = carrots[2]\n    \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n\
    \    \n    carrots_left[1] = carrots[1]\n    carrots_left[2] = carrots[2]\n  \
    \  \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n    \n    carrots_left[1]\
    \ = carrots[1]\n    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n\
    \    meals_left[2] = meals[2]\n    \n    carrots_left[1] = carrots[1]\n    carrots_left[2]\
    \ = carrots[2]\n    \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n\
    \    \n    carrots_left[1] = carrots[1]\n    carrots_left[2] = carrots[2]\n  \
    \  \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n    \n    carrots_left[1]\
    \ = carrots[1]\n    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9f9v14wf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9f9v14wf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9f9v14wf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    if number == 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\n    if number == 0 && remaining > 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\n    if number > 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ number])\n    end\n    if number > 0 && remaining > 0\n        return Vector{Int64}([need,\
    \ number])\n    end\n    return Vector{Int64}()\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\ne\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp96fcjrvt.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp96fcjrvt.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"invalid\
    \ input\")\n    end\n    \n    if number == 0\n        return [need, remaining]\n\
    \    end\n    \n    if remaining == 0\n        return [number, 0]\n    end\n \
    \   \n    if number > remaining\n        return [number, remaining]\n    end\n\
    \    \n    if need == 0\n        return [number, 0]\n    end\n    \n    if number\
    \ > need\n        return [number, need]\n    end\n    \n    if number == need\n\
    \        return [number, 0]\n    end\n    \n    if number > need\n        return\
    \ [number, need]\n    end\n    \n    if number == need\n        return [number,\
    \ 0]\n    end\n    \n    if number == remaining\n        return [number, 0]\n\
    \    end\n    \n    if number > remaining\n        return [number, remaining]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number > remaining\n        return [number, remaining]\n    end\n\
    \    \n    if number == remaining\n        return [number, 0]\n    end\n    \n\
    \    if number > remaining\n        return [number, remaining]\n    end\n    \n\
    \    if number == remaining\n        return [number, 0]\n    end\n    \n    if\
    \ number > remaining\n        return [number, remaining]\n    end\n    \n    if\
    \ number == remaining\n        return [number, 0]\n    end\n    \n    if number\
    \ > remaining\n        return [number, remaining]\n    end\n    \n    if number\
    \ == remaining\n        return [number, 0]\n    end\n    \n    if number > remaining\n\
    \        return [number, remaining]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number > remaining\n      \
    \  return [number, remaining]\n    end\n    \n    if number == remaining\n   \
    \     return [number, 0]\n    end\n    \n    if number > remaining\n        return\
    \ [number, remaining]\n    end\n    \n    if number == remaining\n        return\
    \ [number, 0]\n    end\n    \n    if number > remaining\n        return [number,\
    \ remaining]\n    end\n    \n    if number == remaining\n        return [number,\
    \ 0]\n    end\n    \n    if number > remaining\n        return [number, remaining]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number > remaining\n        return [number, remaining]\n    end\n\
    \    \n    if number == remaining\n        return [number, 0]\n    end\n    \n\
    \    if number > remaining\n        return [number, remaining]\n    end\n    \n\
    \    if number == remaining\n        return [number, 0]\n    end\n    \n    if\
    \ number > remaining\n        return [number, remaining]\n    end\n    \n    if\
    \ number == remaining\n        return [number, 0]\n    end\n    \n    if number\
    \ > remaining\n        return [number, remaining]\n    end\n    \n    if number\
    \ == \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfy_js4ul.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfy_js4ul.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots[2] = remaining - carrots[2]\n    \n\
    \    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppgwpcqd6.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppgwpcqd6.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = need\n    \n    carrots_left = carrots_left\
    \ - number\n    \n    if carrots_left[1] > 0\n        carrots_left[1] -= 1\n \
    \   end\n    \n    if carrots_left[2] > 0\n        carrots_left[2] -= 1\n    end\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1v8xkxe0.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1v8xkxe0.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = number\n    carrots_left = remaining\n\
    \    \n    meals_left = 0\n    \n    while carrots_left > 0\n        if carrots_left\
    \ > need\n            carrots_left -= need\n            meals_left += 1\n    \
    \    else\n            carrots_left -= carrots_left\n        end\n    end\n  \
    \  \n    return [meals_left, carrots_left]\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n integers into k groups. \nThe function should take in two\
    \ parameters: n and k. \nThe function should return an array of integers representing\
    \ the number of ways to arrange the integers into k groups.\nThe function should\
    \ return an empty array if n is less than or equal to 0 or if k is less than or\
    \ equal to 0.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphecful_q.jl:50\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphecful_q.jl:50\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    \n    if number == 0\n        return [need, remaining]\n    end\n\
    \    \n    if remaining < need\n        return [number, 0]\n    end\n    \n  \
    \  carrots = number\n    \n    while carrots > 0\n        carrots = carrots -\
    \ 1\n        need = need - 1\n    end\n    \n    return [need, remaining]\nend\n\
    </cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns an array of integers representing the number of times each of the\
    \ elements in the array appears.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv_6twtom.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv_6twtom.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}([need, remaining])\n    elseif remaining\
    \ == 0\n        Vector{Int64}([number, 0])\n    elseif number > remaining\n  \
    \      Vector{Int64}([number, remaining])\n    else\n        Vector{Int64}([number,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of items in an array\nof size n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0yiala_z.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0yiala_z.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    if number == 0\n        \n        return [need, remaining]\n\
    \    \n    if remaining == 0\n        \n        return [number, 0]\n    \n   \
    \ if number > remaining\n        \n        return [number, remaining]\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmputhcvkyp.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmputhcvkyp.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    need = need - carrots\n    remaining\
    \ = remaining - carrots\n    \n    if remaining <= 0\n        return Vector{Int64}(carrots,\
    \ 0)\n    end\n    \n    carrots = carrots + need\n    \n    return Vector{Int64}(carrots,\
    \ remaining)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp784ywhst.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp784ywhst.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvaj74v6u.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpvaj74v6u.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpvaj74v6u.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = remaining\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals[1] =\
    \ remaining\n    carrots_left_after_meals_after_meals_after_meals[2] = 0\n   \
    \ \n    carrots_left_after_meals_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1] = remaining\n\
    \    carrots_left_after_meals_after_meals_after_meals_after_meals[2] = 0\n   \
    \ \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp_6rq4om.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpp_6rq4om.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpp_6rq4om.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\") \n    else \n   \
    \     \n        carrots = zeros(Int64, 2)\n        carrots[1] = number\n     \
    \   carrots[2] = need\n        \n        carrots_left = zeros(Int64, 2)\n    \
    \    carrots_left[1] = remaining\n        carrots_left[2] = remaining\n      \
    \  \n        carrots_left = carrots_left[1]\n        \n        carrots_left =\
    \ carrots_left\n        \n        carrots_left = carrots_left\n        \n    \
    \    carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpe1sdgoec.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpe1sdgoec.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpe1sdgoec.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = remaining\n    \n    meals = Vector{Int64}()\n\
    \    \n    while carrots_left > 0\n        if carrots_left > need\n          \
    \  meals = meals + carrots_left\n            carrots_left = 0\n        else\n\
    \            meals = meals + need\n            carrots_left -= need\n        end\n\
    \    end\n    \n    return meals\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvjpbsdgp.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvjpbsdgp.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return [need, remaining]\n    elseif remaining\
    \ < 0\n        return [need, 0]\n    elseif remaining == 0\n        return [need,\
    \ 0]\n    elseif number > remaining\n        return [need, 0]\n    else\n    \
    \    return eat(number - 1, need + number, remaining - number)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nExercise 2\n\
    Write a function called eat_all that takes three integers as parameters and returns\
    \ an array of two integers containing the number of carrots you would need to\
    \ eat to complete the day's meals.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfvqg18w9.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfvqg18w9.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    # Your code here\n    \n    \n    return Vector{Int64}([number,\
    \ need-number])\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to choose k items\
    \ from n items. \nThe order of the items does not matter. \nThe function should\
    \ return an array of integers, where each element is the number of ways to choose\
    \ that item from n items.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_56eofgq.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_56eofgq.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \n    return Vector{Int64}([number, remaining])\n\
    end\n</cell>\n<code language=julia-1.5>\n# Run this cell to check your output.\
    \ If everything is correct, you should see output similar to this:\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nPart 3: Mealplan\n\
    Now that you have learned how to write functions, you will be able to write mealplans.\
    \ A mealplan is simply a way to plan out what to do to meet the deadline. For\
    \ example, you may want to order a pizza to eat at noon on Monday, but you may\
    \ not have enough money to order a pizza until after noon on Tuesday. Or you may\
    \ want to order a pizza to eat at noon on Wednesday, but you may not have enough\
    \ money to order a pizza until after noon on Thursday. Or you may want to order\
    \ a pizza to eat at noon on Friday, but you may not have enough money to order\
    \ a pizza until after noon on Saturday. Or you may want to order a pizza to eat\
    \ at noon on Sunday, but you may not have enough money to order a pizza until\
    \ after noon on Monday. Or you may want to order a pizza to eat at noon on Tuesday,\
    \ but you may not have enough money to order a pizza until after noon on Wednesday.\
    \ Or you may want to order a pizza to eat at noon on Thursday, but you may not\
    \ have enough money to order a pizza until after noon on Friday. Or you may want\
    \ to order a pizza to eat at noon on Saturday, but you may not have enough money\
    \ to order a pizza until after noon on Sunday.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptr9ifkra.jl:35\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptr9ifkra.jl:35\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return [need, remaining]\n    else if number >\
    \ remaining\n        return [number, 0]\n    else\n        carrots = number %\
    \ need\n        number = number - carrots\n        remaining = remaining - carrots\n\
    \        return [number, remaining]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that takes in an array\
    \ of integers and returns the number of positive integers less than or equal to\
    \ that number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbdivom7b.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbdivom7b.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n   \
    \ while carrots > 0\n        carrots_left -= 1\n        carrots -= 1\n    end\n\
    \    \n    carrots = need\n    carrots_left = remaining\n    \n    while carrots\
    \ > 0\n        carrots_left -= 1\n        carrots -= 1\n    end\n    \n    return\
    \ Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpigye01h0.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpigye01h0.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = 0\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots_left[1] += meals[1]\n   \
    \     meals[1] -= carrots[1]\n        carrots[1] -= carrots[2]\n        \n   \
    \     if carrots[1] > 0\n            meals[1] -= carrots[1]\n            carrots[1]\
    \ -= carrots[2]\n        end\n        \n        if meals[1] > 0\n            meals[1]\
    \ -= carrots[1]\n            carrots[1] -= carrots[2]\n        end\n    end\n\
    \    \n    return carrots_left\nend\n</cell>\n<code language=julia-1.4>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb3wbgu11.jl:64\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb3wbgu11.jl:64\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([need, number])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuiiec22_.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuiiec22_.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[2]\n    \n    carrots_left = carrots_left\n  \
    \  \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyh5p2dxp.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpyh5p2dxp.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpyh5p2dxp.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    if number == 0 && need == 0 && remaining > 0\n\
    \        return Vector{Int64}([remaining])\n    end\n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}([need])\n    end\n    if\
    \ number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}([number])\n\
    \    end\n    if number > 0 && need == 0 && remaining > 0\n        return Vector{Int64}([number,\
    \ remaining])\n    end\n    if number > 0 && need > 0 && remaining == 0\n    \
    \    return Vector{Int64}([need, number])\n    end\n    if number > 0 && need\
    \ > 0 && remaining > 0\n        return Vector{Int64}([need, number, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    findMeals(meals::Vector{Int64},\
    \ carrots::Int64) -> Vector{Int64}\n    \n    You have a meal plan, and you already\
    \ have eaten a certain number of carrots,\n    but now you need to eat more carrots\
    \ to complete the day's meals.\n    You should return an array of [ total number\
    \ of eaten carrots after your meals,\n                                    the\
    \ number of carrots left after your meals ]\n    if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n   \
    \ \n    Example:\n    * findMeals([5, 6, 10], 6) -> [11, 4]\n    * findMeals([4,\
    \ 8, 9], 10) -> [12, 1]\n    * findMeals([1, 10, 10], 11) -> [11, 0]\n    * findMeals([2,\
    \ 11, 5], 7) -> [7, 0]\n    \n    Variables:\n    @meals : Vector{Int64}\n   \
    \     the meals that you have eaten.\n    @carrots : integer\n        the number\
    \ of carrots that you have eaten.\n    \n    Constrain:\n    * 0 <= meals <= 1000\n\
    \    * 0 <= carrots <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph86gtrd4.jl:55\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph86gtrd4.jl:55\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0 \n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n    meals[1] =\
    \ need\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = number\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n    carrots_left_after_meals_left[1]\
    \ = remaining\n    carrots_left_after_meals_left[2] = 0\n    \n    carrots_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals[1] = number\n\
    \    carrots_left_after_meals_left_after_meals[2] = 0\n    \n    carrots_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left[1] = remaining\n\
    \    carrots_left_after_meals_left_after_meals_left[2] = 0\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = remaining\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = 0\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meal\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpemnitj3j.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpemnitj3j.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpemnitj3j.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1:2]\n    \n\
    \    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrot\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz05gwnin.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpz05gwnin.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpz05gwnin.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    need = need - carrots\n    remaining\
    \ = remaining - carrots\n    \n    if remaining <= 0\n        return Vector{Int64}(carrots,\
    \ 0)\n    end\n    \n    carrots = carrots + need\n    \n    return Vector{Int64}(carrots,\
    \ remaining)\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function called eat_all that takes in an array of integers\
    \ and returns an array of the same length with the number of carrots eaten for\
    \ each meal. \nThe function should return an empty array if there are no carrots\
    \ left.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi_vo3_r_.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi_vo3_r_.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphacr7mqo.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmphacr7mqo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmphacr7mqo.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return [need, remaining]\n    elseif number >\
    \ remaining\n        return [number, 0]\n    elseif number == remaining\n    \
    \    return [number, 0]\n    else\n        \n        \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu8asef70.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu8asef70.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    end\n    if need < 0 || need > 1000 \n        error(\"need\
    \ must be between 0 and 1000\")\n    end\n    if remaining < 0 || remaining >\
    \ 1000 \n        error(\"remaining must be between 0 and 1000\")\n    end\n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjfujttmf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpjfujttmf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpjfujttmf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7zcj7qkf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp7zcj7qkf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp7zcj7qkf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < 0\n  \
    \      Vector{Int64}()\n    elseif remaining == 0\n        Vector{Int64}([need,\
    \ 0])\n    elseif remaining < need\n        Vector{Int64}([need, 0])\n    else\n\
    \        Vector{Int64}([need, number])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    You have a list of numbers, and you need to find the largest number\
    \ in the list.\n    \n    Example:\n    * largest([5, 6, 10, 9, 2, 3]) -> 9\n\
    \    * largest([5, 6, 10, 9, 2, 3]) -> 10\n    * largest([5, 6, 10, 9, 2, 3])\
    \ -> 6\n    \n    Variables:\n    @numbers : array of integers\n        the list\
    \ of numbers that you need to find the largest number of.\n    \n    Constrain:\n\
    \    * numbers is an array of integers\n    * numbers is non-empty\n    * numbers\
    \ is sorted\n    * numbers is non-decreasing\n    \n    Have fun :)\n    \"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8o4nllo2.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8o4nllo2.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be non-negative\")\n    elseif need < 0\n        error(\"\
    need must be non-negative\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be non-negative\")\n    else\n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"\n    You have a certain\
    \ number of carrots, and you have a certain number of meals.\n    You want to\
    \ eat as many carrots as possible, but you only have one meal left.\n    \n  \
    \  Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n \
    \   * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @meals : integer\n        the number of meals that you have left.\n    \n\
    \    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= meals <= 1000\n    \n \
    \   Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvgktaa68.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvgktaa68.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif number == need\n        Vector{Int64}([number,\
    \ 0])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    You have a certain number of carrots, and\
    \ you need to eat some more.\n    You will eat as many carrots as you can until\
    \ you run out of carrots to eat,\n    but you will be hungry for a certain number\
    \ of minutes.\n    \n    Example:\n    * eat(3, 10, 5) -> [7, 0]\n    * eat(3,\
    \ 10, 0) -> [7, 0]\n    * eat(3, 10, -1) -> [7, 0]\n    * eat(3, 10, -2) -> [7,\
    \ 0]\n    * eat(3, 10, -3) -> [7, 0]\n    * eat(3, 10, -4) -> [7, 0]\n    * eat(3,\
    \ 10, -5) -> [7, 0]\n    * eat(3, 10, -6) -> [7, 0]\n    * eat(3, 10, -7) -> [7,\
    \ 0]\n    * eat(3, 10, -8) -> [7, 0]\n    * eat(3, 10, -9) -> [7, 0]\n    * eat(3,\
    \ 10, -10) -> [7, 0]\n    * eat(3, 10, -11) -> [7, 0]\n    * eat(3, 10, -12) ->\
    \ [7, 0]\n    * eat(3, 10, -13) -> [7, 0]\n    * eat(3, 10, -14) -> [7, 0]\n \
    \   * eat(3, 10, -15) -> [7, 0]\n    * eat(3, 10, -16) -> [7, 0]\n    * eat(3,\
    \ 10, -17) -> [7, 0]\n    * eat(3, 10, -18) -> [7, 0]\n    * eat(3, 10, -19) ->\
    \ [7, 0]\n    * eat(3, 10, -20) -> [7, 0]\n    * eat(3, 10, -21) -> [7, 0]\n \
    \   * eat(3, 10, -22) -> [7, 0]\n    * eat(3, 10, -23) -> [7, 0]\n    * eat(3,\
    \ 10, -24) -> [7, 0]\n    * eat(3, 10, -25) -> [7, 0]\n    * eat(3, 10, -26) ->\
    \ [7, 0]\n    * eat(3, 10, -27) -> [7, 0]\n    * eat(3, 10, -28) -> [7, 0]\n \
    \   * eat(3, 10, -29) -> [7, 0]\n    * eat(3, 10, -30) -> [7, 0]\n    * eat(3,\
    \ \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvmitrm_8.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvmitrm_8.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    meals = Vector{Int64}()\n    \n    while remaining\
    \ > 0\n        meals.push(number)\n        number -= 1\n        remaining -= 1\n\
    \    end\n    \n    meals.push(need)\n    \n    return meals\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=juli\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7v7vgdge.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7v7vgdge.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n \
    \       Vector{Int64}([need, number-remaining])\n    end\nend\n</cell>\n<code\
    \ language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways to arrange a collection of n items in m containers.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxz8fcb3f.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxz8fcb3f.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2x84oarj.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp2x84oarj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp2x84oarj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3u3q5rq5.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3u3q5rq5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3u3q5rq5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < 0\n  \
    \      Vector{Int64}()\n    elseif number < need\n        Vector{Int64}()\n  \
    \  else\n        Vector{Int64}(remaining, number - need)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways to arrange a certain number of items in an array.\
    \ \nThe items can be any type, and each item can only occur once.\nThe function\
    \ should return an array of integers.\nThe first element of the array should be\
    \ the total number of ways to arrange the items in the array.\nThe second element\
    \ of the array should be the total number of ways to arrange the items in the\
    \ array in any order.\nThe third element of the array should be the total number\
    \ of ways to arrange the items in the array in any order.\nThe fourth element\
    \ of the array should be the total number of ways to arrange the items in the\
    \ array in any order.\nThe fifth element of the array should be the total number\
    \ of ways to arrange the items in the array in any order.\nThe sixth element of\
    \ the array should be the total number of ways to arrange the items in the array\
    \ in any order.\nThe seventh element of the array should be the total number of\
    \ ways to arrange the items in the array in any order.\nThe eighth element of\
    \ the array should be the total number of ways to arrange the items in the array\
    \ in any order.\nThe ninth element of the array should be the total number of\
    \ ways to arrange the items in the array in any order.\nThe tenth element of the\
    \ array should be the total number of ways to arrange the items in the array in\
    \ any order.\nThe eleventh element of the array should be the total number of\
    \ ways to arrange the items in the array in any order.\nThe twelfth element of\
    \ the array should be the total number of ways to arrange the items in the array\
    \ in any order.\nThe thirteenth element of the array should be the total number\
    \ of ways to arrange the items in the array in any order.\nThe fourteenth element\
    \ of the array should be the total number of ways to arrange the items in the\
    \ array in any order.\nThe fifteenth element of the array should be the total\
    \ number of ways to arrange the items in the array in any order.\nThe sixteenth\
    \ element of the array should be the total number of ways to arrange the items\
    \ in the array in any order.\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr9dloymx.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr9dloymx.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = 0\n  \
    \  \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n   \
    \ carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64, 2)\n\
    \    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = carrots_left_after_meals[1]\n    carrots_left_after_meals_after_meals[2] =\
    \ 0\n    \n    carrots_left_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals[1] = carrots_left_after_meals_after_meals[1]\n\
    \    carrots_left_after_meals_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxbb6e8om.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpxbb6e8om.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpxbb6e8om.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining])\n    elseif\
    \ remaining == 0\n        Vector{Int64}([number, 0])\n    elseif number > need\n\
    \        Vector{Int64}([number, remaining])\n    else\n        Vector{Int64}([number,\
    \ remaining - number])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"\n    meals() -> a function that returns the number of meals left in the day\n\
    \    \n    Example:\n    * meals() -> 10\n    * meals() -> 0\n    \n    Variables:\n\
    \    no input\n    \n    Constrain:\n    * no output\n    * no side effects\n\"\
    \"\"\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0x3vcbwe.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0x3vcbwe.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n   \
    \ carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n\
    \    meals[2] = remaining\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = remaining\n    \n    meals_left = zeros(Int64,\
    \ 2)\n    meals_left[1] = remaining\n    meals_left[2] = remaining\n    \n   \
    \ carrots_left_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals[2] = remaining\n    \n    meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals[1] = remaining\n    meals_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n   \
    \ carrots_left_after_meals_left[1] = remaining\n    carrots_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left = zeros(Int64, 2)\n    meals_left_after_meals_left[1]\
    \ = remaining\n    meals_left_after_meals_left[2] = remaining\n    \n    carrots_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals[1] = remaining\n\
    \    carrots_left_after_meals_left_after_meals[2] = remaining\n    \n    meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals[1] = remaining\n\
    \    meals_left_after_meals_left_after_meals[2] = remaining\n    \n    carrots_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left[1] = remaining\n\
    \    carrots_left_after_meals_left_after_meals_left[2] = remaining\n    \n   \
    \ meals_left_after_meals_left_after_meals_left = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left[1]\
    \ = remaining\n    meals_left_after_meals_left_after_meal\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4t7wc390.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp4t7wc390.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp4t7wc390.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0v2alpc0.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0v2alpc0.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0v2alpc0.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = 0\n    meals_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots[1] -= meals[1]\n        meals[1]\
    \ -= 1\n        \n        if carrots[1] == 0\n            meals[2] += 1\n    \
    \        carrots[2] += meals[2]\n        end\n        \n        if meals_left[1]\
    \ > 0\n            meals_left[1] -= 1\n            meals_left[2] += 1\n      \
    \  end\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n integers in an array such that each number appears exactly\
    \ once and each number is less than or equal to its neighbors.\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptp4jjhe0.jl:63\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmptp4jjhe0.jl:63\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    if number == 0 && need == 0 && remaining\
    \ > 0\n        return Vector{Int64}(remaining, 0)\n    end\n    \n    if number\
    \ == 0 && need > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n\
    \    end\n    \n    if number == 0 && need > 0 && remaining > 0\n        return\
    \ Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need == 0 && remaining\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining > 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining > 0\n   \
    \     return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && \n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu_q9rjyz.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu_q9rjyz.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n items in k containers.\nThe containers are represented\
    \ by an array of n integers called containers.\nThe items are represented by an\
    \ array of n integers called items.\nThe function should return an array of integers\
    \ called results.\nThe function should return an empty array if n is less than\
    \ or equal to 0.\nThe function should return an empty array if k is less than\
    \ or equal to 0.\nThe function should return an empty array if n is greater than\
    \ or equal to k.\nThe function should return an empty array if n is not divisible\
    \ by k.\nThe function should return an empty array if k is not divisible by n.\n\
    The function should return an empty array if n is not divisible by k.\nThe function\
    \ should return an empty array if k is not divisible by n.\nThe function should\
    \ return an empty array if k is greater than or equal to n.\nThe function should\
    \ return an empty array if k is greater than n.\nThe function should return an\
    \ empty array if k is greater than or equal to n.\nThe function should return\
    \ an empty array if k is less than or equal to n.\nThe function should return\
    \ an empty array if k is less than n.\nThe function should return an empty array\
    \ if k is less than or equal to n.\nThe function should return an empty array\
    \ if k is greater than or equal to n.\nThe function should return an empty array\
    \ if k is greater than n.\nThe function should return an empty array if k is greater\
    \ than or equal to n.\nThe function should return an empty array if k is less\
    \ than or equal to n.\nThe function should return an empty array if k is less\
    \ than n.\nThe function should return an empty array if k is less than or equal\
    \ to n.\nThe function should return an empty array if k is greater than or equal\
    \ to n.\nThe function should return an empty array if k is greater than n.\nThe\
    \ function should return an empty array if k is greater than or equal to n.\n\
    The function should return an empty array if k is less than or equal to n.\nThe\
    \ function should return an empty array if k is less than n.\nThe function should\
    \ return an empty array if k is less than or equal to n.\nThe function should\
    \ return \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy26wpar4.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy26wpar4.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n \
    \       Vector{Int64}([need, number])\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4u1cm1gr.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4u1cm1gr.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining\
    \ > 0 && remaining <= 1000\n        answer = []\n        carrots = number\n  \
    \      carrots_left = remaining\n        while carrots > 0\n            carrots_left\
    \ -= 1\n            push!(answer, carrots)\n            carrots -= need\n    \
    \    end\n        return answer\n    else\n        error(\"Invalid input\")\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(100, 100, 100)\n</cell>\n<text>\nExercise 2\nWrite a function called hungry_rabbit\
    \ that takes two integers representing a number of carrots and a number of meals,\
    \ and returns an array of two integers representing the number of carrots left\
    \ after your meals and the number of carrots eaten after your meals.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd_nltsdn.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd_nltsdn.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number > remaining\n\
    \        Vector{Int64}(remaining, 0)\n    elseif need == 0\n        Vector{Int64}(0,\
    \ number)\n    else\n        Vector{Int64}(remaining, number - need)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns the number of days left in a meal plan.\nThe function should take\
    \ in two arguments: the number of days that you have left to eat, and the number\
    \ of days that you need to eat.\nThe function should return an array of two integers,\
    \ the first being the number of days left in the meal plan, and the second being\
    \ the number of days that you need to eat.\nThe function should return an empty\
    \ array if there is not enough remaining days to complete the meal plan.\nThe\
    \ function should return an empty array if there is not enough remaining days\
    \ to complete the meal plan.\nThe function should return an empty array if there\
    \ is not enough remaining days to complete the meal plan.\nThe function should\
    \ return an empty array if there is not enough remaining days to complete the\
    \ meal plan.\nThe function should return an empty array if there is not enough\
    \ remaining days to complete the meal plan.\nThe function should return an empty\
    \ array if there is not enough remaining days to complete the meal plan.\nThe\
    \ function should return an empty array if there is not enough remaining days\
    \ to complete the meal plan.\nThe function should return an empty array if there\
    \ is not enough remaining days to complete the meal plan.\nThe function should\
    \ return an empty array if there is not enough remaining days to complete the\
    \ meal plan.\nThe function should return an empty array if there is not enough\
    \ remaining days to complete the meal plan.\nThe function should return an empty\
    \ array if there is not enough remaining days to complete the meal plan.\nThe\
    \ function should return an empty array if there is not enough remaining days\
    \ to complete the meal plan.\nThe function should return an empty array if there\
    \ is not enough remaining days to complete the meal plan.\nThe function should\
    \ return an empty array if there is not enough remaining days to complete the\
    \ meal plan.\nThe function should return an empty array if there is not enough\
    \ remaining days to complete the meal plan.\nThe function should return an empty\
    \ array if there is not enough \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprrjl_mm3.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprrjl_mm3.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7: Sum square difference\nGiven an array of integers, find the sum of\
    \ square differences between the array elements.\nThe sum of square differences\
    \ is defined as the square of the absolute value of the difference between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzq3sysgz.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzq3sysgz.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\") \n    else \n   \
    \     Vector{Int64}([number, need, remaining]) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function called eat_all that\
    \ takes in an array of integers and returns the number of carrots left after eating\
    \ all meals.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr4an60wg.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr4an60wg.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0\n        \n        \n     \
    \   \n        \n        \n        \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmwm5_br3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmwm5_br3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < need\n\
    \        Vector{Int64}(remaining, 0)\n    else\n        Vector{Int64}(number,\
    \ 0)\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7pra_vps.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7pra_vps.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = 0\n  \
    \  \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = 0\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        if carrots[1] > 0\n            carrots[1]\
    \ -= meals[1]\n            meals[1] -= 1\n            carrots_left[1] += meals[1]\n\
    \            meals[1] -= 1\n        end\n        if carrots[2] > 0\n         \
    \   carrots[2] -= meals[2]\n            meals[2] -= 1\n            carrots_left[2]\
    \ += meals[2]\n            meals[2] -= 1\n        end\n    end\n    \n    return\
    \ carrots_left\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprsr2y6k9.jl:63\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprsr2y6k9.jl:63\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        error(\"\
    Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1]\
    \ = number\n    carrots[2] = need\n    \n    carrots[2] = carrots[2] - carrots[1]\n\
    \    \n    if carrots[2] < 0\n        carrots[2] = 0\n    end\n    \n    if carrots[1]\
    \ > 0\n        carrots[1] = carrots[1] - carrots[2]\n    end\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    return carrots\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5h7fv0qk.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5h7fv0qk.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 \n        error(\"number should be less than 1000\")\n\
    \    else if need > 1000 \n        error(\"need should be less than 1000\")\n\
    \    else if remaining > 1000 \n        error(\"remaining should be less than\
    \ 1000\")\n    else if number == 0 \n        error(\"number should be greater\
    \ than 0\")\n    else if need == 0 \n        error(\"need should be greater than\
    \ 0\")\n    else if remaining == 0 \n        error(\"remaining should be greater\
    \ than 0\")\n    else if number > need \n        error(\"number should be less\
    \ than need\")\n    else if number > remaining \n        error(\"number should\
    \ be less than remaining\")\n    else if number < 0 \n        error(\"number should\
    \ be greater than 0\")\n    else if need < 0 \n        error(\"need should be\
    \ greater than 0\")\n    else if remaining < 0 \n        error(\"remaining should\
    \ be greater than 0\")\n    else if number == need \n        error(\"need should\
    \ be equal to number\")\n    else if number == remaining \n        error(\"remaining\
    \ should be equal to number\")\n    else if number == 0 \n        error(\"number\
    \ should be greater than 0\")\n    else if need == 0 \n        error(\"need should\
    \ be greater than 0\")\n    else if remaining == 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number > need \n        error(\"number\
    \ should be less than need\")\n    else if number > remaining \n        error(\"\
    number should be less than remaining\")\n    else if number < 0 \n        error(\"\
    number should be greater than 0\")\n    else if need < 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining < 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number == need \n        error(\"need\
    \ should be equal to number\")\n    else if number == remaining \n        error(\"\
    remaining should be equal to number\")\n    else if number == 0 \n        error(\"\
    number should be greater than 0\")\n    else if need == 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining == 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number > need \n        error(\"number\
    \ should be less than need\")\n    else if number > remaining \n        error(\"\
    number should be less than remaining\")\n    else if number < 0 \n        error(\"\
    number should be greater than 0\")\n    else if need < 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining < 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number == need \n        error(\"need\
    \ should be equal to number\")\n    else if number == remaining \n        error(\"\
    remaining should be equal to number\")\n    else if number == 0 \n        error(\"\
    number should be greater than 0\")\n    else if need == 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining == 0 \n        error(\"\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa5qhfh_u.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa5qhfh_u.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwc8ooyl0.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwc8ooyl0.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwc8ooyl0.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining\
    \ > 0 && remaining <= 1000\n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc_mn641z.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpc_mn641z.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0\n        error(\"number must be positive\")\n    end\n\
    \    if need <= 0\n        error(\"need must be positive\")\n    end\n    if remaining\
    \ <= 0\n        error(\"remaining must be positive\")\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2n72uuwh.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp2n72uuwh.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp2n72uuwh.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number should be between\
    \ 0 and 1000\")\n    end\n    if need < 0 || need > 1000 \n        error(\"need\
    \ should be between 0 and 1000\")\n    end\n    if remaining < 0 || remaining\
    \ > 1000 \n        error(\"remaining should be between 0 and 1000\")\n    end\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp62g9sba6.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp62g9sba6.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp62g9sba6.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining])\n    elseif\
    \ number == need \n        Vector{Int64}([number, remaining])\n    elseif number\
    \ > need \n        Vector{Int64}([number, remaining])\n    elseif number < need\
    \ \n        Vector{Int64}([need, remaining])\n    elseif remaining == 0\n    \
    \    Vector{Int64}([number, 0])\n    else\n        Vector{Int64}([number, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjaibd9wp.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjaibd9wp.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    You\
    \ have a certain number of carrots, and you know that there are only two kinds\
    \ of carrots:\n    \n    carrots and non-carrots.\n    \n    You want to eat as\
    \ many carrots as possible, without eating non-carrots.\n    \n    You want to\
    \ eat as many non-carrots as possible, without eating carrots.\n    \n    You\
    \ want to eat as many carrots as possible, without eating non-carrots.\n    \n\
    \    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating car\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvlqdungk.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvlqdungk.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots\
    \ > 0 && carrots_left > 0 \n            carrots_left -= 1\n            carrots\
    \ -= 1\n            push!(answer, carrots)\n        end\n        push!(answer,\
    \ carrots)\n        answer\n    else\n        error(\"Invalid input\")\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7: Sum square difference\n\
    You are given an array of integers $x$ and an integer $n$. Your task is to find\
    \ the sum of square differences between each pair of consecutive elements in the\
    \ array. \nThe sum of square differences is the sum of the squares of the differences\
    \ between consecutive elements in the array. \nFor example, if the array is [4,\
    \ 6, 9, 10, 12] and $n=2$, the sum of square differences is $10 + 12 - 9 + 6 +\
    \ 4 = 42$. \nWrite a function that returns the sum of square differences between\
    \ consecutive elements in the array.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpibupt4ca.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpibupt4ca.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([number, need])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function called hungry that takes\
    \ in an array of integers and returns true if the array is hungry, false otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk860uqed.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk860uqed.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else if number ==\
    \ 0 \n        Vector{Int64}([need, remaining])\n    else if number > need \n \
    \       Vector{Int64}([number, need])\n    else if number > remaining \n     \
    \   Vector{Int64}([number, remaining])\n    else \n        Vector{Int64}([number,\
    \ need])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpobgean7e.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpobgean7e.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpadd1_392.jl:32\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpadd1_392.jl:32\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1:2]\n    \n\
    \    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrot\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcffn1131.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpcffn1131.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpcffn1131.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    if number > 0 && need > 0 && remaining > 0 \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnvrufynu.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnvrufynu.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"invalid input\") \n    else \n   \
    \     Vector{Int64}([number, need, remaining]) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp97we_7t0.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp97we_7t0.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        carrots = number\n\
    \        carrots_left = remaining\n        meals = Vector{Int64}()\n        while\
    \ carrots > 0 \n            carrots_left -= 1\n            meals << carrots_left\n\
    \            carrots -= need\n        end\n        return meals\n    else\n  \
    \      return Vector{Int64}()\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 7: Sum square difference\nThe sum of the squares\
    \ of the first ten natural numbers is,\n1^2 + 2^2 + ... + 10^2 = 385\nThe square\
    \ of the sum of the first ten natural numbers is,\n(1 + 2 + ... + 10)^2 = 55^2\
    \ = 3025\nHence the difference between the sum of the squares of the first ten\
    \ natural numbers and the square of the sum is 3025 - 385 = 2640.\nFind the difference\
    \ between the sum of the squares of the first one hundred natural numbers and\
    \ the square of the sum.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm9vgpqxl.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpm9vgpqxl.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = number\n    meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals = zeros(Int64, 2)\n    meals_left_after_meals[1]\
    \ = number\n    meals_left_after_meals[2] = remaining\n    \n    meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left[1] = number\n    meals_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals = zeros(Int64,\
    \ 2)\n    meals_left_after_meals_left_after_meals[1] = number\n    meals_left_after_meals_left_after_meals[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals_left = zeros(Int64,\
    \ 2)\n    meals_left_after_meals_left_after_meals_left[1] = number\n    meals_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    meals_left_after_meals_left_after_meals_left_after_meals[2] =\
    \ remaining\n    \n    meals_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = number\n    meals_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    meals_left_after_me\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8l9ip95t.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp8l9ip95t.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp8l9ip95t.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    if number == 0 && need == 0 && remaining > 0\n\
    \        return Vector{Int64}(remaining, 0)\n    end\n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    if\
    \ number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0, need)\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    if number > 0 && need > 0 && remaining\
    \ == 0\n        return Vector{Int64}(number, need)\n    end\n    if number > 0\
    \ && need > 0 && remaining > 0\n        return Vector{Int64}(number, need)\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    findMeals(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64}\n    \n    You have a certain\
    \ number of carrots, and you know that you will need more carrots to complete\
    \ the day's meals.\n    You want to find out how many carrots you will need in\
    \ order to complete the meals.\n    \n    Variables:\n    @number : integer\n\
    \        the number of carrots that you have eaten.\n    @need : integer\n   \
    \     the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoxib85st.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpoxib85st.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number,\
    \ need-number])\n    end\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n  \
    \  You have a list of meals, and you need to eat as many as you can to finish\
    \ them.\n    \n    Example:\n    * eat([ \"pizza\", \"burger\", \"fries\", \"\
    ice cream\" ], 3) -> [ \"pizza\", \"burger\", \"fries\" ]\n    * eat([ \"pizza\"\
    , \"burger\", \"fries\", \"ice cream\" ], 2) -> [ \"pizza\", \"burger\" ]\n  \
    \  * eat([ \"pizza\", \"burger\", \"fries\", \"ice cream\" ], 1) -> [ \"pizza\"\
    \ ]\n    * eat([ \"pizza\", \"burger\", \"fries\", \"ice cream\" ], 0) -> []\n\
    \    \n    Variables:\n    @meals : Array{String}\n        the meals that you\
    \ have.\n    @number : integer\n        the number of meals that you need to eat.\n\
    \    \n    Constrain:\n    * 0 <= number <= length(meals)\n    * 0 <= number <=\
    \ length(meals)\n    \n    Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa0oymtse.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa0oymtse.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if remaining == 0\n        return Vector{Int64}([number, need])\n\
    \    end\n    \n    carrots = number\n    need = need - carrots\n    remaining\
    \ = remaining - carrots\n    \n    carrots = carrots + eat(number, need, remaining)\n\
    \    \n    return Vector{Int64}([carrots, remaining])\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcmaiw_hu.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcmaiw_hu.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[2]\n    \n    carrots_left = carrots_left\n  \
    \  \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprm9kt94f.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmprm9kt94f.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmprm9kt94f.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    meals = meals[1] + meals[2]\n    \n    carrots = carrots[1] + carrots[2]\n\
    \    \n    carrots = carrots - meals\n    \n    if carrots < 0\n        carrots\
    \ = 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp15ebprb4.jl:54\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp15ebprb4.jl:54\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0 \n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n    meals[1] =\
    \ need\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = carrots_left_after_meals[1]\n    carrots_left_after_meals_after_meals[2] =\
    \ 0\n    \n    carrots_left_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals[1] = carrots_left_after_meals_after_meals[1]\n\
    \    carrots_left_after_meals_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_me\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmdtfwza5.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpmdtfwza5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpmdtfwza5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   if number == 0 && remaining == 0\n        return Vector{Int64}[]\n    end\n\
    \    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n \
    \   end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq3jirbt3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq3jirbt3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        error(\"\
    Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1]\
    \ = number\n    carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp68nzykf8.jl:115\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp68nzykf8.jl:115\n"
  exit_code: 1
  status: Exception
