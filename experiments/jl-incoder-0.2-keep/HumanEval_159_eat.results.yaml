name: HumanEval_159_eat
language: julia
results:
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2]\
    \ = remaining\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1]\
    \ = number\n    carrots_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten[1] = number\n    carrots_left_eaten[2] = remaining\n\
    \    \n    carrots_left_eaten = zeros(Int64, 2)\n    carrots_left_eaten[1] = number\n\
    \    carrots_left_eaten[2] = remaining\n    \n    carrots_left_eaten = zeros(Int64,\
    \ 2)\n    carrots_left_eaten\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkk67mtv6.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkk67mtv6.jl:1\n\
    in expression starting at /tmp/tmpkk67mtv6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([remaining,\
    \ remaining - need])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9p_5ekyb.jl:36\nin expression starting at\
    \ /tmp/tmp9p_5ekyb.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    if need < 0 || need > 1000 \n        error(\"need must be\
    \ between 0 and 1000\")\n    if remaining < 0 || remaining > 1000 \n        error(\"\
    remaining must be between 0 and 1000\")\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpors_hka0.jl:1\nin expression starting at /tmp/tmpors_hka0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return error(\"Invalid\
    \ input\")\n    end\n    if number == 0 && need == 0 && remaining == 0\n     \
    \   return Vector{Int64}()\n    end\n    if number == 0 && need == 0 && remaining\
    \ > 0\n        return Vector{Int64}(remaining)\n    end\n    if number == 0 &&\
    \ need > 0 && remaining == 0\n        return Vector{Int64}()\n    end\n    if\
    \ number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}()\n \
    \   end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    if number > 0 && need > 0 && remaining\
    \ == 0\n        return Vector{Int64}(need, 0)\n    end\n    if number > 0 && need\
    \ > 0 && remaining > 0\n        return Vector{Int64}(need, 0)\n    end\n    if\
    \ number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ need)\n    end\n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(number, need)\n    end\n    if number > 0 && need > 0 && remaining\
    \ == 0\n        return Vector{Int64}(need, number)\n    end\n    if number > 0\
    \ && need > 0 && remaining > 0\n        return Vector{Int64}(need, number)\n \
    \   end\n    return error(\"Invalid input\")\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpih2u7bi6.jl:71\nin expression starting at\
    \ /tmp/tmpih2u7bi6.jl:71\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number-need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after your\
    \ meals.\nIf there are not enough carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\nThe function should take two arguments:\n@number\
    \ : integer\n    the number of carrots that you have eaten.\n@need : integer\n\
    \    the number of carrots that you need to eat.\nThe function should return an\
    \ array of two integers:\n@left : integer\n    the number of carrots left after\
    \ your meals.\n@remaining : integer\n    the number of remaining carrots thet\
    \ exist in stock\nVariables:\n@number : integer\n    the number of carrots that\
    \ you have eaten.\n@need : integer\n    the number of carrots that you need to\
    \ eat.\n@remaining : integer\n    the number of remaining carrots thet exist in\
    \ stock\nConstraints:\n0 <= number <= 1000\n0 <= need <= 1000\n0 <= remaining\
    \ <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsqb4nzfe.jl:36\nin expression starting at\
    \ /tmp/tmpsqb4nzfe.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots\
    \ > 0 \n            carrots_left -= 1\n            carrots -= 1\n            push!(answer,\
    \ carrots)\n        end\n        push!(answer, carrots_left)\n        return answer\n\
    \    else\n        return [0, 0]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange a collection of n integers such that the sum of the integers\
    \ is exactly k.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz0u_k_w7.jl:45\nin expression starting at\
    \ /tmp/tmpz0u_k_w7.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots_left\
    \ > 0 && carrots > 0\n            carrots_left -= 1\n            carrots -= 1\n\
    \            push!(answer, carrots)\n        end\n        \n        push!(answer,\
    \ carrots)\n        \n        return answer\n    else\n        return nothing\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function called hungry that takes two integers representing\
    \ a number of carrots left and number of carrots eaten, and returns true if there\
    \ are enough carrots left and enough carrots eaten. Otherwise, return false.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_6sviz7s.jl:47\nin expression starting at\
    \ /tmp/tmp_6sviz7s.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjk25_1t6.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjk25_1t6.jl:1\n\
    in expression starting at /tmp/tmpjk25_1t6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  answer = []\n        if number == 0\n            answer[1] = remaining\n  \
    \      else\n            answer[1] = number\n            answer[2] = need\n  \
    \          answer[3] = remaining\n        end\n        answer\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp330wb8ar.jl:44\nin expression starting at\
    \ /tmp/tmp330wb8ar.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    if number == 0\n        return [need, remaining]\n    end\n  \
    \  if remaining < need\n        error(\"not enough carrots to eat\")\n    end\n\
    \    \n    carrots = zeros(Int64, 2)\n    carrots[1] = remaining\n    carrots[2]\
    \ = need\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrot\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7ngnasph.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7ngnasph.jl:1\n\
    in expression starting at /tmp/tmp7ngnasph.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > remaining \n        number = remaining\n    end\n    if need\
    \ > remaining \n        need = remaining\n    end\n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_8l2r_fn.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_8l2r_fn.jl:1\n\
    in expression starting at /tmp/tmp_8l2r_fn.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number,\
    \ need])\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwuz3y6ss.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [5, 6] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwuz3y6ss.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwuz3y6ss.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwuz3y6ss.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [4, 8] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwuz3y6ss.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwuz3y6ss.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwuz3y6ss.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [1, 10] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwuz3y6ss.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwuz3y6ss.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwuz3y6ss.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [2, 11] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwuz3y6ss.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwuz3y6ss.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwuz3y6ss.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [4, 5] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwuz3y6ss.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        local carrots = number\n\
    \        local carrots_left = remaining\n        local meals = 0\n        local\
    \ meals_left = 0\n        while carrots > 0 && meals_left > 0 \n            carrots_left\
    \ = carrots_left - 1\n            meals_left = meals_left - 1\n            meals\
    \ = meals + 1\n        end\n        \n        if carrots_left == 0\n         \
    \   carrots = number\n        else\n            carrots = carrots - meals\n  \
    \      end\n        \n        return [meals, carrots_left]\n    end\n    return\
    \ [0, 0]\nend\n</cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of cards.\nThe cards are represented as an array of integers representing\
    \ the ranks of the cards, and the number of cards left over for each rank. \n\
    The function should return an array of integers representing the number of ways\
    \ to arrange the cards.\nThe function should return an array of integers representing\
    \ the number of ways to arrange the cards.\nThe function should return an array\
    \ of integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the number of ways to arrange\
    \ the cards.\nThe function should return an array of integers representing the\
    \ number of ways to arrange the cards.\nThe function should return an array of\
    \ integers representing the number of ways to arrange the cards.\nThe function\
    \ should return an array of integers representing the \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbhaosn2g.jl:51\nin expression starting at\
    \ /tmp/tmpbhaosn2g.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    if number == 0\n        return [need, remaining]\n    end\n\
    \    \n    if remaining < need\n        return [number, 0]\n    end\n    \n  \
    \  if number > remaining\n        return [need, 0]\n    end\n    \n    if number\
    \ == remaining\n        return [need, 0]\n    end\n    \n    return [number, need]\n\
    end\n</cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways you can reach a target number from any given\
    \ starting number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpewoojylz.jl:52\nin expression starting at\
    \ /tmp/tmpewoojylz.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   meals = zeros(Int64, 2)\n    meals[1] = number\n    meals[2] = need\n    \n\
    \    carrots = zeros(Int64, 2)\n    carrots[1] = remaining\n    \n    meals_left\
    \ = zeros(Int64, 2)\n    meals_left[1] = remaining\n    \n    meals_left_carrots\
    \ = zeros(Int64, 2)\n    meals_left_carrots[1] = remaining\n    \n    meals_left_carrots_left\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left[1] = remaining\n    \n    meals_left_carrots_left_carrots\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots[1] = remaining\n    \n\
    \    meals_left_carrots_left_carrots_left = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left[1]\
    \ = remaining\n    \n    meals_left_carrots_left_carrots_left_carrots = zeros(Int64,\
    \ 2)\n    meals_left_carrots_left_carrots_left_carrots[1] = remaining\n    \n\
    \    meals_left_carrots_left_carrots_left_carrots_left = zeros(Int64, 2)\n   \
    \ meals_left_carrots_left_carrots_left_carrots_left[1] = remaining\n    \n   \
    \ meals_left_carrots_left_carrots_left_carrots_left_carrots = zeros(Int64, 2)\n\
    \    meals_left_carrots_left_carrots_left_carrots_left_carrots[1] = remaining\n\
    \    \n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left = zeros(Int64,\
    \ 2)\n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left[1] =\
    \ remaining\n    \n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots[1]\
    \ = remaining\n    \n    meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left_carrots_left_\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpza5xb7t0.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpza5xb7t0.jl:1\n\
    in expression starting at /tmp/tmpza5xb7t0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf4bx6twe.jl:1\nin expression starting at /tmp/tmpf4bx6twe.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpotf8asbo.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpotf8asbo.jl:1\n\
    in expression starting at /tmp/tmpotf8asbo.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 \n        error(\"number should be less than 1000\")\n\
    \    else if need > 1000 \n        error(\"need should be less than 1000\")\n\
    \    else if remaining > 1000 \n        error(\"remaining should be less than\
    \ 1000\")\n    else if number < need \n        error(\"number should be greater\
    \ than need\")\n    else if number == need \n        Vector{Int64}([number, 0])\n\
    \    else if number > remaining \n        error(\"number should be greater than\
    \ remaining\")\n    else if number == remaining \n        Vector{Int64}([number,\
    \ 0])\n    else \n        Vector{Int64}([number, need-number])\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    You have a number of carrots, and you know\
    \ that there are a certain number of carrots left\n    in stock. You need to eat\
    \ as many carrots as you can, but you only have one meal left\n    to eat. You\
    \ are hungry if you eat all the carrots left, but you still have some carrots\
    \ left\n    in stock. You are hungry if you eat all the carrots left, but you\
    \ still have some carrots left\n    in stock. You are hungry if you eat all the\
    \ carrots left, but you still have some carrots left\n    in stock. You are hungry\
    \ if you eat all the carrots left, but you still have some carrots left\n    in\
    \ stock. You are hungry if you eat all the carrots left, but you still have some\
    \ carrots left\n    in stock. You are hungry if you eat all the carrots left,\
    \ but you still have some carrots left\n    in stock. You are hungry if you eat\
    \ all the carrots left, but you still have some carrots left\n    in stock. You\
    \ are hungry if you eat all the carrots left, but you still have some carrots\
    \ left\n    in stock. You are hungry if you eat all the carrots left, but you\
    \ still have some carrots left\n    in stock. You are hungry if you eat all the\
    \ carrots left, but you still have some carrots left\n    in stock. You are hungry\
    \ if you eat all the carrots left, but you still have some carrots left\n    in\
    \ stock. You are hungry if you eat all the carrots left, but you still have some\
    \ carrots left\n    in stock. You are hungry if you \nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqocaynjj.jl:32\nin expression starting at\
    \ /tmp/tmpqocaynjj.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining == 0\n        return Vector{Int64}([number, need])\n    end\n\
    \    \n    if number > remaining\n        return Vector{Int64}([number, need])\n\
    \    end\n    \n    if need == 0\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    \n    if number > need\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    \n    return Vector{Int64}([number, need])\nend\n</cell>\n<code\
    \ language=julia-1.3>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.3>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.3>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.3>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nProblem 7: Sum square difference\nThe sum of the\
    \ squares of the first ten natural numbers is,\n1^2 + 2^2 + ... + 10^2 = 385\n\
    The square of the sum of the first ten natural numbers is,\n(1 + 2 + ... + 10)^2\
    \ = 55^2 = 3025\nHence the difference between the sum of the squares of the first\
    \ ten natural numbers and the square of the sum is 3025 - 385 = 2640.\nFind the\
    \ difference between the sum of the squares of the first one hundred natural numbers\
    \ and the square of the sum.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbm5ifryo.jl:53\nin expression starting at\
    \ /tmp/tmpbm5ifryo.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    if number < 0 || need < 0 || remaining < 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz5v2roqi.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz5v2roqi.jl:1\n\
    in expression starting at /tmp/tmpz5v2roqi.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < 0\n  \
    \      Vector{Int64}()\n    elseif remaining == 0\n        Vector{Int64}([need])\n\
    \    elseif remaining < need\n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\n    You have a certain number of carrots, and you know that there are\
    \ only two types of carrots:\n    \n    carrots and vegetables.\n    \n    You\
    \ want to eat as many carrots as possible, but you only have one type of carrots.\n\
    \    \n    You want to eat as many vegetables as possible, but you only have one\
    \ type of vegetables.\n    \n    You want to eat as many carrots and vegetables\
    \ as possible, but you only have one type of carrots and one type of vegetables.\n\
    \    \n    You want to eat as many carrots and vegetables as possible, but you\
    \ only have one type of carrots and one type of vegetables.\n    \n    You want\
    \ to eat as many carrots and vegetables as possible, but you only have one type\
    \ of carrots and one type of vegetables.\n    \n    You want to eat as many carrots\
    \ and vegetables as possible, but you only have one type of carrots and one type\
    \ of vegetables.\n    \n    You want to eat as many carrots and vegetables as\
    \ possible, but you only have one type of carrots and one type of vegetables.\n\
    \    \n    You want to eat as many carrots and vegetables as possible, but you\
    \ only have one type of carrots and one type of vegetables.\n    \n    You want\
    \ to eat as many carrots and vegetables as possible, but you only have one type\
    \ of carrots and one type of vegetables.\n    \n    You want to eat as many carrots\
    \ and vegetables as possible, but you only have one type of carrots and one type\
    \ of vegetables.\n    \n    You want to eat as many carrots and vegetables as\
    \ possible, but you only have one type of carrots and one type of vegetables.\n\
    \    \n    You want to eat as many carrots and vegetables as possible, but you\
    \ only have one type of carrots and one type of vegetables.\n    \n    You want\
    \ to eat as many carrot\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxthfl9bk.jl:42\nin expression starting at\
    \ /tmp/tmpxthfl9bk.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([remaining,\
    \ remaining - number])\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaz66jx30.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 5] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaz66jx30.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaz66jx30.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpaz66jx30.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 5] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaz66jx30.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaz66jx30.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpaz66jx30.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 9] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpaz66jx30.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaz66jx30.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpaz66jx30.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 3] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaz66jx30.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaz66jx30.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpaz66jx30.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 3] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaz66jx30.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbxn8l_ho.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbxn8l_ho.jl:1\n\
    in expression starting at /tmp/tmpbxn8l_ho.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    \n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    if number == 0 && need == 0 && remaining\
    \ > 0\n        return Vector{Int64}([need, remaining])\n    end\n    \n    if\
    \ number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\n    \n    if number == 0 && need > 0 && remaining > 0\n\
    \        return Vector{Int64}([need, remaining])\n    end\n    \n    if number\
    \ > 0 && need == 0 && remaining == 0\n        return Vector{Int64}([number, 0])\n\
    \    end\n    \n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}([number, 0])\n    end\n    \n    if number > 0 && need > 0 &&\
    \ remaining == 0\n        return Vector{Int64}([number, 0])\n    end\n    \n \
    \   if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}([number,\
    \ 0])\n    end\n    \n    if number > 0 && need == 0 && remaining == 0\n     \
    \   return Vector{Int64}([number, 0])\n    end\n    \n    if number > 0 && need\
    \ == 0 && remaining > 0\n        return Vector{Int64}([number, 0])\n    end\n\
    \    \n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}([number,\
    \ 0])\n    end\n    \n    if number > 0 && need > 0 && remaining > 0\n       \
    \ return Vector{Int64}([number, 0])\n    end\n    \n    return Vector{Int64}()\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbuetdfsp.jl:85\nin expression starting at\
    \ /tmp/tmpbuetdfsp.jl:85\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    # Your code here\n    \n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # run your function with the example inputs\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange n integers\
    \ in ascending order without duplicates.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn0ty3bn7.jl:36\nin expression starting at\
    \ /tmp/tmpn0ty3bn7.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzm5thy_1.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzm5thy_1.jl:1\n\
    in expression starting at /tmp/tmpzm5thy_1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number == need\n \
    \       Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([number,\
    \ need])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after a meal\
    \ is complete.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv8n4t2nz.jl:38\nin expression starting at\
    \ /tmp/tmpv8n4t2nz.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkc8grqve.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkc8grqve.jl:1\n\
    in expression starting at /tmp/tmpkc8grqve.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdwf7_sy3.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdwf7_sy3.jl:1\n\
    in expression starting at /tmp/tmpdwf7_sy3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > need || number < 0 || remaining < 0 || remaining > 1000 ||\
    \ number > remaining\n        return Vector{Int64}()\n    end\n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp421_8vf6.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp421_8vf6.jl:1\n\
    in expression starting at /tmp/tmp421_8vf6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpolep6d4b.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpolep6d4b.jl:1\n\
    in expression starting at /tmp/tmpolep6d4b.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n   \
    \ carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n    if carrots[1]\
    \ > 0\n        carrots[1] -= carrots[2]\n        carrots[2] = 0\n    end\n   \
    \ \n    if carrots[1] == 0\n        carrots[1] = remaining\n        carrots[2]\
    \ = 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps9s_lcr7.jl:52\nin expression starting at\
    \ /tmp/tmps9s_lcr7.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = number\n    meals_left[2]\
    \ = remaining\n    \n    meals_left_left = zeros(Int64, 2)\n    meals_left_left[1]\
    \ = number\n    meals_left_left[2] = remaining\n    \n    meals_left_right = zeros(Int64,\
    \ 2)\n    meals_left_right[1] = number\n    meals_left_right[2] = remaining\n\
    \    \n    meals_right = zeros(Int64, 2)\n    meals_right[1] = number\n    meals_right[2]\
    \ = remaining\n    \n    meals_right_left = zeros(Int64, 2)\n    meals_right_left[1]\
    \ = number\n    meals_right_left[2] = remaining\n    \n    meals_right_right =\
    \ zeros(Int64, 2)\n    meals_right_right[1] = number\n    meals_right_right[2]\
    \ = remaining\n    \n    meals_left_left_left = zeros(Int64, 2)\n    meals_left_left_left[1]\
    \ = number\n    meals_left_left_left[2] = remaining\n    \n    meals_left_left_right\
    \ = zeros(Int64, 2)\n    meals_left_left_right[1] = number\n    meals_left_left_right[2]\
    \ = remaining\n    \n    meals_left_right_left = zeros(Int64, 2)\n    meals_left_right_left[1]\
    \ = number\n    meals_left_right_left[2] = remaining\n    \n    meals_left_right_right\
    \ = zeros(Int64, 2)\n    meals_left_right_right[1] = number\n    meals_left_right_right[2]\
    \ = remaining\n    \n    meals_right_left_left = zeros(Int64, 2)\n    meals_right_left_left[1]\
    \ = number\n    meals_right_left_left[2] = remaining\n    \n    meals_right_left_right\
    \ = zeros(Int64, 2)\n    meals_right_left_right[1] = number\n    meals_right_left_right[2]\
    \ = remaining\n    \n    meals_right_right_left = zeros(Int64, 2)\n    meals_right_right_left[1]\
    \ = number\n    meals_right_right_left[2] = remaining\n    \n    meals_right_right_right\
    \ = zeros(Int64, 2)\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8ytjzhze.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8ytjzhze.jl:1\n\
    in expression starting at /tmp/tmp8ytjzhze.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    if need < 0 || need > 1000 \n        error(\"need must be\
    \ between 0 and 1000\")\n    if remaining < 0 || remaining > 1000 \n        error(\"\
    remaining must be between 0 and 1000\")\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrot\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbgl4zp4v.jl:1\nin expression starting at /tmp/tmpbgl4zp4v.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    need = need\n    remaining = remaining\n\
    \    \n    carrots_left = number\n    \n    while carrots_left > 0 && need > 0\
    \ && remaining > 0\n        if carrots_left >= remaining\n            carrots_left\
    \ -= remaining\n            need -= 1\n            remaining -= 1\n        else\n\
    \            carrots_left -= 1\n            need -= 1\n            remaining -=\
    \ 1\n        end\n    end\n    \n    if carrots_left == 0\n        carrots = remaining\n\
    \    end\n    \n    return Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n\
    <code language=julia-1.5>\n# Test your code\n@test eat(5, 6, 10) == [11, 4]\n\
    @test eat(4, 8, 9) == [12, 1]\n@test eat(1, 10, 10) == [11, 0]\n@test eat(2, 11,\
    \ 5) == [7, 0]\n</cell>\n<text>\nProblem 8\nWrite a function that returns the\
    \ number of prime numbers less than a given integer $n$ (where $n$ is also a positive\
    \ integer). You may wish to use the Sieve of Eratosthenes or the Sieve of Atkin's\
    \ algorithm (which was the first time I heard of either one).\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp40ml26bf.jl:58\nin expression starting at\
    \ /tmp/tmp40ml26bf.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # run your function with the example inputs to see what it does\neat(5, 6, 10)\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns the number of carrots\
    \ left after eating a certain number of carrots.\nThe function should take in\
    \ two integer arguments: the number of carrots you have eaten and the number of\
    \ carrots left after your meals.\nThe function should return an array of two integers,\
    \ the first integer is the number of carrots left after your meals, and the second\
    \ integer is the total number of carrots you have eaten.\nIf there are not enough\
    \ carrots left after your meals, you will eat all remaining carrots, but will\
    \ still be hungry.\nIf there are not enough carrots left after your meals, you\
    \ will eat all remaining carrots, but will still be hungry.\nIf there are not\
    \ enough carrots left after your meals, you will eat all remaining carrots, but\
    \ will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after your meals,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after your meals, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrot\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjm9h9b50.jl:34\nin expression starting at\
    \ /tmp/tmpjm9h9b50.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwynys0r4.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwynys0r4.jl:1\n\
    in expression starting at /tmp/tmpwynys0r4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0\n        error(\"number must be positive\")\n    end\n\
    \    if need <= 0\n        error(\"need must be positive\")\n    end\n    if remaining\
    \ <= 0\n        error(\"remaining must be positive\")\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmihfpck7.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmihfpck7.jl:1\n\
    in expression starting at /tmp/tmpmihfpck7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining]) \n    else \n\
    \        Vector{Int64}([need, number-remaining]) \n    end\nend\n</cell>\n<code\
    \ language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<code language=julia-0.6>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-0.6>\neat(1, 10, 10)\n</cell>\n<code language=julia-0.6>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-0.6>\neat(10, 10, 10)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the number of carrots left after\
    \ a meal is complete.\nIf there are not enough carrots left after a meal, you\
    \ should eat all remaining carrots.\nIf there are not enough carrots left after\
    \ a meal, you should eat all remaining carrots.\nIf there are not enough carrots\
    \ left after a meal, you should eat all remaining carrots.\nIf there are not enough\
    \ carrots left after a meal, you should eat all remaining carrots.\nIf there are\
    \ not enough carrots left after a meal, you should eat all remaining carrots.\n\
    If there are not enough carrots left after a meal, you should eat all remaining\
    \ carrots.\nIf there are not enough carrots left after a meal, you should eat\
    \ all remaining carrots.\nIf there are not enough carrots left after a meal, you\
    \ should eat all remaining carrots.\nIf there are not enough carrots left after\
    \ a meal, you should eat all remaining carrots.\nIf there are not enough carrots\
    \ left after a meal, you should eat all remaining carrots.\nIf there are not enough\
    \ carrots left after a meal, you should eat all remaining carrots.\nIf there are\
    \ not enough carrots left after a meal, you should eat all remaining carrots.\n\
    If there are not enough carrots left after a meal, you should eat all remaining\
    \ carrots.\nIf there are not enough carrots left after a meal, you should eat\
    \ all remaining carrots.\nIf there are not enough carrots left after a meal, you\
    \ should eat all remaining carrots.\nIf there are not enough carrots left after\
    \ a meal, you should eat all remaining carrots.\nIf there are not enough carrots\
    \ left after a meal, you should eat all remaining carrots.\nIf there are not enough\
    \ carrots left after a me\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfndwlktl.jl:36\nin expression starting at\
    \ /tmp/tmpfndwlktl.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjrp5d56i.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpjrp5d56i.jl:1\n\
    in expression starting at /tmp/tmpjrp5d56i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0\n        error(\"number must be positive\")\n    end\n\
    \    if need <= 0\n        error(\"need must be positive\")\n    end\n    if remaining\
    \ <= 0\n        error(\"remaining must be positive\")\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc6hjqs2g.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc6hjqs2g.jl:1\n\
    in expression starting at /tmp/tmpc6hjqs2g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return Vector{Int64}()\n    \n    if remaining\
    \ < need\n        return Vector{Int64}()\n    \n    carrots = number\n    \n \
    \   carrots = carrots - need\n    \n    if carrots < 0\n        carrots = 0\n\
    \    end\n    \n    return Vector{Int64}(carrots, remaining)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqh0gf_9o.jl:46\nin expression starting at\
    \ /tmp/tmpqh0gf_9o.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpaznurnfs.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpaznurnfs.jl:1\n\
    in expression starting at /tmp/tmpaznurnfs.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if number == 0 && remaining == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2]\
    \ = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = number\n    meals[2]\
    \ = remaining\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] =\
    \ remaining\n    carrots_left[2] = need\n    \n    meals_left = zeros(Int64, 2)\n\
    \    meals_left[1] = remaining\n    meals_left[2] = number\n    \n    carrots_left_meals\
    \ = zeros(Int64, 2)\n    carrots_left_meals[1] = remaining\n    carrots_left_meals[2]\
    \ = number\n    \n    meals_left_carrots = zeros(Int64, 2)\n    meals_left_carrots[1]\
    \ = number\n    meals_left_carrots[2] = remaining\n    \n    carrots_left_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_meals_left[1] = remaining\n    carrots_left_meals_left[2]\
    \ = number\n    \n    meals_left_carrots_left = zeros(Int64, 2)\n    meals_left_carrots_left[1]\
    \ = number\n    meals_left_carrots_left[2] = remaining\n    \n    carrots_left_meals_left_meals\
    \ = zeros(Int64, 2)\n    carrots_left_meals_left_meals[1] = remaining\n    carrots_left_meals_left_meals[2]\
    \ = number\n    \n    meals_left_carrots_left_carrots = zeros(Int64, 2)\n    meals_left_carrots_left_carrots[1]\
    \ = number\n    meals_left_carrots_left_carrots[2] = remaining\n    \n    carrots_left_meals_left_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_meals_left_meals_left[1] = remaining\n \
    \   carrots_left_meals_left_meals_left[2] = number\n    \n    meals_left_carrots_left_carrots_left\
    \ = zeros(Int64, 2)\n    meals_left_carrots_left_carrots_left[1] = number\n  \
    \  meals_left_carrots_left_carrots_left[2] = remaining\n    \n    carrots_left_meals_left_meal\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdzs8y_94.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdzs8y_94.jl:1\n\
    in expression starting at /tmp/tmpdzs8y_94.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpas4igo_t.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpas4igo_t.jl:1\n\
    in expression starting at /tmp/tmpas4igo_t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    # Test your code\n@assert eat(5, 6, 10) == [11, 4]\n@assert eat(4, 8, 9) == [12,\
    \ 1]\n@assert eat(1, 10, 10) == [11, 0]\n@assert eat(2, 11, 5) == [7, 0]\n</cell>\n\
    <text>\nProblem 3\nWrite a function that takes in an array of integers and returns\
    \ true if there are two numbers whose sum is equal to the given number. For example,\
    \ the following array should return true:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr14ky7vi.jl:36\nin expression starting at\
    \ /tmp/tmpr14ky7vi.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of days left until Christmas.\nThe Christmas day is the last day of every month\
    \ that is at least 4 days long.\nIf Christmas falls on a weekend, return that\
    \ week's number of days.\nIf Christmas falls on a Saturday, return that Saturday's\
    \ number of days.\nIf Christmas falls on a Friday, return that Friday's number\
    \ of days.\nIf Christmas falls on a Thursday, return that Thursday's number of\
    \ days.\nIf Christmas falls on a Wednesday, return that Wednesday's number of\
    \ days.\nIf Christmas falls on a Tuesday, return that Tuesday's number of days.\n\
    If Christmas falls on a Monday, return that Monday's number of days.\nIf Christmas\
    \ falls on a Sunday, return that Sunday's number of days.\nIf Christmas falls\
    \ on a Friday or Saturday, return that Friday's number of days.\nIf Christmas\
    \ falls on a Thursday or Sunday, return that Thursday's number of days.\nIf Christmas\
    \ falls on a Wednesday or Monday, return that Wednesday's number of days.\nIf\
    \ Christmas falls on a Tuesday or Wednesday, return that Tuesday's number of days.\n\
    If Christmas falls on a Tuesday or Thursday, return that Tuesday's number of days.\n\
    If Christmas falls on a Tuesday or Friday, return that Tuesday's number of days.\n\
    If Christmas falls on a Tuesday or Saturday, return that Tuesday's number of days.\n\
    If Christmas falls on a Wednesday or Thursday, return that Wednesday's number\
    \ of days.\nIf Christmas falls on a Wednesday or Friday, return that Wednesday's\
    \ number of days.\nIf Christmas falls on a Wednesday or Saturday, return that\
    \ Wednesday's number of days.\nIf Christmas falls on a Thurs\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2_v0_z6c.jl:37\nin expression starting at\
    \ /tmp/tmp2_v0_z6c.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpd4xuoedh.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpd4xuoedh.jl:1\n\
    in expression starting at /tmp/tmpd4xuoedh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        return Vector{Int64}(undef,\
    \ 0)\n    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n\
    \    while carrots_left > 0\n        carrots_left -= 1\n        carrots += need\n\
    \    end\n    \n    return Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of times a given word appears in a given string.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptft5u70g.jl:44\nin expression starting at\
    \ /tmp/tmptft5u70g.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4tny_n0p.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4tny_n0p.jl:1\n\
    in expression starting at /tmp/tmp4tny_n0p.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number > 1000 || need > 1000 || remaining > 1000\n        return\
    \ Vector{Int64}()\n    end\n    \n    carrots = Vector{Int64}()\n    \n    carrots\
    \ = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n\
    \    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    carrots = carrots\n    \n    carrots =\
    \ carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n    \n  \
    \  carrots = carrots\n    \n    carrots = carrots\n    \n    carrots = carrots\n\
    \    \n    carrots = carrots\n    \n    car\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnp35uff8.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnp35uff8.jl:1\n\
    in expression starting at /tmp/tmpnp35uff8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots_left = number - need\n    carrots_eaten = need - remaining\n    \n \
    \   if carrots_left == 0\n        return Vector{Int64}(carrots_eaten, remaining)\n\
    \    else\n        return Vector{Int64}(carrots_eaten, carrots_left)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppc790b54.jl:43\nin expression starting at\
    \ /tmp/tmppc790b54.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif number == need\n        Vector{Int64}([number,\
    \ 0])\n    else\n        Vector{Int64}([number, need-number])\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    You have a certain number of carrots,\
    \ and you know that you have eaten a certain number of carrots.\n    You now need\
    \ to eat some more carrots to complete the day's meals.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6cze8sb4.jl:48\nin expression starting at\
    \ /tmp/tmp6cze8sb4.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    if number == 0\n        return Vector{Int64}([need, remaining])\n\
    \    end\n    if remaining == 0\n        return Vector{Int64}([number, 0])\n \
    \   end\n    if number > remaining\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    return Vector{Int64}([number, remaining - number])\nend\n</cell>\n\
    <code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ called hungry_rabbit that takes two integers representing a person's age, and\
    \ a person's hungry status (true or false). It should return true if the person\
    \ is hungry, and false otherwise.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt7fqaslj.jl:44\nin expression starting at\
    \ /tmp/tmpt7fqaslj.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([remaining,\
    \ remaining - need])\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of times a given value appears\
    \ in a given array.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphhucyuhs.jl:36\nin expression starting at\
    \ /tmp/tmphhucyuhs.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining < need\n        return Vector{Int64}()\n    end\n    \n    if\
    \ number < need\n        return Vector{Int64}([number, need])\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpomvdg11j.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpomvdg11j.jl:1\n\
    in expression starting at /tmp/tmpomvdg11j.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots[2] = remaining - carrots[2]\n    \n\
    \    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after a meal.\n\
    The function should take 3 arguments: number of carrots eaten, number of carrots\
    \ left after meal, and number of carrots left after meal (again).\nThe function\
    \ should return an array of two elements: number of carrots left after meal, and\
    \ number of carrots left after meal (again).\nThe function should return an array\
    \ of two elements: number of carrots left after meal, and number of carrots left\
    \ after meal (again).\nThe function should return an array of two elements: number\
    \ of carrots left after meal, and number of carrots left after meal (again).\n\
    The function should return an array of two elements: number of carrots left after\
    \ meal, and number of carrots left after meal (again).\nThe function should return\
    \ an array of two elements: number of carrots left after meal, and number of carrots\
    \ left after meal (again).\nThe function should return an array of two elements:\
    \ number of carrots left after meal, and number of carrots left after meal (again).\n\
    The function should return an array of two elements: number of carrots left after\
    \ meal, and number of carrots left after meal (again).\nThe function should return\
    \ an array of two elements: number of carrots left after meal, and number of carrots\
    \ left after meal (again).\nThe function should return an array of two elements:\
    \ number of carrots left after meal, and number of carrots left after meal (again).\n\
    The function should return an array of two elements: number of carrots left after\
    \ meal, and number of carrots left after meal (again).\nThe function should return\
    \ an array of two elements: number of carrots left after meal, and number of carrots\
    \ left after meal (again).\nThe function should return an array of two element\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2e26ds6w.jl:42\nin expression starting at\
    \ /tmp/tmp2e26ds6w.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else\n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpao1iiwn3.jl:32\nin expression starting at\
    \ /tmp/tmpao1iiwn3.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfhidw9i2.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfhidw9i2.jl:1\n\
    in expression starting at /tmp/tmpfhidw9i2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = remaining\n    \n    meals = Vector{Int64}()\n\
    \    \n    while carrots_left > 0\n        meals = meals + 1\n        carrots_left\
    \ = carrots_left - need\n    end\n    \n    return meals, carrots - meals\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways you can reach a certain sum from any given number\
    \ in a given number of steps.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaz0cwqy8.jl:46\nin expression starting at\
    \ /tmp/tmpaz0cwqy8.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots\
    \ > 0 && carrots_left > 0 \n            carrots_left -= 1\n            carrots\
    \ -= 1\n            push!(answer, carrots)\n        end\n        return answer\n\
    \    else\n        return [0, 0]\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 4\nWrite a function that takes in an array\
    \ of integers and returns the number of positive integers that are less than or\
    \ equal to each other.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpksiovlbf.jl:44\nin expression starting at\
    \ /tmp/tmpksiovlbf.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of days until a rabbit eats another rabbit.\nThe rabbit eats another rabbit\
    \ if and only if it has eaten at least 1 carrot in the last 7 days.\nThe rabbit\
    \ eats another rabbit if and only if it has eaten at least 2 carrots in the last\
    \ 7 days.\nThe rabbit eats another rabbit if and only if it has eaten at least\
    \ 3 carrots in the last 7 days.\nThe rabbit eats another rabbit if and only if\
    \ it has eaten at least 4 carrots in the last 7 days.\nThe rabbit eats another\
    \ rabbit if and only if it has eaten at least 5 carrots in the last 7 days.\n\
    The rabbit eats another rabbit if and only if it has eaten at least 6 carrots\
    \ in the last 7 days.\nThe rabbit eats another rabbit if and only if it has eaten\
    \ at least 7 carrots in the last 7 days.\nThe rabbit eats another rabbit if and\
    \ only if it has eaten at least 8 carrots in the last 7 days.\nThe rabbit eats\
    \ another rabbit if and only if it has eaten at least 9 carrots in the last 7\
    \ days.\nThe rabbit eats another rabbit if and only if it has eaten at least 10\
    \ carrots in the last 7 days.\nThe rabbit eats another rabbit if and only if it\
    \ has eaten at least 11 carrots in the last 7 days.\nThe rabbit eats another rabbit\
    \ if and only if it has eaten at least 12 carrots in the last 7 days.\nThe rabbit\
    \ eats another rabbit if and only if it has eaten at least 13 carrots in the last\
    \ 7 days.\nThe rabbit eats another rabbit if and only if it has eaten at least\
    \ 14 carrots in the \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx4f62ex9.jl:36\nin expression starting at\
    \ /tmp/tmpx4f62ex9.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\n\
    # Run this cell to check your answer\n@assert eat(5, 6, 10) == [11, 4]\n@assert\
    \ eat(4, 8, 9) == [12, 1]\n@assert eat(1, 10, 10) == [11, 0]\n@assert eat(2, 11,\
    \ 5) == [7, 0]\n</cell>\n<text>\nPart B\nNow that you've seen how to use @assert\
    \ to check your code, let's see if you can solve the problem using Julia's built-in\
    \ assert function.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4c5xappz.jl:34\nin expression starting at\
    \ /tmp/tmp4c5xappz.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n   \
    \ carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n    if carrots[1]\
    \ > 0\n        carrots[1] = carrots[1] - carrots[2]\n        carrots[2] = 0\n\
    \    end\n    \n    if carrots[1] == 0\n        carrots[1] = remaining\n    end\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 1)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 2)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 3)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 4)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 6)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 7)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 8)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 9)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 11)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 12)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 13)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 14)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 15)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 16)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 17)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 18)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 19)\n\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgtsp924u.jl:51\nin expression starting at\
    \ /tmp/tmpgtsp924u.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number-need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    You\
    \ have a certain number of carrots, and you know that you need to eat some carrots\
    \ to complete the day's meals.\n    You want to know how many carrots you will\
    \ need to eat to complete the day's meals.\n    \n    Example:\n    * meals(5,\
    \ 6, 10) -> [11, 4]\n    * meals(4, 8, 9) -> [12, 1]\n    * meals(1, 10, 10) ->\
    \ [11, 0]\n    * meals(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprl4_pq3b.jl:36\nin expression starting at\
    \ /tmp/tmprl4_pq3b.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjfptgubn.jl:36\nin expression starting at\
    \ /tmp/tmpjfptgubn.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n   \
    \ while carrots > 0\n        if carrots_left <= 0\n            carrots_left =\
    \ remaining\n            carrots = number\n        else\n            carrots_left\
    \ -= 1\n        end\n    end\n    \n    return Vector{Int64}(carrots, carrots_left)\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways to arrange n integers in an array, such that\
    \ the total sum is exactly k.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd51a1b99.jl:48\nin expression starting at\
    \ /tmp/tmpd51a1b99.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    # Your code here\n    \n    return Vector{Int64}([number,\
    \ need-number])\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7: Meet and Greet\nYou are a hungry rabbit who has decided to eat some\
    \ carrots. You want to greet everyone in the rabbit who has eaten carrots. You\
    \ will greet everyone in the rabbit who has eaten carrots at least once.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5ly6gmjg.jl:36\nin expression starting at\
    \ /tmp/tmp5ly6gmjg.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     \n        carrots_left = remaining\n        carrots_eaten = number\n   \
    \     \n        while carrots_left > 0 && carrots_eaten > 0 \n            carrots_left\
    \ -= 1\n            carrots_eaten -= 1\n            \n            push!(answer,\
    \ carrots_eaten)\n        end\n        \n        push!(answer, carrots_left)\n\
    \        \n        return answer\n    else\n        error(\"Not enough carrots\
    \ left\")\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcsknbxqt.jl:50\nin expression starting at\
    \ /tmp/tmpcsknbxqt.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    else\n        Vector{Int64}([number, need-number])\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\n    You have a list\
    \ of numbers, each number in the list represents how many carrots you have eaten\
    \ so far.\n    You have a list of numbers, each number in the list represents\
    \ how many carrots you have left after your meals.\n    \n    You want to know\
    \ how many carrots you will need to eat to complete the meals.\n    \n    Example:\n\
    \    * meals([5, 6, 10], [4, 8, 9], [1, 10, 10]) -> [11, 4]\n    * meals([4, 8,\
    \ 9], [1, 10, 10], [2, 11, 5]) -> [12, 1]\n    * meals([1, 10, 10], [2, 11, 5],\
    \ [3, 12, 6]) -> [11, 0]\n    * meals([2, 11, 5], [3, 12, 6], [4, 13, 7]) -> [7,\
    \ 0]\n    \n    Variables:\n    @meals : array of integers\n        the meals\
    \ you have eaten\n    @left : array of integers\n        the carrots you have\
    \ left after your meals\n    \n    Constrain:\n    * 0 <= meals[i] <= 1000\n \
    \   * 0 <= left[i] <= 1000\n    \n    Have fun :)\n    \"\"\"\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfp3erqwb.jl:46\nin expression starting at\
    \ /tmp/tmpfp3erqwb.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else if number ==\
    \ 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    meals() -> a function\
    \ that returns the number of carrots left after your meals.\n    \n    Example:\n\
    \    * meals() -> 11\n    * meals() -> 12\n    * meals() -> 11\n    * meals()\
    \ -> 7\n    \n    Variables:\n    no input\n    \n    Constrain:\n    no constraints\n\
    \    \n    Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc4cl1n17.jl:32\nin expression starting at\
    \ /tmp/tmpc4cl1n17.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] =\
    \ remaining\n    meals_left[2] = 0\n    \n    meals_left_after_meals = zeros(Int64,\
    \ 2)\n    meals_left_after_meals[1] = remaining\n    meals_left_after_meals[2]\
    \ = 0\n    \n    meals_left_after_meals_2 = zeros(Int64, 2)\n    meals_left_after_meals_2[1]\
    \ = remaining\n    meals_left_after_meals_2[2] = 0\n    \n    meals_left_after_meals_3\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_3[1] = remaining\n    meals_left_after_meals_3[2]\
    \ = 0\n    \n    meals_left_after_meals_4 = zeros(Int64, 2)\n    meals_left_after_meals_4[1]\
    \ = remaining\n    meals_left_after_meals_4[2] = 0\n    \n    meals_left_after_meals_5\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_5[1] = remaining\n    meals_left_after_meals_5[2]\
    \ = 0\n    \n    meals_left_after_meals_6 = zeros(Int64, 2)\n    meals_left_after_meals_6[1]\
    \ = remaining\n    meals_left_after_meals_6[2] = 0\n    \n    meals_left_after_meals_7\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_7[1] = remaining\n    meals_left_after_meals_7[2]\
    \ = 0\n    \n    meals_left_after_meals_8 = zeros(Int64, 2)\n    meals_left_after_meals_8[1]\
    \ = remaining\n    meals_left_after_meals_8[2] = 0\n    \n    meals_left_after_meals_9\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_9[1] = remaining\n    meals_left_after_meals_9[2]\
    \ = 0\n    \n    meals_left_after_meals_10 = zeros(Int64, 2)\n    meals_left_after_meals_10[1]\
    \ = remaining\n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpj8o_0fu2.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpj8o_0fu2.jl:1\n\
    in expression starting at /tmp/tmpj8o_0fu2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\")\n    else\n     \
    \   Vector{Int64}([number, need, remaining])\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprift1szd.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [5, 6, 10] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprift1szd.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprift1szd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprift1szd.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [4, 8, 9] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprift1szd.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprift1szd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprift1szd.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [1, 10, 10] == [11, 0]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprift1szd.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprift1szd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprift1szd.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [2, 11, 5] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprift1szd.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprift1szd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprift1szd.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [4, 5, 7] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprift1szd.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzn7zgw0c.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpzn7zgw0c.jl:1\n\
    in expression starting at /tmp/tmpzn7zgw0c.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8bpc42by.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8bpc42by.jl:1\n\
    in expression starting at /tmp/tmp8bpc42by.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots[2] = carrots[2] - 1\n    \n    if carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2]\
    \ - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] > 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] == 0 && carrots[2] < 0\n        carrots[1] = carrots[1] - 1\n   \
    \     carrots[2] = carrots[2] - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2]\
    \ < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2] -\
    \ 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] == 0 && carrots[2] < 0\n        carrots[1] = carrots[1] - 1\n   \
    \     carrots[2] = carrots[2] - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2]\
    \ < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2] -\
    \ 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        carrots[2] = carrots[2] - 1\n    end\n    \n    if\
    \ carrots[1] == 0 && carrots[2] < 0\n        carrots[1] = carrots[1] - 1\n   \
    \     carrots[2] = carrots[2] - 1\n    end\n    \n    if carrots[1] == 0 && carrots[2]\
    \ < 0\n        carrots[1] = carrots[1] - 1\n        carrots[2] = carrots[2] -\
    \ 1\n    end\n    \n    if carrots[1] == 0 && carrots[2] < 0\n        carrots[1]\
    \ = carrots[1] - 1\n        \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp48rsa01e.jl:1\nin expression starting at /tmp/tmp48rsa01e.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif number == remaining\n        Vector{Int64}([need,\
    \ remaining])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"\n    rabbit(number::Int64, need::Int64,\
    \ remaining::Int64)::Bool\n    \n    Determine whether you have a rabbit or not.\n\
    \    \n    Variables:\n    @number : integer\n        the number of carrots that\
    \ you have eaten.\n    @need : integer\n        the number of carrots that you\
    \ need to eat.\n    @remaining : integer\n        the number of remaining carrots\
    \ thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    *\
    \ 0 <= need <= 1000\n    * 0 <= remaining <= 1000\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyyhik_ka.jl:48\nin expression starting at\
    \ /tmp/tmpyyhik_ka.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0\n        return Vector{Int64}[], remaining\n    end\n\
    \    if remaining < need\n        return Vector{Int64}[], 0\n    end\n    \n \
    \   carrots = Vector{Int64}[]\n    carrots = carrots + [number]\n    carrots =\
    \ carrots + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots\
    \ + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n\
    \    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots\
    \ = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots\
    \ + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n\
    \    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots\
    \ = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots\
    \ + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n\
    \    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots\
    \ = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots\
    \ + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n\
    \    carrots = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots\
    \ = carrots + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots\
    \ + [remaining]\n    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n\
    \    carrots = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots\
    \ = carrots + [need]\n    carrots = carrots + [remaining]\n    carrots = carrots\
    \ + [need]\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpji10d7ga.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpji10d7ga.jl:1\n\
    in expression starting at /tmp/tmpji10d7ga.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_dro41s6.jl:36\nin expression starting at\
    \ /tmp/tmp_dro41s6.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number < 0 || need < 0 || remaining < 0\n        return error(\"\
    Invalid input\")\n    end\n    \n    if remaining == 0\n        return [number,\
    \ 0]\n    end\n    \n    carrots = number\n    \n    if number > need\n      \
    \  carrots = number-need\n    end\n    \n    if remaining < carrots\n        carrots\
    \ = remaining\n    end\n    \n    return [carrots, carrots-number]\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns the number of prime numbers less than a given number. \nThe function\
    \ should take in a single integer and return the number of prime numbers less\
    \ than that number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptvzyxh1w.jl:51\nin expression starting at\
    \ /tmp/tmptvzyxh1w.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5y4mrwqg.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5y4mrwqg.jl:1\n\
    in expression starting at /tmp/tmp5y4mrwqg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = 0\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = 0\n    carrots_left_after_meals[2] = 0\n\
    \    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals[1] =\
    \ 0\n    carrots_left_after_meals_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals_after_meals_after_meals[2] = 0\n\
    \    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = 0\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkujxkn6o.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkujxkn6o.jl:1\n\
    in expression starting at /tmp/tmpkujxkn6o.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n   \
    \ while carrots_left > 0\n        carrots_left -= 1\n        carrots += need\n\
    \    end\n    \n    return Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7: Write a function\
    \ that returns the number of ways to arrange n people into k groups of people.\n\
    The function should take in two integers n and k and return an integer that represents\
    \ the number of ways to arrange n people into k groups of people.\nThe function\
    \ should return 0 if there are not enough people to fill the groups.\nThe function\
    \ should return -1 if there are not enough people to fill the groups.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz0o1kasw.jl:44\nin expression starting at\
    \ /tmp/tmpz0o1kasw.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 && number <= need && number\
    \ <= remaining \n        then return [number, remaining - number]\n    else return\
    \ [0, 0]\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa7soglcr.jl:31\nin expression starting at /tmp/tmpa7soglcr.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots[2] = carrots[2] - (carrots[1] - carrots[2])\n    \n    if carrots[2]\
    \ < 0\n        carrots[2] = 0\n    end\n    \n    if carrots[1] < 0\n        carrots[1]\
    \ = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n\
    \    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1]\
    \ = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1] < 0\n    \
    \    carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        carrots[1] = 0\n    end\n\
    \    \n    carrots[1] = carrots[1] - (carrots[2] - carrots[1])\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    carrots[1] = carrots[1] - (carrots[2]\
    \ - carrots[1])\n    \n    if carrots[1] < 0\n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoqh4o6p4.jl:1\nin expression starting at /tmp/tmpoqh4o6p4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2]\
    \ = remaining\n    \n    while carrots_left[2] > 0\n        carrots_left[2] -=\
    \ 1\n        meals[2] += 1\n    end\n    \n    while meals[2] > 0\n        meals[2]\
    \ -= 1\n        carrots[1] += 1\n    end\n    \n    return carrots\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ called hungry_rabbit that takes three integers as inputs:\n    \n    Your age\n\
    \    Your weight in kilograms\n    Your height in centimeters\n    \n    Your\
    \ function should return true if the rabbit is hungry, false otherwise.\n    \n\
    \    Your function should return false if any of the inputs are less than 0 or\
    \ greater than 1000.\n    \n    Your function should return false if any of the\
    \ inputs are negative.\n    \n    Your function should return false if any of\
    \ the inputs are greater than 1000.\n    \n    Your function should return false\
    \ if any of the inputs are equal to 0.\n    \n    Your function should return\
    \ false if any of the inputs are greater than or equal to 100.\n    \n    Your\
    \ function should return false if any of the inputs are greater than or equal\
    \ to 200.\n    \n    Your function should return false if any of the inputs are\
    \ greater than or equal to 300.\n    \n    Your function should return false if\
    \ any of the inputs are greater than or equal to 400.\n    \n    Your function\
    \ should return false if any of the inputs are greater than or equal to 500.\n\
    \    \n    Your function should return false if any of the inputs are greater\
    \ than or equal to 600.\n    \n    Your function should return false if any of\
    \ the inputs are greater than or equal to 700.\n    \n    Your function should\
    \ return false if any of the inputs are greater than or equal to 800.\n    \n\
    \    Your function should return \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps245chxn.jl:58\nin expression starting at\
    \ /tmp/tmps245chxn.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    meals = need\n    carrots_left = remaining\n\
    \    \n    carrots_left_after_meals = carrots - meals\n    carrots_after_meals\
    \ = carrots - carrots_left\n    \n    return Vector{Int64}(carrots_after_meals,\
    \ carrots_left_after_meals)\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function named is_hungry that takes three integers as input,\
    \ and returns true if the number is hungry, false otherwise.\nThe function should\
    \ return false for negative numbers, zero, and positive numbers.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7u8l_htq.jl:43\nin expression starting at\
    \ /tmp/tmp7u8l_htq.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"eat(number,\
    \ need, remaining) called with invalid parameters\")\n    end\n    if number ==\
    \ 0 && remaining == 0\n        return Vector{Int64}[]\n    end\n    if number\
    \ == 0 && remaining > 0\n        return Vector{Int64}[]\n    end\n    if need\
    \ == 0 && remaining > 0\n        return Vector{Int64}[]\n    end\n    if number\
    \ == 0 && need == 0 && remaining > 0\n        return Vector{Int64}[]\n    end\n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7k57mgpn.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7k57mgpn.jl:1\n\
    in expression starting at /tmp/tmp7k57mgpn.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif remaining == 0\n        Vector{Int64}([number,\
    \ 0])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    meals() -> a function that returns an array\
    \ of meals you can make.\n    \n    Example:\n    * meals() -> [ \"breakfast\"\
    , \"lunch\", \"dinner\" ]\n    \n    Variables:\n    no input\n    \n    Constrain:\n\
    \    no output\n    \n    Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu6wl3voh.jl:48\nin expression starting at\
    \ /tmp/tmpu6wl3voh.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpohzifx6m.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpohzifx6m.jl:1\n\
    in expression starting at /tmp/tmpohzifx6m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0 && need == 0 && remaining == 0\n        Vector{Int64}()\n\
    \    elseif number == 0 && need == 0 && remaining > 0\n        Vector{Int64}(remaining,\
    \ 0)\n    elseif number == 0 && need > 0 && remaining == 0\n        Vector{Int64}(0,\
    \ need)\n    elseif number > 0 && need == 0 && remaining == 0\n        Vector{Int64}(number,\
    \ 0)\n    elseif number > 0 && need == 0 && remaining > 0\n        Vector{Int64}(number,\
    \ need)\n    elseif number > 0 && need > 0 && remaining == 0\n        Vector{Int64}(number,\
    \ need)\n    elseif number > 0 && need > 0 && remaining > 0\n        Vector{Int64}(number,\
    \ need)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    findMeals(meals::Vector{Int64},\
    \ need::Int64, remaining::Int64)::Vector{Int64}\n    \n    You have a meal plan,\
    \ and you need to eat as many carrots as possible.\n    \n    Variables:\n   \
    \ @meals : Vector{Int64}\n        the meals that you have planned for the day\n\
    \    @need : integer\n        the number of carrots that you need to eat.\n  \
    \  @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprpn7hqa4.jl:47\nin expression starting at\
    \ /tmp/tmprpn7hqa4.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining\
    \ > 0 && remaining <= 1000\n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfa_6tpvr.jl:1\nin expression starting at /tmp/tmpfa_6tpvr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = need\n    \n    while\
    \ carrots_left > 0\n        carrots_left -= 1\n        carrots += 1\n    end\n\
    \    \n    return Vector{Int64}(carrots, carrots-1)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0x1sm2jw.jl:49\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: no method matching\
    \ Vector{Int64}(::Int64, ::Int64)\n  Closest candidates are:\n    Array{T, N}(!Matched::Nothing,\
    \ ::Any...) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:42\n\
    \    Array{T, N}(!Matched::Missing, ::Any...) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:43\n\
    \    Vector{T}(!Matched::UndefInitializer, ::Int64) where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:457\n\
    \    ...\n  Stacktrace:\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\n\
    \     @ Main /tmp/tmp0x1sm2jw.jl:42\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0x1sm2jw.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0x1sm2jw.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp0x1sm2jw.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(4, 8, 9) == [12, 1]\n  MethodError: no method matching Vector{Int64}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{T, N}(!Matched::Nothing, ::Any...)\
    \ where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:42\n\
    \    Array{T, N}(!Matched::Missing, ::Any...) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:43\n\
    \    Vector{T}(!Matched::UndefInitializer, ::Int64) where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:457\n\
    \    ...\n  Stacktrace:\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\n\
    \     @ Main /tmp/tmp0x1sm2jw.jl:42\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0x1sm2jw.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0x1s"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0x1sm2jw.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\")\n    else \n    \
    \    \n        carrots = zeros(Int64, 2)\n        carrots[1] = number\n      \
    \  carrots[2] = need\n        \n        carrots_left = zeros(Int64, 2)\n     \
    \   carrots_left[1] = remaining\n        carrots_left[2] = need\n        \n  \
    \      carrots_left = carrots_left\n        carrots_left[1] = carrots_left[1]\
    \ - 1\n        carrots_left[2] = carrots_left[2] - 1\n        \n        carrots_left\
    \ = carrots_left\n        carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2]\
    \ = carrots_left[2] - 1\n        \n        carrots_left = carrots_left\n     \
    \   carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2]\
    \ - 1\n        \n        carrots_left = carrots_left\n        carrots_left[1]\
    \ = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2] - 1\n     \
    \   \n        carrots_left = carrots_left\n        carrots_left[1] = carrots_left[1]\
    \ - 1\n        carrots_left[2] = carrots_left[2] - 1\n        \n        carrots_left\
    \ = carrots_left\n        carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2]\
    \ = carrots_left[2] - 1\n        \n        carrots_left = carrots_left\n     \
    \   carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2]\
    \ - 1\n        \n        carrots_left = carrots_left\n        carrots_left[1]\
    \ = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2] - 1\n     \
    \   \n        carrots_left = carrots_left\n        carrots_left[1] = carrots_left[1]\
    \ - 1\n        carrots_left[2] = carrots_left[2] - 1\n        \n        carrots_left\
    \ = carrots_left\n        carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2]\
    \ = carrots_left[2] - 1\n        \n        carrots_left = carrots_left\n     \
    \   carrots_left[1] = carrots_left[1] - 1\n        carrots_left[2] = carrots_left[2]\
    \ - 1\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpr8oh3_i3.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpr8oh3_i3.jl:1\n\
    in expression starting at /tmp/tmpr8oh3_i3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpse16gx4z.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpse16gx4z.jl:1\n\
    in expression starting at /tmp/tmpse16gx4z.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    meals_left = zeros(Int64, 2)\n\
    \    meals_left[1] = 0\n    meals_left[2] = 0\n    \n    while meals[1] > 0\n\
    \        carrots_left[1] -= meals[1]\n        meals_left[1] -= meals[1]\n    \
    \    \n        if carrots_left[1] < 0\n            carrots_left[1] = 0\n     \
    \   end\n        \n        if meals_left[1] < 0\n            meals_left[1] = 0\n\
    \        end\n        \n        if carrots_left[1] > 0\n            carrots[1]\
    \ += carrots_left[1]\n        end\n        \n        if meals_left[1] > 0\n  \
    \          meals[1] += meals_left[1]\n        end\n        \n        if carrots[1]\
    \ > 0\n            carrots[2] += 1\n        end\n        \n        if meals[1]\
    \ > 0\n            meals[2] += 1\n        end\n    end\n    \n    return carrots\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your code\n@test eat(5, 6, 10)\
    \ == [11, 4]\n@test eat(4, 8, 9) == [12, 1]\n@test eat(1, 10, 10) == [11, 0]\n\
    @test eat(2, 11, 5) == [7, 0]\n</cell>\n<text>\nProblem 3\nThe Fibonacci sequence\
    \ is defined by the formula:\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpme4lst5e.jl:81\nin expression starting at\
    \ /tmp/tmpme4lst5e.jl:81\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining < 0\n        return Vector{Int64}()\n    end\n    \n    if number\
    \ > remaining\n        number = remaining\n    end\n    \n    if need == 0\n \
    \       return Vector{Int64}([number, 0])\n    end\n    \n    if number > need\n\
    \        number = need\n    end\n    \n    return Vector{Int64}([number, number-number])\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppmdeu70u.jl:53\nin expression starting at\
    \ /tmp/tmppmdeu70u.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc44nu47w.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc44nu47w.jl:1\n\
    in expression starting at /tmp/tmpc44nu47w.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        return Vector{Int64}()\n    end\n    \n\
    \    if remaining < need\n        return Vector{Int64}()\n    end\n    \n    carrots\
    \ = Vector{Int64}()\n    \n    if number < need\n        carrots = Vector{Int64}([number])\n\
    \    end\n    \n    carrots = carrots + eat(number - need, need, remaining)\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaehc9lar.jl:49\nin expression starting at\
    \ /tmp/tmpaehc9lar.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9rpw6e_g.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9rpw6e_g.jl:1\n\
    in expression starting at /tmp/tmp9rpw6e_g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n\
    \    \n    meals = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals\
    \ = meals[2:end]\n    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n\
    \    carrots = carrots[2:end]\n    \n    meals = meals[2:end]\n    car\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy791a5x1.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy791a5x1.jl:1\n\
    in expression starting at /tmp/tmpy791a5x1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number should be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need should\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining should be between 0 and 1000\")\n    else \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmf7lvve5.jl:32\nin expression starting at\
    \ /tmp/tmpmf7lvve5.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \nend\n</cell>\n<text>\nProblem 3\nWrite a\
    \ function that takes an array of integers and returns the number of positive\
    \ integers that are less than the given number.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqw4wigjh.jl:34\nin expression starting at\
    \ /tmp/tmpqw4wigjh.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"invalid\
    \ input\")\n    end\n    \n    carrots = number\n    left  = need\n    \n    while\
    \ left > 0\n        carrots = carrots + 1\n        left = left - 1\n    end\n\
    \    \n    carrots = carrots - remaining\n    \n    return Vector{Int64}(carrots,\
    \ left)\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of items in an array. \nThe function should take in an array of integers\
    \ and an integer $k$ as input, and output the number of ways to arrange the items\
    \ in $k$ containers.\nThe function should return an array of integers containing\
    \ the number of ways to arrange the items in $k$ containers.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprxzm39bm.jl:46\nin expression starting at\
    \ /tmp/tmprxzm39bm.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        error(\"\
    invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1]\
    \ = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n  \
    \  meals[1] = need\n    meals[2] = remaining\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = number\n    carrots_left[2] = remaining\n    \n  \
    \  while carrots_left[2] > 0 && meals[2] > 0\n        carrots_left[2] = carrots_left[2]\
    \ - 1\n        meals[2] = meals[2] - 1\n    end\n    \n    if carrots_left[2]\
    \ > 0 || meals[2] > 0\n        carrots_left[2] = carrots_left[2] - 1\n       \
    \ meals[2] = meals[2] - 1\n    end\n    \n    carrots_left[1] = carrots_left[1]\
    \ - carrots[1]\n    carrots_left[2] = carrots_left[2] - carrots[2]\n    \n   \
    \ if carrots_left[1] < 0 || carrots_left[2] < 0\n        carrots_left[1] = carrots_left[1]\
    \ + 1\n        carrots_left[2] = carrots_left[2] + 1\n    end\n    \n    return\
    \ carrots_left\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp00nx9gjs.jl:66\nin expression starting at\
    \ /tmp/tmp00nx9gjs.jl:66\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = need\n    \n    while carrots > 0\n   \
    \     carrots_left -= 1\n        carrots -= 1\n    end\n    \n    carrots_left\
    \ = carrots - remaining\n    \n    return Vector{Int64}(carrots_left, carrots)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpci74ya2t.jl:51\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: no method matching\
    \ Vector{Int64}(::Int64, ::Int64)\n  Closest candidates are:\n    Array{T, N}(!Matched::Nothing,\
    \ ::Any...) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:42\n\
    \    Array{T, N}(!Matched::Missing, ::Any...) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:43\n\
    \    Vector{T}(!Matched::UndefInitializer, ::Int64) where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:457\n\
    \    ...\n  Stacktrace:\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\n\
    \     @ Main /tmp/tmpci74ya2t.jl:44\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpci74ya2t.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpci74ya2t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpci74ya2t.jl:52\n  Test threw exception\n  Expression:\
    \ candidate(4, 8, 9) == [12, 1]\n  MethodError: no method matching Vector{Int64}(::Int64,\
    \ ::Int64)\n  Closest candidates are:\n    Array{T, N}(!Matched::Nothing, ::Any...)\
    \ where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:42\n\
    \    Array{T, N}(!Matched::Missing, ::Any...) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/baseext.jl:43\n\
    \    Vector{T}(!Matched::UndefInitializer, ::Int64) where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:457\n\
    \    ...\n  Stacktrace:\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\n\
    \     @ Main /tmp/tmpci74ya2t.jl:44\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpci74ya2t.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpci74"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpci74ya2t.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = 0\n    \n    while meals[1] > 0\n        carrots_left[1]\
    \ -= 1\n        meals[1] -= 1\n        carrots[1] -= carrots[2]\n        carrots[2]\
    \ = 0\n    end\n    \n    while carrots_left[1] > 0\n        meals[1] -= 1\n \
    \       carrots[1] -= carrots[2]\n        carrots[2] = 0\n    end\n    \n    return\
    \ carrots\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0_778fdn.jl:61\nin expression starting at\
    \ /tmp/tmp0_778fdn.jl:61\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n# Test your code\n\
    @test eat(5, 6, 10) == [11, 4]\n@test eat(4, 8, 9) == [12, 1]\n@test eat(1, 10,\
    \ 10) == [11, 0]\n@test eat(2, 11, 5) == [7, 0]\n</cell>\n<text>\nProblem 7\n\
    Write a function that returns the number of prime numbers less than a given integer\
    \ $n$, where $n$ is also a prime.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1zjxupng.jl:36\nin expression starting at\
    \ /tmp/tmp1zjxupng.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6gr8ynb1.jl:1\nin expression starting at /tmp/tmp6gr8ynb1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else if number ==\
    \ 0 && need == 0 && remaining == 0 \n        return Vector{Int64}()\n    else\
    \ if number == 0 && need == 0 && remaining > 0 \n        return Vector{Int64}(remaining)\n\
    \    else if number == 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(need)\n\
    \    else if number == 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number,\
    \ need)\n    else if number > 0 && need == 0 && remaining == 0 \n        return\
    \ Vector{Int64}(number, need)\n    else if number > 0 && need == 0 && remaining\
    \ > 0 \n        return Vector{Int64}(number, need, remaining)\n    else if number\
    \ > 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(number, need)\n\
    \    else if number > 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number,\
    \ need, remaining)\n    else if number > 0 && need > 0 && remaining == 0 \n  \
    \      return Vector{Int64}(number, need)\n    else if number > 0 && need > 0\
    \ && remaining > 0 \n        return Vector{Int64}(number, need, remaining)\n \
    \   else if number > 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(number,\
    \ need)\n    else if number > 0 && need > 0 && remaining > 0 \n        return\
    \ Vector{Int64}(number, need, remaining)\n    else if number > 0 && need > 0 &&\
    \ remaining == 0 \n        return Vector{Int64}(number, need)\n    else if number\
    \ > 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number, need,\
    \ remaining)\n    else if number > 0 && need > 0 && remaining == 0 \n        return\
    \ Vector{Int64}(number, need)\n    else if number > 0 && need > 0 && remaining\
    \ > 0 \n        return Vector{Int64}(number, need, remaining)\n    else if number\
    \ > 0 && need > 0 && remaining == 0 \n        return Vector{Int64}(number, need)\n\
    \    else if number > 0 && need > 0 && remaining > 0 \n        return Vector{Int64}(number,\
    \ need, remaining)\n    else if number > 0 && need > 0 && remaining == 0 \n  \
    \      return Vector{Int64}(number, need)\n    else if number > 0 && need > 0\
    \ && remaining > 0 \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx_x6azhv.jl:32\nin expression starting at\
    \ /tmp/tmpx_x6azhv.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpijr_1wqu.jl:36\nin expression starting at\
    \ /tmp/tmpijr_1wqu.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps7dod883.jl:32\nin expression starting at\
    \ /tmp/tmps7dod883.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    if number == 0\n        return Vector{Int64}([need, remaining])\n\
    \    end\n    if remaining == 0\n        return Vector{Int64}([number, 0])\n \
    \   end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphnx_v96i.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphnx_v96i.jl:1\n\
    in expression starting at /tmp/tmphnx_v96i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     \n        carrots_left = number - need\n        carrots_eaten = remaining\n\
    \        \n        while carrots_eaten > 0 \n            carrots_left -= 1\n \
    \           carrots_eaten -= 1\n            push!(answer, carrots_eaten)\n   \
    \     end\n        \n        push!(answer, carrots_left)\n        \n        return\
    \ answer\n    end\n    return []\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of prime numbers less than\
    \ a given number. \nThe function should take in a single integer and output a\
    \ vector of integers \nthat represent the number of prime numbers less than that\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpubjpcs_o.jl:48\nin expression starting at\
    \ /tmp/tmpubjpcs_o.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = number\n    meals_left[2]\
    \ = remaining\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] =\
    \ number\n    carrots_left[2] = remaining\n    \n    carrots_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals[1] = number\n    carrots_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n   \
    \ carrots_left_after_meals_left[1] = number\n    carrots_left_after_meals_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_left_after_meals[1] = number\n    carrots_left_after_meals_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_left_after_meals_left[1] = number\n    carrots_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyd5v98sf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyd5v98sf.jl:1\n\
    in expression starting at /tmp/tmpyd5v98sf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = remaining\n    \n    while carrots_left\
    \ > 0\n        if carrots_left > need\n            carrots_left -= need\n    \
    \        carrots += need\n        else\n            carrots_left -= carrots_left\n\
    \            carrots += 1\n        end\n    end\n    \n    return Vector{Int64}(carrots,\
    \ carrots_left)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm0ep817o.jl:49\nin expression starting at\
    \ /tmp/tmpm0ep817o.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc4ecz5lu.jl:36\nin expression starting at\
    \ /tmp/tmpc4ecz5lu.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = 0\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots_left[1] += meals[1]\n   \
    \     meals[1] -= carrots[1]\n        carrots[1] -= carrots[2]\n        carrots[2]\
    \ += meals[2]\n        meals[2] -= carrots[2]\n    end\n    \n    return carrots_left\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns the number of ways you can reach a target number from any given\
    \ starting number by adding or subtracting one to that starting number. For example,\
    \ if you start at 5 and want to reach 10, you can either add one to 5 or subtract\
    \ one from 5, and you can add one to 10 or subtract one from 10. Write a recursive\
    \ function that returns the number of ways you can reach the target number from\
    \ any given starting number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6sa18b0g.jl:56\nin expression starting at\
    \ /tmp/tmp6sa18b0g.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return error(\"Invalid input\")\n    end\n\
    \    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2]\
    \ = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2]\
    \ = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n\
    \    carrots_left[2] = 0\n    \n    while carrots_left[2] > 0 && meals[2] > 0\n\
    \        if carrots[1] > 0\n            carrots[1] -= meals[1]\n            meals[1]\
    \ = 0\n        end\n        if carrots[2] > 0\n            carrots[2] -= meals[2]\n\
    \            meals[2] = 0\n        end\n        \n        if carrots_left[1] >\
    \ 0\n            carrots_left[1] -= meals[1]\n            meals[1] = 0\n     \
    \   end\n        if carrots_left[2] > 0\n            carrots_left[2] -= meals[2]\n\
    \            meals[2] = 0\n        end\n    end\n    \n    if carrots_left[2]\
    \ > 0\n        carrots_left[2] -= meals[2]\n        meals[2] = 0\n    end\n  \
    \  \n    if carrots[1] > 0\n        carrots[1] -= meals[1]\n        meals[1] =\
    \ 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\ne\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj6ufuttr.jl:78\nin expression starting at\
    \ /tmp/tmpj6ufuttr.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        if remaining\
    \ < need\n            Vector{Int64}(remaining, 0)\n        else\n            Vector{Int64}(number,\
    \ need - remaining)\n        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function called hungry that returns\
    \ true if the number of carrots left after your meals is less than or equal to\
    \ zero, and false otherwise.\nHint: You will need to use the eat function you\
    \ wrote in the previous exercise.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9pb7h6ip.jl:40\nin expression starting at\
    \ /tmp/tmp9pb7h6ip.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > remaining \n        number = remaining\n    end\n    if number\
    \ == 0 \n        Vector{Int64}([need, remaining])\n    elseif number < need \n\
    \        Vector{Int64}([number, remaining])\n    elseif number == need \n    \
    \    Vector{Int64}([number, 0])\n    elseif number > need \n        Vector{Int64}([need,\
    \ 0])\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 1)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 2)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 3)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 4)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 5)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 6)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 7)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 8)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 9)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 11)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 12)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 13)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 14)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 15)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 16)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 17)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 18)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 19)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 20)\n</cell>\n<code language=julia-1.0>\neat(10, 10, \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgrarc5px.jl:43\nin expression starting at\
    \ /tmp/tmpgrarc5px.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_iu_67h7.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_iu_67h7.jl:1\n\
    in expression starting at /tmp/tmp_iu_67h7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    meals_left = zeros(Int64, 2)\n\
    \    meals_left[1] = 0\n    meals_left[2] = 0\n    \n    carrots_left[1] = carrots[1]\n\
    \    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n    meals_left[2]\
    \ = meals[2]\n    \n    carrots_left[1] = carrots[1]\n    carrots_left[2] = carrots[2]\n\
    \    \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n    \n    carrots_left[1]\
    \ = carrots[1]\n    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n\
    \    meals_left[2] = meals[2]\n    \n    carrots_left[1] = carrots[1]\n    carrots_left[2]\
    \ = carrots[2]\n    \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n\
    \    \n    carrots_left[1] = carrots[1]\n    carrots_left[2] = carrots[2]\n  \
    \  \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n    \n    carrots_left[1]\
    \ = carrots[1]\n    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n\
    \    meals_left[2] = meals[2]\n    \n    carrots_left[1] = carrots[1]\n    carrots_left[2]\
    \ = carrots[2]\n    \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n\
    \    \n    carrots_left[1] = carrots[1]\n    carrots_left[2] = carrots[2]\n  \
    \  \n    meals_left[1] = meals[1]\n    meals_left[2] = meals[2]\n    \n    carrots_left[1]\
    \ = carrots[1]\n    carrots_left[2] = carrots[2]\n    \n    meals_left[1] = meals[1]\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpg5hpm9io.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpg5hpm9io.jl:1\n\
    in expression starting at /tmp/tmpg5hpm9io.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        return Vector{Int64}()\n\
    \    end\n    if number == 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\n    if number == 0 && remaining > 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\n    if number > 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ number])\n    end\n    if number > 0 && remaining > 0\n        return Vector{Int64}([need,\
    \ number])\n    end\n    return Vector{Int64}()\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.4>\ne\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj58v9636.jl:47\nin expression starting at\
    \ /tmp/tmpj58v9636.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"invalid\
    \ input\")\n    end\n    \n    if number == 0\n        return [need, remaining]\n\
    \    end\n    \n    if remaining == 0\n        return [number, 0]\n    end\n \
    \   \n    if number > remaining\n        return [number, remaining]\n    end\n\
    \    \n    if need == 0\n        return [number, 0]\n    end\n    \n    if number\
    \ > need\n        return [number, need]\n    end\n    \n    if number == need\n\
    \        return [number, 0]\n    end\n    \n    if number > need\n        return\
    \ [number, need]\n    end\n    \n    if number == need\n        return [number,\
    \ 0]\n    end\n    \n    if number == remaining\n        return [number, 0]\n\
    \    end\n    \n    if number > remaining\n        return [number, remaining]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number > remaining\n        return [number, remaining]\n    end\n\
    \    \n    if number == remaining\n        return [number, 0]\n    end\n    \n\
    \    if number > remaining\n        return [number, remaining]\n    end\n    \n\
    \    if number == remaining\n        return [number, 0]\n    end\n    \n    if\
    \ number > remaining\n        return [number, remaining]\n    end\n    \n    if\
    \ number == remaining\n        return [number, 0]\n    end\n    \n    if number\
    \ > remaining\n        return [number, remaining]\n    end\n    \n    if number\
    \ == remaining\n        return [number, 0]\n    end\n    \n    if number > remaining\n\
    \        return [number, remaining]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number > remaining\n      \
    \  return [number, remaining]\n    end\n    \n    if number == remaining\n   \
    \     return [number, 0]\n    end\n    \n    if number > remaining\n        return\
    \ [number, remaining]\n    end\n    \n    if number == remaining\n        return\
    \ [number, 0]\n    end\n    \n    if number > remaining\n        return [number,\
    \ remaining]\n    end\n    \n    if number == remaining\n        return [number,\
    \ 0]\n    end\n    \n    if number > remaining\n        return [number, remaining]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number > remaining\n        return [number, remaining]\n    end\n\
    \    \n    if number == remaining\n        return [number, 0]\n    end\n    \n\
    \    if number > remaining\n        return [number, remaining]\n    end\n    \n\
    \    if number == remaining\n        return [number, 0]\n    end\n    \n    if\
    \ number > remaining\n        return [number, remaining]\n    end\n    \n    if\
    \ number == remaining\n        return [number, 0]\n    end\n    \n    if number\
    \ > remaining\n        return [number, remaining]\n    end\n    \n    if number\
    \ == \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7tqsfy__.jl:1\nin expression starting at /tmp/tmp7tqsfy__.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots[2] = remaining - carrots[2]\n    \n\
    \    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy7w12u8p.jl:42\nin expression starting at\
    \ /tmp/tmpy7w12u8p.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = need\n    \n    carrots_left = carrots_left\
    \ - number\n    \n    if carrots_left[1] > 0\n        carrots_left[1] -= 1\n \
    \   end\n    \n    if carrots_left[2] > 0\n        carrots_left[2] -= 1\n    end\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw8kovx6m.jl:54\nin expression starting at\
    \ /tmp/tmpw8kovx6m.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = number\n    carrots_left = remaining\n\
    \    \n    meals_left = 0\n    \n    while carrots_left > 0\n        if carrots_left\
    \ > need\n            carrots_left -= need\n            meals_left += 1\n    \
    \    else\n            carrots_left -= carrots_left\n        end\n    end\n  \
    \  \n    return [meals_left, carrots_left]\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n integers into k groups. \nThe function should take in two\
    \ parameters: n and k. \nThe function should return an array of integers representing\
    \ the number of ways to arrange the integers into k groups.\nThe function should\
    \ return an empty array if n is less than or equal to 0 or if k is less than or\
    \ equal to 0.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgapdev59.jl:50\nin expression starting at\
    \ /tmp/tmpgapdev59.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    \n    if number == 0\n        return [need, remaining]\n    end\n\
    \    \n    if remaining < need\n        return [number, 0]\n    end\n    \n  \
    \  carrots = number\n    \n    while carrots > 0\n        carrots = carrots -\
    \ 1\n        need = need - 1\n    end\n    \n    return [need, remaining]\nend\n\
    </cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.4>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns an array of integers representing the number of times each of the\
    \ elements in the array appears.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5shuw4ay.jl:51\nin expression starting at\
    \ /tmp/tmp5shuw4ay.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}([need, remaining])\n    elseif remaining\
    \ == 0\n        Vector{Int64}([number, 0])\n    elseif number > remaining\n  \
    \      Vector{Int64}([number, remaining])\n    else\n        Vector{Int64}([number,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of items in an array\nof size n.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaznpdj8n.jl:40\nin expression starting at\
    \ /tmp/tmpaznpdj8n.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    if number == 0\n        \n        return [need, remaining]\n\
    \    \n    if remaining == 0\n        \n        return [number, 0]\n    \n   \
    \ if number > remaining\n        \n        return [number, remaining]\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzj9eogxh.jl:1\nin expression starting at /tmp/tmpzj9eogxh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    need = need - carrots\n    remaining\
    \ = remaining - carrots\n    \n    if remaining <= 0\n        return Vector{Int64}(carrots,\
    \ 0)\n    end\n    \n    carrots = carrots + need\n    \n    return Vector{Int64}(carrots,\
    \ remaining)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyvwnczj1.jl:46\nin expression starting at\
    \ /tmp/tmpyvwnczj1.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp72_icje2.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp72_icje2.jl:1\n\
    in expression starting at /tmp/tmp72_icje2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = remaining\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals[1] =\
    \ remaining\n    carrots_left_after_meals_after_meals_after_meals[2] = 0\n   \
    \ \n    carrots_left_after_meals_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1] = remaining\n\
    \    carrots_left_after_meals_after_meals_after_meals_after_meals[2] = 0\n   \
    \ \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5zvt2q7f.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5zvt2q7f.jl:1\n\
    in expression starting at /tmp/tmp5zvt2q7f.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\") \n    else \n   \
    \     \n        carrots = zeros(Int64, 2)\n        carrots[1] = number\n     \
    \   carrots[2] = need\n        \n        carrots_left = zeros(Int64, 2)\n    \
    \    carrots_left[1] = remaining\n        carrots_left[2] = remaining\n      \
    \  \n        carrots_left = carrots_left[1]\n        \n        carrots_left =\
    \ carrots_left\n        \n        carrots_left = carrots_left\n        \n    \
    \    carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = carrots_left\n        \n        carrots_left\
    \ = carrots_left\n        \n        carrots_left = carrots_left\n        \n  \
    \      carrots_left = carrots_left\n        \n        carrots_left = carrots_left\n\
    \        \n        carrots_left = \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp44n67co7.jl:30\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp44n67co7.jl:1\n\
    in expression starting at /tmp/tmp44n67co7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        return Vector{Int64}()\n    end\n    \n   \
    \ carrots = number\n    carrots_left = remaining\n    \n    meals = Vector{Int64}()\n\
    \    \n    while carrots_left > 0\n        if carrots_left > need\n          \
    \  meals = meals + carrots_left\n            carrots_left = 0\n        else\n\
    \            meals = meals + need\n            carrots_left -= need\n        end\n\
    \    end\n    \n    return meals\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 6, 10)\n</cell>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp643hqu6w.jl:51\nin expression starting at\
    \ /tmp/tmp643hqu6w.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return [need, remaining]\n    elseif remaining\
    \ < 0\n        return [need, 0]\n    elseif remaining == 0\n        return [need,\
    \ 0]\n    elseif number > remaining\n        return [need, 0]\n    else\n    \
    \    return eat(number - 1, need + number, remaining - number)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nExercise 2\n\
    Write a function called eat_all that takes three integers as parameters and returns\
    \ an array of two integers containing the number of carrots you would need to\
    \ eat to complete the day's meals.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnq6uku15.jl:42\nin expression starting at\
    \ /tmp/tmpnq6uku15.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    # Your code here\n    \n    \n    return Vector{Int64}([number,\
    \ need-number])\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to choose k items\
    \ from n items. \nThe order of the items does not matter. \nThe function should\
    \ return an array of integers, where each element is the number of ways to choose\
    \ that item from n items.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppax4_gm3.jl:37\nin expression starting at\
    \ /tmp/tmppax4_gm3.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    # Your code here\n    \n    return Vector{Int64}([number, remaining])\n\
    end\n</cell>\n<code language=julia-1.5>\n# Run this cell to check your output.\
    \ If everything is correct, you should see output similar to this:\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nPart 3: Mealplan\n\
    Now that you have learned how to write functions, you will be able to write mealplans.\
    \ A mealplan is simply a way to plan out what to do to meet the deadline. For\
    \ example, you may want to order a pizza to eat at noon on Monday, but you may\
    \ not have enough money to order a pizza until after noon on Tuesday. Or you may\
    \ want to order a pizza to eat at noon on Wednesday, but you may not have enough\
    \ money to order a pizza until after noon on Thursday. Or you may want to order\
    \ a pizza to eat at noon on Friday, but you may not have enough money to order\
    \ a pizza until after noon on Saturday. Or you may want to order a pizza to eat\
    \ at noon on Sunday, but you may not have enough money to order a pizza until\
    \ after noon on Monday. Or you may want to order a pizza to eat at noon on Tuesday,\
    \ but you may not have enough money to order a pizza until after noon on Wednesday.\
    \ Or you may want to order a pizza to eat at noon on Thursday, but you may not\
    \ have enough money to order a pizza until after noon on Friday. Or you may want\
    \ to order a pizza to eat at noon on Saturday, but you may not have enough money\
    \ to order a pizza until after noon on Sunday.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwgrlis51.jl:35\nin expression starting at\
    \ /tmp/tmpwgrlis51.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return [need, remaining]\n    else if number >\
    \ remaining\n        return [number, 0]\n    else\n        carrots = number %\
    \ need\n        number = number - carrots\n        remaining = remaining - carrots\n\
    \        return [number, remaining]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that takes in an array\
    \ of integers and returns the number of positive integers less than or equal to\
    \ that number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjgw6psfk.jl:32\nin expression starting at\
    \ /tmp/tmpjgw6psfk.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    carrots_left = remaining\n    \n   \
    \ while carrots > 0\n        carrots_left -= 1\n        carrots -= 1\n    end\n\
    \    \n    carrots = need\n    carrots_left = remaining\n    \n    while carrots\
    \ > 0\n        carrots_left -= 1\n        carrots -= 1\n    end\n    \n    return\
    \ Vector{Int64}(carrots, carrots_left)\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmpbgd4q2.jl:52\nin expression starting at\
    \ /tmp/tmpmpbgd4q2.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = 0\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots_left[1] += meals[1]\n   \
    \     meals[1] -= carrots[1]\n        carrots[1] -= carrots[2]\n        \n   \
    \     if carrots[1] > 0\n            meals[1] -= carrots[1]\n            carrots[1]\
    \ -= carrots[2]\n        end\n        \n        if meals[1] > 0\n            meals[1]\
    \ -= carrots[1]\n            carrots[1] -= carrots[2]\n        end\n    end\n\
    \    \n    return carrots_left\nend\n</cell>\n<code language=julia-1.4>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa7zi9y8y.jl:64\nin expression starting at\
    \ /tmp/tmpa7zi9y8y.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([need, number])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7jxifi5l.jl:37\nin expression starting at\
    \ /tmp/tmp7jxifi5l.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[2]\n    \n    carrots_left = carrots_left\n  \
    \  \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpt93buz0v.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpt93buz0v.jl:1\n\
    in expression starting at /tmp/tmpt93buz0v.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    if number == 0 && need == 0 && remaining > 0\n\
    \        return Vector{Int64}([remaining])\n    end\n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}([need])\n    end\n    if\
    \ number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}([number])\n\
    \    end\n    if number > 0 && need == 0 && remaining > 0\n        return Vector{Int64}([number,\
    \ remaining])\n    end\n    if number > 0 && need > 0 && remaining == 0\n    \
    \    return Vector{Int64}([need, number])\n    end\n    if number > 0 && need\
    \ > 0 && remaining > 0\n        return Vector{Int64}([need, number, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    findMeals(meals::Vector{Int64},\
    \ carrots::Int64) -> Vector{Int64}\n    \n    You have a meal plan, and you already\
    \ have eaten a certain number of carrots,\n    but now you need to eat more carrots\
    \ to complete the day's meals.\n    You should return an array of [ total number\
    \ of eaten carrots after your meals,\n                                    the\
    \ number of carrots left after your meals ]\n    if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n   \
    \ \n    Example:\n    * findMeals([5, 6, 10], 6) -> [11, 4]\n    * findMeals([4,\
    \ 8, 9], 10) -> [12, 1]\n    * findMeals([1, 10, 10], 11) -> [11, 0]\n    * findMeals([2,\
    \ 11, 5], 7) -> [7, 0]\n    \n    Variables:\n    @meals : Vector{Int64}\n   \
    \     the meals that you have eaten.\n    @carrots : integer\n        the number\
    \ of carrots that you have eaten.\n    \n    Constrain:\n    * 0 <= meals <= 1000\n\
    \    * 0 <= carrots <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphqpwatzi.jl:55\nin expression starting at\
    \ /tmp/tmphqpwatzi.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0 \n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n    meals[1] =\
    \ need\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = number\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n    carrots_left_after_meals_left[1]\
    \ = remaining\n    carrots_left_after_meals_left[2] = 0\n    \n    carrots_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals[1] = number\n\
    \    carrots_left_after_meals_left_after_meals[2] = 0\n    \n    carrots_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left[1] = remaining\n\
    \    carrots_left_after_meals_left_after_meals_left[2] = 0\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = remaining\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = 0\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals_left_after_meals_left_after_meal\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1xyh3wjb.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1xyh3wjb.jl:1\n\
    in expression starting at /tmp/tmp1xyh3wjb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1:2]\n    \n\
    \    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrot\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3m04k8ko.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3m04k8ko.jl:1\n\
    in expression starting at /tmp/tmp3m04k8ko.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    if number <= 0 || need <= 0 || remaining <= 0\n        return Vector{Int64}()\n\
    \    end\n    \n    carrots = number\n    need = need - carrots\n    remaining\
    \ = remaining - carrots\n    \n    if remaining <= 0\n        return Vector{Int64}(carrots,\
    \ 0)\n    end\n    \n    carrots = carrots + need\n    \n    return Vector{Int64}(carrots,\
    \ remaining)\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function called eat_all that takes in an array of integers\
    \ and returns an array of the same length with the number of carrots eaten for\
    \ each meal. \nThe function should return an empty array if there are no carrots\
    \ left.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnln7cwpc.jl:47\nin expression starting at\
    \ /tmp/tmpnln7cwpc.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpox6mrfw9.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpox6mrfw9.jl:1\n\
    in expression starting at /tmp/tmpox6mrfw9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        return [need, remaining]\n    elseif number >\
    \ remaining\n        return [number, 0]\n    elseif number == remaining\n    \
    \    return [number, 0]\n    else\n        \n        \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqkp720vc.jl:41\nin expression starting at\
    \ /tmp/tmpqkp720vc.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    end\n    if need < 0 || need > 1000 \n        error(\"need\
    \ must be between 0 and 1000\")\n    end\n    if remaining < 0 || remaining >\
    \ 1000 \n        error(\"remaining must be between 0 and 1000\")\n    end\n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpa_t1abeb.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa_t1abeb.jl:1\n\
    in expression starting at /tmp/tmpa_t1abeb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = need\n    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n\
    \    meals[2] = 0\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    meals = meals[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    meals = meals[2:end]\n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6zddmfnf.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6zddmfnf.jl:1\n\
    in expression starting at /tmp/tmp6zddmfnf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < 0\n  \
    \      Vector{Int64}()\n    elseif remaining == 0\n        Vector{Int64}([need,\
    \ 0])\n    elseif remaining < need\n        Vector{Int64}([need, 0])\n    else\n\
    \        Vector{Int64}([need, number])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\n    You have a list of numbers, and you need to find the largest number\
    \ in the list.\n    \n    Example:\n    * largest([5, 6, 10, 9, 2, 3]) -> 9\n\
    \    * largest([5, 6, 10, 9, 2, 3]) -> 10\n    * largest([5, 6, 10, 9, 2, 3])\
    \ -> 6\n    \n    Variables:\n    @numbers : array of integers\n        the list\
    \ of numbers that you need to find the largest number of.\n    \n    Constrain:\n\
    \    * numbers is an array of integers\n    * numbers is non-empty\n    * numbers\
    \ is sorted\n    * numbers is non-decreasing\n    \n    Have fun :)\n    \"\"\"\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt_lu_u_y.jl:42\nin expression starting at\
    \ /tmp/tmpt_lu_u_y.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be non-negative\")\n    elseif need < 0\n        error(\"\
    need must be non-negative\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be non-negative\")\n    else\n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"\n    You have a certain\
    \ number of carrots, and you have a certain number of meals.\n    You want to\
    \ eat as many carrots as possible, but you only have one meal left.\n    \n  \
    \  Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n \
    \   * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @meals : integer\n        the number of meals that you have left.\n    \n\
    \    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= meals <= 1000\n    \n \
    \   Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3g2pijm5.jl:42\nin expression starting at\
    \ /tmp/tmp3g2pijm5.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number < 0\n     \
    \   error(\"number must be positive\")\n    elseif need < 0\n        error(\"\
    need must be positive\")\n    elseif remaining < 0\n        error(\"remaining\
    \ must be positive\")\n    elseif number > remaining\n        error(\"number must\
    \ be less than remaining\")\n    elseif need > remaining\n        error(\"need\
    \ must be less than remaining\")\n    elseif number == need\n        Vector{Int64}([number,\
    \ 0])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    You have a certain number of carrots, and\
    \ you need to eat some more.\n    You will eat as many carrots as you can until\
    \ you run out of carrots to eat,\n    but you will be hungry for a certain number\
    \ of minutes.\n    \n    Example:\n    * eat(3, 10, 5) -> [7, 0]\n    * eat(3,\
    \ 10, 0) -> [7, 0]\n    * eat(3, 10, -1) -> [7, 0]\n    * eat(3, 10, -2) -> [7,\
    \ 0]\n    * eat(3, 10, -3) -> [7, 0]\n    * eat(3, 10, -4) -> [7, 0]\n    * eat(3,\
    \ 10, -5) -> [7, 0]\n    * eat(3, 10, -6) -> [7, 0]\n    * eat(3, 10, -7) -> [7,\
    \ 0]\n    * eat(3, 10, -8) -> [7, 0]\n    * eat(3, 10, -9) -> [7, 0]\n    * eat(3,\
    \ 10, -10) -> [7, 0]\n    * eat(3, 10, -11) -> [7, 0]\n    * eat(3, 10, -12) ->\
    \ [7, 0]\n    * eat(3, 10, -13) -> [7, 0]\n    * eat(3, 10, -14) -> [7, 0]\n \
    \   * eat(3, 10, -15) -> [7, 0]\n    * eat(3, 10, -16) -> [7, 0]\n    * eat(3,\
    \ 10, -17) -> [7, 0]\n    * eat(3, 10, -18) -> [7, 0]\n    * eat(3, 10, -19) ->\
    \ [7, 0]\n    * eat(3, 10, -20) -> [7, 0]\n    * eat(3, 10, -21) -> [7, 0]\n \
    \   * eat(3, 10, -22) -> [7, 0]\n    * eat(3, 10, -23) -> [7, 0]\n    * eat(3,\
    \ 10, -24) -> [7, 0]\n    * eat(3, 10, -25) -> [7, 0]\n    * eat(3, 10, -26) ->\
    \ [7, 0]\n    * eat(3, 10, -27) -> [7, 0]\n    * eat(3, 10, -28) -> [7, 0]\n \
    \   * eat(3, 10, -29) -> [7, 0]\n    * eat(3, 10, -30) -> [7, 0]\n    * eat(3,\
    \ \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7vjk4j3m.jl:48\nin expression starting at\
    \ /tmp/tmp7vjk4j3m.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0\n        error(\"Invalid\
    \ input\")\n    end\n    \n    meals = Vector{Int64}()\n    \n    while remaining\
    \ > 0\n        meals.push(number)\n        number -= 1\n        remaining -= 1\n\
    \    end\n    \n    meals.push(need)\n    \n    return meals\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=juli\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi23r6ndp.jl:46\nin expression starting at\
    \ /tmp/tmpi23r6ndp.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n \
    \       Vector{Int64}([need, number-remaining])\n    end\nend\n</cell>\n<code\
    \ language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways to arrange a collection of n items in m containers.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpleurrt28.jl:36\nin expression starting at\
    \ /tmp/tmpleurrt28.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp09bq15e8.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp09bq15e8.jl:1\n\
    in expression starting at /tmp/tmp09bq15e8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqbi03n7r.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqbi03n7r.jl:1\n\
    in expression starting at /tmp/tmpqbi03n7r.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < 0\n  \
    \      Vector{Int64}()\n    elseif number < need\n        Vector{Int64}()\n  \
    \  else\n        Vector{Int64}(remaining, number - need)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of ways to arrange a certain number of items in an array.\
    \ \nThe items can be any type, and each item can only occur once.\nThe function\
    \ should return an array of integers.\nThe first element of the array should be\
    \ the total number of ways to arrange the items in the array.\nThe second element\
    \ of the array should be the total number of ways to arrange the items in the\
    \ array in any order.\nThe third element of the array should be the total number\
    \ of ways to arrange the items in the array in any order.\nThe fourth element\
    \ of the array should be the total number of ways to arrange the items in the\
    \ array in any order.\nThe fifth element of the array should be the total number\
    \ of ways to arrange the items in the array in any order.\nThe sixth element of\
    \ the array should be the total number of ways to arrange the items in the array\
    \ in any order.\nThe seventh element of the array should be the total number of\
    \ ways to arrange the items in the array in any order.\nThe eighth element of\
    \ the array should be the total number of ways to arrange the items in the array\
    \ in any order.\nThe ninth element of the array should be the total number of\
    \ ways to arrange the items in the array in any order.\nThe tenth element of the\
    \ array should be the total number of ways to arrange the items in the array in\
    \ any order.\nThe eleventh element of the array should be the total number of\
    \ ways to arrange the items in the array in any order.\nThe twelfth element of\
    \ the array should be the total number of ways to arrange the items in the array\
    \ in any order.\nThe thirteenth element of the array should be the total number\
    \ of ways to arrange the items in the array in any order.\nThe fourteenth element\
    \ of the array should be the total number of ways to arrange the items in the\
    \ array in any order.\nThe fifteenth element of the array should be the total\
    \ number of ways to arrange the items in the array in any order.\nThe sixteenth\
    \ element of the array should be the total number of ways to arrange the items\
    \ in the array in any order.\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp00mrkukk.jl:40\nin expression starting at\
    \ /tmp/tmp00mrkukk.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = 0\n  \
    \  \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n   \
    \ carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64, 2)\n\
    \    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = carrots_left_after_meals[1]\n    carrots_left_after_meals_after_meals[2] =\
    \ 0\n    \n    carrots_left_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals[1] = carrots_left_after_meals_after_meals[1]\n\
    \    carrots_left_after_meals_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp38x_e84w.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp38x_e84w.jl:1\n\
    in expression starting at /tmp/tmp38x_e84w.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining])\n    elseif\
    \ remaining == 0\n        Vector{Int64}([number, 0])\n    elseif number > need\n\
    \        Vector{Int64}([number, remaining])\n    else\n        Vector{Int64}([number,\
    \ remaining - number])\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\
    \"\n    meals() -> a function that returns the number of meals left in the day\n\
    \    \n    Example:\n    * meals() -> 10\n    * meals() -> 0\n    \n    Variables:\n\
    \    no input\n    \n    Constrain:\n    * no output\n    * no side effects\n\"\
    \"\"\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi0wh66t4.jl:40\nin expression starting at\
    \ /tmp/tmpi0wh66t4.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n   \
    \ carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n\
    \    meals[2] = remaining\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = remaining\n    \n    meals_left = zeros(Int64,\
    \ 2)\n    meals_left[1] = remaining\n    meals_left[2] = remaining\n    \n   \
    \ carrots_left_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals[2] = remaining\n    \n    meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals[1] = remaining\n    meals_left_after_meals[2]\
    \ = remaining\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n   \
    \ carrots_left_after_meals_left[1] = remaining\n    carrots_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left = zeros(Int64, 2)\n    meals_left_after_meals_left[1]\
    \ = remaining\n    meals_left_after_meals_left[2] = remaining\n    \n    carrots_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals[1] = remaining\n\
    \    carrots_left_after_meals_left_after_meals[2] = remaining\n    \n    meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals[1] = remaining\n\
    \    meals_left_after_meals_left_after_meals[2] = remaining\n    \n    carrots_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left[1] = remaining\n\
    \    carrots_left_after_meals_left_after_meals_left[2] = remaining\n    \n   \
    \ meals_left_after_meals_left_after_meals_left = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left[1]\
    \ = remaining\n    meals_left_after_meals_left_after_meal\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3m4nrkag.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3m4nrkag.jl:1\n\
    in expression starting at /tmp/tmp3m4nrkag.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpprbnq6af.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpprbnq6af.jl:1\n\
    in expression starting at /tmp/tmpprbnq6af.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = 0\n    meals_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots[1] -= meals[1]\n        meals[1]\
    \ -= 1\n        \n        if carrots[1] == 0\n            meals[2] += 1\n    \
    \        carrots[2] += meals[2]\n        end\n        \n        if meals_left[1]\
    \ > 0\n            meals_left[1] -= 1\n            meals_left[2] += 1\n      \
    \  end\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n integers in an array such that each number appears exactly\
    \ once and each number is less than or equal to its neighbors.\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd35jmz6x.jl:63\nin expression starting at\
    \ /tmp/tmpd35jmz6x.jl:63\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    \n    if number == 0 && need == 0 && remaining\
    \ > 0\n        return Vector{Int64}(remaining, 0)\n    end\n    \n    if number\
    \ == 0 && need > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n\
    \    end\n    \n    if number == 0 && need > 0 && remaining > 0\n        return\
    \ Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need == 0 && remaining\
    \ == 0\n        return Vector{Int64}()\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining > 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining == 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining > 0\n   \
    \     return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n\
    \    if number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0,\
    \ need)\n    end\n    \n    if number == 0 && need == 0 && remaining == 0\n  \
    \      return Vector{Int64}(0, need)\n    end\n    \n    if number == 0 && \n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe18v5wr0.jl:1\nin expression starting at /tmp/tmpe18v5wr0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    else\n      \
    \  Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n items in k containers.\nThe containers are represented\
    \ by an array of n integers called containers.\nThe items are represented by an\
    \ array of n integers called items.\nThe function should return an array of integers\
    \ called results.\nThe function should return an empty array if n is less than\
    \ or equal to 0.\nThe function should return an empty array if k is less than\
    \ or equal to 0.\nThe function should return an empty array if n is greater than\
    \ or equal to k.\nThe function should return an empty array if n is not divisible\
    \ by k.\nThe function should return an empty array if k is not divisible by n.\n\
    The function should return an empty array if n is not divisible by k.\nThe function\
    \ should return an empty array if k is not divisible by n.\nThe function should\
    \ return an empty array if k is greater than or equal to n.\nThe function should\
    \ return an empty array if k is greater than n.\nThe function should return an\
    \ empty array if k is greater than or equal to n.\nThe function should return\
    \ an empty array if k is less than or equal to n.\nThe function should return\
    \ an empty array if k is less than n.\nThe function should return an empty array\
    \ if k is less than or equal to n.\nThe function should return an empty array\
    \ if k is greater than or equal to n.\nThe function should return an empty array\
    \ if k is greater than n.\nThe function should return an empty array if k is greater\
    \ than or equal to n.\nThe function should return an empty array if k is less\
    \ than or equal to n.\nThe function should return an empty array if k is less\
    \ than n.\nThe function should return an empty array if k is less than or equal\
    \ to n.\nThe function should return an empty array if k is greater than or equal\
    \ to n.\nThe function should return an empty array if k is greater than n.\nThe\
    \ function should return an empty array if k is greater than or equal to n.\n\
    The function should return an empty array if k is less than or equal to n.\nThe\
    \ function should return an empty array if k is less than n.\nThe function should\
    \ return an empty array if k is less than or equal to n.\nThe function should\
    \ return \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv80je9p2.jl:36\nin expression starting at\
    \ /tmp/tmpv80je9p2.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}([need, remaining])\n    else\n \
    \       Vector{Int64}([need, number])\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn_d_f7o0.jl:36\nin expression starting at\
    \ /tmp/tmpn_d_f7o0.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining\
    \ > 0 && remaining <= 1000\n        answer = []\n        carrots = number\n  \
    \      carrots_left = remaining\n        while carrots > 0\n            carrots_left\
    \ -= 1\n            push!(answer, carrots)\n            carrots -= need\n    \
    \    end\n        return answer\n    else\n        error(\"Invalid input\")\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(100, 100, 100)\n</cell>\n<text>\nExercise 2\nWrite a function called hungry_rabbit\
    \ that takes two integers representing a number of carrots and a number of meals,\
    \ and returns an array of two integers representing the number of carrots left\
    \ after your meals and the number of carrots eaten after your meals.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppdrgazql.jl:44\nin expression starting at\
    \ /tmp/tmppdrgazql.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif number > remaining\n\
    \        Vector{Int64}(remaining, 0)\n    elseif need == 0\n        Vector{Int64}(0,\
    \ number)\n    else\n        Vector{Int64}(remaining, number - need)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns the number of days left in a meal plan.\nThe function should take\
    \ in two arguments: the number of days that you have left to eat, and the number\
    \ of days that you need to eat.\nThe function should return an array of two integers,\
    \ the first being the number of days left in the meal plan, and the second being\
    \ the number of days that you need to eat.\nThe function should return an empty\
    \ array if there is not enough remaining days to complete the meal plan.\nThe\
    \ function should return an empty array if there is not enough remaining days\
    \ to complete the meal plan.\nThe function should return an empty array if there\
    \ is not enough remaining days to complete the meal plan.\nThe function should\
    \ return an empty array if there is not enough remaining days to complete the\
    \ meal plan.\nThe function should return an empty array if there is not enough\
    \ remaining days to complete the meal plan.\nThe function should return an empty\
    \ array if there is not enough remaining days to complete the meal plan.\nThe\
    \ function should return an empty array if there is not enough remaining days\
    \ to complete the meal plan.\nThe function should return an empty array if there\
    \ is not enough remaining days to complete the meal plan.\nThe function should\
    \ return an empty array if there is not enough remaining days to complete the\
    \ meal plan.\nThe function should return an empty array if there is not enough\
    \ remaining days to complete the meal plan.\nThe function should return an empty\
    \ array if there is not enough remaining days to complete the meal plan.\nThe\
    \ function should return an empty array if there is not enough remaining days\
    \ to complete the meal plan.\nThe function should return an empty array if there\
    \ is not enough remaining days to complete the meal plan.\nThe function should\
    \ return an empty array if there is not enough remaining days to complete the\
    \ meal plan.\nThe function should return an empty array if there is not enough\
    \ remaining days to complete the meal plan.\nThe function should return an empty\
    \ array if there is not enough \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw31b8xyr.jl:40\nin expression starting at\
    \ /tmp/tmpw31b8xyr.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7: Sum square difference\nGiven an array of integers, find the sum of\
    \ square differences between the array elements.\nThe sum of square differences\
    \ is defined as the square of the absolute value of the difference between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum of the squares of the differences between the\
    \ array elements.\nThe sum of square differences is the sum of the squares of\
    \ the differences between the array elements.\nThe sum of square differences is\
    \ the sum of the squares of the differences between the array elements.\nThe sum\
    \ of square differences is the sum\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr_lc828j.jl:36\nin expression starting at\
    \ /tmp/tmpr_lc828j.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"Invalid input\") \n    else \n   \
    \     Vector{Int64}([number, need, remaining]) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function called eat_all that\
    \ takes in an array of integers and returns the number of carrots left after eating\
    \ all meals.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaqzzb8es.jl:36\nin expression starting at\
    \ /tmp/tmpaqzzb8es.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0\n        \n        \n     \
    \   \n        \n        \n        \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl30h31ld.jl:1\nin expression starting at /tmp/tmpl30h31ld.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    elseif remaining < need\n\
    \        Vector{Int64}(remaining, 0)\n    else\n        Vector{Int64}(number,\
    \ 0)\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqei0wt1v.jl:38\nin expression starting at\
    \ /tmp/tmpqei0wt1v.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = 0\n  \
    \  \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = 0\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        if carrots[1] > 0\n            carrots[1]\
    \ -= meals[1]\n            meals[1] -= 1\n            carrots_left[1] += meals[1]\n\
    \            meals[1] -= 1\n        end\n        if carrots[2] > 0\n         \
    \   carrots[2] -= meals[2]\n            meals[2] -= 1\n            carrots_left[2]\
    \ += meals[2]\n            meals[2] -= 1\n        end\n    end\n    \n    return\
    \ carrots_left\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgfq7hmwu.jl:63\nin expression starting at\
    \ /tmp/tmpgfq7hmwu.jl:63\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        error(\"\
    Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1]\
    \ = number\n    carrots[2] = need\n    \n    carrots[2] = carrots[2] - carrots[1]\n\
    \    \n    if carrots[2] < 0\n        carrots[2] = 0\n    end\n    \n    if carrots[1]\
    \ > 0\n        carrots[1] = carrots[1] - carrots[2]\n    end\n    \n    if carrots[1]\
    \ < 0\n        carrots[1] = 0\n    end\n    \n    return carrots\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzmo7u2uv.jl:54\nin expression starting at\
    \ /tmp/tmpzmo7u2uv.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 \n        error(\"number should be less than 1000\")\n\
    \    else if need > 1000 \n        error(\"need should be less than 1000\")\n\
    \    else if remaining > 1000 \n        error(\"remaining should be less than\
    \ 1000\")\n    else if number == 0 \n        error(\"number should be greater\
    \ than 0\")\n    else if need == 0 \n        error(\"need should be greater than\
    \ 0\")\n    else if remaining == 0 \n        error(\"remaining should be greater\
    \ than 0\")\n    else if number > need \n        error(\"number should be less\
    \ than need\")\n    else if number > remaining \n        error(\"number should\
    \ be less than remaining\")\n    else if number < 0 \n        error(\"number should\
    \ be greater than 0\")\n    else if need < 0 \n        error(\"need should be\
    \ greater than 0\")\n    else if remaining < 0 \n        error(\"remaining should\
    \ be greater than 0\")\n    else if number == need \n        error(\"need should\
    \ be equal to number\")\n    else if number == remaining \n        error(\"remaining\
    \ should be equal to number\")\n    else if number == 0 \n        error(\"number\
    \ should be greater than 0\")\n    else if need == 0 \n        error(\"need should\
    \ be greater than 0\")\n    else if remaining == 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number > need \n        error(\"number\
    \ should be less than need\")\n    else if number > remaining \n        error(\"\
    number should be less than remaining\")\n    else if number < 0 \n        error(\"\
    number should be greater than 0\")\n    else if need < 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining < 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number == need \n        error(\"need\
    \ should be equal to number\")\n    else if number == remaining \n        error(\"\
    remaining should be equal to number\")\n    else if number == 0 \n        error(\"\
    number should be greater than 0\")\n    else if need == 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining == 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number > need \n        error(\"number\
    \ should be less than need\")\n    else if number > remaining \n        error(\"\
    number should be less than remaining\")\n    else if number < 0 \n        error(\"\
    number should be greater than 0\")\n    else if need < 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining < 0 \n        error(\"remaining\
    \ should be greater than 0\")\n    else if number == need \n        error(\"need\
    \ should be equal to number\")\n    else if number == remaining \n        error(\"\
    remaining should be equal to number\")\n    else if number == 0 \n        error(\"\
    number should be greater than 0\")\n    else if need == 0 \n        error(\"need\
    \ should be greater than 0\")\n    else if remaining == 0 \n        error(\"\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb_1xip2v.jl:32\nin expression starting at\
    \ /tmp/tmpb_1xip2v.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcd0b84sr.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcd0b84sr.jl:1\n\
    in expression starting at /tmp/tmpcd0b84sr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && number <= 1000 && need > 0 && need <= 1000 && remaining\
    \ > 0 && remaining <= 1000\n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq4qdsfv0.jl:1\nin expression starting at /tmp/tmpq4qdsfv0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0\n        error(\"number must be positive\")\n    end\n\
    \    if need <= 0\n        error(\"need must be positive\")\n    end\n    if remaining\
    \ <= 0\n        error(\"remaining must be positive\")\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6096mn2u.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6096mn2u.jl:1\n\
    in expression starting at /tmp/tmp6096mn2u.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number should be between\
    \ 0 and 1000\")\n    end\n    if need < 0 || need > 1000 \n        error(\"need\
    \ should be between 0 and 1000\")\n    end\n    if remaining < 0 || remaining\
    \ > 1000 \n        error(\"remaining should be between 0 and 1000\")\n    end\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2gt_cpb_.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2gt_cpb_.jl:1\n\
    in expression starting at /tmp/tmp2gt_cpb_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining])\n    elseif\
    \ number == need \n        Vector{Int64}([number, remaining])\n    elseif number\
    \ > need \n        Vector{Int64}([number, remaining])\n    elseif number < need\
    \ \n        Vector{Int64}([need, remaining])\n    elseif remaining == 0\n    \
    \    Vector{Int64}([number, 0])\n    else\n        Vector{Int64}([number, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n\
    <code language=julia-1.0>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmvtdsth9.jl:44\nin expression starting at\
    \ /tmp/tmpmvtdsth9.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    You\
    \ have a certain number of carrots, and you know that there are only two kinds\
    \ of carrots:\n    \n    carrots and non-carrots.\n    \n    You want to eat as\
    \ many carrots as possible, without eating non-carrots.\n    \n    You want to\
    \ eat as many non-carrots as possible, without eating carrots.\n    \n    You\
    \ want to eat as many carrots as possible, without eating non-carrots.\n    \n\
    \    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating carrots.\n\
    \    \n    You want to eat as many carrots as possible, without eating non-carrots.\n\
    \    \n    You want to eat as many non-carrots as possible, without eating car\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6p1a03pg.jl:36\nin expression starting at\
    \ /tmp/tmp6p1a03pg.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        answer = []\n   \
    \     carrots = number\n        carrots_left = remaining\n        while carrots\
    \ > 0 && carrots_left > 0 \n            carrots_left -= 1\n            carrots\
    \ -= 1\n            push!(answer, carrots)\n        end\n        push!(answer,\
    \ carrots)\n        answer\n    else\n        error(\"Invalid input\")\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 7: Sum square difference\n\
    You are given an array of integers $x$ and an integer $n$. Your task is to find\
    \ the sum of square differences between each pair of consecutive elements in the\
    \ array. \nThe sum of square differences is the sum of the squares of the differences\
    \ between consecutive elements in the array. \nFor example, if the array is [4,\
    \ 6, 9, 10, 12] and $n=2$, the sum of square differences is $10 + 12 - 9 + 6 +\
    \ 4 = 42$. \nWrite a function that returns the sum of square differences between\
    \ consecutive elements in the array.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3qh9pvv4.jl:45\nin expression starting at\
    \ /tmp/tmp3qh9pvv4.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0 \n        Vector{Int64}([need, remaining])\n    else\n\
    \        Vector{Int64}([number, need])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function called hungry that takes\
    \ in an array of integers and returns true if the array is hungry, false otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_7nn2lp6.jl:36\nin expression starting at\
    \ /tmp/tmp_7nn2lp6.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else if number ==\
    \ 0 \n        Vector{Int64}([need, remaining])\n    else if number > need \n \
    \       Vector{Int64}([number, need])\n    else if number > remaining \n     \
    \   Vector{Int64}([number, remaining])\n    else \n        Vector{Int64}([number,\
    \ need])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkrvs097b.jl:32\nin expression starting at\
    \ /tmp/tmpkrvs097b.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 \n        error(\"number must be between\
    \ 0 and 1000\")\n    else if need < 0 || need > 1000 \n        error(\"need must\
    \ be between 0 and 1000\")\n    else if remaining < 0 || remaining > 1000 \n \
    \       error(\"remaining must be between 0 and 1000\")\n    else \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfb8ub5xd.jl:32\nin expression starting at\
    \ /tmp/tmpfb8ub5xd.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1:2]\n    \n\
    \    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrots_left[1:2]\n\
    \    \n    carrots_left = carrots_left[1:2]\n    \n    carrots_left = carrot\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpizynl2pd.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpizynl2pd.jl:1\n\
    in expression starting at /tmp/tmpizynl2pd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    \n    \n    if number > 0 && need > 0 && remaining > 0 \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7t4hmdtg.jl:1\nin expression starting at /tmp/tmp7t4hmdtg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 \n        error(\"invalid input\") \n    else \n   \
    \     Vector{Int64}([number, need, remaining]) \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1wnwcevx.jl:36\nin expression starting at\
    \ /tmp/tmp1wnwcevx.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 0 && need > 0 && remaining > 0 \n        carrots = number\n\
    \        carrots_left = remaining\n        meals = Vector{Int64}()\n        while\
    \ carrots > 0 \n            carrots_left -= 1\n            meals << carrots_left\n\
    \            carrots -= need\n        end\n        return meals\n    else\n  \
    \      return Vector{Int64}()\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 7: Sum square difference\nThe sum of the squares\
    \ of the first ten natural numbers is,\n1^2 + 2^2 + ... + 10^2 = 385\nThe square\
    \ of the sum of the first ten natural numbers is,\n(1 + 2 + ... + 10)^2 = 55^2\
    \ = 3025\nHence the difference between the sum of the squares of the first ten\
    \ natural numbers and the square of the sum is 3025 - 385 = 2640.\nFind the difference\
    \ between the sum of the squares of the first one hundred natural numbers and\
    \ the square of the sum.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp038e67d4.jl:44\nin expression starting at\
    \ /tmp/tmp038e67d4.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = number\n    meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals = zeros(Int64, 2)\n    meals_left_after_meals[1]\
    \ = number\n    meals_left_after_meals[2] = remaining\n    \n    meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left[1] = number\n    meals_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals = zeros(Int64,\
    \ 2)\n    meals_left_after_meals_left_after_meals[1] = number\n    meals_left_after_meals_left_after_meals[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals_left = zeros(Int64,\
    \ 2)\n    meals_left_after_meals_left_after_meals_left[1] = number\n    meals_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    meals_left_after_meals_left_after_meals_left_after_meals[2] =\
    \ remaining\n    \n    meals_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = number\n    meals_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = remaining\n    \n    meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = number\n    meals_left_after_me\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpoey7d8_f.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpoey7d8_f.jl:1\n\
    in expression starting at /tmp/tmpoey7d8_f.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"invalid input\"\
    )\n    end\n    if number == 0 && need == 0 && remaining == 0\n        return\
    \ Vector{Int64}()\n    end\n    if number == 0 && need == 0 && remaining > 0\n\
    \        return Vector{Int64}(remaining, 0)\n    end\n    if number == 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    if\
    \ number == 0 && need > 0 && remaining > 0\n        return Vector{Int64}(0, need)\n\
    \    end\n    if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    if number > 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    if number > 0 && need > 0 && remaining\
    \ == 0\n        return Vector{Int64}(number, need)\n    end\n    if number > 0\
    \ && need > 0 && remaining > 0\n        return Vector{Int64}(number, need)\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    findMeals(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64}\n    \n    You have a certain\
    \ number of carrots, and you know that you will need more carrots to complete\
    \ the day's meals.\n    You want to find out how many carrots you will need in\
    \ order to complete the meals.\n    \n    Variables:\n    @number : integer\n\
    \        the number of carrots that you have eaten.\n    @need : integer\n   \
    \     the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpey8w2toq.jl:58\nin expression starting at\
    \ /tmp/tmpey8w2toq.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number == 0\n        Vector{Int64}()\n    else\n        Vector{Int64}([number,\
    \ need-number])\n    end\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n  \
    \  You have a list of meals, and you need to eat as many as you can to finish\
    \ them.\n    \n    Example:\n    * eat([ \"pizza\", \"burger\", \"fries\", \"\
    ice cream\" ], 3) -> [ \"pizza\", \"burger\", \"fries\" ]\n    * eat([ \"pizza\"\
    , \"burger\", \"fries\", \"ice cream\" ], 2) -> [ \"pizza\", \"burger\" ]\n  \
    \  * eat([ \"pizza\", \"burger\", \"fries\", \"ice cream\" ], 1) -> [ \"pizza\"\
    \ ]\n    * eat([ \"pizza\", \"burger\", \"fries\", \"ice cream\" ], 0) -> []\n\
    \    \n    Variables:\n    @meals : Array{String}\n        the meals that you\
    \ have.\n    @number : integer\n        the number of meals that you need to eat.\n\
    \    \n    Constrain:\n    * 0 <= number <= length(meals)\n    * 0 <= number <=\
    \ length(meals)\n    \n    Have fun :)\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr6ynsj0w.jl:36\nin expression starting at\
    \ /tmp/tmpr6ynsj0w.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || need < 0 || remaining < 0\n        error(\"Invalid input\"\
    )\n    end\n    if remaining == 0\n        return Vector{Int64}([number, need])\n\
    \    end\n    \n    carrots = number\n    need = need - carrots\n    remaining\
    \ = remaining - carrots\n    \n    carrots = carrots + eat(number, need, remaining)\n\
    \    \n    return Vector{Int64}([carrots, remaining])\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpis197q0l.jl:45\nin expression starting at\
    \ /tmp/tmpis197q0l.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = need\n    \n    carrots_left = carrots_left[1]\n    \n \
    \   carrots_left = carrots_left[2]\n    \n    carrots_left = carrots_left\n  \
    \  \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = carrots_left\n    \n    carrots_left = carrots_left\n\
    \    \n    carrots_left = \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprbyy3q7a.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprbyy3q7a.jl:1\n\
    in expression starting at /tmp/tmprbyy3q7a.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n \
    \   carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n\
    \    \n    meals = meals[1] + meals[2]\n    \n    carrots = carrots[1] + carrots[2]\n\
    \    \n    carrots = carrots - meals\n    \n    if carrots < 0\n        carrots\
    \ = 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp311f8138.jl:54\nin expression starting at\
    \ /tmp/tmp311f8138.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number <= 0 || need <= 0 || remaining <= 0 \n        error(\"Invalid\
    \ input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1] = number\n\
    \    carrots[2] = remaining\n    \n    meals = zeros(Int64, 2)\n    meals[1] =\
    \ need\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1]\
    \ = carrots_left_after_meals[1]\n    carrots_left_after_meals_after_meals[2] =\
    \ 0\n    \n    carrots_left_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals[1] = carrots_left_after_meals_after_meals[1]\n\
    \    carrots_left_after_meals_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = carrots_left_after_meals_after_meals[1]\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_me\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6j981r1_.jl:29\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6j981r1_.jl:1\n\
    in expression starting at /tmp/tmp6j981r1_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n \
    \   if number == 0 && remaining == 0\n        return Vector{Int64}[]\n    end\n\
    \    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n \
    \   end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining == 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining > 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number > 0 && remaining < 0\n        return Vector{Int64}[]\n\
    \    end\n    \n    if number == 0 && remaining == 0\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp9aff2mj.jl:1\nin expression starting at /tmp/tmpp9aff2mj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number > 1000 || need > 1000 || remaining > 1000\n        error(\"\
    Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n    carrots[1]\
    \ = number\n    carrots[2] = need\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpumnnl7tu.jl:115\nin expression starting at\
    \ /tmp/tmpumnnl7tu.jl:115\n"
  exit_code: 1
  status: SyntaxError
