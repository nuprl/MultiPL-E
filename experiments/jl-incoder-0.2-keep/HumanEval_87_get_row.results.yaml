name: HumanEval_87_get_row
language: julia
results:
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols = cols +\
    \ length(lst[row])\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n\
    \        coords[row] = ((rows - row(rows)), (cols - row(cols)))\n    end\n   \
    \ \n    coords = sort(coords)\n    \n    coords = coords[coords[1, 1] <= x]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_sga1gmb.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_sga1gmb.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a matrix and a vector as input, and returns the dot product of the matrix and\
    \ the vector.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6a5b09mj.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6a5b09mj.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + 1\n      \
    \  cols = cols + length(row)\n        \n        if x == row\n            \n  \
    \          return [(i, j)  for j in (1:length(row)), (1:length(row))] \n     \
    \   end\n    end\n    \n    return []\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwx1k3e2r.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwx1k3e2r.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6hq2_r5r.jl:39\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Array{Int64,1} to an object of type Int64\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n   \
    \ convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n\
    \  Stacktrace:\n   [1] convert(::Type{Tuple{Int64}}, ::Tuple{Array{Int64,1}})\
    \ at ./essentials.jl:310 (repeats 2 times)\n   [2] setindex!(::Array{Tuple{Int64,Int64},1},\
    \ ::Tuple{Int64,Array{Int64,1}}, ::Int64) at ./array.jl:826\n   [3] copyto! at\
    \ ./multidimensional.jl:962 [inlined]\n   [4] Array{Tuple{Int64,Int64},1}(::Array{Tuple{Int64,Array{Int64,1}},1})\
    \ at ./array.jl:541\n   [5] convert at ./array.jl:533 [inlined]\n   [6] get_row(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp6hq2_r5r.jl:32\n   [7] top-level scope at /tmp/tmp6hq2_r5r.jl:39\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp6hq2_r5r.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6hq2_r5r.jl:40\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] convert(::Type{Tuple{Int64}},\
    \ ::Tuple{Array{Int64,1}}) at ./essentials.jl:310 (repeats 2 times)\n   [2] setindex!(::Array{Tuple{Int64,Int64},1},\
    \ ::Tuple{Int64,Array{Int64,1}}, ::Int64) at ./array.jl:826\n   [3] copyto! at\
    \ ./multidimensional.jl:962 [inlined]\n   [4] Array{Tuple{Int64,Int64},1}(::Array{Tuple{Int64,Array{Int64,1}},1})\
    \ at ./array.jl:541\n   [5] convert at ./array.jl:533 [inlined]\n   [6] get_row(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp6hq2_r5r.jl:32\n   [7] top-level scope at /tmp/tmp6hq2_r5r.jl:40\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp6hq2_r5r.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6hq2_r5r.jl:41\n  Test threw exception\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]\n  MethodError: Cannot `convert` an object of type Array{Int64,1}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] convert(::Type{Tuple{Int64}},\
    \ ::Tuple{Array{Int64,1}}) at ./essentials.jl:310 (repeats 2 times)\n   [2] setindex!(::Array{Tuple{Int64,Int64},1},\
    \ ::Tuple{Int64,Array{Int64,1}}, ::Int64) at ./array.jl:826\n   [3] copyto! at\
    \ ./multidimensional.jl:962 [inlined]\n   [4] Array{Tuple{Int64,Int64},1}(::Array{Tuple{Int64,Array{Int64,1}},1})\
    \ at ./array.jl:541\n   [5] convert at ./array.jl:533 [inlined]\n   [6] get_row(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp6hq2_r5r.jl:32\n   [7] top-level scope at /tmp/tmp6hq2_r5r.jl:41\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp6hq2_r5r.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6hq2_r5r.jl:43\n  Test threw exception\n  Expression: candidate([[1]],\
    \ 2) == Vector{Tuple{Int64, Int64}}([])\n  MethodError: Cannot `convert` an object\
    \ of type Array{Int64,1} to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] convert(::Type{Tuple{Int64}},\
    \ ::Tuple{Array{Int64,1}}) at ./essentials.jl:310 (repeats 2 times)\n   [2] setindex!(::Array{Tuple{Int64,Int64},1},\
    \ ::Tuple{Int64,Array{Int64,1}}, ::Int64) at ./array.jl:826\n   [3] copyto! at\
    \ ./multidimensional.jl:962 [inlined]\n   [4] Array{Tuple{Int64,Int64},1}(::Array{Tuple{Int64,Array{Int64,1}},1})\
    \ at ./array.jl:541\n   [5] convert at ./array.jl:533 [inlined]\n   [6] get_row(::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp6hq2_r5r.jl:32\n   [7] top-level scope at /tmp/tmp6hq2_r5r.jl:43\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmp6hq2_r5r.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6hq2_r5r.jl:44\n  Test threw exception\n  Expression: candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Array{Array{Any,1},1},\
    \ ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Array{Array{Int64,1},1},\
    \ ::Int64) at /tmp/tmp6hq2_r5r.jl:22\n  Stacktrace:\n   [1] top-level scope at\
    \ /tmp/tmp6hq2_r5r.jl:44\n   [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [3] top-level scope at /tmp/tmp6hq2_r5r.jl:38\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      5      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6hq2_r5r.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8y8p2qal.jl:88\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8y8p2qal.jl:88\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5oijf2d_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp5oijf2d_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp5oijf2d_.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,r) in enumerate(rows)\n\
    \        for (c,c) in enumerate(cols)\n            coords[i,c] = (r,c)\n     \
    \   end\n    end\n    \n    coords = coords[coords[:,1] .== x, :]\n    \n    coords\
    \ = coords[sortperm(coords[:,2], rev=true), :]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfnm_7er5.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfnm_7er5.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpv1hrs2qq.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpv1hrs2qq.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpv1hrs2qq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        row_coords = Tuple{Int64, Int64}()\n        \n        for col in row\n\
    \            \n            if col == x\n                \n                row_coords\
    \ = Tuple(row, col)\n                \n            end\n            \n       \
    \ end\n        \n        push!(rows, row_coords)\n        \n    end\n    \n  \
    \  rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    return rows\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0ny3dnja.jl:50\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp0ny3dnja.jl:50\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplnowlx2j.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplnowlx2j.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxxhsqr3f.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxxhsqr3f.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + 1\n        \n        lst[i] = sort(lst[i])\n        \n        lst[i]\
    \ = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n        \n       \
    \ lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n        \n\
    \        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n   \
    \     \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmpwflwfwqg.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwflwfwqg.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwflwfwqg.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + row\n    \
    \    cols = cols + 1\n        \n        if rows == x\n            \n         \
    \   coord = Tuple(row-1, cols-1)\n            \n            return coord\n   \
    \     end\n    end\n    \n    return []\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4qs6x2n3.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4qs6x2n3.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = sort(row)\n        \n        if columns[end]==x\n         \
    \   push!(rows, (length(row), length(columns)))\n        end\n    end\n    \n\
    \    sort(rows)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj8s0__n5.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj8s0__n5.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + lst[row]\n        cols =\
    \ cols + lst[row, end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for row in 1:length(rows)\n\
    \        for col in 1:length(cols)\n            if rows == row && cols == col\n\
    \                coords[row, col] = 1\n            end\n        end\n    end\n\
    \    \n    coords = sort(coords, rev=true)\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3uqmm_p_.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3uqmm_p_.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp03d0m9kq.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp03d0m9kq.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = rows[cols\
    \ == x]\n    cols = cols[cols == x]\n    \n    rows = reverse(rows)\n    cols\
    \ = reverse(cols)\n    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpu59wnauw.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpu59wnauw.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x, :]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp325119ln.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp325119ln.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2f_2zpjw.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2f_2zpjw.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n        coords[row]\
    \ = ((rows - row(rows)), (cols - row(cols)))\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[coords[:, 1] .<= x]\n    coords = coords[coords[:,\
    \ 2] .>= x]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3pfduh9e.jl:48\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3pfduh9e.jl:48\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise\nWrite a\
    \ function that returns all possible combinations of length n of elements from\
    \ an input vector. For example, given [1, 2, 3], the function should return [[1,\
    \ 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]].\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6zlktyzx.jl:30\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6zlktyzx.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(1:length(lst.[1])))\n    cols =\
    \ sort(collect(1:length(lst.[1])))\n    \n    rows = sort(rows, by=x->-x)\n  \
    \  cols = sort(cols, by=x->-x)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,j) in zip(rows, cols) \n        coords[i,j] = (i,j)\n    end\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcy8a9u7t.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcy8a9u7t.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + lst[row]\n        cols =\
    \ cols + lst[row, end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols > x]\n    cols = cols[cols > x]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n   \
    \ rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpju74foab.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpju74foab.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpju74foab.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        for (c,col) in enumerate(cols)\n\
    \            coords[i,c] = Tuple(row, col)\n        end\n    end\n    \n    coords\
    \ = sort(coords, by=x->x[1])\n    coords = sort(coords, by=x->x[2])\n    \n  \
    \  return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp14zfjggp.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp14zfjggp.jl:41\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpivtkq00i.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpivtkq00i.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpivtkq00i.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsts9qfmn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpsts9qfmn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpsts9qfmn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    cols = zeros(Int,\
    \ length(lst))\n    \n    for i = 1:length(lst)\n        cols = cols + lst[i][end]\n\
    \    end\n    \n    cols = sort(cols)\n    \n    return zip(rows, cols)\nend\n\
    </cell>\n<code language=julia-1.5>\nget_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n\
    \      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns all possible combinations\
    \ of k elements from n elements.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcbgvwf5x.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcbgvwf5x.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeh3xs6a7.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpeh3xs6a7.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpeh3xs6a7.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqw_ihhgi.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpqw_ihhgi.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpqw_ihhgi.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(cols)\n            if lst[row][c] == x\n                coords[i,c]\
    \ = (c,row)\n            end\n        end\n    end\n    \n    coords = coords[sortperm(coords[:,1]),\
    \ :]\n    coords = coords[sortperm(coords[:,2]), :]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe7d2ocv3.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe7d2ocv3.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdv8fdbce.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdv8fdbce.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols = cols +\
    \ length(lst[row])\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n\
    \        coords[row] = ((rows - row(rows)), (cols - row(cols)))\n    end\n   \
    \ \n    coords = sort(coords)\n    \n    coords = coords[coords[1, 1] <= x]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplq6f4z9i.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplq6f4z9i.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        for col in cols\n            if\
    \ lst[row][col] == x\n                push!(coords, Tuple{row, col})\n       \
    \     end\n        end\n    end\n    \n    coords = sort(coords, by=(x->x[1],\
    \ x->x[2]))\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzm9o04x6.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzm9o04x6.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = ((rows[i] - 1), (length(lst[i]) - 1))\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that finds all the coordinates of x in a nested list.\nFor example,\
    \ get_coords([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nHint: use get_row and\
    \ get_col functions to solve this problem.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnj40qr91.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnj40qr91.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,1] .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n\
    \    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,1] .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgqsnln8d.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpgqsnln8d.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpgqsnln8d.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4zp9i1ae.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4zp9i1ae.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    end\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9w_3pdnr.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9w_3pdnr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9w_3pdnr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        (0, 0)\n    else\n        (x, y) = get_row(lst[x - 1], lst[x\
    \ - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x,\
    \ y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_blfrrcy.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_blfrrcy.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdf_noa3x.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdf_noa3x.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = rows[i], lst[i][x]\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9azvc8f3.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9azvc8f3.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[2:end]\n    \n    coords = reverse(coords)\n    \n\
    \    coords = coords[2:end]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2xjtey90.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2xjtey90.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpevtwye8z.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpevtwye8z.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwfu824n5.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwfu824n5.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i]\n        cols = cols\
    \ + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n   \
    \ coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[2:end-1, 2:end-1]\n    \n    coords = coords[coords[1,\
    \ 1] == x, :]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_7hlpsar.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_7hlpsar.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzl4i7f9m.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzl4i7f9m.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzl4i7f9m.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp405mdfap.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp405mdfap.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp405mdfap.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        for j, (col) in enumerate(cols)\n\
    \            if lst[row][col] == x\n                coords[i][j] = (i,j)\n   \
    \         end\n        end\n    end\n    \n    coords = sort(coords, by=x->x[1],\
    \ rev=true)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf0j39r0v.jl:31\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf0j39r0v.jl:31\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        rows[i] = row\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for (i,col) in enumerate(reverse(rows))\n\
    \        columns[i] = col\n    end\n    \n    columns = sort(columns)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,coord) in enumerate(zip(rows,\
    \ columns))\n        coords[i] = coord\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[coords[:,1] .<= x]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjqd1lo8u.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjqd1lo8u.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5kkd351x.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp5kkd351x.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp5kkd351x.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpam2n0_2d.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpam2n0_2d.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpam2n0_2d.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    return [(rows[i], cols[i]) for i in 1:length(lst)]\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7w8gpw2w.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7w8gpw2w.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + row\n    \
    \    cols = cols + 1\n        \n        if rows == x\n            \n         \
    \   coords = Tuple{Int64, Int64}(i, cols-1)\n            \n            return\
    \ [(coords, coords)]\n        end\n    end\n    \n    return []\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa1iqo2xu.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa1iqo2xu.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   rows = rows + 1\n        \n        cols = zeros(Int, length(lst[row]))\n \
    \       \n        for col in 1:length(lst[row])\n            cols = cols + 1\n\
    \            \n            if lst[row][col] == x\n                \n         \
    \       tup = Tuple{Int64, Int64}((row, cols))\n                \n           \
    \     if tup < lst[end]\n                    lst[end] = tup\n                end\n\
    \                \n                if tup > lst[end]\n                    lst[end]\
    \ = tup\n                end\n                \n            end\n        end\n\
    \    end\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd7wzx_3k.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd7wzx_3k.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n        coords[row]\
    \ = ((rows - 1) - row) * length(lst[row]) + cols[row]\n    end\n    \n    coords\
    \ = sort(coords)\n    \n    coords = coords[coords <= length(lst, 1)]\n    \n\
    \    coords = coords[coords <= x]\n    \n    coords = coords[coords > 0]\n   \
    \ \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphpqbc6yz.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphpqbc6yz.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for row in rows\n        for col in cols\n        \
    \    coords[row, col] = ((row, col), lst[row][col])\n        end\n    end\n  \
    \  \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe5evnj3i.jl:35\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe5evnj3i.jl:35\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,j) in zip(rows, cols)\n        coords[i,j] =\
    \ (i,j)\n    end\n    \n    coords = sort(coords, by=x->x[1], rev=true)\n    coords\
    \ = sort(coords, by=x->x[2], rev=true)\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp59cf4ysy.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp59cf4ysy.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpq9ys7zb5.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpq9ys7zb5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpq9ys7zb5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp72xlbxxu.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp72xlbxxu.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcs3eogwn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpcs3eogwn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpcs3eogwn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(Int, length(rows),\
    \ length(cols))\n    \n    for row in rows\n        for col in cols\n        \
    \    coords[row, col] = findfirst(x->x == lst[row][col], x)\n        end\n   \
    \ end\n    \n    coords = coords[sortperm(coords[:, cols]), :]\n    coords = coords[:,\
    \ sortperm(coords[:, rows])]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2edfyzr3.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2edfyzr3.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcnsml32a.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpcnsml32a.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpcnsml32a.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpy8eixkys.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpy8eixkys.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfxm0jl9r.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfxm0jl9r.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfxm0jl9r.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    columns = sort(collect(1:length(lst)),\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwvwd9mo1.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwvwd9mo1.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwvwd9mo1.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for j, (col) in enumerate(cols)\n            if lst[row][col] == x\n\
    \                coords[i][j] = Tuple(row, col)\n            end\n        end\n\
    \    end\n    \n    coords = sort(coords, by=coords)\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl556u655.jl:28\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl556u655.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    col\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpu5b9sgzj.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpu5b9sgzj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpu5b9sgzj.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv4lktfod.jl:101\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv4lktfod.jl:101\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    return [(rows, cols)]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppmj6o353.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmppmj6o353.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpygi19tcb.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpygi19tcb.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpygi19tcb.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        lst = sort(lst[row])\n      \
    \  \n        columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            \n            columns = columns + 1\n            \n            if\
    \ lst[col] == x\n                \n                tup = Tuple{Int64, Int64}((row,\
    \ columns))\n                \n                push!(reverse(tup), tup)\n    \
    \            \n            end\n            \n        end\n        \n    end\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpuaprk2cq.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpuaprk2cq.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwxm4ljt0.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwxm4ljt0.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwxm4ljt0.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[2] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp312zpjr3.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp312zpjr3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwqyk3_70.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwqyk3_70.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwqyk3_70.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4rivct59.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp4rivct59.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp4rivct59.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxaxekoml.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpxaxekoml.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpxaxekoml.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        columns\
    \ = columns + lst[i][end]\n    end\n    \n    columns = sort(columns)\n    \n\
    \    return zip(rows, columns)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn4s4pilb.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn4s4pilb.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + 1\n      \
    \  cols = cols + length(row)\n        \n        for j in 1:length(row)\n     \
    \       if row[j] == x\n                \n                tup = Tuple(rows[i],\
    \ cols[j])\n                \n                push!(tups, tup)\n             \
    \   \n            end\n        end\n    end\n    \n    sort(tups, rev=true)\n\
    \    \nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6yhrncxn.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6yhrncxn.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwqcerxu7.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwqcerxu7.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwqcerxu7.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        coords = coords + [(row, cols[cols..end])]\n\
    \    end\n    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5q1__ga7.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp5q1__ga7.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgk2hjdyp.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpgk2hjdyp.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpgk2hjdyp.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp38grr1yn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp38grr1yn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp38grr1yn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        coords[i,:] = [row, cols]\n\
    \    end\n    \n    coords = sort(coords, by=x->x[2])\n    \n    coords = coords[end:-1:1]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7y8p1rzz.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7y8p1rzz.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n  \
    \  rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkztiy4j9.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkztiy4j9.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        columns\
    \ = columns + lst[i][end]\n    end\n    \n    columns = sort(columns)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n     \
    \   coords[i] = (i-1, columns[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1ver_r0r.jl:50\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp1ver_r0r.jl:50\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        (0, 0)\n    else\n        (x, y) = get_row(lst[x - 1], lst[x\
    \ - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x,\
    \ y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp10a5gwol.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp10a5gwol.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0drxvjaw.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp0drxvjaw.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0drxvjaw.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = coords[2:end]\n    \n\
    \    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpry3vfond.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpry3vfond.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        coords[i,:] = [(row,col) for col in cols]\n    end\n    \n    coords\
    \ = coords[coords[:,1] .== x,:]\n    \n    coords = coords[sortperm(coords[:,2]),:]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpoiy2j_dp.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpoiy2j_dp.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    return collect(enumerate(rows))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpno0jllu3.jl:30\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpno0jllu3.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptbxlte7a.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmptbxlte7a.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmptbxlte7a.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpzl_o0k0z.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpzl_o0k0z.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpzl_o0k0z.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(cols)\n            coords[i,c] = Tuple(row, col)\n        end\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->-x[1])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpapnrcp9a.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpapnrcp9a.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for col in row\n       \
    \     push!(columns, col)\n        end\n        \n        push!(rows, (row, columns))\n\
    \    end\n    \n    rows = sort(rows)\n    \n    columns = sort(collect(eachrow(lst)))\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7v0_d_mw.jl:164\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp7v0_d_mw.jl:164\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9o2zy16z.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9o2zy16z.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9o2zy16z.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplrviwncz.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmplrviwncz.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmplrviwncz.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1d0hf_bp.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp1d0hf_bp.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp1d0hf_bp.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpe5ubek83.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpe5ubek83.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpe5ubek83.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->x[19])\n    \n    rows = sort(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3k5g7aro.jl:85\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3k5g7aro.jl:85\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[2]))\n    \n    rows = sort(rows, by=x->-length(x[3]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[4]))\n    \n    rows = sort(rows, by=x->-length(x[5]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[6]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[7]))\n    \n    rows = sort(rows, by=x->-length(x[8]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[9]))\n    \n    rows = sort(rows, by=x->-length(x[10]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[11]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[12]))\n    \n    rows = sort(rows, by=x->-length(x[13]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[14]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[15]))\n    \n    rows = sort(rows, by=x->-length(x[16]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[17]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[18]))\n    \n    rows = sort(rows, by=x->-length(x[19]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[20]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[21]))\n    \n    rows = sort(rows, by=x->-length(x[22]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[23]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[24]))\n    \n    rows = sort(rows, by=x->-length(x[25]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[26]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[27]))\n    \n    rows = sort(rows, by=x->-length(x[28]))\n \
    \   \n    rows = sort(rows, by=x->-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk220tznr.jl:87\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpk220tznr.jl:87\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        cols[i] = row.index(x)\n        rows[i]\
    \ = i\n    end\n    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n \
    \   ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ all possible combinations of n numbers from an array.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphx4cp9kh.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphx4cp9kh.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpndmtuk39.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpndmtuk39.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpndmtuk39.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that finds all the subsets of a given set (without duplicates) of\
    \ size n.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp31eh_c2p.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp31eh_c2p.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x!=x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxphxu8x7.jl:83\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxphxu8x7.jl:83\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (min(columns), max(columns)))\n    end\n    \n    rows = sort(rows)\n    \n\
    \    rows = reverse(rows)\n    \n    columns = Vector{Int64}()\n    \n    for\
    \ row in rows\n        push!(columns, row[1])\n    end\n    \n    columns = sort(columns)\n\
    \    \n    columns = reverse(columns)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps1xgmrzc.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmps1xgmrzc.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmps1xgmrzc.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnrl600ya.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnrl600ya.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpogzm7agc.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpogzm7agc.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpogzm7agc.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpevnmtowq.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpevnmtowq.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpevnmtowq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = length(lst)\n    cols = lst[1].length\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in 1:rows\n        \n        row_coords = Tuple{Int64,\
    \ Int64}(0, row)\n        \n        for col in 1:cols\n            \n        \
    \    col_coords = Tuple{Int64, Int64}(0, col)\n            \n            if lst[row][col]\
    \ == x\n                \n                push!(coords, row_coords)\n        \
    \        push!(coords, col_coords)\n            end\n        end\n    end\n  \
    \  \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n   \
    \ return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa91bz78b.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpa91bz78b.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk338n161.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpk338n161.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpk338n161.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj7n_qxov.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpj7n_qxov.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn04oa_u_.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpn04oa_u_.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp631addfe.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp631addfe.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp631addfe.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    coords = Vector{Tuple{Int64, Int64}}(undef, 0)\n\
    \    \n    for row in rows\n        for col in cols\n            if lst[row][col]\
    \ == x\n                push!(coords, Tuple{row, col})\n            end\n    \
    \    end\n    end\n    \n    coords\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd8xs1mro.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpd8xs1mro.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(lst), 2)\n    \n    for i = 1:length(lst)\n \
    \       coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_48g_jrd.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_48g_jrd.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][i]\n        cols = cols\
    \ + lst[i][1:end-1]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords,\
    \ rev=true)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkzt_2949.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkzt_2949.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst[findfirst(x->x==lst[end], lst)-1]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    You are given a\
    \ 2 dimensional data, as a nested lists,\n    which is similar to matrix, however,\
    \ unlike matrices,\n    each row may contain a different number of columns.\n\
    \    Given lst, and integer x, find integers x in the list,\n    and return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n    Sort coordinates initially by rows in\
    \ ascending order.\n    Also, sort coordinates of the row by columns in descending\
    \ order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n\
    \      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
    \    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpux3e1k3_.jl:29\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpux3e1k3_.jl:29\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp180cqlkn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp180cqlkn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp180cqlkn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[i,:] = [lst[rows[i],cols[i]],\
    \ i]\n    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = reverse(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf1y_peyk.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf1y_peyk.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        cols[row] = length(lst[row])\n        rows[row]\
    \ = row\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n \
    \   coords = zeros(Int, length(lst))\n    \n    for row in rows\n        for col\
    \ in cols\n            if lst[row][col] == x\n                coords[row] = col\n\
    \                break\n            end\n        end\n    end\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq72musyy.jl:52\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpq72musyy.jl:52\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(1:length(lst)))\n    cols = sort(collect(1:length(lst[1])))\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3o8vmx78.jl:148\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp3o8vmx78.jl:148\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpjkp9biat.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpjkp9biat.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpjkp9biat.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmj1nt26v.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmj1nt26v.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbwm67yy2.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpbwm67yy2.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpbwm67yy2.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpobcr0t6z.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpobcr0t6z.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpobcr0t6z.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for j, (col)\
    \ in enumerate(cols)\n            coords[i,j] = row==col ? x : -1\n        end\n\
    \    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpismkohwa.jl:28\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpismkohwa.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        coords[i,:]\
    \ = [row, cols[row]]\n    end\n    \n    coords = coords[sortperm(coords[:,1]),:]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpntqlzebp.jl:35\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpntqlzebp.jl:35\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpaq6w8v96.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpaq6w8v96.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpaq6w8v96.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpz4omx7zg.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpz4omx7zg.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp61kfjlxz.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp61kfjlxz.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp61kfjlxz.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxloosv0u.jl:51\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxloosv0u.jl:51\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for j, (col) in enumerate(cols)\n            if lst[row][col] == x\n\
    \                coords[i][j] = Tuple(row, col)\n            end\n        end\n\
    \    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_6lsyyi6.jl:28\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_6lsyyi6.jl:28\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        cols[i] = length(row)\n        rows[i]\
    \ = i\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n   \
    \ coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = rows[i]\n    end\n    \n    coords = sort(coords)\n    \n\
    \    coords = coords[coords <= x]\n    \n    coords = coords[coords > 0]\n   \
    \ \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3ijkk8dq.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp3ijkk8dq.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp3ijkk8dq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpn0emsnkn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpn0emsnkn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpn0emsnkn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[i, :] = [lst[rows[i],\
    \ cols[i]], lst[rows[i], cols[i]]]\n    end\n    \n    coords = sort(coords, dims=2)\n\
    \    \n    coords = coords[coords[:, 1] .>= x, :]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4hhv2myj.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4hhv2myj.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        lst = sort(lst[row])\n      \
    \  \n        columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            \n            columns = columns + 1\n            \n            if\
    \ lst[col] == x\n                \n                return [(rows - 1, columns\
    \ - 1)]\n            end\n        end\n    end\n    \n    return []\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplai2021b.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmplai2021b.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows <=\
    \ x]\n    \n    rows = rows[rows > x]\n    cols = cols[cols > x]\n    \n    rows\
    \ = rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n \
    \   rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n\
    \    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n   \
    \ cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols =\
    \ cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n\
    \    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n   \
    \ cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols =\
    \ cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n   \
    \ rows = rows[row\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzqp220n2.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzqp220n2.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(enumerate(lst.[1])))\n    cols\
    \ = sort(collect(enumerate(reverse(lst[1]))))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,j) in zip(rows, cols)\n        coords[i, j] = (i,j)\n    end\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf6yz1w70.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpf6yz1w70.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb4r4pbuw.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpb4r4pbuw.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = length(lst)\n    cols = lst[1].length\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in 1:rows\n        \n        row_coords = Tuple{Int64,\
    \ Int64}(0, row)\n        \n        for col in 1:cols\n            \n        \
    \    if lst[row][col] == x\n                \n                push!(coords, row_coords)\n\
    \                \n            end\n            \n        end\n        \n    end\n\
    \    \n    sort(coords, rev=true)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpksx3oazg.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpksx3oazg.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in lst\n        rows = rows + row\n        cols = cols + 1\n    end\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpml2l2uj2.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpml2l2uj2.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpml2l2uj2.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    columns = sort(collect(1:length(lst[[1]])))\n\
    \    \n    columns = sort(columns, by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(columns))\n    \n    for (r,c) in zip(rows, columns)\n        coords[r][c]\
    \ = (r,c)\n    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_0g0j2d6.jl:38\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_0g0j2d6.jl:38\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwx6gg6ou.jl:47\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpwx6gg6ou.jl:47\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfyr66brp.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfyr66brp.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfyr66brp.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(enumerate(lst.[1])))\n    cols\
    \ = sort(collect(enumerate(reverse(lst[1]))))\n    \n    coords = zeros(Int, 2)\n\
    \    \n    for (i,j) in rows \n        if j == x \n            coords[1] = i\n\
    \            break\n    end\n    \n    for (i,j) in cols \n        if i == x \n\
    \            coords[1] = j\n            break\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8pqrd1oo.jl:43\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8pqrd1oo.jl:43\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols = cols +\
    \ lst[row][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n\
    \        coords[row] = ((rows - row), cols - lst[row][end])\n    end\n    \n \
    \   coords = sort(coords)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph_84zz15.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph_84zz15.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5o_0jyh5.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp5o_0jyh5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp5o_0jyh5.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst) == 0 \n        return\
    \ [] \n    \n    rows = sort(collect(enumerate(lst)))\n    \n    rows = rows[rows[2]\
    \ .< rows[3]]\n    \n    coords = zeros(Int, length(rows))\n    \n    for (i,row)\
    \ in enumerate(rows)\n        coords[i] = row\n    end\n    \n    coords = coords[coords[2]\
    \ .< coords[3]]\n    \n    coords = coords[coords[1] .< x]\n    \n    coords =\
    \ coords[coords[1] .< x]\n    \n    coords = coords[coords[1] .< x]\n    \n  \
    \  return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyltvnbxz.jl:44\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpyltvnbxz.jl:44\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols\
    \ .<= x]\n    \n    coords = zip(rows, cols)\n    \n    coords = sort!(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxa7wtwcp.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxa7wtwcp.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqvaq6zd3.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpqvaq6zd3.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpqvaq6zd3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + ones(Int, length(row))\n    end\n    \n    rows = sort(rows)\n    cols\
    \ = sort(cols)\n    \n    rows = rows[rows > x]\n    cols = cols[cols > x]\n \
    \   \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n   \
    \ rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n   \
    \ rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpse_mqnoo.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpse_mqnoo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpse_mqnoo.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl9gm12ay.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpl9gm12ay.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        append!(coords, Tuple{row, cols})\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n \
    \   ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns the number of occurrences of an element in\
    \ a given list.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiji9519t.jl:35\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiji9519t.jl:35\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    cols = zeros(Int,\
    \ length(lst))\n    \n    for i = 1:length(lst)\n        cols = cols + lst[i][end]\n\
    \    end\n    \n    cols = sort(cols)\n    \n    return zip(rows, cols)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp30xe1gir.jl:42\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp30xe1gir.jl:42\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7m3hpuhr.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp7m3hpuhr.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp7m3hpuhr.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7xhfptfi.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp7xhfptfi.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp7xhfptfi.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        coords[i,:] = [row, cols]\n\
    \    end\n    \n    coords = coords[coords[:,1] .<= x, :]\n    coords = coords[coords[:,2]\
    \ .>= x, :]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdku_tgec.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdku_tgec.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6g37vuvg.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp6g37vuvg.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp6g37vuvg.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2honucle.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp2honucle.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp2honucle.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        coords = coords + [(row, cols[cols..end-1])]\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n \
    \   ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns a list of tuples [(x1, y1), (x2, y2) ...] such\
    \ that\neach tuple is a coordinate - (row, columns), starting with 0.\nSort coordinates\
    \ initially by rows in ascending order.\nAlso, sort coordinates of the row by\
    \ columns in descending order.\nFor example, get_row([\n      [1,2,3,4,5,6],\n\
    \      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvx966pjt.jl:35\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvx966pjt.jl:35\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    columns = sort(collect(1:length(lst[1,:])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        \n        append!(coords, Tuple{Int64,\
    \ Int64}(row, columns[columns == row]))\n    end\n    \n    coords = sort(coords,\
    \ by=x->x[1])\n    coords = sort(coords, by=x->x[2])\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkvjdomi7.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkvjdomi7.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7yj5j5sf.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp7yj5j5sf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp7yj5j5sf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmpwr8yoc.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpmpwr8yoc.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpmpwr8yoc.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp359m1109.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp359m1109.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp359m1109.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        lst = sort(lst[row])\n      \
    \  \n        columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            \n            columns = columns + 1\n            \n            if\
    \ lst[col] == x\n                \n                return [(row, columns)]\n \
    \           end\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv7jz9vw3.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv7jz9vw3.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (length(columns), max(columns)))\n    end\n    \n    rows = sort(rows)\n   \
    \ \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n    \n   \
    \ rows = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows,\
    \ by=first)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n\
    \    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows,\
    \ by=first)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n\
    \    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows,\
    \ by=first)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmph_n9_630.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmph_n9_630.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmph_n9_630.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnr175ktn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpnr175ktn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpnr175ktn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgmchvw0t.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpgmchvw0t.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpgmchvw0t.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that finds the number of occurrences of x in a nested list.\nFor\
    \ example, get_count([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == 3\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcm1rdl0z.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpcm1rdl0z.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        rows[i] = row\n    end\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    columns = zeros(Int, length(lst))\n    \n    for (i,col)\
    \ in enumerate(lst)\n        columns[i] = col\n    end\n    \n    columns = sort(columns)\n\
    \    \n    columns = reverse(columns)\n    \n    coords = zeros(Int, length(lst))\n\
    \    \n    for (i,coord) in enumerate(zip(rows, columns))\n        coords[i] =\
    \ coord\n    end\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = coords[findfirst(x->x==x, coords)]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnk56uymg.jl:58\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpnk56uymg.jl:58\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwsjb335s.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwsjb335s.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwsjb335s.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpip7eq9ch.jl:30\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpip7eq9ch.jl:30\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpexjpeauk.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpexjpeauk.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpexjpeauk.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}(undef, 0)\n    \n    for row in rows\n        for col in cols\n    \
    \        if lst[row][col] == x\n                push!(coords, Tuple{row, col})\n\
    \            end\n        end\n    end\n    \n    sort(coords, rev=true)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfvmjxz7a.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfvmjxz7a.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[[1]] .== x]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"rows[[2]]\
    \ .\" at /tmp/tmpi3pymetz.jl:82\nStacktrace:\n [1] top-level scope at /tmp/tmpi3pymetz.jl:82\n\
    \ [2] include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpi3pymetz.jl:82\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x,:]\n\
    \    \n    coords = coords[sortperm(coords[:,2]),:]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nget_row([\n      [1,2,3,4,5,6],\n   \
    \   [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]\n</cell>\n<text>\nExercise 2\nWrite a function that finds all\
    \ the coordinates of x in the given list.\nThe function should return a list of\
    \ tuples, where each tuple is a coordinate - (row, columns), starting with 0.\n\
    Sort coordinates initially by rows in ascending order.\nAlso, sort coordinates\
    \ of the row by columns in descending order.\nThe function should work for any\
    \ nested list.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpob1l1tzd.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpob1l1tzd.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (length(columns), columns))\n    end\n    \n    rows = sort(rows)\n    \n  \
    \  rows = reverse(rows)\n    \n    columns = sort(lst[end][end])\n    \n    columns\
    \ = reverse(columns)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    \nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxh0wgoh_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpxh0wgoh_.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpxh0wgoh_.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4k8y7zrn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp4k8y7zrn.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp4k8y7zrn.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    coords = zeros(Int,\
    \ length(lst))\n    \n    for (i,row) in enumerate(lst)\n        coords[i] = findfirst(x->x==row,\
    \ rows)\n    end\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpehcobtr2.jl:50\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpehcobtr2.jl:50\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        append!(coords, Tuple{Int64, Int64}(0,\
    \ row))\n        for col in cols\n            if lst[row][col] == x\n        \
    \        append!(coords, Tuple{Int64, Int64}(row, col))\n            end\n   \
    \     end\n    end\n    \n    coords = sort(coords, by=(x->x[1], x->x[2]))\n \
    \   \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiom4cvb6.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpiom4cvb6.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9vh1c0zq.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp9vh1c0zq.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp9vh1c0zq.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        coords = coords + [(row, cols[cols..end])]\n\
    \    end\n    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpevyk0czc.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpevyk0czc.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpevyk0czc.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpuf5rcuo3.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpuf5rcuo3.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpuf5rcuo3.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x,:]\n\
    \    \n    coords = coords[coords[:,2] .== x,:]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nget_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n\
    \      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
    </cell>\n<code language=julia-1.5>\nget_row([], 1) == []\n</cell>\n<code language=julia-1.5>\n\
    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nExercise\nWrite\
    \ a function that finds the number of occurrences of an element in a given list.\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfgbxtkex.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfgbxtkex.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    else \n        rows = sort(collect(1:length(lst)))\n    \
    \    cols = sort(collect(1:length(lst[1])))\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqhwo66y2.jl:88\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpqhwo66y2.jl:88\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbe6mpus2.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpbe6mpus2.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpbe6mpus2.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + 1\n      \
    \  cols = cols + length(row)\n        \n        if x == row\n            \n  \
    \          return [(i, j)  for j in (1:cols) ]\n        end\n    end\n    \n \
    \   return []\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9xloe_fr.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9xloe_fr.jl:40\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    else \n        rows = sort(collect(1:length(lst)))\n    \
    \    cols = sort(collect(1:length(lst[1])))\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2ehs7vtx.jl:89\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2ehs7vtx.jl:89\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + row\n    \
    \    cols = cols + 1\n        \n        if i == x\n            \n            rows\
    \ = sort(rows)\n            cols = sort(cols)\n            \n            rows\
    \ = reverse(rows)\n            cols = reverse(cols)\n            \n          \
    \  rows = reverse(rows)\n            cols = reverse(cols)\n            \n    \
    \        return [(i, rows[i]), (i, cols[i])]\n        end\n    end\n    \n   \
    \ return []\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkvnk5kmd.jl:49\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkvnk5kmd.jl:49\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(lst), 2)\n    \n    for i = 1:length(lst)\n \
    \       coords[i] = (i-1, cols[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nProblem 3\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzguvgmwu.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpzguvgmwu.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   rows = rows + 1\n        \n        lst = sort(lst[row])\n        \n      \
    \  columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            columns = columns + 1\n            \n            if lst[col] == x\n\
    \                tup = Tuple{Int64, Int64}(row, columns)\n                \n \
    \               push!(rows, tup)\n            end\n        end\n    end\n    \n\
    \    return rows\nend\n</cell>\n<code language=julia-1.3>\nget_row([\n      [1,2,3,4,5,6],\n\
    \      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.3>\nget_row([], 1) == []\n\
    </cell>\n<code language=julia-1.3>\nget_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns the number of times\
    \ a given value appears in a given list.\nFor example, given lst = [1, 2, 3, 1,\
    \ 2, 3], and x = 2, the function should return 3.\nWrite a function that returns\
    \ the number of times a given value appears in a given list.\nFor example, given\
    \ lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return 3.\nWrite a\
    \ function that returns the number of times a given value appears in a given list.\n\
    For example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return\
    \ 3.\nWrite a function that returns the number of times a given value appears\
    \ in a given list.\nFor example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the\
    \ function should return 3.\nWrite a function that returns the number of times\
    \ a given value appears in a given list.\nFor example, given lst = [1, 2, 3, 1,\
    \ 2, 3], and x = 2, the function should return 3.\nWrite a function that returns\
    \ the number of times a given value appears in a given list.\nFor example, given\
    \ lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return 3.\nWrite a\
    \ function that returns the number of times a given value appears in a given list.\n\
    For example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return\
    \ 3.\nWrite a function that returns the number of times a given value appears\
    \ in a given list.\nFor example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the\
    \ function should return 3.\nWrite a function that returns the number of times\
    \ a given value appears in a given list.\nFor example, given lst = [1, 2, 3, 1,\
    \ 2, 3], and x = 2, the function should return 3.\nWrite a function that returns\
    \ the number of times a given value appears in a given list.\nFor example, given\
    \ lst = [1, 2, 3, 1, 2, \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv94fczdr.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpv94fczdr.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc_16krgf.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpc_16krgf.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpc_16krgf.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpagbq52j0.jl:45\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpagbq52j0.jl:45\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by = x => -x)\n    \n    coords\
    \ = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n    \
    \    coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords, by\
    \ = x => x[1])\n    coords = sort(coords, by = x => x[2])\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8uuunxhy.jl:36\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp8uuunxhy.jl:36\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = reverse(rows)\n    \n    columns = sort(collect(enumerate(rows[end][1])))\n\
    \    \n    columns = reverse(columns)\n    \n    coords = zeros(length(rows),\
    \ length(columns))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(columns)\n            if row[1] == col[1]\n                coords[i,c]\
    \ = (c,row[1])\n            end\n        end\n    end\n    \n    coords = sort(coords,\
    \ by=x->x[1])\n    \n    coords = reverse(coords)\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2u49gber.jl:46\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2u49gber.jl:46\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    else \n        rows = sort(collect(1:length(lst)))\n    \
    \    cols = sort(collect(1:length(lst[1])))\n        \n        rows = sort(rows)\n\
    \        cols = sort(cols)\n        \n        rows = rows[cols..end]\n       \
    \ cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols\
    \ = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols =\
    \ cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n\
    \        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n  \
    \      \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n    \
    \    \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n      \
    \  \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n\
    \        rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n  \
    \      rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n    \
    \    rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n      \
    \  rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n        rows\
    \ = rows[cols..end]\n        cols = cols[rows..end]\n        \n        rows =\
    \ rows[cols..end]\n        cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n\
    \        cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n  \
    \      cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n    \
    \    cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n      \
    \  cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols\
    \ = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols =\
    \ cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n\
    \        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n  \
    \      \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n    \
    \    \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n      \
    \  \n        rows = rows[cols..\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_9jqng19.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp_9jqng19.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqraupdqs.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpqraupdqs.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpqraupdqs.jl:1\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    return [(i, j) for (i, j) in zip(sort(rows),\
    \ sort(cols))]\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmghanwl_.jl:34\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpmghanwl_.jl:34\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp12zba064.jl:37\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp12zba064.jl:37\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    rows = sort(collect(enumerate(lst)))\n    \n \
    \   rows = reverse(rows)\n    \n    rows = sort(rows, by=x->x[1])\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = reverse(rows)\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprnvnnfya.jl:39\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmprnvnnfya.jl:39\n"
  exit_code: 1
  status: Exception
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwi_aj_a1.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpwi_aj_a1.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpwi_aj_a1.jl:1\n"
  exit_code: 1
  status: Exception
