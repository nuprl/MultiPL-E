name: HumanEval_87_get_row
language: julia
results:
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols = cols +\
    \ length(lst[row])\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n\
    \        coords[row] = ((rows - row(rows)), (cols - row(cols)))\n    end\n   \
    \ \n    coords = sort(coords)\n    \n    coords = coords[coords[1, 1] <= x]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx0ayf6j8.jl:47\nin expression starting at\
    \ /tmp/tmpx0ayf6j8.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a matrix and a vector as input, and returns the dot product of the matrix and\
    \ the vector.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3v624as4.jl:34\nin expression starting at\
    \ /tmp/tmp3v624as4.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + 1\n      \
    \  cols = cols + length(row)\n        \n        if x == row\n            \n  \
    \          return [(i, j)  for j in (1:length(row)), (1:length(row))] \n     \
    \   end\n    end\n    \n    return []\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1gpnp9ov.jl:34\nin expression starting at\
    \ /tmp/tmp1gpnp9ov.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpv77w4811.jl:39\\n  Test threw\
    \ exception\\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\\n  MethodError:\
    \ Cannot `convert` an object of type Vector{Int64} to an object of type Int64\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n    [1] cvt1\\n      @ ./essentials.jl:343 [inlined]\\\
    n    [2] ntuple\\n      @ ./ntuple.jl:49 [inlined]\\n    [3] convert(#unused#::Type{Tuple{Int64,\
    \ Int64}}, x::Tuple{Int64, Vector{Int64}})\\n      @ Base ./essentials.jl:344\\\
    n    [4] setindex!(A::Vector{Tuple{Int64, Int64}}, x::Tuple{Int64, Vector{Int64}},\
    \ i1::Int64)\\n      @ Base ./array.jl:903\\n    [5] _unsafe_copyto!(dest::Vector{Tuple{Int64,\
    \ Int64}}, doffs::Int64, src::Vector{Tuple{Int64, Vector{Int64}}}, soffs::Int64,\
    \ n::Int64)\\n      @ Base ./array.jl:253\\n    [6] unsafe_copyto!\\n      @ ./array.jl:307\
    \ [inlined]\\n    [7] _copyto_impl!\\n      @ ./array.jl:331 [inlined]\\n    [8]\
    \ copyto!\\n      @ ./array.jl:317 [inlined]\\n    [9] copyto!\\n      @ ./array.jl:343\
    \ [inlined]\\n   [10] copyto_axcheck!\\n      @ ./abstractarray.jl:1104 [inlined]\\\
    n   [11] Vector{Tuple{Int64, Int64}}(x::Vector{Tuple{Int64, Vector{Int64}}})\\\
    n      @ Base ./array.jl:563\\n   [12] convert\\n      @ ./array.jl:554 [inlined]\\\
    n   [13] get_row(lst::Vector{Vector{Int64}}, x::Int64)\\n      @ Main /tmp/tmpv77w4811.jl:32\\\
    n   [14] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [15] macro expansion\\n      @ /tmp/tmpv77w4811.jl:39 [inlined]\\\
    n   [16] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0s8osvsw.jl:88\nin expression starting at\
    \ /tmp/tmp0s8osvsw.jl:88\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwwxhem3t.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwwxhem3t.jl:1\n\
    in expression starting at /tmp/tmpwwxhem3t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,r) in enumerate(rows)\n\
    \        for (c,c) in enumerate(cols)\n            coords[i,c] = (r,c)\n     \
    \   end\n    end\n    \n    coords = coords[coords[:,1] .== x, :]\n    \n    coords\
    \ = coords[sortperm(coords[:,2], rev=true), :]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmmpco3iu.jl:39\nin expression starting at\
    \ /tmp/tmpmmpco3iu.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcy1e_xap.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcy1e_xap.jl:1\n\
    in expression starting at /tmp/tmpcy1e_xap.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        row_coords = Tuple{Int64, Int64}()\n        \n        for col in row\n\
    \            \n            if col == x\n                \n                row_coords\
    \ = Tuple(row, col)\n                \n            end\n            \n       \
    \ end\n        \n        push!(rows, row_coords)\n        \n    end\n    \n  \
    \  rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    return rows\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz5v7dmck.jl:50\nin expression starting at\
    \ /tmp/tmpz5v7dmck.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpus4nr2bm.jl:37\nin expression starting at\
    \ /tmp/tmpus4nr2bm.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptintrgri.jl:43\nin expression starting at\
    \ /tmp/tmptintrgri.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + 1\n        \n        lst[i] = sort(lst[i])\n        \n        lst[i]\
    \ = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n        \n       \
    \ lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n        \n\
    \        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n   \
    \     \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n        lst[i] = sort(lst[i])\n\
    \        \n        lst[i] = lst[i][2:end]\n        \n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmpw7gzrrxt.jl:26\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7gzrrxt.jl:1\n\
    in expression starting at /tmp/tmpw7gzrrxt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + row\n    \
    \    cols = cols + 1\n        \n        if rows == x\n            \n         \
    \   coord = Tuple(row-1, cols-1)\n            \n            return coord\n   \
    \     end\n    end\n    \n    return []\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfvpgybys.jl:42\nin expression starting at\
    \ /tmp/tmpfvpgybys.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = sort(row)\n        \n        if columns[end]==x\n         \
    \   push!(rows, (length(row), length(columns)))\n        end\n    end\n    \n\
    \    sort(rows)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt7tb0zik.jl:37\nin expression starting at\
    \ /tmp/tmpt7tb0zik.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + lst[row]\n        cols =\
    \ cols + lst[row, end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for row in 1:length(rows)\n\
    \        for col in 1:length(cols)\n            if rows == row && cols == col\n\
    \                coords[row, col] = 1\n            end\n        end\n    end\n\
    \    \n    coords = sort(coords, rev=true)\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp249hkzpn.jl:49\nin expression starting at\
    \ /tmp/tmp249hkzpn.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn2_6d604.jl:45\nin expression starting at\
    \ /tmp/tmpn2_6d604.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = rows[cols\
    \ == x]\n    cols = cols[cols == x]\n    \n    rows = reverse(rows)\n    cols\
    \ = reverse(cols)\n    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa_nm6c2b.jl:46\nin expression starting at\
    \ /tmp/tmpa_nm6c2b.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x, :]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0khm6ynf.jl:37\nin expression starting at\
    \ /tmp/tmp0khm6ynf.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmyirii_l.jl:43\nin expression starting at\
    \ /tmp/tmpmyirii_l.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n        coords[row]\
    \ = ((rows - row(rows)), (cols - row(cols)))\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[coords[:, 1] .<= x]\n    coords = coords[coords[:,\
    \ 2] .>= x]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp21vtmszl.jl:48\nin expression starting at\
    \ /tmp/tmp21vtmszl.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise\nWrite a\
    \ function that returns all possible combinations of length n of elements from\
    \ an input vector. For example, given [1, 2, 3], the function should return [[1,\
    \ 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]].\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpclzwl7jx.jl:30\nin expression starting at\
    \ /tmp/tmpclzwl7jx.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(1:length(lst.[1])))\n    cols =\
    \ sort(collect(1:length(lst.[1])))\n    \n    rows = sort(rows, by=x->-x)\n  \
    \  cols = sort(cols, by=x->-x)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,j) in zip(rows, cols) \n        coords[i,j] = (i,j)\n    end\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjjezfl56.jl:38\nin expression starting at\
    \ /tmp/tmpjjezfl56.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + lst[row]\n        cols =\
    \ cols + lst[row, end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols > x]\n    cols = cols[cols > x]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n   \
    \ rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp27m28a__.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp27m28a__.jl:1\n\
    in expression starting at /tmp/tmp27m28a__.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        for (c,col) in enumerate(cols)\n\
    \            coords[i,c] = Tuple(row, col)\n        end\n    end\n    \n    coords\
    \ = sort(coords, by=x->x[1])\n    coords = sort(coords, by=x->x[2])\n    \n  \
    \  return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsnom06sw.jl:41\nin expression starting at\
    \ /tmp/tmpsnom06sw.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpayi0r3jr.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpayi0r3jr.jl:1\n\
    in expression starting at /tmp/tmpayi0r3jr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3ouxf6kz.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3ouxf6kz.jl:1\n\
    in expression starting at /tmp/tmp3ouxf6kz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    cols = zeros(Int,\
    \ length(lst))\n    \n    for i = 1:length(lst)\n        cols = cols + lst[i][end]\n\
    \    end\n    \n    cols = sort(cols)\n    \n    return zip(rows, cols)\nend\n\
    </cell>\n<code language=julia-1.5>\nget_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n\
    \      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns all possible combinations\
    \ of k elements from n elements.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeiife7ww.jl:42\nin expression starting at\
    \ /tmp/tmpeiife7ww.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp2pexx7t.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpp2pexx7t.jl:1\n\
    in expression starting at /tmp/tmpp2pexx7t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpceeefx5i.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpceeefx5i.jl:1\n\
    in expression starting at /tmp/tmpceeefx5i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(cols)\n            if lst[row][c] == x\n                coords[i,c]\
    \ = (c,row)\n            end\n        end\n    end\n    \n    coords = coords[sortperm(coords[:,1]),\
    \ :]\n    coords = coords[sortperm(coords[:,2]), :]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl8qgrii5.jl:40\nin expression starting at\
    \ /tmp/tmpl8qgrii5.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphr0k9p8o.jl:43\nin expression starting at\
    \ /tmp/tmphr0k9p8o.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols = cols +\
    \ length(lst[row])\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n\
    \        coords[row] = ((rows - row(rows)), (cols - row(cols)))\n    end\n   \
    \ \n    coords = sort(coords)\n    \n    coords = coords[coords[1, 1] <= x]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb0hn73a3.jl:47\nin expression starting at\
    \ /tmp/tmpb0hn73a3.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        for col in cols\n            if\
    \ lst[row][col] == x\n                push!(coords, Tuple{row, col})\n       \
    \     end\n        end\n    end\n    \n    coords = sort(coords, by=(x->x[1],\
    \ x->x[2]))\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpplcc80zf.jl:39\nin expression starting at\
    \ /tmp/tmpplcc80zf.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = ((rows[i] - 1), (length(lst[i]) - 1))\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that finds all the coordinates of x in a nested list.\nFor example,\
    \ get_coords([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nHint: use get_row and\
    \ get_col functions to solve this problem.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8l3yh7oy.jl:42\nin expression starting at\
    \ /tmp/tmp8l3yh7oy.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,1] .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n\
    \    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,1] .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords =\
    \ coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n\
    \    \n    coords = coords[coords[:,2] .!= x,:]\n    \n    coords = coords[coords[:,2]\
    \ .!= x,:]\n    \n    coords = coords[coords[:,1] .!= x,:]\n    \n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp17gxg5cp.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp17gxg5cp.jl:1\n\
    in expression starting at /tmp/tmp17gxg5cp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprk9hs0n5.jl:43\nin expression starting at\
    \ /tmp/tmprk9hs0n5.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    end\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpss_t1k4w.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpss_t1k4w.jl:1\n\
    in expression starting at /tmp/tmpss_t1k4w.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        (0, 0)\n    else\n        (x, y) = get_row(lst[x - 1], lst[x\
    \ - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x,\
    \ y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9x61n196.jl:1\nin expression starting at /tmp/tmp9x61n196.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr3tz7td5.jl:47\nin expression starting at\
    \ /tmp/tmpr3tz7td5.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = rows[i], lst[i][x]\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgzovdvqm.jl:42\nin expression starting at\
    \ /tmp/tmpgzovdvqm.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[2:end]\n    \n    coords = reverse(coords)\n    \n\
    \    coords = coords[2:end]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3tu18ly4.jl:51\nin expression starting at\
    \ /tmp/tmp3tu18ly4.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppj41hn0k.jl:37\nin expression starting at\
    \ /tmp/tmppj41hn0k.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwpmqejj0.jl:43\nin expression starting at\
    \ /tmp/tmpwpmqejj0.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i]\n        cols = cols\
    \ + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n   \
    \ coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[2:end-1, 2:end-1]\n    \n    coords = coords[coords[1,\
    \ 1] == x, :]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyrlhpvdr.jl:49\nin expression starting at\
    \ /tmp/tmpyrlhpvdr.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptnxe52hv.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptnxe52hv.jl:1\n\
    in expression starting at /tmp/tmptnxe52hv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpckqe_0xw.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpckqe_0xw.jl:1\n\
    in expression starting at /tmp/tmpckqe_0xw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        for j, (col) in enumerate(cols)\n\
    \            if lst[row][col] == x\n                coords[i][j] = (i,j)\n   \
    \         end\n        end\n    end\n    \n    coords = sort(coords, by=x->x[1],\
    \ rev=true)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplptn7_fy.jl:31\nin expression starting at\
    \ /tmp/tmplptn7_fy.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        rows[i] = row\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for (i,col) in enumerate(reverse(rows))\n\
    \        columns[i] = col\n    end\n    \n    columns = sort(columns)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,coord) in enumerate(zip(rows,\
    \ columns))\n        coords[i] = coord\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[coords[:,1] .<= x]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcgwp4z2f.jl:52\nin expression starting at\
    \ /tmp/tmpcgwp4z2f.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpju5helt6.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpju5helt6.jl:1\n\
    in expression starting at /tmp/tmpju5helt6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppce9ay1f.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppce9ay1f.jl:1\n\
    in expression starting at /tmp/tmppce9ay1f.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    return [(rows[i], cols[i]) for i in 1:length(lst)]\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_byuvszy.jl:34\nin expression starting at\
    \ /tmp/tmp_byuvszy.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + row\n    \
    \    cols = cols + 1\n        \n        if rows == x\n            \n         \
    \   coords = Tuple{Int64, Int64}(i, cols-1)\n            \n            return\
    \ [(coords, coords)]\n        end\n    end\n    \n    return []\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplz42_kom.jl:42\nin expression starting at\
    \ /tmp/tmplz42_kom.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   rows = rows + 1\n        \n        cols = zeros(Int, length(lst[row]))\n \
    \       \n        for col in 1:length(lst[row])\n            cols = cols + 1\n\
    \            \n            if lst[row][col] == x\n                \n         \
    \       tup = Tuple{Int64, Int64}((row, cols))\n                \n           \
    \     if tup < lst[end]\n                    lst[end] = tup\n                end\n\
    \                \n                if tup > lst[end]\n                    lst[end]\
    \ = tup\n                end\n                \n            end\n        end\n\
    \    end\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpluutmv8m.jl:52\nin expression starting at\
    \ /tmp/tmpluutmv8m.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n        coords[row]\
    \ = ((rows - 1) - row) * length(lst[row]) + cols[row]\n    end\n    \n    coords\
    \ = sort(coords)\n    \n    coords = coords[coords <= length(lst, 1)]\n    \n\
    \    coords = coords[coords <= x]\n    \n    coords = coords[coords > 0]\n   \
    \ \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4eb36nfy.jl:51\nin expression starting at\
    \ /tmp/tmp4eb36nfy.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for row in rows\n        for col in cols\n        \
    \    coords[row, col] = ((row, col), lst[row][col])\n        end\n    end\n  \
    \  \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4cjphobx.jl:35\nin expression starting at\
    \ /tmp/tmp4cjphobx.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,j) in zip(rows, cols)\n        coords[i,j] =\
    \ (i,j)\n    end\n    \n    coords = sort(coords, by=x->x[1], rev=true)\n    coords\
    \ = sort(coords, by=x->x[2], rev=true)\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp5impuuc.jl:36\nin expression starting at\
    \ /tmp/tmpp5impuuc.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3peveql1.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3peveql1.jl:1\n\
    in expression starting at /tmp/tmp3peveql1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwbfz0k2x.jl:37\nin expression starting at\
    \ /tmp/tmpwbfz0k2x.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw5cci0di.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw5cci0di.jl:1\n\
    in expression starting at /tmp/tmpw5cci0di.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(Int, length(rows),\
    \ length(cols))\n    \n    for row in rows\n        for col in cols\n        \
    \    coords[row, col] = findfirst(x->x == lst[row][col], x)\n        end\n   \
    \ end\n    \n    coords = coords[sortperm(coords[:, cols]), :]\n    coords = coords[:,\
    \ sortperm(coords[:, rows])]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbxn6sx53.jl:38\nin expression starting at\
    \ /tmp/tmpbxn6sx53.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprvqrnhz_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprvqrnhz_.jl:1\n\
    in expression starting at /tmp/tmprvqrnhz_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa3ux08o8.jl:45\nin expression starting at\
    \ /tmp/tmpa3ux08o8.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2t5w45y_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2t5w45y_.jl:1\n\
    in expression starting at /tmp/tmp2t5w45y_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    columns = sort(collect(1:length(lst)),\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpebsul46r.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpebsul46r.jl:1\n\
    in expression starting at /tmp/tmpebsul46r.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for j, (col) in enumerate(cols)\n            if lst[row][col] == x\n\
    \                coords[i][j] = Tuple(row, col)\n            end\n        end\n\
    \    end\n    \n    coords = sort(coords, by=coords)\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz2n3zof6.jl:28\nin expression starting at\
    \ /tmp/tmpz2n3zof6.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    col\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkfk894ip.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkfk894ip.jl:1\n\
    in expression starting at /tmp/tmpkfk894ip.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpihk9gq9z.jl:101\nin expression starting at\
    \ /tmp/tmpihk9gq9z.jl:101\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    return [(rows, cols)]\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppmlpp32s.jl:34\nin expression starting at\
    \ /tmp/tmppmlpp32s.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4fehr1oh.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4fehr1oh.jl:1\n\
    in expression starting at /tmp/tmp4fehr1oh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        lst = sort(lst[row])\n      \
    \  \n        columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            \n            columns = columns + 1\n            \n            if\
    \ lst[col] == x\n                \n                tup = Tuple{Int64, Int64}((row,\
    \ columns))\n                \n                push!(reverse(tup), tup)\n    \
    \            \n            end\n            \n        end\n        \n    end\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp80ztdqac.jl:52\nin expression starting at\
    \ /tmp/tmp80ztdqac.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz78zwei_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz78zwei_.jl:1\n\
    in expression starting at /tmp/tmpz78zwei_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[2] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[rows[1] .< x] \n    \n    rows = rows[rows[1] .< x] \n\
    \    \n    rows = rows[\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4gl_py93.jl:1\nin expression starting at /tmp/tmp4gl_py93.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphztspzq2.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphztspzq2.jl:1\n\
    in expression starting at /tmp/tmphztspzq2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnkhiz1r0.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnkhiz1r0.jl:1\n\
    in expression starting at /tmp/tmpnkhiz1r0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_bvtwnke.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_bvtwnke.jl:1\n\
    in expression starting at /tmp/tmp_bvtwnke.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        columns\
    \ = columns + lst[i][end]\n    end\n    \n    columns = sort(columns)\n    \n\
    \    return zip(rows, columns)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6_awsz65.jl:42\nin expression starting at\
    \ /tmp/tmp6_awsz65.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + 1\n      \
    \  cols = cols + length(row)\n        \n        for j in 1:length(row)\n     \
    \       if row[j] == x\n                \n                tup = Tuple(rows[i],\
    \ cols[j])\n                \n                push!(tups, tup)\n             \
    \   \n            end\n        end\n    end\n    \n    sort(tups, rev=true)\n\
    \    \nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy5otjzmj.jl:46\nin expression starting at\
    \ /tmp/tmpy5otjzmj.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpynh3v_nx.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpynh3v_nx.jl:1\n\
    in expression starting at /tmp/tmpynh3v_nx.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        coords = coords + [(row, cols[cols..end])]\n\
    \    end\n    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph3exzuyb.jl:1\nin expression starting at /tmp/tmph3exzuyb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptm48jex_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptm48jex_.jl:1\n\
    in expression starting at /tmp/tmptm48jex_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpminlypbn.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpminlypbn.jl:1\n\
    in expression starting at /tmp/tmpminlypbn.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        coords[i,:] = [row, cols]\n\
    \    end\n    \n    coords = sort(coords, by=x->x[2])\n    \n    coords = coords[end:-1:1]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg750okiy.jl:40\nin expression starting at\
    \ /tmp/tmpg750okiy.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = rows[rows > 0]\n    cols = cols[rows > 0]\n    \n  \
    \  rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpob37v_8_.jl:1\nin expression starting at /tmp/tmpob37v_8_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        columns\
    \ = columns + lst[i][end]\n    end\n    \n    columns = sort(columns)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n     \
    \   coords[i] = (i-1, columns[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptgmc7orl.jl:50\nin expression starting at\
    \ /tmp/tmptgmc7orl.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        (0, 0)\n    else\n        (x, y) = get_row(lst[x - 1], lst[x\
    \ - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x,\
    \ y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end],\
    \ lst[x - 1][end])\n        (x, y) = (lst[x - 1][end], lst[x - 1][end])\n    \
    \    (x, y) = (lst[x - 1][end], lst[x - 1][end])\n        (x, y) = (lst[x - 1][end\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyd0zlr3c.jl:1\nin expression starting at /tmp/tmpyd0zlr3c.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpoppux9y5.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpoppux9y5.jl:1\n\
    in expression starting at /tmp/tmpoppux9y5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = coords[2:end]\n    \n\
    \    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf78u91gl.jl:49\nin expression starting at\
    \ /tmp/tmpf78u91gl.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        coords[i,:] = [(row,col) for col in cols]\n    end\n    \n    coords\
    \ = coords[coords[:,1] .== x,:]\n    \n    coords = coords[sortperm(coords[:,2]),:]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl5fjqp9h.jl:37\nin expression starting at\
    \ /tmp/tmpl5fjqp9h.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    return collect(enumerate(rows))\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpliog5u44.jl:30\nin expression starting at\
    \ /tmp/tmpliog5u44.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpetgwuqok.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpetgwuqok.jl:1\n\
    in expression starting at /tmp/tmpetgwuqok.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplyk8szsd.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplyk8szsd.jl:1\n\
    in expression starting at /tmp/tmplyk8szsd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(cols)\n            coords[i,c] = Tuple(row, col)\n        end\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->-x[1])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1jtlqfnv.jl:38\nin expression starting at\
    \ /tmp/tmp1jtlqfnv.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for col in row\n       \
    \     push!(columns, col)\n        end\n        \n        push!(rows, (row, columns))\n\
    \    end\n    \n    rows = sort(rows)\n    \n    columns = sort(collect(eachrow(lst)))\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows\
    \ = sort(rows)\n    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n\
    \    \n    columns = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(columns)\n    \n    rows = sort(rows)\n    \n    columns = sort(columns)\n\
    \    \n    rows = sort(\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpszg4_dvh.jl:164\nin expression starting at\
    \ /tmp/tmpszg4_dvh.jl:164\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpoboxebnb.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpoboxebnb.jl:1\n\
    in expression starting at /tmp/tmpoboxebnb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp543_bdjx.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp543_bdjx.jl:1\n\
    in expression starting at /tmp/tmp543_bdjx.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqx309dq6.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqx309dq6.jl:1\n\
    in expression starting at /tmp/tmpqx309dq6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpd0cagos_.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpd0cagos_.jl:1\n\
    in expression starting at /tmp/tmpd0cagos_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->x[19])\n    \n    rows = sort(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpww16lkfd.jl:85\nin expression starting at\
    \ /tmp/tmpww16lkfd.jl:85\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[2]))\n    \n    rows = sort(rows, by=x->-length(x[3]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[4]))\n    \n    rows = sort(rows, by=x->-length(x[5]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[6]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[7]))\n    \n    rows = sort(rows, by=x->-length(x[8]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[9]))\n    \n    rows = sort(rows, by=x->-length(x[10]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[11]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[12]))\n    \n    rows = sort(rows, by=x->-length(x[13]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[14]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[15]))\n    \n    rows = sort(rows, by=x->-length(x[16]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[17]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[18]))\n    \n    rows = sort(rows, by=x->-length(x[19]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[20]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[21]))\n    \n    rows = sort(rows, by=x->-length(x[22]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[23]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[24]))\n    \n    rows = sort(rows, by=x->-length(x[25]))\n \
    \   \n    rows = sort(rows, by=x->-length(x[26]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[27]))\n    \n    rows = sort(rows, by=x->-length(x[28]))\n \
    \   \n    rows = sort(rows, by=x->-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpztybvs64.jl:87\nin expression starting at\
    \ /tmp/tmpztybvs64.jl:87\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        cols[i] = row.index(x)\n        rows[i]\
    \ = i\n    end\n    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n \
    \   ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ all possible combinations of n numbers from an array.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp79ubtnmo.jl:34\nin expression starting at\
    \ /tmp/tmp79ubtnmo.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcbb86cs6.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcbb86cs6.jl:1\n\
    in expression starting at /tmp/tmpcbb86cs6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nProblem 3\nWrite\
    \ a function that finds all the subsets of a given set (without duplicates) of\
    \ size n.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp52cocxio.jl:37\nin expression starting at\
    \ /tmp/tmp52cocxio.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x!=x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(rows, by=x->-length(x[x==x]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==x]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==x]))\n    \n    rows = sort(\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpipsuutqo.jl:83\nin expression starting at\
    \ /tmp/tmpipsuutqo.jl:83\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (min(columns), max(columns)))\n    end\n    \n    rows = sort(rows)\n    \n\
    \    rows = reverse(rows)\n    \n    columns = Vector{Int64}()\n    \n    for\
    \ row in rows\n        push!(columns, row[1])\n    end\n    \n    columns = sort(columns)\n\
    \    \n    columns = reverse(columns)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpe9e8s9x8.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpe9e8s9x8.jl:1\n\
    in expression starting at /tmp/tmpe9e8s9x8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4v_rxrb8.jl:43\nin expression starting at\
    \ /tmp/tmp4v_rxrb8.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = reverse(coords)\n    \n\
    \    coords = reverse(coords)\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfvw7ma9q.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfvw7ma9q.jl:1\n\
    in expression starting at /tmp/tmpfvw7ma9q.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8006dv7q.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8006dv7q.jl:1\n\
    in expression starting at /tmp/tmp8006dv7q.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = length(lst)\n    cols = lst[1].length\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in 1:rows\n        \n        row_coords = Tuple{Int64,\
    \ Int64}(0, row)\n        \n        for col in 1:cols\n            \n        \
    \    col_coords = Tuple{Int64, Int64}(0, col)\n            \n            if lst[row][col]\
    \ == x\n                \n                push!(coords, row_coords)\n        \
    \        push!(coords, col_coords)\n            end\n        end\n    end\n  \
    \  \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n   \
    \ return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6i3ieotq.jl:51\nin expression starting at\
    \ /tmp/tmp6i3ieotq.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1,:])]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpz73d8lxg.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpz73d8lxg.jl:1\n\
    in expression starting at /tmp/tmpz73d8lxg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0_c5tvkj.jl:37\nin expression starting at\
    \ /tmp/tmp0_c5tvkj.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprdnxie1y.jl:43\nin expression starting at\
    \ /tmp/tmprdnxie1y.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpijy43qae.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpijy43qae.jl:1\n\
    in expression starting at /tmp/tmpijy43qae.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    coords = Vector{Tuple{Int64, Int64}}(undef, 0)\n\
    \    \n    for row in rows\n        for col in cols\n            if lst[row][col]\
    \ == x\n                push!(coords, Tuple{row, col})\n            end\n    \
    \    end\n    end\n    \n    coords\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpocl_pf_g.jl:40\nin expression starting at\
    \ /tmp/tmpocl_pf_g.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(lst), 2)\n    \n    for i = 1:length(lst)\n \
    \       coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5nwo4n92.jl:43\nin expression starting at\
    \ /tmp/tmp5nwo4n92.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][i]\n        cols = cols\
    \ + lst[i][1:end-1]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords,\
    \ rev=true)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprb98krnt.jl:45\nin expression starting at\
    \ /tmp/tmprb98krnt.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst[findfirst(x->x==lst[end], lst)-1]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    You are given a\
    \ 2 dimensional data, as a nested lists,\n    which is similar to matrix, however,\
    \ unlike matrices,\n    each row may contain a different number of columns.\n\
    \    Given lst, and integer x, find integers x in the list,\n    and return list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n    Sort coordinates initially by rows in\
    \ ascending order.\n    Also, sort coordinates of the row by columns in descending\
    \ order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n\
    \      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
    \    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpub84qw92.jl:29\nin expression starting at\
    \ /tmp/tmpub84qw92.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp38dyju9t.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp38dyju9t.jl:1\n\
    in expression starting at /tmp/tmp38dyju9t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[i,:] = [lst[rows[i],cols[i]],\
    \ i]\n    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = reverse(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi39nkhoq.jl:36\nin expression starting at\
    \ /tmp/tmpi39nkhoq.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        cols[row] = length(lst[row])\n        rows[row]\
    \ = row\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n \
    \   coords = zeros(Int, length(lst))\n    \n    for row in rows\n        for col\
    \ in cols\n            if lst[row][col] == x\n                coords[row] = col\n\
    \                break\n            end\n        end\n    end\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcnzmisc2.jl:52\nin expression starting at\
    \ /tmp/tmpcnzmisc2.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(1:length(lst)))\n    cols = sort(collect(1:length(lst[1])))\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpegh5jlvp.jl:148\nin expression starting at\
    \ /tmp/tmpegh5jlvp.jl:148\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4h2t28ar.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4h2t28ar.jl:1\n\
    in expression starting at /tmp/tmp4h2t28ar.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt7_97rrn.jl:34\nin expression starting at\
    \ /tmp/tmpt7_97rrn.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpas3lek17.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpas3lek17.jl:1\n\
    in expression starting at /tmp/tmpas3lek17.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpd8w3_41u.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpd8w3_41u.jl:1\n\
    in expression starting at /tmp/tmpd8w3_41u.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for j, (col)\
    \ in enumerate(cols)\n            coords[i,j] = row==col ? x : -1\n        end\n\
    \    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn7jmcns9.jl:28\nin expression starting at\
    \ /tmp/tmpn7jmcns9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        coords[i,:]\
    \ = [row, cols[row]]\n    end\n    \n    coords = coords[sortperm(coords[:,1]),:]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9jyjsxed.jl:35\nin expression starting at\
    \ /tmp/tmp9jyjsxed.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps8nuob57.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmps8nuob57.jl:1\n\
    in expression starting at /tmp/tmps8nuob57.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsil0wkyy.jl:34\nin expression starting at\
    \ /tmp/tmpsil0wkyy.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi295wpgg.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi295wpgg.jl:1\n\
    in expression starting at /tmp/tmpi295wpgg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpepme6_h8.jl:51\nin expression starting at\
    \ /tmp/tmpepme6_h8.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for j, (col) in enumerate(cols)\n            if lst[row][col] == x\n\
    \                coords[i][j] = Tuple(row, col)\n            end\n        end\n\
    \    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa84gs6o3.jl:28\nin expression starting at\
    \ /tmp/tmpa84gs6o3.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        cols[i] = length(row)\n        rows[i]\
    \ = i\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n   \
    \ coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = rows[i]\n    end\n    \n    coords = sort(coords)\n    \n\
    \    coords = coords[coords <= x]\n    \n    coords = coords[coords > 0]\n   \
    \ \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \    \n    coords = coords[reverse .!= coords]\n    \n    coords = coords[reverse\
    \ .!= coords]\n    \n    coords = coords[reverse .!= coords]\n    \n    coords\
    \ = coords[reverse .!= coords]\n    \n    coords = coords[reverse .!= coords]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwhymig0b.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwhymig0b.jl:1\n\
    in expression starting at /tmp/tmpwhymig0b.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = sort(rows)\n    cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols\
    \ = col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4ccnu1od.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4ccnu1od.jl:1\n\
    in expression starting at /tmp/tmp4ccnu1od.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[i, :] = [lst[rows[i],\
    \ cols[i]], lst[rows[i], cols[i]]]\n    end\n    \n    coords = sort(coords, dims=2)\n\
    \    \n    coords = coords[coords[:, 1] .>= x, :]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1i2dqybq.jl:37\nin expression starting at\
    \ /tmp/tmp1i2dqybq.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        lst = sort(lst[row])\n      \
    \  \n        columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            \n            columns = columns + 1\n            \n            if\
    \ lst[col] == x\n                \n                return [(rows - 1, columns\
    \ - 1)]\n            end\n        end\n    end\n    \n    return []\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppojfqqix.jl:47\nin expression starting at\
    \ /tmp/tmppojfqqix.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows <=\
    \ x]\n    \n    rows = rows[rows > x]\n    cols = cols[cols > x]\n    \n    rows\
    \ = rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n \
    \   rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n\
    \    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n   \
    \ cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols =\
    \ cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n\
    \    cols = cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n   \
    \ cols = cols[cols > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols =\
    \ cols[cols < length(lst[1])]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows < length(lst)]\n    cols = cols[cols < length(lst[1])]\n    \n   \
    \ rows = rows[row\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgzo52l_p.jl:1\nin expression starting at /tmp/tmpgzo52l_p.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(enumerate(lst.[1])))\n    cols\
    \ = sort(collect(enumerate(reverse(lst[1]))))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,j) in zip(rows, cols)\n        coords[i, j] = (i,j)\n    end\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvq7dirt3.jl:38\nin expression starting at\
    \ /tmp/tmpvq7dirt3.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfmos6q99.jl:34\nin expression starting at\
    \ /tmp/tmpfmos6q99.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = length(lst)\n    cols = lst[1].length\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in 1:rows\n        \n        row_coords = Tuple{Int64,\
    \ Int64}(0, row)\n        \n        for col in 1:cols\n            \n        \
    \    if lst[row][col] == x\n                \n                push!(coords, row_coords)\n\
    \                \n            end\n            \n        end\n        \n    end\n\
    \    \n    sort(coords, rev=true)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpif07red1.jl:49\nin expression starting at\
    \ /tmp/tmpif07red1.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in lst\n        rows = rows + row\n        cols = cols + 1\n    end\n\
    \    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows\
    \ = rows[cols == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows\
    \ == x]\n    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvgpchzt7.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvgpchzt7.jl:1\n\
    in expression starting at /tmp/tmpvgpchzt7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    columns = sort(collect(1:length(lst[[1]])))\n\
    \    \n    columns = sort(columns, by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(columns))\n    \n    for (r,c) in zip(rows, columns)\n        coords[r][c]\
    \ = (r,c)\n    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi_uzu9sp.jl:38\nin expression starting at\
    \ /tmp/tmpi_uzu9sp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbu0iyyz2.jl:47\nin expression starting at\
    \ /tmp/tmpbu0iyyz2.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqoax065o.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqoax065o.jl:1\n\
    in expression starting at /tmp/tmpqoax065o.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    \n    rows = sort(collect(enumerate(lst.[1])))\n    cols\
    \ = sort(collect(enumerate(reverse(lst[1]))))\n    \n    coords = zeros(Int, 2)\n\
    \    \n    for (i,j) in rows \n        if j == x \n            coords[1] = i\n\
    \            break\n    end\n    \n    for (i,j) in cols \n        if i == x \n\
    \            coords[1] = j\n            break\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxemkf6u8.jl:43\nin expression starting at\
    \ /tmp/tmpxemkf6u8.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols = cols +\
    \ lst[row][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n\
    \        coords[row] = ((rows - row), cols - lst[row][end])\n    end\n    \n \
    \   coords = sort(coords)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp48akvaw0.jl:45\nin expression starting at\
    \ /tmp/tmp48akvaw0.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_932w39d.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_932w39d.jl:1\n\
    in expression starting at /tmp/tmp_932w39d.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst) == 0 \n        return\
    \ [] \n    \n    rows = sort(collect(enumerate(lst)))\n    \n    rows = rows[rows[2]\
    \ .< rows[3]]\n    \n    coords = zeros(Int, length(rows))\n    \n    for (i,row)\
    \ in enumerate(rows)\n        coords[i] = row\n    end\n    \n    coords = coords[coords[2]\
    \ .< coords[3]]\n    \n    coords = coords[coords[1] .< x]\n    \n    coords =\
    \ coords[coords[1] .< x]\n    \n    coords = coords[coords[1] .< x]\n    \n  \
    \  return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6g4v4qa7.jl:44\nin expression starting at\
    \ /tmp/tmp6g4v4qa7.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols\
    \ .<= x]\n    \n    coords = zip(rows, cols)\n    \n    coords = sort!(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2cqtm1go.jl:37\nin expression starting at\
    \ /tmp/tmp2cqtm1go.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpuww60hnu.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuww60hnu.jl:1\n\
    in expression starting at /tmp/tmpuww60hnu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + ones(Int, length(row))\n    end\n    \n    rows = sort(rows)\n    cols\
    \ = sort(cols)\n    \n    rows = rows[rows > x]\n    cols = cols[cols > x]\n \
    \   \n    rows = rows[cols > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n   \
    \ rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n\
    \    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows\
    \ > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n   \
    \ rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols\
    \ > 0]\n    cols = cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols =\
    \ cols[rows > 0]\n    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n\
    \    \n    rows = rows[cols > 0]\n    cols = cols[rows > 0]\n    \n    rows =\
    \ rows[cols > 0]\n    col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_nmd6d8d.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_nmd6d8d.jl:1\n\
    in expression starting at /tmp/tmp_nmd6d8d.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7jnrr35u.jl:34\nin expression starting at\
    \ /tmp/tmp7jnrr35u.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        append!(coords, Tuple{row, cols})\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n \
    \   ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns the number of occurrences of an element in\
    \ a given list.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpht9rdu08.jl:35\nin expression starting at\
    \ /tmp/tmpht9rdu08.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    cols = zeros(Int,\
    \ length(lst))\n    \n    for i = 1:length(lst)\n        cols = cols + lst[i][end]\n\
    \    end\n    \n    cols = sort(cols)\n    \n    return zip(rows, cols)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj706tbh5.jl:42\nin expression starting at\
    \ /tmp/tmpj706tbh5.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqtkat3li.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqtkat3li.jl:1\n\
    in expression starting at /tmp/tmpqtkat3li.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbxp9ihe2.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbxp9ihe2.jl:1\n\
    in expression starting at /tmp/tmpbxp9ihe2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[[1]])))\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        coords[i,:] = [row, cols]\n\
    \    end\n    \n    coords = coords[coords[:,1] .<= x, :]\n    coords = coords[coords[:,2]\
    \ .>= x, :]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb4okk19d.jl:39\nin expression starting at\
    \ /tmp/tmpb4okk19d.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpijwt8ic8.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpijwt8ic8.jl:1\n\
    in expression starting at /tmp/tmpijwt8ic8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3017ixsr.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3017ixsr.jl:1\n\
    in expression starting at /tmp/tmp3017ixsr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1,:])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        coords = coords + [(row, cols[cols..end-1])]\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n \
    \   ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns a list of tuples [(x1, y1), (x2, y2) ...] such\
    \ that\neach tuple is a coordinate - (row, columns), starting with 0.\nSort coordinates\
    \ initially by rows in ascending order.\nAlso, sort coordinates of the row by\
    \ columns in descending order.\nFor example, get_row([\n      [1,2,3,4,5,6],\n\
    \      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqr3eeq9x.jl:35\nin expression starting at\
    \ /tmp/tmpqr3eeq9x.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    columns = sort(collect(1:length(lst[1,:])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        \n        append!(coords, Tuple{Int64,\
    \ Int64}(row, columns[columns == row]))\n    end\n    \n    coords = sort(coords,\
    \ by=x->x[1])\n    coords = sort(coords, by=x->x[2])\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvxtmq7l1.jl:37\nin expression starting at\
    \ /tmp/tmpvxtmq7l1.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppoxabyg4.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppoxabyg4.jl:1\n\
    in expression starting at /tmp/tmppoxabyg4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps_sdrb7b.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmps_sdrb7b.jl:1\n\
    in expression starting at /tmp/tmps_sdrb7b.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpm4gsaztl.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpm4gsaztl.jl:1\n\
    in expression starting at /tmp/tmpm4gsaztl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        lst = sort(lst[row])\n      \
    \  \n        columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            \n            columns = columns + 1\n            \n            if\
    \ lst[col] == x\n                \n                return [(row, columns)]\n \
    \           end\n        end\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9i1t0rep.jl:45\nin expression starting at\
    \ /tmp/tmp9i1t0rep.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (length(columns), max(columns)))\n    end\n    \n    rows = sort(rows)\n   \
    \ \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n    \n   \
    \ rows = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows,\
    \ by=first)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n\
    \    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows,\
    \ by=first)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n\
    \    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = sort(rows, by=first)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = sort(rows, by=last)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows,\
    \ by=first)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows, by=last)\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqzab_euj.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqzab_euj.jl:1\n\
    in expression starting at /tmp/tmpqzab_euj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpew3xkyv5.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpew3xkyv5.jl:1\n\
    in expression starting at /tmp/tmpew3xkyv5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw4e8jo38.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw4e8jo38.jl:1\n\
    in expression starting at /tmp/tmpw4e8jo38.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n \
    \     [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that finds the number of occurrences of x in a nested list.\nFor\
    \ example, get_count([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == 3\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe0gz9rja.jl:34\nin expression starting at\
    \ /tmp/tmpe0gz9rja.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        rows[i] = row\n    end\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    columns = zeros(Int, length(lst))\n    \n    for (i,col)\
    \ in enumerate(lst)\n        columns[i] = col\n    end\n    \n    columns = sort(columns)\n\
    \    \n    columns = reverse(columns)\n    \n    coords = zeros(Int, length(lst))\n\
    \    \n    for (i,coord) in enumerate(zip(rows, columns))\n        coords[i] =\
    \ coord\n    end\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = coords[findfirst(x->x==x, coords)]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphxvna25o.jl:58\nin expression starting at\
    \ /tmp/tmphxvna25o.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvqpsu5yg.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvqpsu5yg.jl:1\n\
    in expression starting at /tmp/tmpvqpsu5yg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoxogqomn.jl:30\nin expression starting at\
    \ /tmp/tmpoxogqomn.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpehi701tf.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpehi701tf.jl:1\n\
    in expression starting at /tmp/tmpehi701tf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}(undef, 0)\n    \n    for row in rows\n        for col in cols\n    \
    \        if lst[row][col] == x\n                push!(coords, Tuple{row, col})\n\
    \            end\n        end\n    end\n    \n    sort(coords, rev=true)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5i7ugel7.jl:37\nin expression starting at\
    \ /tmp/tmp5i7ugel7.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[[1]] .== x]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows\
    \ = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .> rows[[1]]]\n\
    \    \n    rows = rows[rows[[2]] .> rows[[1]]]\n    \n    rows = rows[rows[[2]]\
    \ .> rows[[1]]]\n    \n    rows = rows[rows[[2]] .\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"rows[[2]]\
    \ .\" at /tmp/tmpccd_rehn.jl:82\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpccd_rehn.jl:82\n\
    in expression starting at /tmp/tmpccd_rehn.jl:82\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x,:]\n\
    \    \n    coords = coords[sortperm(coords[:,2]),:]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nget_row([\n      [1,2,3,4,5,6],\n   \
    \   [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]\n</cell>\n<text>\nExercise 2\nWrite a function that finds all\
    \ the coordinates of x in the given list.\nThe function should return a list of\
    \ tuples, where each tuple is a coordinate - (row, columns), starting with 0.\n\
    Sort coordinates initially by rows in ascending order.\nAlso, sort coordinates\
    \ of the row by columns in descending order.\nThe function should work for any\
    \ nested list.\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmvfuex02.jl:39\nin expression starting at\
    \ /tmp/tmpmvfuex02.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (length(columns), columns))\n    end\n    \n    rows = sort(rows)\n    \n  \
    \  rows = reverse(rows)\n    \n    columns = sort(lst[end][end])\n    \n    columns\
    \ = reverse(columns)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = reverse(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    \nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi0kpxnuw.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi0kpxnuw.jl:1\n\
    in expression starting at /tmp/tmpi0kpxnuw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnuvyvsxf.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnuvyvsxf.jl:1\n\
    in expression starting at /tmp/tmpnuvyvsxf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    coords = zeros(Int,\
    \ length(lst))\n    \n    for (i,row) in enumerate(lst)\n        coords[i] = findfirst(x->x==row,\
    \ rows)\n    end\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyim7o3nw.jl:50\nin expression starting at\
    \ /tmp/tmpyim7o3nw.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    \n    for row in rows\n        append!(coords, Tuple{Int64, Int64}(0,\
    \ row))\n        for col in cols\n            if lst[row][col] == x\n        \
    \        append!(coords, Tuple{Int64, Int64}(row, col))\n            end\n   \
    \     end\n    end\n    \n    coords = sort(coords, by=(x->x[1], x->x[2]))\n \
    \   \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl3u3b_q1.jl:40\nin expression starting at\
    \ /tmp/tmpl3u3b_q1.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpu5ero961.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpu5ero961.jl:1\n\
    in expression starting at /tmp/tmpu5ero961.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        coords = coords + [(row, cols[cols..end])]\n\
    \    end\n    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpe3cnl2cf.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpe3cnl2cf.jl:1\n\
    in expression starting at /tmp/tmpe3cnl2cf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7gv8qisl.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7gv8qisl.jl:1\n\
    in expression starting at /tmp/tmp7gv8qisl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for (i,row) in enumerate(rows)\n\
    \        for (c,col) in enumerate(cols)\n            coords[i,c] = Tuple(row,\
    \ col)\n        end\n    end\n    \n    coords = coords[coords[:,1] .== x,:]\n\
    \    \n    coords = coords[coords[:,2] .== x,:]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nget_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n\
    \      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\
    </cell>\n<code language=julia-1.5>\nget_row([], 1) == []\n</cell>\n<code language=julia-1.5>\n\
    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nExercise\nWrite\
    \ a function that finds the number of occurrences of an element in a given list.\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgheyf1zi.jl:39\nin expression starting at\
    \ /tmp/tmpgheyf1zi.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    else \n        rows = sort(collect(1:length(lst)))\n    \
    \    cols = sort(collect(1:length(lst[1])))\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->-x)\n        \n        rows = sort(rows,\
    \ by=x->-x)\n        cols = sort(cols, by=x->\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfdz4u8lz.jl:88\nin expression starting at\
    \ /tmp/tmpfdz4u8lz.jl:88\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmgmd0t3a.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmgmd0t3a.jl:1\n\
    in expression starting at /tmp/tmpmgmd0t3a.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + 1\n      \
    \  cols = cols + length(row)\n        \n        if x == row\n            \n  \
    \          return [(i, j)  for j in (1:cols) ]\n        end\n    end\n    \n \
    \   return []\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn0yj0051.jl:40\nin expression starting at\
    \ /tmp/tmpn0yj0051.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    else \n        rows = sort(collect(1:length(lst)))\n    \
    \    cols = sort(collect(1:length(lst[1])))\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(cols[rows..end])\n        \n        rows = sort(rows[cols..end])\n\
    \        cols = sort(col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuct6xhxh.jl:89\nin expression starting at\
    \ /tmp/tmpuct6xhxh.jl:89\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        \n        rows = rows + row\n    \
    \    cols = cols + 1\n        \n        if i == x\n            \n            rows\
    \ = sort(rows)\n            cols = sort(cols)\n            \n            rows\
    \ = reverse(rows)\n            cols = reverse(cols)\n            \n          \
    \  rows = reverse(rows)\n            cols = reverse(cols)\n            \n    \
    \        return [(i, rows[i]), (i, cols[i])]\n        end\n    end\n    \n   \
    \ return []\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp38bmvq9w.jl:49\nin expression starting at\
    \ /tmp/tmp38bmvq9w.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(lst), 2)\n    \n    for i = 1:length(lst)\n \
    \       coords[i] = (i-1, cols[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nget_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.5>\n\
    get_row([], 1) == []\n</cell>\n<code language=julia-1.5>\nget_row([[], [1], [1,\
    \ 2, 3]], 3) == [(2, 2)]\n</cell>\n<text>\nProblem 3\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp84bw3gjx.jl:45\nin expression starting at\
    \ /tmp/tmp84bw3gjx.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   rows = rows + 1\n        \n        lst = sort(lst[row])\n        \n      \
    \  columns = zeros(Int, length(lst))\n        \n        for col in 1:length(lst)\n\
    \            columns = columns + 1\n            \n            if lst[col] == x\n\
    \                tup = Tuple{Int64, Int64}(row, columns)\n                \n \
    \               push!(rows, tup)\n            end\n        end\n    end\n    \n\
    \    return rows\nend\n</cell>\n<code language=julia-1.3>\nget_row([\n      [1,2,3,4,5,6],\n\
    \      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]\n</cell>\n<code language=julia-1.3>\nget_row([], 1) == []\n\
    </cell>\n<code language=julia-1.3>\nget_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns the number of times\
    \ a given value appears in a given list.\nFor example, given lst = [1, 2, 3, 1,\
    \ 2, 3], and x = 2, the function should return 3.\nWrite a function that returns\
    \ the number of times a given value appears in a given list.\nFor example, given\
    \ lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return 3.\nWrite a\
    \ function that returns the number of times a given value appears in a given list.\n\
    For example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return\
    \ 3.\nWrite a function that returns the number of times a given value appears\
    \ in a given list.\nFor example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the\
    \ function should return 3.\nWrite a function that returns the number of times\
    \ a given value appears in a given list.\nFor example, given lst = [1, 2, 3, 1,\
    \ 2, 3], and x = 2, the function should return 3.\nWrite a function that returns\
    \ the number of times a given value appears in a given list.\nFor example, given\
    \ lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return 3.\nWrite a\
    \ function that returns the number of times a given value appears in a given list.\n\
    For example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the function should return\
    \ 3.\nWrite a function that returns the number of times a given value appears\
    \ in a given list.\nFor example, given lst = [1, 2, 3, 1, 2, 3], and x = 2, the\
    \ function should return 3.\nWrite a function that returns the number of times\
    \ a given value appears in a given list.\nFor example, given lst = [1, 2, 3, 1,\
    \ 2, 3], and x = 2, the function should return 3.\nWrite a function that returns\
    \ the number of times a given value appears in a given list.\nFor example, given\
    \ lst = [1, 2, 3, 1, 2, \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkrw03aqo.jl:46\nin expression starting at\
    \ /tmp/tmpkrw03aqo.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmptzlf1wpz.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptzlf1wpz.jl:1\n\
    in expression starting at /tmp/tmptzlf1wpz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiunb0ins.jl:45\nin expression starting at\
    \ /tmp/tmpiunb0ins.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by = x => -x)\n    \n    coords\
    \ = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n    \
    \    coords[i, :] = [rows, cols]\n    end\n    \n    coords = sort(coords, by\
    \ = x => x[1])\n    coords = sort(coords, by = x => x[2])\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp53drsami.jl:36\nin expression starting at\
    \ /tmp/tmp53drsami.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = reverse(rows)\n    \n    columns = sort(collect(enumerate(rows[end][1])))\n\
    \    \n    columns = reverse(columns)\n    \n    coords = zeros(length(rows),\
    \ length(columns))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(columns)\n            if row[1] == col[1]\n                coords[i,c]\
    \ = (c,row[1])\n            end\n        end\n    end\n    \n    coords = sort(coords,\
    \ by=x->x[1])\n    \n    coords = reverse(coords)\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmhrsqp6s.jl:46\nin expression starting at\
    \ /tmp/tmpmhrsqp6s.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.[1]) == 0 \n    \
    \    return [] \n    else \n        rows = sort(collect(1:length(lst)))\n    \
    \    cols = sort(collect(1:length(lst[1])))\n        \n        rows = sort(rows)\n\
    \        cols = sort(cols)\n        \n        rows = rows[cols..end]\n       \
    \ cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols\
    \ = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols =\
    \ cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n\
    \        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n  \
    \      \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n    \
    \    \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n      \
    \  \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n\
    \        rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n  \
    \      rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n    \
    \    rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n      \
    \  rows = rows[cols..end]\n        cols = cols[rows..end]\n        \n        rows\
    \ = rows[cols..end]\n        cols = cols[rows..end]\n        \n        rows =\
    \ rows[cols..end]\n        cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n\
    \        cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n  \
    \      cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n    \
    \    cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n      \
    \  cols = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols\
    \ = cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols =\
    \ cols[rows..end]\n        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n\
    \        \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n  \
    \      \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n    \
    \    \n        rows = rows[cols..end]\n        cols = cols[rows..end]\n      \
    \  \n        rows = rows[cols..\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcd4686u_.jl:1\nin expression starting at /tmp/tmpcd4686u_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5faywc_1.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5faywc_1.jl:1\n\
    in expression starting at /tmp/tmp5faywc_1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    return [(i, j) for (i, j) in zip(sort(rows),\
    \ sort(cols))]\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9kqq26m5.jl:34\nin expression starting at\
    \ /tmp/tmp9kqq26m5.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp13weidt.jl:37\nin expression starting at\
    \ /tmp/tmpp13weidt.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    rows = sort(collect(enumerate(lst)))\n    \n \
    \   rows = reverse(rows)\n    \n    rows = sort(rows, by=x->x[1])\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = reverse(rows)\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpippib1aq.jl:39\nin expression starting at\
    \ /tmp/tmpippib1aq.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n \
    \   which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \  Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n\
    \      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) ==\
    \ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsgta64jy.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsgta64jy.jl:1\n\
    in expression starting at /tmp/tmpsgta64jy.jl:1\n"
  exit_code: 1
  status: SyntaxError
