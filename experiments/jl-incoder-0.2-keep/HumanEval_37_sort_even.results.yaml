name: HumanEval_37_sort_even
language: julia
results:
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nI\
    \ like this solution, but I wonder if there is a way to avoid the double `findall`\
    \ call. Maybe `sortperm` can do that?\n<|/ c |>\n<| c |>\nI didn't know about\
    \ `sortperm`, but that would require a change to the `sort_even` function which\
    \ I didn't want to do. I'll see if I can come up with something that doesn't require\
    \ that.\n<|/ c |>\n<| c |>\nI added a version that doesn't require `sortperm`.\n\
    <|/ c |>\n<| c |>\nI added a version that doesn't require `sortperm`.\n<|/ c |>\n\
    <| a tags=julia,sorting,arrays |>\nHere's a solution using sortperm:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpik1itle4.jl:17\nin expression starting at\
    \ /tmp/tmpik1itle4.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> mod(x,2) == 0, l)]\n    odd = l[findall(x -> mod(x,2)\
    \ == 1, l)]\n    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nI like the idea of using an anonymous function,\
    \ but this doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]`\n<|/ c |>\n<| c |>\nI tested it and it works. I guess you didn't copy the\
    \ code correctly. Try `sort_even([5, 6, 3, 4])` again.\n<|/ c |>\n<| c |>\nAh,\
    \ I see what happened. I was using an older version of Julia. Thanks!\n<|/ c |>\n\
    <| a tags=julia,sorting |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 5\n 6\n 4\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nThe accepted answer does not work for me. Here's a version that does:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyt0z6gjl.jl:16\nin expression starting at\
    \ /tmp/tmpyt0z6gjl.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list.\
    \ For example, `sort_even([1,1,2,3])` returns `[1,2,3]` instead of `[1,1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI fixed the issue you mentioned\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are duplicate elements in the list. For example, `sort_even([1,1,2,3])`\
    \ returns `[1,2,3]` instead of `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nI fixed the issue\
    \ you mentioned\n<|/ c |>\n<| a dscore=3 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzyebw0u5.jl:17\nin expression starting at\
    \ /tmp/tmpzyebw0u5.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp714nkq1s.jl:17\nin expression starting at\
    \ /tmp/tmp714nkq1s.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if you have duplicate elements in the input array.\n<|/ c |>\n\
    <| c |>\nIt does work if you use sets, as I mentioned in my answer. `set` will\
    \ remove duplicates.\n<|/ c |>\n<| c |>\nI see your point. My answer was meant\
    \ to be a general solution for any type of array (including sets). Your solution\
    \ will work for sets as well.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnaquttln.jl:17\nin expression starting at\
    \ /tmp/tmpnaquttln.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia,sorting |>\nHere's a solution using sortperm:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})\n           even = l[findall(l\
    \ .% 2 == 0)]\n           odd = l[findall(l .% 2 .== 1)]\n           return sortperm(even\
    \ .+ odd)\n       end\nsort_even (generic function with 1 method)\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk_7onvkq.jl:16\nin expression starting at\
    \ /tmp/tmpk_7onvkq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd9wooijb.jl:15\nin expression starting at\
    \ /tmp/tmpd9wooijb.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = sort(even)\n    return even\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote a Julia package called\
    \ SortByIndex which does exactly this. It sorts a vector by index. \n<code>\n\
    julia> using SortByIndex\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzhv5a1s_.jl:17\nin expression starting at\
    \ /tmp/tmpzhv5a1s_.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even.sort()\n    odd.sort()\n    return even ++ odd\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd4a4zxb8.jl:16\nin expression starting at\
    \ /tmp/tmpd4a4zxb8.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = sort(even)\n    odd = sort(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nThis is not the most efficient solution, but I believe it does what you\
    \ want:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp2mr86wg.jl:19\nin expression starting at\
    \ /tmp/tmpp2mr86wg.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the input vector. For example, `sort_even([1,2,2,3,4])` returns `[1,2,2,3,4]`\
    \ instead of `[1,2,3,4,2]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed\
    \ it. I also added a version that doesn't require any imports.\n<|/ c |>\n<| a\
    \ tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo2ac2u4x.jl:17\nin expression starting at\
    \ /tmp/tmpo2ac2u4x.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\nI like using\
    \ mapslices for these sorts of things:\n<code>\njulia> mapslices(sort,rand(1:10,10))\n\
    10-element Array{Int64,1}:\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\nI like using mapslices for these\
    \ sorts of things:\n<code>\njulia> mapslices(sort,rand(1:10,10))\n10-element Array{Int64,1}:\n\
    \ 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=2 |>\nI like using mapslices for these sorts of things:\n<code>\njulia>\
    \ mapslices(sort,rand(1:10,10))\n10-element Array{Int64,1}:\n 3\n 2\n 3\n 2\n\
    \ 3\n 2\n 3\n 2\n 3\n 2\n 3\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n\
    I like using mapslices for these sorts of things:\n<code>\njulia> mapslices(sort,rand(1:10,10))\n\
    10-element Array{Int64,1}:\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia |>\nI like using mapslices for these sorts\
    \ of things:\n<code>\njulia> mapslices(sort,rand(1:10,10))\n10-element Array{Int64,1}:\n\
    \ 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n 2\n 3\n</code>\n<|/ a dscore=2 |>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2lpzjjkc.jl:17\nin expression starting at\
    \ /tmp/tmp2lpzjjkc.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3pbfuzp0.jl:16\nin expression starting at\
    \ /tmp/tmp3pbfuzp0.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.0>\n\
    sort_even([5, 6, 3, 4])\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a list l and returns a list l' such that\n    l' is identical to l in the even\
    \ indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1,\
    \ 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpchl2mvv6.jl:16\nin expression starting at\
    \ /tmp/tmpchl2mvv6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nYes,\
    \ it does. `sort` works on `Array{Int64,1}` just fine.\n<|/ c |>\n<| c |>\nIt\
    \ does work, but only because `sort` works on `Array{Int64,1}` just fine. `sort`\
    \ works on `Array{Int64,2}` just fine, but `sort` doesn't work on `Array{Int64,1}`\
    \ because `sort` doesn't work on `Array{Int64,1}`.\n<|/ c |>\n<| c |>\nOh, I see.\
    \ Thanks for the clarification.\n<|/ c |>\n<| a tags=julia |>\nThe answer by is\
    \ correct, but I thought I'd add an alternative that doesn't require the use of\
    \ findall.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpztgk4j3c.jl:16\nin expression starting at\
    \ /tmp/tmpztgk4j3c.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote a\
    \ function that sorts even and odd numbers in ascending order and returns the\
    \ sorted list. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp20np4otq.jl:17\nin expression starting at\
    \ /tmp/tmp20np4otq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppw0pq11o.jl:16\nin expression starting at\
    \ /tmp/tmppw0pq11o.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work.\
    \ `sort_even([5,6,3,4])` returns `[3,6,5,4]` instead of `[3,6,4,5]`.\n<|/ c |>\n\
    <| c |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<| a tags=sorting,julia\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd0_1elv6.jl:15\nin expression starting at\
    \ /tmp/tmpd0_1elv6.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4oex5s9x.jl:16\nin expression starting at\
    \ /tmp/tmp4oex5s9x.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting |>\n\
    I wrote a package for Julia called Sorting which does this for you. \n<code>\n\
    using Sorting\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpque6lwid.jl:17\nin expression starting at\
    \ /tmp/tmpque6lwid.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\nI like using zip for this\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp25xwr3zw.jl:16\nin expression starting at\
    \ /tmp/tmp25xwr3zw.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    l[findall(l .== even)]\
    \ = odd\n    l\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis does\
    \ not work if there are repeated elements in the list. For example, `sort_even([1,\
    \ 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\n\
    I believe that `sort` will always return sorted arrays. So `sort_even([1, 1, 2,\
    \ 3])` returns `[1, 2, 3]` instead of `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\nI believe\
    \ that `sort` will always return sorted arrays. So `sort_even([1, 1, 2, 3])` returns\
    \ `[1, 2, 3]` instead of `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\nI believe that `sort`\
    \ will always return sorted arrays. So `sort_even([1, 1, 2, 3])` returns `[1,\
    \ 2, 3]` instead of `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\nI believe that `sort`\
    \ will always return sorted arrays. So `sort_even([1, 1, 2, 3])` returns `[1,\
    \ 2, 3]` instead of `[1, 1, 2, 3]`.\n<|/ c |>\n<| a tags=julia,sorting |>\nThis\
    \ solution will work for any number of elements in the list. \n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgprp35oj.jl:18\nin expression starting at\
    \ /tmp/tmpgprp35oj.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkseh02_y.jl:18\nin expression starting at\
    \ /tmp/tmpkseh02_y.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd) |> sort\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nI wanted to add my own answer, because I wanted to see how it compared to\
    \ other answers. I ran it on Julia 1.5.2 and it took about a minute to run on\
    \ my machine.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1pjgjhli.jl:16\nin expression starting at\
    \ /tmp/tmp1pjgjhli.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work for me. `sort_even([5, 6, 3, 4])` returns `[3, 5, 6,\
    \ 4]` instead of `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I used Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works.\
    \ I used Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works.\
    \ I used Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works.\
    \ I used Julia 0.6.2\n<|/ c |>\n<| a dscore=2 |>\nI believe that this is what\
    \ you are looking for:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even.sort()\n           odd.sort()\n           even.extend(odd)\n\
    \           return even\n       end\nsort_even (generic function with 1 method)\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_6sdylpv.jl:17\nin expression starting at\
    \ /tmp/tmp_6sdylpv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</cell>\n<text>\nExercise 4\nWrite\
    \ a function that takes a list l and returns a list l' such that\n    l' is identical\
    \ to l in the even indicies, while its values at the odd indicies are equal\n\
    \    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 5, 6, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjcrd8pft.jl:16\nin expression starting at\
    \ /tmp/tmpjcrd8pft.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nI wrote a function that does this in Julia 1.0:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprs8ubu4d.jl:16\nin expression starting at\
    \ /tmp/tmprs8ubu4d.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp65_02fpz.jl:16\nin expression starting at\
    \ /tmp/tmp65_02fpz.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8h27p0wi.jl:16\nin expression starting at\
    \ /tmp/tmp8h27p0wi.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even.(1:end-1)\n    odd = odd.(1:end-1)\n   \
    \ even = even.(2:end) \n    odd = odd.(2:end) \n    even = even.(1:end-1) \n \
    \   odd = odd.(1:end-1) \n    even = even.(2:end) \n    odd = odd.(2:end) \n \
    \   even = even.(1:end-1) \n    odd = odd.(1:end-1) \n    even = even.(2:end)\
    \ \n    odd = odd.(2:end) \n    even = even.(1:end-1) \n    odd = odd.(1:end-1)\
    \ \n    even = even.(2:end) \n    odd = odd.(2:end) \n    even = even.(1:end-1)\
    \ \n    odd = odd.(1:end-1) \n    even = even.(2:end) \n    odd = odd.(2:end)\
    \ \n    even = even.(1:end-1) \n    odd = odd.(1:end-1) \n    even = even.(2:end)\
    \ \n    odd = odd.(2:end) \n    even = even.(1:end-1) \n    odd = odd.(1:end-1)\
    \ \n    even = even.(2:end) \n    odd = odd.(2:end) \n    even = even.(1:end-1)\
    \ \n    odd = odd.(1:end-1) \n    even = even.(2:end) \n    odd = odd.(2:end)\
    \ \n    even = even.(1:end-1) \n    odd = odd.(1:end-1) \n    even = even.(2:end)\
    \ \n    odd = odd.(2:end) \n    even = even.(1:end-1) \n    odd = odd.(1:end-1)\
    \ \n    even = even.(2:end) \n    odd = odd.(2:end) \n    even = even.(1:end-1)\
    \ \n    odd = odd.(1:end-1) \n    even = even.(2:end) \n    odd = odd.(2:end)\
    \ \n    even = even.(1:end-1) \n    odd = odd.(1:end-1) \n    even = even.(2:end)\
    \ \n    odd = odd.\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing last argument in \"1:\" range expression\
    \ \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4dgfwr10.jl:14\nin expression\
    \ starting at /tmp/tmp4dgfwr10.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp18inry_3.jl:17\nin expression starting at\
    \ /tmp/tmp18inry_3.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work if you\
    \ have repeated elements in the array.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with repeated elements. I hope this helps.\n<|/ c |>\n<| a dscore=1 |>\n\
    I wrote a function that does this in Julia. \n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpixa24f4r.jl:17\nin expression starting at\
    \ /tmp/tmpixa24f4r.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd)\nend\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/10395644)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He wants to sort a\
    \ list by even and odd indices. He is trying to do that by sorting two separate\
    \ lists. He is also trying to do this in one line. He is also trying to do this\
    \ in one line. He is trying to do this in one line. He is trying to do this in\
    \ one line. He is trying to do this in one line. He is trying to do this in one\
    \ line. He is trying to do this in one line. He is trying to do this in one line.\
    \ He is trying to do this in one line. He is trying to do this in one line. He\
    \ is trying to do this in one line. He is trying to do this in one line. He is\
    \ trying to do this in one line. He is trying to do this in one line. He is trying\
    \ to do this in one line. He is trying to do this in one line. He is trying to\
    \ do this in one line. He is trying to do this in one line. He is trying to do\
    \ this in one line. He is trying to do this in one line. He is trying to do this\
    \ in one line. He is trying to do this in one line. He is trying to do this in\
    \ one line. He is trying to do this in one line. He is trying to do this in one\
    \ line. He is trying to do this in one line. He is trying to do this in one line.\
    \ He is trying to do this in one line. He is trying to do this in one line. He\
    \ is trying to do this in one line. He is trying to do this in one line. He is\
    \ trying to do this in one line. He is trying to do this in one line. He is trying\
    \ to do this in one line. He is trying to do this in one line. He is trying to\
    \ do this in one line. He is trying to do this in one line. He is trying to do\
    \ this in one line. He is trying to do this in one line. He is trying to do this\
    \ in one line. He is \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpda81thfg.jl:16\nin expression starting at\
    \ /tmp/tmpda81thfg.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting |>\n\
    Here is a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even = sort_even(even)\n           odd = sort_even(odd)\n\
    \           even = union(even, odd)\n           return sortperm(even)\n      \
    \ end\nsort_even (generic function with 1 method)\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgo2t55a_.jl:17\nin expression starting at\
    \ /tmp/tmpgo2t55a_.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7gyz2kj_.jl:16\nin expression starting at\
    \ /tmp/tmp7gyz2kj_.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=sorting,julia |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0a_71l8t.jl:16\nin expression starting at\
    \ /tmp/tmp0a_71l8t.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are duplicate elements\
    \ in the list. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]`.\n\
    <|/ c |>\n<| c |>\nYes, I see that now. Thanks for pointing that out. I've edited\
    \ my answer to fix it.\n<|/ c |>\n<| a tags=sorting,julia |>\nHere's a solution\
    \ using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n     \
    \      even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 .== 1)]\n\
    \           return sortperm(even .+ odd)\n       end\nsort_even (generic function\
    \ with 1 method)\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxrq15x2s.jl:16\nin expression starting at\
    \ /tmp/tmpxrq15x2s.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicate\
    \ elements in the list. For example, `sort_even([1, 1, 2])` returns `[1, 1, 2]`.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting. `sort_even([1, 1,\
    \ 2])` returns `[1, 1, 2]`.\n<|/ c |>\n<| c |>\nOh, I see what you mean. Yes,\
    \ it does work. Sorry about that. My bad.\n<|/ c |>\n<| c |>\nNo problem. Thanks\
    \ for your help.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_z3dsln4.jl:17\nin expression starting at\
    \ /tmp/tmp_z3dsln4.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if `l` is an `Int64` array, which seems to be the case\
    \ in the question.\n<|/ c |>\n<| c |>\nI agree, my answer was meant to be a general\
    \ solution. I'll edit my answer to include a solution for `Int64` arrays. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5egz498o.jl:16\nin expression starting at\
    \ /tmp/tmp5egz498o.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = sort(even)\n    odd = sort(odd)\n    return\
    \ even ++ odd\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't seem to\
    \ work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I guess you didn't copy the code correctly. Can you\
    \ please try again?\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it, and\
    \ it still doesn't work. I'm running Julia 1.5.1. What version are you using?\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 too. Can you please try again?\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 too. Can you please try again?\n\
    <|/ c |>\n<| a dscore=2 |>\nThis should work:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyzwhikuf.jl:18\nin expression starting at\
    \ /tmp/tmpyzwhikuf.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd) |> sort\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv7xfnvlu.jl:16\nin expression starting at\
    \ /tmp/tmpv7xfnvlu.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    return even\
    \ ++ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it\
    \ with `sort_even([5, 6, 3, 4])`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I added a test case to my answer. Did you try it?\n<|/ c |>\n<| c |>\nYes, I\
    \ did. Your code doesn't work. Try it with `sort_even([5, 6, 3, 4])`.\n<|/ c |>\n\
    <| c |>\nI added a test case to my answer. Did you try it?\n<|/ c |>\n<| c |>\n\
    Yes, I did. Your code doesn't work. Try it with `sort_even([5, 6, 3, 4])`.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk9czt2ow.jl:16\nin expression starting at\
    \ /tmp/tmpk9czt2ow.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = even.(l)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp126_tv_v.jl:15\nin expression starting at\
    \ /tmp/tmp126_tv_v.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=julia |>\nThis can be done using sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia\
    \ |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n   \
    \        even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 .==\
    \ 1)]\n           even.sort()\n           odd.sort()\n           return even +\
    \ odd\n       end\nsort_even (generic function with 1 method)\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpys3id6nj.jl:16\nin expression starting at\
    \ /tmp/tmpys3id6nj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid the\
    \ allocation. Maybe by using a `Vector{Int}` and then `push!`ing values into it\
    \ instead of `sort!`ing them?\n<|/ c |>\n<| c |>\nYes, you can do that too. I'll\
    \ add that to my answer.\n<|/ c |>\n<| c |>\nI added a version that avoids allocation.\
    \ Hope you don't mind.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nThe other\
    \ answers here are great, but I thought I'd add my own solution that is more efficient\
    \ than sort! and is more flexible than sorting.\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm1fe151d.jl:16\nin expression starting at\
    \ /tmp/tmpm1fe151d.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp9yhawwn.jl:17\nin expression starting at\
    \ /tmp/tmpp9yhawwn.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = union(even,\
    \ l)\n    return even\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcda3oc_c.jl:15\nin expression starting at\
    \ /tmp/tmpcda3oc_c.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[5,\
    \ 6, 3, 4]`\n<|/ c |>\n<| c |>\nI tested it and it works. I added the function\
    \ to the answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the function\
    \ to the answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the function\
    \ to the answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the function\
    \ to the answer.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nYou can use the\
    \ sort function and pass it a custom comparison function:\n<code>\njulia> sort(a,\
    \ by=x->x%2)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't seem to work. `sort([5, 6, 3, 4])` returns `[5, 6, 3, 4]`\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I added the function to the answer.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I added the function to the answer.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can use the sort function and pass it a custom\
    \ comparison function:\n<code>\njulia> sort(a, by=x->x%2)\n3-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays\
    \ |>\nThe answer by is correct, but I thought I'd add some explanation as to why\
    \ it works.\nThe by argument to sort is a function that takes a single argument\
    \ and returns a boolean. sort will then sort the array using the boolean value\
    \ returned by by. \nThe function by is called on each element of the array and\
    \ returns a boolean value indicating whether the element should be placed before\
    \ or after the current element. \nThe default sort order is ascending. \nThe function\
    \ by is called on each element of the array and returns a boolean value indicating\
    \ whether the element should be placed before or after the current element. \n\
    The default sort \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5ep5nlva.jl:17\nin expression starting at\
    \ /tmp/tmp5ep5nlva.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = union(even, even)\n    return\
    \ even\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a solution that\
    \ uses only built-in functions:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp03yri60t.jl:17\nin expression starting at\
    \ /tmp/tmp03yri60t.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 ==\
    \ 1, l)]\n    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a |>\nI came up with this solution:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp99onytnt.jl:16\nin expression starting at\
    \ /tmp/tmp99onytnt.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution,\
    \ but I wonder if it can be done without recursion.\n<|/ c |>\n<| c |>\nI guess\
    \ it can, but I wouldn't recommend it. I would just use recursion.\n<|/ c |>\n\
    <| c |>\nI added a recursive solution to my answer.\n<|/ c |>\n<| c |>\nI added\
    \ a recursive solution to my answer.\n<|/ c |>\n<| c |>\nI added a recursive solution\
    \ to my answer.\n<|/ c |>\n<| a |>\nThis can be done using recursion:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn623evhk.jl:17\nin expression starting at\
    \ /tmp/tmpn623evhk.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw5fjit02.jl:14\nin expression starting at\
    \ /tmp/tmpw5fjit02.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2lgm__qs.jl:16\nin expression starting at\
    \ /tmp/tmp2lgm__qs.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work\
    \ if there are duplicate values in the list. For example, `sort_even([1,2,2,3])`\
    \ returns `[1,2,3]` instead of `[1,2,2,3]`.\n<|/ c |>\n<| a tags=julia |>\nI like\
    \ using sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nI like using sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\nI like using sortperm:\n<code>\njulia>\
    \ sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a tags=julia |>\n<| a tags=julia\
    \ |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia |>\nI like using sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a tags=julia |>\n<| a dscore=3\
    \ |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptngiawme.jl:17\nin expression starting at\
    \ /tmp/tmptngiawme.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a list l and returns a list l' such that\n    l' is identical\
    \ to l in the even indicies, while its values at the odd indicies are equal\n\
    \    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz_7i545s.jl:16\nin expression starting at\
    \ /tmp/tmpz_7i545s.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not\
    \ answer the question. He wants to sort a list by its even indices. Your code\
    \ does not do that.\n<|/ c |>\n<| c |>\nThis does answer the question. He wants\
    \ to sort a list by its even indices. He also wants to sort it by its even indices.\
    \ He also wants to sort it by its even indices. He also wants to sort it by its\
    \ even indices. He also wants to sort it by its even indices. He also wants to\
    \ sort it by its even indices. He also wants to sort it by its even indices. He\
    \ also wants to sort it by its even indices. He also wants to sort it by its even\
    \ indices. He also wants to sort it by its even indices. He also wants to sort\
    \ it by its even indices. He also wants to sort it by its even indices. He also\
    \ wants to sort it by its even indices. He also wants to sort it by its even indices.\
    \ He also wants to sort it by its even indices. He also wants to sort it by its\
    \ even indices. He also wants to sort it by its even indices. He also wants to\
    \ sort it by its even indices. He also wants to sort it by its even indices. He\
    \ also wants to sort it by its even indices. He also wants to sort it by its even\
    \ indices. He also wants to sort it by its even indices. He also wants to sort\
    \ it by its even indices. He also wants to sort it by its even indices. He also\
    \ wants to sort it by its even indices. He also wants to sort it by its even indices.\
    \ He also wants to sort it by its even indices. He also wants to sort it by its\
    \ even indices. He also wants to sort it by its even indices. He also wants to\
    \ sort it by its even indices. He also wants to sort it by its even indices. He\
    \ also wants to sort it by its even indices. He also wants to sort it by its even\
    \ indices. He also wants to sort it by its even indices. He also wants to sort\
    \ it by its even indices. He also want\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph42mzhrr.jl:15\nin expression starting at\
    \ /tmp/tmph42mzhrr.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns\
    \ `[1,2,3]` instead of `[2,1,3]`.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it\
    \ on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<|\
    \ a dscore=3 |>\nThe answer by is correct, but I thought I'd add some explanation.\n\
    The reason why your function doesn't work is that you're using == to compare the\
    \ elements of the vectors. However, == compares two vectors by comparing their\
    \ elements by their indices. In other words, it compares l[i] with l[j] where\
    \ i is the index of the element of l and j is the index of the element of l. Since\
    \ you're comparing two vectors, it compares l[i] with l[j] where i is the index\
    \ of the element of l and j is the index of the element of l. Since you're comparing\
    \ two vectors, it compares l[i] with l[j] where i is the index of the element\
    \ of l and j is the index of the element of l. Since you're comparing two vectors,\
    \ it compares l[i] with l[j] where i is the index of the element of l and j is\
    \ the index of the element of l. Since you're comparing two vectors, it compares\
    \ l[i] with l[j] where i is the index of the element of l and j is the index of\
    \ the element of l. Since you're comparing two vectors, it compares l[i] with\
    \ l[j] where i is the index of the element of l and j is the index of the element\
    \ of l. Since you're comparing two vectors, it compares l[i] with l[j] where i\
    \ is the index of the element of l and j is the index of the element of l. Since\
    \ you're comparing two vectors, it compares l[i] with l[j] where i is the index\
    \ of the element of l and j is the index of the element of l. Since you're comparing\
    \ two vectors, it compares l[i] with l[j] where i is the index of the element\
    \ of l and j is the index of the element of l. Since you're comparing two \nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_4443mbn.jl:16\nin expression starting at\
    \ /tmp/tmp_4443mbn.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nI wrote a package called\
    \ Sorting.jl that does this for you:\n<code>\njulia> using Sorting\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbgtpwbmc.jl:16\nin expression starting at\
    \ /tmp/tmpbgtpwbmc.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| a dscore=2 |>\nThe answer by is great,\
    \ but I wanted to add that you can also use sortperms to sort the even indices\
    \ and then sortperms to sort the odd indices. \n<code>\njulia> sortperms([1,2,3])\n\
    3-element Array{Int64,1}:\n 2\n 1\n 3\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2cpjjfep.jl:17\nin expression starting at\
    \ /tmp/tmp2cpjjfep.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqwbxfk3r.jl:16\nin expression starting at\
    \ /tmp/tmpqwbxfk3r.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt works with `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt\
    \ works for me on Julia 1.5.1. What version are you using?\n<|/ c |>\n<| c |>\n\
    I'm using Julia 1.5.1\n<|/ c |>\n<| a tags=julia,sorting |>\nThis should work:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppqgyq6qa.jl:17\nin expression starting at\
    \ /tmp/tmppqgyq6qa.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that takes a list l and returns a list l' such that\n  \
    \  l' is identical to l in the even indicies, while its values at the odd indicies\
    \ are equal\n    to the values of the odd indicies of l, but sorted.\n    >>>\
    \ sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [4,\
    \ 6, 3, 5]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc5jluxof.jl:16\nin expression starting at\
    \ /tmp/tmpc5jluxof.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,julia |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplosfc1h4.jl:18\nin expression starting at\
    \ /tmp/tmplosfc1h4.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like this solution, but I wonder if it can be made more efficient.\
    \ For example, `sort!` does a lot of copying when `sort!` is called on an array\
    \ that is already sorted. Is there a way to avoid this copying?\n<|/ c |>\n<|\
    \ c |>\nI haven't benchmarked it, but I suspect that `sort!` does a lot of copying\
    \ because `sort!` has to copy the entire array before it can sort it. So the only\
    \ way to avoid copying is to sort it in-place. `sort!` doesn't do that because\
    \ it doesn't need to copy the entire array. `sort!` can sort an array in-place\
    \ by copying only a portion of the array and swapping two elements. So `sort!`\
    \ can sort an array in-place by copying only a portion of the array and swapping\
    \ two elements. So `sort!` can sort an array in-place by copying only a portion\
    \ of the array and swapping two elements. So `sort!` can sort an array in-place\
    \ by copying only a portion of the array and swapping two elements. So `sort!`\
    \ can sort an array in-place by copying only a portion of the array and swapping\
    \ two elements. So `sort!` can sort an array in-place by copying only a portion\
    \ of the array and swapping two elements.\n<|/ c |>\n<| c |>\nI suspect that `sort!`\
    \ does a lot of copying because `sort!` has to copy the entire array before it\
    \ can sort it. So the only way to avoid copying is to sort it in-place. `sort!`\
    \ doesn't do that because it doesn't need to copy the entire array. `sort!` can\
    \ sort an array in-place by copying only a portion of the array and swapping two\
    \ elements. So `sort!` can sort an array in-place by copying only a portion of\
    \ the array and swapping two elements. So `sort!` can sort an array in-place by\
    \ copying only a portion of the array and swapping two elements. So `sort!` can\
    \ sort an array in-place by copying only a portion of the array and swapping two\
    \ elements. So `sort!` can sort an array in-place by copying only a portion of\
    \ the array and swapping two elements.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3eatlunv.jl:17\nin expression starting at\
    \ /tmp/tmp3eatlunv.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI believe this should be `even = l[findall(l .% 2 == 0)]` instead\
    \ of `even = l[findall(l .% 2 == 1)]`\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ I fixed it.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1csil1mf.jl:17\nin expression starting at\
    \ /tmp/tmp1csil1mf.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if there are duplicate elements\
    \ in the list. For example, `sort_even([1,2,2,3])` returns `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI see that now. Thanks for pointing that out. I've updated the answer\
    \ to account for that case.\n<|/ c |>\n<| a tags=julia,sorting |>\nThe answer\
    \ by is correct, but I thought I'd add some explanation as to why it works.\n\
    The function sort_even is defined as follows:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprs7qs3ce.jl:16\nin expression starting at\
    \ /tmp/tmprs7qs3ce.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd) |> collect\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the list. For example,\
    \ if `l = [1,1,2,3]`, then `sort_even` returns `[1,2,3]`, not `[1,1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<| a\
    \ dscore=3 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxraq5dc2.jl:16\nin expression starting at\
    \ /tmp/tmpxraq5dc2.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjlkunk43.jl:17\nin expression starting at\
    \ /tmp/tmpjlkunk43.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqand0awq.jl:16\nin expression starting at\
    \ /tmp/tmpqand0awq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = sort(even)\n    odd\
    \ = sort(odd)\n    return even ++ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in the\
    \ input vector. For example, `sort_even([1,1,2,2])` returns `[1,1,2,2]`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I added a fix for that case.\n<|/ c |>\n<| c |>\n\
    I added a fix for that case. Thanks for pointing it out.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nHere is a simple solution that uses sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           return sortperm(l)\n       end\nsort_even (generic function with 1\
    \ method)\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzspmtwmp.jl:18\nin expression starting at\
    \ /tmp/tmpzspmtwmp.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n\
    <| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\n\
    This doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptauop6vj.jl:16\nin expression starting at\
    \ /tmp/tmptauop6vj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=1 |>\nHere is a solution using sort!\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpixog49d2.jl:16\nin expression starting at\
    \ /tmp/tmpixog49d2.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd) |> sort\nend\n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvxvvo59f.jl:16\nin expression starting at\
    \ /tmp/tmpvxvvo59f.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x, y| x + y}\nend\n</code>\n<|/ a\
    \ tags=julia,sorting |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp45_us6sf.jl:14\nin expression starting at\
    \ /tmp/tmp45_us6sf.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks for the answer! I ended up using something similar to this, but I\
    \ used the mod operator to find the even indicies and odd indicies and then used\
    \ the sort function to sort them.\n<|/ c |>\n<| a tags=julia |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpryd_fhvc.jl:16\nin expression starting at\
    \ /tmp/tmpryd_fhvc.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    even = sort(even)\n    even =\
    \ l[findall(x -> x % 2 == 0, l)]\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3,\
    \ 6, 5, 4]`\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I've edited\
    \ my answer to reflect what I think you meant.\n<|/ c |>\n<| c |>\nThis works.\
    \ I guess I misunderstood the question. I've edited my answer to reflect what\
    \ I think you meant.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question.\
    \ I've edited my answer to reflect what I think you meant.\n<|/ c |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`\n\
    <|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5nuhzs7m.jl:15\nin expression starting at\
    \ /tmp/tmp5nuhzs7m.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input array.\n\
    <|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy9sd91n4.jl:16\nin expression starting at\
    \ /tmp/tmpy9sd91n4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = sort(even)\n    odd = sort(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c\
    \ |>\nThanks for your answer. Your code works but is very slow. My original code\
    \ was much faster. I am not sure why.\n<|/ c |>\n<| c |>\nI added my original\
    \ code to the question. I am not sure why it is so slow for you. Maybe it is because\
    \ I used a for loop?\n<|/ c |>\n<| c |>\nI added my original code to the question.\
    \ I am not sure why it is so slow for you. Maybe it is because I used a for loop?\n\
    <|/ c |>\n<| c |>\nI added my original code to the question. I am not sure why\
    \ it is so slow for you. Maybe it is because I used a for loop?\n<|/ c |>\n<|\
    \ c |>\nI added my original code to the question. I am not sure why it is so slow\
    \ for you. Maybe it is because I used a for loop?\n<|/ c |>\n<| a tags=julia |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptskwoddy.jl:19\nin expression starting at\
    \ /tmp/tmptskwoddy.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=sorting,julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3i_nixu2.jl:16\nin expression starting at\
    \ /tmp/tmp3i_nixu2.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=2\
    \ |>\nI wrote a package called ArrayTools.jl that provides many useful array manipulation\
    \ functions. Here are some examples:\n<code>\njulia> using ArrayTools\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7e70pmb1.jl:17\nin expression starting at\
    \ /tmp/tmp7e70pmb1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppor2t_9i.jl:16\nin expression starting at\
    \ /tmp/tmppor2t_9i.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7_rly60v.jl:16\nin expression starting at\
    \ /tmp/tmp7_rly60v.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = union(even, even)\n    return\
    \ even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia |>\nHere is a\
    \ simple solution that uses only built-in functions:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuxcvvlma.jl:17\nin expression starting at\
    \ /tmp/tmpuxcvvlma.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpluvl52or.jl:15\nin expression starting at\
    \ /tmp/tmpluvl52or.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([5, 6, 3, 4])` returns `[3,\
    \ 6, 5, 4]` instead of `[3, 6, 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it on julia\
    \ 0.4.6 and it works. What version are you using?\n<|/ c |>\n<| c |>\nI tested\
    \ it on julia 0.4.6 and it works. What version are you using?\n<|/ c |>\n<| c\
    \ |>\nI tested it on julia 0.4.6 and it works. What version are you using?\n<|/\
    \ c |>\n<| c |>\nI tested it on julia 0.4.6 and it works. What version are you\
    \ using?\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl48mobhi.jl:16\nin expression starting at\
    \ /tmp/tmpl48mobhi.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    l = copy(even)\n    for e in even\n        push!(l,\
    \ e)\n    end\n    for o in odd\n        push!(l, o)\n    end\n    return l\n\
    end\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if there\
    \ are duplicate values in the input vector. For example, `sort_even([1, 1, 2,\
    \ 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I've edited my answer to account for that case.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI believe that this is what you are looking for:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprchj7ful.jl:23\nin expression starting at\
    \ /tmp/tmprchj7ful.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = l[findall(l\
    \ .% 2 == 1)]\n    even = sort_even(even)\n    return even\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=sorting,julia |>\nThe accepted answer doesn't work\
    \ for me. Here's my solution:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdwmiymvu.jl:16\nin expression starting at\
    \ /tmp/tmpdwmiymvu.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = sort(even)\n    odd\
    \ = sort(odd)\n    return even ++ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the list. For example, `sort_even([1,2,2,3,4])`\
    \ returns `[1,2,2,3,4]`.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ duplicates.\n<|/ c |>\n<| c |>\nI added a version that works with duplicates.\n\
    <|/ c |>\n<| a tags=sorting,julia |>\nI wrote a package called SortArrays.jl that\
    \ does this sort of thing:\n<code>\njulia> using SortArrays\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm12yz8ns.jl:18\nin expression starting at\
    \ /tmp/tmpm12yz8ns.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes a list l and returns a list l' such that\n    l' is identical\
    \ to l in the even indicies, while its values at the odd indicies are equal\n\
    \    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnl2_qp5q.jl:16\nin expression starting at\
    \ /tmp/tmpnl2_qp5q.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=1 |>\nI came up\
    \ with a solution that is more efficient than sorting the entire list and then\
    \ removing duplicates. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb8kgphc7.jl:17\nin expression starting at\
    \ /tmp/tmpb8kgphc7.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\nThe answer by is correct but can be simplified\
    \ a bit:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo9cqe0hh.jl:17\nin expression starting at\
    \ /tmp/tmpo9cqe0hh.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe solution\
    \ using sort! is very elegant, but it is O(n^2) in time and space. Here is a solution\
    \ that is O(n) in time and O(1) in space:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5b_dh06y.jl:17\nin expression starting at\
    \ /tmp/tmp5b_dh06y.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicates in the list. For example, `sort_even([5,\
    \ 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]` instead of `[3, 6, 5, 4]`.\n<|/ c |>\n\
    <| c |>\nGood catch. I fixed the code so it now works with duplicates.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nThis should work:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0qh3ledm.jl:16\nin expression starting at\
    \ /tmp/tmp0qh3ledm.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nI came up with\
    \ a solution that is quite efficient and doesn't require any packages:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqd2oy933.jl:17\nin expression starting at\
    \ /tmp/tmpqd2oy933.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array.\
    \ `sort!` will sort `Int64` arrays lexicographically, not numerically.\n<|/ c\
    \ |>\n<| c |>\nGood point. I added a version that works with `Int64` arrays. Thanks!\n\
    <|/ c |>\n<| a |>\nHere's a solution using sort!:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2s8n981n.jl:17\nin expression starting at\
    \ /tmp/tmp2s8n981n.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have a vector of length greater than 2.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe easiest way is to use the sort function with a\
    \ custom comparison function:\n<code>\njulia> sort([5,6,3,1], lt=(x) -> x%2==0)\n\
    3-element Array{Int64,1}:\n 1\n 3\n 5\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| c |>\nThis doesn't work if you have a vector of length greater than 2.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdf6flzlx.jl:16\nin expression starting at\
    \ /tmp/tmpdf6flzlx.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = sort_even(even)\n    return even\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nI wrote a function that sorts even numbers\
    \ in ascending order and odd numbers in descending order. \n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprnc4m38i.jl:17\nin expression starting at\
    \ /tmp/tmprnc4m38i.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=julia |>\nI like your solution, but I thought I'd add my own solution,\
    \ which is slightly more efficient (but still not as elegant) than yours. I used\
    \ the fact that sorting is stable and that you can sort a vector in-place. \n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppx2p3zc4.jl:16\nin expression starting at\
    \ /tmp/tmppx2p3zc4.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the original list.\
    \ For example, `sort_even([1,2,2,3])` returns `[1,2,3]` instead of `[1,2,2,3]`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it works as\
    \ expected.\n<|/ c |>\n<| a dscore=3 |>\n<code>\njulia> sort_even([1,2,2,3])\n\
    3-element Array{Int64,1}:\n 1\n 2\n 2\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=3 |>\n<code>\njulia> sort_even([1,2,2,3])\n3-element Array{Int64,1}:\n\
    \ 1\n 2\n 2\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpywxbus2_.jl:15\nin expression starting at\
    \ /tmp/tmpywxbus2_.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| a tags=julia\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2imyue7.jl:16\nin expression starting at\
    \ /tmp/tmpt2imyue7.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 ==\
    \ 1, l)]\n    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the list. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1,\
    \ 2, 3]`.\n<|/ c |>\n<| c |>\nI believe this answer is correct, though I haven't\
    \ tested it myself. It seems like the correct approach is to sort both lists separately\
    \ and then concatenate the two sorted lists.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are repeated elements in the list. For example, `sort_even([1,\
    \ 1, 2, 3])` returns `[1, 1, 2, 3]`.\n<|/ c |>\n<| a tags=julia,sorting |>\nHere's\
    \ a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(x -> x % 2 == 0, l)]\n           odd = l[findall(x\
    \ -> x % 2 == 1, l)]\n           return sortperm(even .+ odd)\n       end\nsort_even\
    \ (generic function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx0v_4a3e.jl:16\nin expression starting at\
    \ /tmp/tmpx0v_4a3e.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1_6ime8d.jl:17\nin expression starting at\
    \ /tmp/tmp1_6ime8d.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for your answer!\
    \ I tried to run your code, but I got this error `MethodError: no method matching\
    \ sort_even(::Int64)`. Any ideas on how to fix this?\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a solution that should work\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I tried to run your code, but I got this error `MethodError:\
    \ no method matching sort_even(::Int64)`. Any ideas on how to fix this?\n<|/ c\
    \ |>\n<| c |>\nI edited my answer to include a solution that should work\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I tried to run your code, but I got this\
    \ error `MethodError: no method matching sort_even(::Int64)`. Any ideas on how\
    \ to fix this?\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp92j0lufk.jl:17\nin expression starting at\
    \ /tmp/tmp92j0lufk.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdd2rs9sn.jl:16\nin expression starting at\
    \ /tmp/tmpdd2rs9sn.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work. `sort` sorts in-place, so `even` will just be the original list\
    \ unsorted. Also, `sort` doesn't return anything, so `even` will just be the original\
    \ list unsorted.\n<|/ c |>\n<| c |>\nAh, you're right. `sort` doesn't return anything.\
    \ I've fixed the code. Thanks for pointing that out.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even.sort()\n           odd.sort()\n           return even\
    \ + odd\n       end\nsort_even (generic function with 1 method)\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0z39dqyj.jl:16\nin expression starting at\
    \ /tmp/tmp0z39dqyj.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nI came up with this:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm9xsowno.jl:17\nin expression starting at\
    \ /tmp/tmpm9xsowno.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,sorting |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbiyf9ri1.jl:17\nin expression starting at\
    \ /tmp/tmpbiyf9ri1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes a list l and returns a list l' such that\n    l' is identical\
    \ to l in the even indicies, while its values at the odd indicies are equal\n\
    \    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwl24wmif.jl:16\nin expression starting at\
    \ /tmp/tmpwl24wmif.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).map(x -> x[1])\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis doesn't work if there are duplicate elements in the list. For example,\
    \ `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]` instead of `[3, 6, 5,\
    \ 4]`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I fixed the code by adding\
    \ `even.sort()` before `odd.sort()`.\n<|/ c |>\n<| a |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkkx6120b.jl:16\nin expression starting at\
    \ /tmp/tmpkkx6120b.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list.\
    \ For example, `sort_even([1,2,2,3])` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I see what you mean. Thanks for pointing that out. I updated the answer to account\
    \ for duplicates.\n<|/ c |>\n<| a tags=sorting,julia |>\nHere's a solution using\
    \ sortperm:\n<code>\njulia> sort_even([1,2,3])\n3-element Array{Int64,1}:\n 1\n\
    \ 2\n 3\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp86afphug.jl:16\nin expression starting at\
    \ /tmp/tmp86afphug.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/\
    \ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])`\
    \ returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nI tested it on Julia\
    \ 0.6.2 and 0.6.3. I also tested it on 0.6.1 and 0.6.2. What version are you using?\n\
    <|/ c |>\n<| c |>\nI'm on 0.6.1. I guess it's time to upgrade. Thanks!\n<|/ c\
    \ |>\n<| a dscore=2 |>\nThe accepted answer doesn't work for me. Here's a version\
    \ that does:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdx3i1gpq.jl:16\nin expression starting at\
    \ /tmp/tmpdx3i1gpq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]` instead of `[3, 6, 4, 5]`.\n<|/ c |>\n<| c |>\nI fixed it by changing `even.sort()`\
    \ to `even.sort() .= even`.\n<|/ c |>\n<| c |>\nI fixed it by changing `even.sort()`\
    \ to `even.sort() .= even`.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplwt5mp7r.jl:16\nin expression starting at\
    \ /tmp/tmplwt5mp7r.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nI wanted to add another\
    \ answer that doesn't require a custom sort function, but instead uses Julia's\
    \ built-in sort function.  It also doesn't require any additional packages.\n\
    <code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\
    \ 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis should be the\
    \ accepted answer. `sort` does exactly what OP asked for, while `sort!` does something\
    \ else.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\njulia> sort(collect(1:10))\n\
    10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n\
    <|/ a dscore=4 |>\n<| a |>\n<code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a tags=julia,sorting dscore=4\
    \ |>\n<| a tags=julia,sorting |>\n<code>\njulia> sort(collect(1:10))\n10-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\n<code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| a |>\n<code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n 1\n\
    \ 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a tags=\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5pjqoxy6.jl:16\nin expression starting at\
    \ /tmp/tmp5pjqoxy6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the array.\
    \ For example, `sort_even([1,2,2,3])` returns `[1,2,3]`.\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmjo8jbdx.jl:16\nin expression starting at\
    \ /tmp/tmpmjo8jbdx.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate values in the list. For\
    \ example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\n\
    Yes, I noticed that and fixed it by adding another line that sorts the even values\
    \ before concatenating the odd values.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate values in the list. For example, `sort_even([1, 1, 2, 3])`\
    \ returns `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it\
    \ by adding another line that sorts the even values before concatenating the odd\
    \ values.\n<|/ c |>\n<| c |>\nThis doesn't work if there are duplicate values\
    \ in the list. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]`.\n\
    <|/ c |>\n<| a dscore=3 |>\nI believe this to be the most efficient solution:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})\n           even = l[findall(l\
    \ .== 0)]\n           odd = l[findall(l .!= 0)]\n           even = sort_even(even)\n\
    \           odd = sort_even(odd)\n           return even .+ odd\n       end\n\
    sort_even (generic function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy958nm9g.jl:16\nin expression starting at\
    \ /tmp/tmpy958nm9g.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a |>\nThe solution by is very elegant,\
    \ but can be improved by using Julia's built-in sort function and passing a custom\
    \ comparison function as the second argument:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           return sort(even, lt=(x->x<=>odd.last))\n       end\nsort_even\
    \ (generic function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph4dwe1ic.jl:16\nin expression starting at\
    \ /tmp/tmph4dwe1ic.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even.(l .== 0)\n    odd = odd.(l .!= 0)\n   \
    \ even = union(even, odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5_79jb4b.jl:19\nin expression starting at\
    \ /tmp/tmp5_79jb4b.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .!= 0)]\n    return even\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpyht74tph.jl:20\n  Expression: candidate([1,\
    \ 2, 3]) == [1, 2, 3]\n   Evaluated: Int64[] == [1, 2, 3]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyht74tph.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyht74tph.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpyht74tph.jl:21\n  Expression: candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]\n   Evaluated:\
    \ Int64[] == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyht74tph.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyht74tph.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpyht74tph.jl:22\n  Expression: candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]\n   Evaluated:\
    \ Int64[] == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyht74tph.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyht74tph.jl:19\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyht74tph.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqdhqgmz6.jl:16\nin expression starting at\
    \ /tmp/tmpqdhqgmz6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpieuz1gqz.jl:16\nin expression starting at\
    \ /tmp/tmpieuz1gqz.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9i5s6m8q.jl:16\nin expression starting at\
    \ /tmp/tmp9i5s6m8q.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input array.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting.\n<|/ c |>\n<| c |>\n\
    I tested it on Julia 0.6.2 and it works. I added a test case to my answer.\n<|/\
    \ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I added a test case\
    \ to my answer.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it works. I\
    \ added a test case to my answer.\n<|/ c |>\n<| a dscore=3 |>\nThe accepted answer\
    \ doesn't work for duplicates in the input array. Here's a version that does:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdkj6y8f6.jl:14\nin expression starting at\
    \ /tmp/tmpdkj6y8f6.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=sorting,julia |>\n<| c |>\nThis doesn't\
    \ seem to work if there are duplicate elements in the list. For example, `sort_even([1,1,2,3])`\
    \ returns `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if there\
    \ are duplicate elements in the list. For example, `sort_even([1,1,2,3])` returns\
    \ `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if there are duplicate\
    \ elements in the list. For example, `sort_even([1,1,2,3])` returns `[1,1,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if there are duplicate elements in\
    \ the list. For example, `sort_even([1,1,2,3])` returns `[1,1,2,3]`.\n<|/ c |>\n\
    <| a dscore=4 |>\nThe accepted answer doesn't work for duplicate elements in the\
    \ list. For example, sort_even([1,1,2,3]) returns [1,1,2,3].\nHere's a solution\
    \ that works with duplicate elements in the list:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4hgzqxke.jl:18\nin expression starting at\
    \ /tmp/tmp4hgzqxke.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nHere's a solution using sortperm:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu5pb3l_l.jl:16\nin expression starting at\
    \ /tmp/tmpu5pb3l_l.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv4_bez4n.jl:17\nin expression starting at\
    \ /tmp/tmpv4_bez4n.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    return even \nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3,\
    \ 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used `sort_even([5,\
    \ 6, 3, 4])` as input and it returned `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I used `sort_even([5, 6, 3, 4])` as input and it returned\
    \ `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it again and it works. I used `sort_even([5,\
    \ 6, 3, 4])` as input and it returned `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I used `sort_even([5, 6, 3, 4])` as input and it returned\
    \ `[3, 6, 5, 4]`.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a package called Sorting.jl\
    \ that does this for you:\n<code>\njulia> using Sorting\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqfbutkyy.jl:16\nin expression starting at\
    \ /tmp/tmpqfbutkyy.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\nA bit more concise and efficient:\n<code>\n\
    julia> function sort_even(l::Vector{Int64})\n           even = l[findall(l .%\
    \ 2 == 0)]\n           odd = l[findall(l .% 2 != 0)]\n           even.sort()\n\
    \           odd.sort()\n           return even .+ odd\n       end\nsort_even (generic\
    \ function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw979vx9u.jl:16\nin expression starting at\
    \ /tmp/tmpw979vx9u.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    even = sort_even(even)\n    even\
    \ = sort(even)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([5, 6, 3, 4])` returns `[3,\
    \ 6, 5, 4]` instead of `[5, 6, 3, 4]`.\n<|/ c |>\n<| c |>\nOops, I forgot to sort\
    \ the even elements. Fixed now.\n<|/ c |>\n<| c |>\nThis doesn't work for me.\
    \ `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]` instead of `[5, 6, 3, 4]`.\n\
    <|/ c |>\n<| c |>\nOops, I forgot to sort the even elements. Fixed now.\n<|/ c\
    \ |>\n<| a dscore=3 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx0rhs6ss.jl:15\nin expression starting at\
    \ /tmp/tmpx0rhs6ss.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote a\
    \ Julia package that does this for you:\nhttps://github.com/jamie-may/JuliaArrays\n\
    <code>\njulia> using JuliaArrays\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx6cknk9_.jl:17\nin expression starting at\
    \ /tmp/tmpx6cknk9_.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = union(even, even)\n    return\
    \ even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI believe this solution is O(n^2)\
    \ because of the sorting. Sorting is a O(n log n) operation.\n<|/ c |>\n<| c |>\n\
    Yes, sorting is O(n log n), but it's only done once per list element. Sorting\
    \ is not done more than once.\n<|/ c |>\n<| c |>\nYes, I agree with you. Sorting\
    \ is a O(n log n) operation. But the sorting is done only once per list element.\
    \ Sorting is not done more than once.\n<|/ c |>\n<| c |>\nI believe that sorting\
    \ is done only once per list element. Sorting is not done more than once.\n<|/\
    \ c |>\n<| c |>\nYes, I agree with you. Sorting is a O(n log n) operation. But\
    \ the sorting is done only once per list element. Sorting is not done more than\
    \ once.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw5_d2uvl.jl:17\nin expression starting at\
    \ /tmp/tmpw5_d2uvl.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified a bit. `sort_even` can be written as `sort_even = x ->\
    \ sort(x, rev=true)`.\n<|/ c |>\n<| c |>\nYes, that is a nice improvement. Thanks.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\nHere's a solution using sortperm:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpejpoxr2s.jl:17\nin expression starting at\
    \ /tmp/tmpejpoxr2s.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work\
    \ if there are duplicates in the input vector. For example, `sort_even([1,2,2,3])`\
    \ returns `[1,2,3]` instead of `[1,2,2,3]`.\n<|/ c |>\n<| c |>\nThanks, I fixed\
    \ it.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using sortperm:\n<code>\n\
    julia> function sort_even(l::Vector{Int64})\n           even = l[findall(l .==\
    \ 0)]\n           odd = l[findall(l .!= 0)]\n           even = sort_even(even)\n\
    \           odd = sort_even(odd)\n           even = union(even, odd)\n       \
    \    even = sortperm(even)\n           return even\n       end\nsort_even (generic\
    \ function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx0ca0eqd.jl:18\nin expression starting at\
    \ /tmp/tmpx0ca0eqd.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia,sorting,arrays |>\nThe accepted answer does not work for\
    \ me. Here is a working solution:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5p7cp482.jl:14\nin expression starting at\
    \ /tmp/tmp5p7cp482.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ c |>\nThis doesn't work if there are duplicates in the input vector. For example,\
    \ `sort_even([1,1,2,3])` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nI believe this\
    \ answer should be updated to use `sortperm` instead of `sort`. `sortperm` will\
    \ preserve the original order of the elements in the input vector, while `sort`\
    \ will sort the elements in the input vector in lexicographical order.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nI believe this answer should be updated to use sortperm\
    \ instead of sort. sortperm will preserve the original order of the elements in\
    \ the input vector, while sort will sort the elements in the input vector in lexicographical\
    \ order.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp19f8u0w0.jl:16\nin expression starting at\
    \ /tmp/tmp19f8u0w0.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort!\n\
    \    odd.sort!\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxqp993xl.jl:14\nin expression starting at\
    \ /tmp/tmpxqp993xl.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjm89ngxa.jl:14\nin expression starting at\
    \ /tmp/tmpjm89ngxa.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt\
    \ works with `Array{Int64,1}` just fine. `sort` works on `Array{Int64,1}` just\
    \ fine.\n<|/ c |>\n<| c |>\nAh, I see. My mistake. Thanks for pointing that out.\n\
    <|/ c |>\n<| a dscore=2 |>\nI came up with a solution that doesn't require any\
    \ packages. It's a little bit more verbose than some of the other solutions, but\
    \ it works with any type of collection (including Array{Int64,1}):\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpri_7df6l.jl:16\nin expression starting at\
    \ /tmp/tmpri_7df6l.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if there are duplicate elements in the list. For example, `sort_even([1,1,2,3])`\
    \ returns `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted\
    \ my comment. I've updated my answer to include a version that doesn't have that\
    \ problem.\n<|/ c |>\n<| a tags=julia,sorting |>\nI wanted to add an answer that\
    \ doesn't require any packages, just base Julia functions. I came up with this\
    \ solution:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpih9lfrjm.jl:17\nin expression starting at\
    \ /tmp/tmpih9lfrjm.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks for your answer. Your code works fine for small lists, but it fails\
    \ for large lists. I get the following error for large lists: ```ERROR: LoadError:\
    \ Stack overflow (local array size limit exceeded)```\n<|/ c |>\n<| c |>\nI tested\
    \ it on lists of length 10^6 and it worked fine. Are you sure you didn't just\
    \ run out of memory?\n<|/ c |>\n<| c |>\nI tested it on lists of length 10^7 and\
    \ it worked fine. Are you sure you didn't just run out of memory?\n<|/ c |>\n\
    <| c |>\nI tested it on lists of length 10^8 and it worked fine. Are you sure\
    \ you didn't just run out of memory?\n<|/ c |>\n<| c |>\nI tested it on lists\
    \ of length 10^9 and it worked fine. Are you sure you didn't just run out of memory?\n\
    <|/ c |>\n<| a dscore=1 |>\nI wrote a recursive function which should do the trick:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptchnbhkr.jl:16\nin expression starting at\
    \ /tmp/tmptchnbhkr.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified a bit. `sort_even` can be written as `sort_even = x ->\
    \ sort(x, rev=!iseven)`. Then `sort_even` can be written as `sort_even = x ->\
    \ sort(x, rev=!iseven, by=identity)`. Then `sort_even` can be written as `sort_even\
    \ = x -> sort(x, rev=!iseven, by=identity, stable=true)`. Then `sort_even` can\
    \ be written as `sort_even = x -> sort(x, rev=!iseven, by=identity, stable=true,\
    \ inplace=true)`. Then `sort_even` can be written as `sort_even = x -> sort(x,\
    \ rev=!iseven, by=identity, inplace=true)`. Then `sort_even` can be written as\
    \ `sort_even = x -> sort(x, rev=!iseven, by=identity, inplace=true, stable=true)`.\
    \ Then `sort_even` can be written as `sort_even = x -> sort(x, rev=!iseven, by=identity,\
    \ inplace=true, stable=true)`. Then `sort_even` can be written as `sort_even =\
    \ x -> sort(x, rev=!iseven, by=identity, inplace=true, stable=true)`. Then `sort_even`\
    \ can be written as `sort_even = x -> sort(x, rev=!iseven, by=identity, inplace=true,\
    \ stable=true)`. Then `sort_even` can be written as `sort_even = x -> sort(x,\
    \ rev=!iseven, by=identity, inplace=true, stable=true)`. Then `sort_even` can\
    \ be written as `sort_even = x -> sort(x, rev=!iseven, by=identity, inplace=true,\
    \ stable=true)`. Then `sort_even` can be written as `sort_even = x -> sort(x,\
    \ rev=!iseven, by=identity, inplace=true, stable=true)`. Then `sort_even` can\
    \ be written as `sort_even = x -> sort(x, rev=!iseven, by=identity, inplace=true,\
    \ stable=true)`. Then `sort_even` can be written as `sort_even = x -> sort(x,\
    \ rev=!iseven, \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprw54qncb.jl:17\nin expression starting at\
    \ /tmp/tmprw54qncb.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list.\
    \ For example, `sort_even([1,1,2,3])` returns `[1,1,2,3]`.\n<|/ c |>\n<| c |>\n\
    Yes, I see that now. Thanks for pointing that out. I've edited my answer to fix\
    \ the problem.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprtdj50d7.jl:14\nin expression starting at\
    \ /tmp/tmprtdj50d7.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a dscore=1 |>\nI wanted to add another answer\
    \ that uses Julia's built-in sort function, but that doesn't require the use of\
    \ any extra packages. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiy04uqm6.jl:16\nin expression starting at\
    \ /tmp/tmpiy04uqm6.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays\
    \ |>\nA more general solution that will work for any number of dimensions:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpza3ppv_n.jl:17\nin expression starting at\
    \ /tmp/tmpza3ppv_n.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = sort(even)\n    odd\
    \ = sort(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n<|/\
    \ a tags=julia,sorting |>\n<| a dscore=1 |>\nHere's a solution that uses only\
    \ built-in functions:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvyx52e6d.jl:19\nin expression starting at\
    \ /tmp/tmpvyx52e6d.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = sort(even)\n    return even\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI like to use Julia's built-in\
    \ sort! function for this purpose:\n<code>\njulia> sort!([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia |>\n\
    <| c |>\nThis does not sort the list in-place. `sort!` returns a new sorted list.\n\
    <|/ c |>\n<| c |>\nYes, I know. I was just giving a simple example to show that\
    \ `sort!` can be used.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2765fs20.jl:17\nin expression starting at\
    \ /tmp/tmp2765fs20.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the input vector. For example, `sort_even([1,\
    \ 1, 2, 3])` returns `[1, 1, 2, 3]`, which is not the sorted version.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nsort_even(x::Vector{Int64}) = sort(x)[findall(x .% 2\
    \ == 0)]\n</code>\n<|/ a tags=julia,sorting |>\n<| a dscore=2 |>\n<code>\nsort_even(x::Vector{Int64})\
    \ = sort(x)[findall(x .% 2 == 0)]\n</code>\n<|/ a tags=julia,sorting |>\n<| a\
    \ dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp74va55mw.jl:17\nin expression starting at\
    \ /tmp/tmp74va55mw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5hjq1muq.jl:16\nin expression starting at\
    \ /tmp/tmp5hjq1muq.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nI tested it and it works for me. Are\
    \ you sure you copied it correctly? I tested it on Julia 0.6.2\n<|/ c |>\n<| c\
    \ |>\nI copied it exactly as you wrote it. I also tested it on 0.6.2. What version\
    \ are you using?\n<|/ c |>\n<| c |>\nI am using 0.6.2. I tried it on 0.6.2 and\
    \ it works. I guess it might be a problem with my version of Julia. I'll try it\
    \ on 0.6.2 and see if it works.\n<|/ c |>\n<| c |>\nIt works on 0.6.2 as well.\
    \ Maybe you have a problem with your installation? What happens when you run `julia\
    \ --version`?\n<|/ c |>\n<| a dscore=3 |>\nThe accepted answer doesn't work for\
    \ me. Here's a version that does:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_uikzepb.jl:16\nin expression starting at\
    \ /tmp/tmp_uikzepb.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like this solution, although I wonder if there is a more efficient\
    \ way to do this in Julia. Perhaps some sort of in-place sorting or something\
    \ similar?\n<|/ c |>\n<| c |>\nI doubt that there is an in-place sorting in Julia.\
    \ Perhaps someone else can prove me wrong.\n<|/ c |>\n<| a dscore=2 |>\nI like\
    \ your solution, but I thought I'd post my own solution as well. \n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptu5jou6w.jl:15\nin expression starting at\
    \ /tmp/tmptu5jou6w.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis\
    \ does not answer the question. The question is about sorting an array of integers,\
    \ not an array of strings.\n<|/ c |>\n<| c |>\nThe question was about sorting\
    \ an array of integers, not an array of strings. I answered the question by providing\
    \ code for a function that sorts integers. I do not see how this does not answer\
    \ the question.\n<|/ c |>\n<| c |>\nThe question was about sorting an array of\
    \ integers, not an array of strings. I answered the question by providing code\
    \ for a function that sorts integers. I do not see how this does not answer the\
    \ question.\n<|/ c |>\n<| c |>\nThe question was about sorting an array of integers,\
    \ not an array of strings. I answered the question by providing code for a function\
    \ that sorts integers. I do not see how this does not answer the question.\n<|/\
    \ c |>\n<| c |>\nThe question was about sorting an array of integers, not an array\
    \ of strings. I answered the question by providing code for a function that sorts\
    \ integers. I do not see how this does not answer the question.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nThe easiest way is to use the sort function with a custom comparison\
    \ function:\n<code>\njulia> sort(a, by=x->x%2)\n5-element Array{Int64,1}:\n 2\n\
    \ 3\n 1\n 6\n 5\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis does\
    \ not answer the question. The question is about sorting an array of integers,\
    \ not an array of strings.\n<|/ c |>\n<| c |>\nThe question was about sorting\
    \ an array of integers, not an array of strings. I answered the question by providing\
    \ code for a function that sorts integers. I do not see how this does not answer\
    \ the question.\n<|/ c |>\n<| c |>\nThe question was about sorting an array of\
    \ integers, not an array of strings. I answered the question by providing code\
    \ for a function that sorts integers. I do not see how this does not answer the\
    \ question.\n<|/ c |>\n<| c |>\nThe question was about sorting an array of integers,\
    \ not an array of strings. I answered the question by providing code for a \n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqu3uu1_y.jl:17\nin expression starting at\
    \ /tmp/tmpqu3uu1_y.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    for x in odd\n  \
    \      push!(l, x)\n    end\n    return l\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThis doesn't work if there are duplicate elements in the input list.\
    \ For example, `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]` instead of `[3,\
    \ 6, 4, 5]`.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted my comment.\
    \ I'll edit my answer to include a fix for that.\n<|/ c |>\n<| c |>\nI added a\
    \ fix for that as well.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a package called\
    \ Sorting which does this sort of thing. \n<code>\njulia> using Sorting\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp05aqt3lg.jl:20\nin expression starting at\
    \ /tmp/tmp05aqt3lg.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nI like using filter for these sorts of things:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7qg2p_lo.jl:16\nin expression starting at\
    \ /tmp/tmp7qg2p_lo.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort!\n\
    \    odd.sort!\n    return even ++ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzd4c0scb.jl:16\nin expression starting at\
    \ /tmp/tmpzd4c0scb.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI came up\
    \ with a solution that is more efficient than sorting and also more readable (at\
    \ least to me). \n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn2n_v9fx.jl:17\nin expression starting at\
    \ /tmp/tmpn2n_v9fx.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `sort_even([5, 6, 3, 4])`\
    \ returns `[3, 6, 5, 4]`, not `[5, 6, 3, 4]`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I've fixed the code.\n<|/ c |>\n<| a dscore=0 |>\nThis solution uses\
    \ no loops and is O(n) in the number of elements in the input vector:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcbxqilfd.jl:17\nin expression starting at\
    \ /tmp/tmpcbxqilfd.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0qszsxqv.jl:16\nin expression starting at\
    \ /tmp/tmp0qszsxqv.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = sort(even)\n    odd = sort(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array` of Int64s.\n<|/ c |>\n<|\
    \ c |>\nIt does work if `l` is an `Array` of Int64s. I tested it on Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it does work. `sort_even([5,\
    \ 6, 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it on Julia\
    \ 0.6.2 and it does work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`.\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and it does work. `sort_even([5,\
    \ 6, 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptfbk7qmv.jl:19\nin expression starting at\
    \ /tmp/tmptfbk7qmv.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprohbzx3t.jl:17\nin expression starting at\
    \ /tmp/tmprohbzx3t.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ps1ztpz.jl:14\nin expression starting at\
    \ /tmp/tmp6ps1ztpz.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nIt works fine for me on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for me on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt works for me on `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nIt works for me on `Array{Int64,1}` too. I'm using Julia 1.5.2\n\
    <|/ c |>\n<| a dscore=3 |>\nA simple solution is to use sortperm:\n<code>\njulia>\
    \ sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nIt works for me on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt works for me\
    \ on `Array{Int64,1}` too. I'm using Julia 1.5.2\n<|/ c |>\n<| c |>\nIt works\
    \ for me on `Array{Int64,1}` too. I'm using Julia 1.5.2\n<|/ c |>\n<| c |>\nIt\
    \ works for me on `Array{Int64,1}` too. I'm using Julia 1.5.2\n<|/ c |>\n<| a\
    \ dscore=3 |>\nThe answer by is correct but can be simplified a bit:\n<code>\n\
    julia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/\
    \ a tags=julia,sorting |>\n<| a dscore=2 |>\nThe answer by is correct but can\
    \ be simplified a bit:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\n\
    The answer by is \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa_5mmng1.jl:17\nin expression starting at\
    \ /tmp/tmpa_5mmng1.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the list\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it before posting it. I will edit my answer to\
    \ include a version that does work if there are duplicates.\n<|/ c |>\n<| c |>\n\
    Oh sorry, I missed the part where you said \"while its values at the even indicies\
    \ are equal to the values of the even indicies of l\"\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplbyntdym.jl:17\nin expression starting at\
    \ /tmp/tmplbyntdym.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even.(l)\n\
    \    return even\nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution, but I\
    \ wonder if there is a way to avoid the intermediate `even` vector. Maybe `sort!`\
    \ could do it, but I haven't found a way yet.\n<|/ c |>\n<| c |>\nI guess `sort!`\
    \ could do it, but I haven't found a way yet. `sort!` doesn't seem to work with\
    \ `Int64` vectors.\n<|/ c |>\n<| c |>\n`sort!` works with `Int64` vectors, as\
    \ long as you use `Int64` instead of `Int` in the function signature.\n<|/ c |>\n\
    <| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn5qdctdw.jl:15\nin expression starting at\
    \ /tmp/tmpn5qdctdw.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    l[findall(l .== even)]\
    \ = odd\n    return l\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis\
    \ doesn't work if you have a vector of strings. You can't sort strings like that.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a vector of strings. You can't\
    \ sort strings like that. \u2013 user207421\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have a vector of strings. You can't sort strings like that.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have a vector of strings. You can't sort strings\
    \ like that.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a vector of strings.\
    \ You can't sort strings like that.\n<|/ c |>\n<| a dscore=4 |>\n<code>\njulia>\
    \ using Statistics\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1kcb_rkx.jl:18\nin expression starting at\
    \ /tmp/tmp1kcb_rkx.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if there are duplicates in the list.\
    \ For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1,\
    \ 2, 3]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it. I also added a\
    \ version that doesn't require any imports.\n<|/ c |>\n<| a tags=sorting,julia\
    \ |>\nI came up with a solution which doesn't require any imports and is very\
    \ efficient:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplckl4r15.jl:16\nin expression starting at\
    \ /tmp/tmplckl4r15.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=1 |>\nI wanted to add another answer that uses only built-in functions.\
    \ I wanted to add this answer because I wanted to see how it compared to the other\
    \ answers. I ran some benchmarks and here are the results (in seconds):\n<code>\n\
    julia> sort_even([1,2,3,4,5,6,7,8,9,10])\n10-element Vector{Int64}:\n 2\n 3\n\
    \ 4\n 5\n 6\n 7\n 8\n 9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpntn68jbx.jl:16\nin expression starting at\
    \ /tmp/tmpntn68jbx.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1ukwjtyt.jl:16\nin expression starting at\
    \ /tmp/tmp1ukwjtyt.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n   \
    \ for x in odd\n        push!(l, x)\n    end\n    return l\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])`\
    \ returns `[3, 6, 5, 4]` instead of `[5, 6, 3, 4]`.\n<|/ c |>\n<| c |>\nYes, I\
    \ noticed that and fixed it. I was just trying to give a general idea of how to\
    \ do it.\n<|/ c |>\n<| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsp553vzp.jl:20\nin expression starting at\
    \ /tmp/tmpsp553vzp.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work for\
    \ me. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]` instead of `[3, 6, 4, 5]`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug in the code. Thanks for pointing it out.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution that doesn't require any additional\
    \ packages:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyu1gtoah.jl:17\nin expression starting at\
    \ /tmp/tmpyu1gtoah.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a dscore=2 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc0swc401.jl:17\nin expression starting at\
    \ /tmp/tmpc0swc401.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't work. Try `sort_even([5, 6, 3, 4])`.\n<|/ c |>\n<| c |>\nIt\
    \ does work. Try `sort_even([5, 6, 3, 4])`.\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try `sort_even([5, 6, 3, 4])`.\n<|/ c |>\n<| c |>\nIt does work. Try `sort_even([5,\
    \ 6, 3, 4])`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try `sort_even([5, 6, 3, 4])`.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe6mehkbp.jl:16\nin expression starting at\
    \ /tmp/tmpe6mehkbp.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    even = union(even, even)\n    return\
    \ even\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjk5mtdv7.jl:17\nin expression starting at\
    \ /tmp/tmpjk5mtdv7.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to avoid the temporary\
    \ arrays. I guess it would be possible to do something like `even = sort(l[findall(l\
    \ .% 2 == 0)])`, but that would require a temporary array and would not preserve\
    \ the original ordering.\n<|/ c |>\n<| c |>\nYes, that would work. `sort` returns\
    \ a new array, so you could do `even = sort(l[findall(l .% 2 == 0)])`, but that\
    \ would require a temporary array and would not preserve the original ordering.\n\
    <|/ c |>\n<| c |>\nYes, I thought of that, but I wonder if there is a way to avoid\
    \ the temporary arrays. I guess it would be possible to do something like `even\
    \ = sort(l[findall(l .% 2 == 0)])`, but that would require a temporary array and\
    \ would not preserve the original ordering.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that avoids the temporary arrays. I hope it helps.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that avoids the temporary arrays. I hope it helps.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nHere's a solution using sort!:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpewekrrl_.jl:17\nin expression starting at\
    \ /tmp/tmpewekrrl_.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcbxw9oe8.jl:18\nin expression starting at\
    \ /tmp/tmpcbxw9oe8.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try `sort_even([1,3,5,2,4])`\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I even tested it on `sort_even([1,3,5,2,4])`\
    \ which should return `[1,2,3,4,5]` but instead it returns `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| c |>\nI tested it again and it works. I even tested it on `sort_even([1,3,5,2,4])`\
    \ which should return `[1,2,3,4,5]` but instead it returns `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| c |>\nI tested it again and it works. I even tested it on `sort_even([1,3,5,2,4])`\
    \ which should return `[1,2,3,4,5]` but instead it returns `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| c |>\nI tested it again and it works. I even tested it on `sort_even([1,3,5,2,4])`\
    \ which should return `[1,2,3,4,5]` but instead it returns `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| a tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7nj1opxk.jl:16\nin expression starting at\
    \ /tmp/tmp7nj1opxk.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis doesn't work if there are duplicates in the\
    \ input vector. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]`\
    \ instead of `[1, 2, 3]`.\n<|/ c |>\n<| a dscore=2 |>\nI came up with a solution\
    \ which doesn't require any packages:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphp_zwp5y.jl:17\nin expression starting at\
    \ /tmp/tmphp_zwp5y.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nI wanted to add another answer that uses mapslices\
    \ and a comprehension instead of findall:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpryet_jja.jl:16\nin expression starting at\
    \ /tmp/tmpryet_jja.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcoicrpib.jl:17\nin expression starting at\
    \ /tmp/tmpcoicrpib.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .== 0)]\n    even = sort_even(even)\n    return even\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks for your answer. Could you\
    \ please explain what is the purpose of \"l[findall(l .== 0)]\" in the code? I\
    \ understand that \"findall\" returns indices of elements that satisfy a condition,\
    \ but I don't understand what is the purpose of \"l[findall(l .== 0)]\" in the\
    \ code. Thanks.\n<|/ c |>\n<| c |>\n`findall` returns indices of elements that\
    \ satisfy a condition. `l[findall(l .== 0)]` returns all elements of `l` except\
    \ the ones that satisfy the condition. `l[findall(l .== 0)]` returns all elements\
    \ of `l` except the ones that satisfy the condition. `l[findall(l .== 0)]` returns\
    \ all elements of `l` except the ones that satisfy the condition. `l[findall(l\
    \ .== 0)]` returns all elements of `l` except the ones that satisfy the condition.\
    \ `l[findall(l .== 0)]` returns all elements of `l` except the ones that satisfy\
    \ the condition. `l[findall(l .== 0)]` returns all elements of `l` except the\
    \ ones that satisfy the condition. `l[findall(l .== 0)]` returns all elements\
    \ of `l` except the ones that satisfy the condition. `l[findall(l .== 0)]` returns\
    \ all elements of `l` except the ones that satisfy the condition. `l[findall(l\
    \ .== 0)]` returns all elements of `l` except the ones that satisfy the condition.\
    \ `l[findall(l .== 0)]` returns all elements of `l` except the ones that satisfy\
    \ the condition. `l[findall(l .== 0)]` returns all elements of `l` except the\
    \ ones that satisfy the condition. `l[findall(l .== 0)]` returns all elements\
    \ of `l` except the ones that satisfy the condition. `l[findall(l .== 0)]` returns\
    \ all elements of `l` except the ones that satisfy the condition. `l[findall(l\
    \ .== 0)]` returns all elements of `l` except the ones that satisfy the condition.\
    \ `l[findall(l .== \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4_pise7h.jl:17\nin expression starting at\
    \ /tmp/tmp4_pise7h.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([5, 6, 3, 4])` returns `[3,\
    \ 6, 5, 4]` instead of `[3, 6, 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it on Julia\
    \ 0.6.1 and it works fine. Maybe you have a different version?\n<|/ c |>\n<| c\
    \ |>\nI tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. Maybe you have a different\
    \ version? I tested it on Julia 0.6.1 and it works fine. \nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjrpquyo3.jl:16\nin expression starting at\
    \ /tmp/tmpjrpquyo3.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ c |>\nThis doesn't work. `sort` returns a sorted array, but `even` still contains\
    \ the original unsorted array.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I've edited the answer to reflect this.\n<|/ c |>\n<| a dscore=2 |>\nI came\
    \ up with this solution:\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_tqw2hoa.jl:15\nin expression starting at\
    \ /tmp/tmp_tqw2hoa.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are duplicates in the list. For example, `sort_even([1,1,2,3])`\
    \ returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, it does. I\
    \ added a note about that to the answer.\n<|/ c |>\n<| a dscore=2 |>\nHere's a\
    \ solution that doesn't require any packages:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw9_0h89a.jl:17\nin expression starting at\
    \ /tmp/tmpw9_0h89a.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(x -> x % 2 == 0, l)]\n    odd = l[findall(x -> x % 2 !=\
    \ 0, l)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    return even\
    \ ++ odd\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis does not answer the\
    \ question. `sort_even` does not sort the even indicies of `l`, it just sorts\
    \ the even indicies of `l`'s values. `sort_even` does not sort the even indicies\
    \ of `l`, it just sorts the even indicies of `l`'s values.\n<|/ c |>\n<| c |>\n\
    I see what you mean. I'll update my answer.\n<|/ c |>\n<| c |>\nI updated my answer\
    \ to include a solution that sorts the even indicies of `l`'s values.\n<|/ c |>\n\
    <| c |>\nI added a solution that sorts the even indicies of `l`'s values.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if `l` is an `Array` because `Array` doesn't\
    \ have a `sort` method.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using sortperm:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})\n           even = l[findall(x\
    \ -> x % 2 == 0, l)]\n           odd = l[findall(x -> x % 2 != 0, l)]\n      \
    \     even = sort_even(even)\n           odd = sort_even(odd)\n           return\
    \ even ++ odd\n       end\nsort_even (generic function with 1 method)\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkh8aoiak.jl:16\nin expression starting at\
    \ /tmp/tmpkh8aoiak.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate values in the input list. For example, `sort_even([5, 6,\
    \ 3, 6, 5, 4])` returns `[3, 6, 5, 4]` instead of `[3, 6, 5, 4]`.\n<|/ c |>\n\
    <| c |>\nI edited my answer to include a fix for duplicates.\n<|/ c |>\n<| c |>\n\
    This doesn't work if there are duplicate values in the input list. For example,\
    \ `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]` instead of `[3, 6, 5,\
    \ 4]`.\n<|/ c |>\n<| c |>\nI edited my answer to include a fix for duplicates.\n\
    <|/ c |>\n<| a |>\nHere's a solution that uses sort! to sort the even indices\
    \ and then append! to append the odd indices to the sorted even indices.\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpog3vaflz.jl:17\nin expression starting at\
    \ /tmp/tmpog3vaflz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the input list. For example, `sort_even([5, 6, 3, 6, 5, 4])` returns `[3,\
    \ 6, 5, 4]`.\n<|/ c |>\n<| c |>\nYes, I noticed that after I posted my answer.\
    \ Thanks for pointing that out. I'll update my answer.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I appreciate it! I ended up using your solution and added a\
    \ little bit of code to the end of my question. Thanks again!\n<|/ c |>\n<| a\
    \ |>\nI ended up using 's solution and added a little bit of code to the end of\
    \ my question. Thanks again!\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7bage7mc.jl:17\nin expression starting at\
    \ /tmp/tmp7bage7mc.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\nI came up with a solution that is more efficient than sorting twice:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph_1cm8lh.jl:17\nin expression starting at\
    \ /tmp/tmph_1cm8lh.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbtn7h9he.jl:16\nin expression starting at\
    \ /tmp/tmpbtn7h9he.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nI believe that `sort` will sort\
    \ by index rather than value, so this won't work if you have duplicate values\
    \ in the list. Also, `sort!` will mutate the original list, so this won't work\
    \ if you have duplicate values in the list. Also, this doesn't work for `sort!`\
    \ because `sort!` will sort the list in-place, while `sort` returns a new list.\n\
    <|/ c |>\n<| c |>\nI believe that `sort` will sort by index rather than value,\
    \ so this won't work if you have duplicate values in the list. Also, `sort!` will\
    \ mutate the original list, so this won't work if you have duplicate values in\
    \ the list. Also, this doesn't work for `sort!` because `sort!` will sort the\
    \ list in-place, while `sort` returns a new list.\n<|/ c |>\n<| c |>\nI believe\
    \ that `sort` will sort by index rather than value, so this won't work if you\
    \ have duplicate values in the list. Also, `sort!` will mutate the original list,\
    \ so this won't work if you have duplicate values in the list. Also, this doesn't\
    \ work for `sort!` because `sort!` will sort the list in-place, while `sort` returns\
    \ a new list.\n<|/ c |>\n<| c |>\nI believe that `sort` will sort by index rather\
    \ than value, so this won't work if you have duplicate values in the list. Also,\
    \ `sort!` will mutate the original list, so this won't work if you have duplicate\
    \ values in the list. Also, this doesn't work for `sort!` because `sort!` will\
    \ sort the list in-place, while `sort` returns a new list.\n<|/ c |>\n<| c |>\n\
    I believe that `sort` will sort by index rather than value, so this won't work\
    \ if you have duplicate values in the list. Also, `sort!` will mutate the original\
    \ list, so this won't work if you have duplicate values in the list. Also, this\
    \ doesn't work for `sort!` because `sort!` will sort the list in-place, while\
    \ `sort` returns a new list.\n<|/ c |>\n<| a dscore=2 |>\nThe most efficient way\
    \ is to use Julia's built-in sort! function, which sorts the array in-place:\n\
    <code>\njulia> sort!([5, 6, 3, 4])\n3-element Array{Int64,1}:\n \nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp83ykhzle.jl:17\nin expression starting at\
    \ /tmp/tmp83ykhzle.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like your solution,\
    \ but I wonder why you didn't use [`sortperm`](http://docs.julialang.org/en/latest/stdlib/arrays/#Base.sortperm).\n\
    <|/ c |>\n<| c |>\nI didn't know about `sortperm` until now. Thanks!\n<|/ c |>\n\
    <| c |>\nI didn't know about `sortperm` until now. Thanks!\n<|/ c |>\n<| a tags=julia\
    \ |>\nI like your solution, but I wonder why you didn't use sortperm. \n<code>\n\
    julia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI didn't know about `sortperm` until now.\
    \ Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI like your solution, but I wonder why\
    \ you didn't use sortperm. \n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=julia |>\n<| a dscore=1 |>\nI like your\
    \ solution, but I wonder why you didn't use sortperm. \n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\nI like your solution, but I wonder why you didn't use sortperm.\
    \ \n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI like your solution,\
    \ but I wonder why you didn't use sortperm. \n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5jryalgg.jl:17\nin expression starting at\
    \ /tmp/tmp5jryalgg.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu2ech6e0.jl:16\nin expression starting at\
    \ /tmp/tmpu2ech6e0.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=1 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpddpqlpjt.jl:15\nin expression starting at\
    \ /tmp/tmpddpqlpjt.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ tags=sorting,julia,arrays |>\nHere is a solution using sortperm:\n<code>\njulia>\
    \ function sort_even(l::Vector{Int64})\n           even = l[findall(l .% 2 ==\
    \ 0)]\n           odd = l[findall(l .% 2 .== 1)]\n           even.sort()\n   \
    \        odd.sort()\n           return even ++ odd\n       end\nsort_even (generic\
    \ function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpioif5b9k.jl:16\nin expression starting at\
    \ /tmp/tmpioif5b9k.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even ++ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a dscore=1 |>\nI like using sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a |>\nI like using sortperm:\n<code>\n\
    julia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/\
    \ a tags=julia,sorting,arrays dscore=1 |>\n<| a tags=julia,sorting,arrays |>\n\
    The other answers here are great, but I wanted to add that you can also use sortperm!\
    \ which modifies the array in place:\n<code>\njulia> sortperm!([1,2,3])\n3-element\
    \ Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    I like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post. - [From Review](/review/low-quality-posts/26829184)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question, since it provides\
    \ a solution that is similar to other answers already given.\n<|/ c |>\n<| c |>\n\
    This does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/26829184)\n\
    <|/ c |>\n<| c |>\nThis does answer the question, since it provides a solution\
    \ that is similar to other answers already given.\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7vp0idrt.jl:16\nin expression starting at\
    \ /tmp/tmp7vp0idrt.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort_even(even)\n    even = sort(even)\n\
    \    even = l[findall(l .% 2 == 1)]\n    return even \nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=2 |>\nI came up with this solution:\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy6o7zohm.jl:16\nin expression starting at\
    \ /tmp/tmpy6o7zohm.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp39z58up5.jl:16\nin expression starting at\
    \ /tmp/tmp39z58up5.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzq6knymp.jl:18\nin expression starting at\
    \ /tmp/tmpzq6knymp.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp85sbtgi9.jl:16\nin expression starting at\
    \ /tmp/tmp85sbtgi9.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis does not work if there are repeated elements in the list.\
    \ For example, `sort_even([1,1,2,2])` returns `[1,1,2,2]`.\n<|/ c |>\n<| c |>\n\
    Yes, I realized that after I posted my comment. Thanks for pointing it out. I've\
    \ edited my answer to fix it.\n<|/ c |>\n<| a tags=julia,sorting |>\nI wanted\
    \ to add another answer because I thought it would be useful to see how this can\
    \ be done with Base.partition. \n<code>\njulia> Base.partition(x -> x % 2 == 0,\
    \ [1, 2, 3, 4, 5, 6])\n([1,2,3,4,5,6], [2,4,6])\n</code>\nThis works because partition\
    \ is defined as:\n<code>\nBase.partition(; predicate, x)\n</code>\nand Base.partition\
    \ calls the predicate function on each element of x to determine whether it should\
    \ be in the first or second partition. \nSo we can write our own version of partition\
    \ which does exactly what we want:\n<code>\nBase.partition(predicate, x) = Base.partition(predicate,\
    \ x, Base.identity)\n</code>\nThis works because Base.identity is defined as:\n\
    <code>\nBase.identity(x) = x\n</code>\nSo we simply pass in Base.identity as the\
    \ predicate function and x as the argument to Base.partition. \n<code>\nBase.partition(predicate,\
    \ x, identity) = Base.partition(predicate, x, identity)\n</code>\nNow we can write\
    \ our own version of sort_even which does exactly what we want:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk7h5jja8.jl:16\nin expression starting at\
    \ /tmp/tmpk7h5jja8.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ does not answer the question. OP wants to sort even and odd numbers in different\
    \ places.\n<|/ c |>\n<| c |>\nThe question was edited after I posted my answer.\
    \ My answer was based on the original question, which was to sort even and odd\
    \ numbers in different places.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpii_au4xd.jl:16\nin expression starting at\
    \ /tmp/tmpii_au4xd.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI wrote a\
    \ function that sorts even and odd numbers in ascending order:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9_mhy_yr.jl:17\nin expression starting at\
    \ /tmp/tmp9_mhy_yr.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"This function takes a list l and returns a list l' such that\n \
    \   l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    even = sort(even)\n    even = even[findall(even\
    \ .% 2 == 1)]\n    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]`, not `[2,1,3]`.\n\
    <|/ c |>\n<| c |>\nYes, I missed that one. Thanks for pointing it out. Fixed now.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgcb906qg.jl:15\nin expression starting at\
    \ /tmp/tmpgcb906qg.jl:15\n"
  exit_code: 1
  status: SyntaxError
