name: HumanEval_129_minPath
language: js
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered lists of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered list of the values on the cells that the minimum\
  \ path go through.\nfunction minPath(grid, k){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = minPath;\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1,\
  \ 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);\n\
  \  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13,\
  \ 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6, 4, 13, 10],\
  \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);\n\
  \  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3,\
  \ 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11, 8, 7, 2],\
  \ [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);\n\
  \  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
  \ 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, 0, path, sum);\n        }\n \
    \   }\n    return minPath;\n    function dfs(i, j, steps, path, sum){\n      \
    \  if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || steps > k){\n   \
    \         return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(steps === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            else if(sum === minSum){\n                if(path.join('')\
    \ < minPath.join('')){\n                    minPath = path.slice();\n        \
    \        }\n            }\n        }\n        else{\n            dfs(i - 1, j,\
    \ steps + 1, path, sum);\n            dfs(i + 1, j, steps + 1, path, sum);\n \
    \           dfs(i, j - 1, steps + 1, path, sum);\n            dfs(i, j + 1, steps\
    \ + 1, path, sum);\n        }\n        path.pop();\n        visited[i][j] = false;\n\
    \    }\n}\n", "  let n = grid.length;\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 =\
    \ [];\n  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n  let minPath3\
    \ = [];\n  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n  let minPath4\
    \ = [];\n  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n  let minPath5\
    \ = [];\n  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n  let minPath6\
    \ = [];\n  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n  let minPath7\
    \ = [];\n  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n  let minPath8\
    \ = [];\n  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n  let minPath9\
    \ = [];\n  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n  let minPath10\
    \ = [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n  let minPath11\
    \ = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n  let minPath12\
    \ = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n  let minPath13\
    \ = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n  let minPath14\
    \ = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n  let minPath15\
    \ = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n  let minPath16\
    \ = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n  let minPath17\
    \ = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity;\n  let minPath18\
    \ = [];\n  let minSum18 = Infinity;\n  let minPathSum19 = Infinity;\n  let minPath19\
    \ = [];\n ", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, k, grid, visited, path, sum);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let visited = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        visited[i] = new Array(n).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPaths\
    \ = [];\n    let minPathsSum = [];\n    let minPathsIndex = [];\n    let minPathsIndexSum\
    \ = [];\n    let minPathsIndexSumIndex = [];\n    let minPathsIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndex = [];\n    let minPathsIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndex = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndex = [];\n    let\
    \ minPathsIndexSumIndexSumIndexSumIndexSumIndexSum = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum = [];\n\
    \    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex = [];\n\
    \    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum = [];\n\
    \    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(Infinity));\n    let prev = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(null));\n    let queue = [];\n    let ans = [];\n    let\
    \ min = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            if(grid[i][j] === 1){\n                dp[i][j] = 0;\n\
    \                queue.push([i, j]);\n            }\n        }\n    }\n    while(queue.length){\n\
    \        let [x, y] = queue.shift();\n        if(x + 1 < n && dp[x + 1][y] > dp[x][y]\
    \ + 1){\n            dp[x + 1][y] = dp[x][y] + 1;\n            prev[x + 1][y]\
    \ = [x, y];\n            queue.push([x + 1, y]);\n        }\n        if(x - 1\
    \ >= 0 && dp[x - 1][y] > dp[x][y] + 1){\n            dp[x - 1][y] = dp[x][y] +\
    \ 1;\n            prev[x - 1][y] = [x, y];\n            queue.push([x - 1, y]);\n\
    \        }\n        if(y + 1 < m && dp[x][y + 1] > dp[x][y] + 1){\n          \
    \  dp[x][y + 1] = dp[x][y] + 1;\n            prev[x][y + 1] = [x, y];\n      \
    \      queue.push([x, y + 1]);\n        }\n        if(y - 1 >= 0 && dp[x][y -\
    \ 1] > dp[x][y] + 1){\n            dp[x][y - 1] = dp[x][y] + 1;\n            prev[x][y\
    \ - 1] = [x, y];\n            queue", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n \
    \ let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsSumSet = new Set();\n\
    \  let minPathsSet = new Set();\n  let minPathsSetArr = [];\n  let minPathsSetArrSum\
    \ = [];\n  let minPathsSetArrSumSet = new Set();\n  let minPathsSetArrSumSetArr\
    \ = [];\n  let minPathsSetArrSumSetArrSum = [];\n  let minPathsSetArrSumSetArrSumSet\
    \ = new Set();\n  let minPathsSetArrSumSetArrSumSetArr = [];\n  let minPathsSetArrSumSetArrSumSetArrSum\
    \ = [];\n  let minPathsSetArrSumSetArrSumSetArrSumSet = new Set();\n  let minPathsSetArrSumSetArrSumSetArrSumSetArr\
    \ = [];\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSum = [];\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSet\
    \ = new Set();\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSetArr = [];\n\
    \  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSetArrSum = [];\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSetArrSumSet\
    \ = new Set();\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSetArrSumSetArr\
    \ = [];\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSetArrSumSetArrSum\
    \ = [];\n  let minPathsSetArrSumSetArrSumSetArrSumSetArrSumSetArrSumSetAr", " \
    \   let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let visited = new\
    \ Set();\n    let path = [];\n    let sum = 0;\n    let paths = [];\n    let pathSum\
    \ = 0;\n    let pathSums = [];\n    let pathSumsMap = new Map();\n    let pathSumsMap2\
    \ = new Map();\n    let pathSumsMap3 = new Map();\n    let pathSumsMap4 = new\
    \ Map();\n    let pathSumsMap5 = new Map();\n    let pathSumsMap6 = new Map();\n\
    \    let pathSumsMap7 = new Map();\n    let pathSumsMap8 = new Map();\n    let\
    \ pathSumsMap9 = new Map();\n    let pathSumsMap10 = new Map();\n    let pathSumsMap11\
    \ = new Map();\n    let pathSumsMap12 = new Map();\n    let pathSumsMap13 = new\
    \ Map();\n    let pathSumsMap14 = new Map();\n    let pathSumsMap15 = new Map();\n\
    \    let pathSumsMap16 = new Map();\n    let pathSumsMap17 = new Map();\n    let\
    \ pathSumsMap18 = new Map();\n    let pathSumsMap19 = new Map();\n    let pathSumsMap20\
    \ = new Map();\n    let pathSumsMap21 = new Map();\n    let pathSumsMap22 = new\
    \ Map();\n    let pathSumsMap23 = new Map();\n    let pathSumsMap24 = new Map();\n\
    \    let pathSumsMap25 = new Map();\n    let pathSumsMap26 = new Map();\n    let\
    \ pathSumsMap27 = new Map();\n    let pathSumsMap28 = new Map();\n    let pathSumsMap29\
    \ = new Map();\n    let pathSumsMap30 = new Map();\n    let pathSumsMap31 = new\
    \ Map();\n    let pathSumsMap32 = new Map();\n    let pathSumsMap33 = new Map();\n\
    \    let pathSumsMap34 = new Map();\n    let pathSumsMap35 = new Map();\n    let\
    \ pathSumsMap36 =", "  let n = grid.length;\n  let m = grid[0].length;\n  let\
    \ visited = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i] = new\
    \ Array(m).fill(false);\n  }\n  let min = [];\n  let minSum = Infinity;\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      let curr = [];\n\
    \      let currSum = 0;\n      dfs(grid, i, j, visited, curr, currSum, k, min,\
    \ minSum);\n    }\n  }\n  return min;\n}\n", "    let n = grid.length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let visited = new Set();\n  \
    \  let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= n || visited.has(i + ',' + j)){\n            return;\n        }\n     \
    \   if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path;\n            }\n            return;\n\
    \        }\n        visited.add(i + ',' + j);\n        dfs(i + 1, j, path.concat(grid[i][j]),\
    \ sum + grid[i][j]);\n        dfs(i - 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \        dfs(i, j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i,\
    \ j - 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        visited.delete(i\
    \ + ',' + j);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0;\
    \ j < n; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "  // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n\
    \    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minSum3 = Infinity;\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minSum4 = Infinity;\n\
    \    let minPathSum5 = Infinity;\n    let minPath5 = [];\n    let minSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minSum8 = Infinity;\n\
    \    let minPathSum9 = Infinity;\n    let minPath9 = [];\n    let minSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minSum10 =\
    \ Infinity;\n    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let\
    \ minSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPath12 =\
    \ [];\n    let minSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let\
    \ minPath13 = [];\n    let minSum13 = Infinity;\n    let minPathSum14 = Infinity;\n\
    \    let minPath14 = [];\n    let minSum14 = Infinity;\n    let minPathSum15 =\
    \ Infinity;\n    let minPath15 = [];\n    let minSum15 = Infinity;\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minSum16 = Infinity;\n    let\
    \ minPathSum17 = Infinity;\n    let minPath17 = [];\n    let minSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minSum18 =\
    \ Infinity;\n    let minPathSum19 = Infinity", "    let N = grid.length;\n   \
    \ let visited = new Array(N);\n    for(let i = 0; i < N; i++){\n        visited[i]\
    \ = new Array(N).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < N; i++){\n        for(let j = 0; j < N; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ path, sum);\n            visited[i][j] = false;\n        }\n    }\n    return\
    \ minPath;\n\n    function dfs(i, j, k, path, sum){\n        if(i < 0 || i >=\
    \ N || j < 0 || j >= N || visited[i][j]){\n            return;\n        }\n  \
    \      if(path.length === k){\n            if(sum < minSum){\n               \
    \ minSum = sum;\n                minPath = path.slice();\n            }\n    \
    \        return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i - 1, j, k, path, sum);\n        dfs(i\
    \ + 1, j, k, path, sum);\n        dfs(i, j - 1, k, path, sum);\n        dfs(i,\
    \ j + 1, k, path, sum);\n        path.pop();\n        sum -= grid[i][j];\n   \
    \     visited[i][j] = false;\n    }\n}\n", "  let n = grid.length;\n  let minPath\
    \ = [];\n  let minSum = Infinity;\n  let visited = new Set();\n  let dfs = function(i,\
    \ j, path, sum){\n    if(path.length === k){\n      if(sum < minSum){\n      \
    \  minSum = sum;\n        minPath = path;\n      }\n      return;\n    }\n   \
    \ if(sum > minSum){\n      return;\n    }\n    let key = i + ',' + j;\n    if(visited.has(key)){\n\
    \      return;\n    }\n    visited.add(key);\n    if(i > 0){\n      dfs(i - 1,\
    \ j, path.concat(grid[i - 1][j]), sum + grid[i - 1][j]);\n    }\n    if(i < n\
    \ - 1){\n      dfs(i + 1, j, path.concat(grid[i + 1][j]), sum + grid[i + 1][j]);\n\
    \    }\n    if(j > 0){\n      dfs(i, j - 1, path.concat(grid[i][j - 1]), sum +\
    \ grid[i][j - 1]);\n    }\n    if(j < n - 1){\n      dfs(i, j + 1, path.concat(grid[i][j\
    \ + 1]), sum + grid[i][j + 1]);\n    }\n    visited.delete(key);\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < n; j++){\n      dfs(i, j, [grid[i][j]],\
    \ grid[i][j]);\n    }\n  }\n  return minPath;\n}", "  let n = grid.length;\n \
    \ let visited = new Set();\n  let minPath = [];\n  let minPathSum = Infinity;\n\
    \  let minPathSum2 = Infinity;\n  let minPath2 = [];\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minPathSum4 = Infinity;\n  let minPath4 = [];\n \
    \ let minPathSum5 = Infinity;\n  let minPath5 = [];\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minPathSum7 = Infinity;\n  let minPath7 = [];\n \
    \ let minPathSum8 = Infinity;\n  let minPath8 = [];\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minPathSum10 = Infinity;\n  let minPath10 = [];\n\
    \  let minPathSum11 = Infinity;\n  let minPath11 = [];\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minPathSum13 = Infinity;\n  let minPath13 = [];\n\
    \  let minPathSum14 = Infinity;\n  let minPath14 = [];\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minPathSum16 = Infinity;\n  let minPath16 = [];\n\
    \  let minPathSum17 = Infinity;\n  let minPath17 = [];\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minPathSum19 = Infinity;\n  let minPath19 = [];\n\
    \  let minPathSum20 = Infinity;\n  let minPath20 = [];\n  let minPathSum21 = Infinity;\n\
    \  let minPath21 = [];\n  let minPathSum22 = Infinity;\n  let minPath22 = [];\n\
    \  let minPathSum23 = Infinity;\n  let minPath23 = [];\n  let minPathSum24 = Infinity;\n\
    \  let minPath24 = [];\n  let minPathSum25 = Infinity;\n  let minPath25 = [];\n\
    \  let minPathSum26 = Infinity;\n  let minPath26 = [];\n  let minPathSum27 = Infinity;\n\
    \  let minPath27 = [];\n  let minPathSum28 = Infinity;\n", "    let n = grid.length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSumIndex = -1;\n    let visited = new Set();\n    let path = [];\n\
    \    let pathSum = 0;\n    let pathSumIndex = 0;\n    let pathIndex = 0;\n   \
    \ let pathIndexes = [];\n    let pathSums = [];\n    let pathSumIndexes = [];\n\
    \    let pathIndexesSum = 0;\n    let pathSumIndexesSum = 0;\n    let pathIndexesSumIndex\
    \ = 0;\n    let pathSumIndexesSumIndex = 0;\n    let pathIndexesSumIndexes = [];\n\
    \    let pathSumIndexesSumIndexes = [];\n    let pathIndexesSumIndexesSum = 0;\n\
    \    let pathSumIndexesSumIndexesSum = 0;\n    let pathIndexesSumIndexesSumIndex\
    \ = 0;\n    let pathSumIndexesSumIndexesSumIndex = 0;\n    let pathIndexesSumIndexesSumIndexes\
    \ = [];\n    let pathSumIndexesSumIndexesSumIndexes = [];\n    let pathIndexesSumIndexesSumIndexesSum\
    \ = 0;\n    let pathSumIndexesSumIndexesSumIndexesSum = 0;\n    let pathIndexesSumIndexesSumIndexesSumIndex\
    \ = 0;\n    let pathSumIndexesSumIndexesSumIndexesSumIndex = 0;\n    let pathIndexesSumIndexesSumIndexesSumIndexes\
    \ = [];\n    let pathSumIndexesSumIndexesSumIndexesSumIndexes = [];\n    let pathIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = 0;\n    let pathSumIndexesSumIndexesSumIndexesSumIndexesSum = 0;\n    let\
    \ pathIndexesSumIndexesSumIndexesSumIndexesSumIndex = 0;\n    let pathSumIndexesSumIndexesSumIndexesSumIndexesSumIndex\
    \ = 0;\n    let pathIndexesSumIndexesSumIndexesSumIndexesSumIndexes = [];\n  \
    \  let pathSumIndexesSumIndexesSumIndexesSumIndexesSumIndexes = [];\n    let pathIndexesSumIndexesSumIndexesSumIndexesSumIndexesSum\
    \ = 0;\n    let pathSumIndex", "    // Write your code here\n    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let min = [];\n    let minVal = Number.MAX_SAFE_INTEGER;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            let curr = [];\n\
    \            dfs(i, j, grid, k, curr, visited);\n            if(curr.length >\
    \ 0 && curr.length <= k){\n                let val = curr.reduce((a, b) => a *\
    \ 10 + b);\n                if(val < minVal){\n                    minVal = val;\n\
    \                    min = curr;\n                }\n            }\n        }\n\
    \    }\n    return min;\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n\
    \  let visited = new Array(n);\n  for(let i = 0; i < n; i++){\n    visited[i]\
    \ = new Array(m).fill(false);\n  }\n  let min = [];\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      let path = [];\n      dfs(grid, i, j,\
    \ k, path, visited, min);\n    }\n  }\n  return min;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let min = Infinity;\n    let minPath = [];\n\
    \    let dfs = (i, j, path, sum) => {\n        if (sum > min) return;\n      \
    \  if (path.length === k) {\n            if (sum < min) {\n                min\
    \ = sum;\n                minPath = path;\n            }\n            return;\n\
    \        }\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        dfs(i\
    \ + 1, j, path.slice(), sum + grid[i][j]);\n        dfs(i - 1, j, path.slice(),\
    \ sum + grid[i][j]);\n        dfs(i, j + 1, path.slice(), sum + grid[i][j]);\n\
    \        dfs(i, j - 1, path.slice(), sum + grid[i][j]);\n        visited[i][j]\
    \ = false;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    // Write your code here\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i < n;\
    \ i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let pathSum = 0;\n            dfs(i, j, k, path, pathSum);\n    \
    \    }\n    }\n    return minPath;\n\n    function dfs(i, j, k, path, pathSum){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length\
    \ > k){\n            return;\n        }\n        path.push(grid[i][j]);\n    \
    \    pathSum += grid[i][j];\n        visited[i][j] = true;\n        if(path.length\
    \ === k){\n            if(pathSum < minPathSum){\n                minPathSum =\
    \ pathSum;\n                minPath = path.slice();\n            }\n         \
    \   else if(pathSum === minPathSum){\n                if(path.toString() < minPath.toString()){\n\
    \                    minPath = path.slice();\n                }\n            }\n\
    \        }\n        else{\n            dfs(i + 1, j, k, path, pathSum);\n    \
    \        dfs(i - 1, j, k, path, pathSum);\n            dfs(i, j + 1, k, path,\
    \ pathSum);\n            dfs(i, j - 1, k, path, pathSum);\n        }\n       \
    \ path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j] = false;\n\
    \    }\n}\n", "    let n = grid.length;\n    let minPath = [];\n    let minSum\
    \ = Infinity;\n    let minPaths = [];\n    let minSumPaths = [];\n    let visited\
    \ = new Set();\n    function dfs(i, j, path, sum){\n        if(visited.has(i +\
    \ ',' + j)) return;\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(path.length === k){\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            else if(sum === minSum){\n                minPaths.push(path.slice());\n\
    \            }\n            visited.delete(i + ',' + j);\n            path.pop();\n\
    \            return;\n        }\n        if(i > 0) dfs(i - 1, j, path, sum);\n\
    \        if(i < n - 1) dfs(i + 1, j, path, sum);\n        if(j > 0) dfs(i, j -\
    \ 1, path, sum);\n        if(j < n - 1) dfs(i, j + 1, path, sum);\n        visited.delete(i\
    \ + ',' + j);\n        path.pop();\n    }\n    for(let i = 0; i < n; i++){\n \
    \       for(let j = 0; j < n; j++){\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    if(minPaths.length === 0) return minPath;\n    minPaths.forEach(path\
    \ => {\n        let sum = path.reduce((acc, cur) => acc + cur, 0);\n        if(sum\
    \ === minSum) minSumPaths.push(path);\n    });\n    if(minSumPaths.length ===\
    \ 1) return minSumPaths[0];\n    let minPath = minSumPaths[0];\n    for(let i\
    \ = 1; i < minSumPaths.length; i++){\n        let path = minSumPaths[i];\n   \
    \     for(let j = 0;", "    let n = grid.length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(n).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < n; j++){\n            let currPath\
    \ = [];\n            let currSum = 0;\n            dfs(i, j, k, currPath, currSum);\n\
    \        }\n    }\n    return minPath;\n\n    function dfs(i, j, k, currPath,\
    \ currSum){\n        if(k === 0){\n            if(currSum < minSum){\n       \
    \         minSum = currSum;\n                minPath = currPath.slice();\n   \
    \         }\n            return;\n        }\n        if(i < 0 || i >= n || j <\
    \ 0 || j >= n || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        currPath.push(grid[i][j]);\n        currSum += grid[i][j];\n\
    \        dfs(i + 1, j, k - 1, currPath, currSum);\n        dfs(i - 1, j, k - 1,\
    \ currPath, currSum);\n        dfs(i, j + 1, k - 1, currPath, currSum);\n    \
    \    dfs(i, j - 1, k - 1, currPath, currSum);\n        visited[i][j] = false;\n\
    \        currPath.pop();\n    }\n}\n", "  var n = grid.length;\n  var m = grid[0].length;\n\
    \  var visited = new Array(n);\n  for(var i = 0; i < n; i++){\n    visited[i]\
    \ = new Array(m);\n    for(var j = 0; j < m; j++){\n      visited[i][j] = false;\n\
    \    }\n  }\n  var minPath = [];\n  var minSum = Infinity;\n  var minPathSum =\
    \ Infinity;\n  var minPathSumHelper = function(i, j, path, sum){\n    if(i < 0\
    \ || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n    }\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minPathSum){\n\
    \        minPathSum = sum;\n        minPath = path.slice();\n      }\n      else\
    \ if(sum === minPathSum){\n        var pathStr = path.join('');\n        var minPathStr\
    \ = minPath.join('');\n        if(pathStr < minPathStr){\n          minPath =\
    \ path.slice();\n        }\n      }\n      path.pop();\n      return;\n    }\n\
    \    visited[i][j] = true;\n    minPathSumHelper(i + 1, j, path, sum);\n    minPathSumHelper(i\
    \ - 1, j, path, sum);\n    minPathSumHelper(i, j + 1, path, sum);\n    minPathSumHelper(i,\
    \ j - 1, path, sum);\n    visited[i][j] = false;\n    path.pop();\n  };\n  for(var\
    \ i = 0; i < n; i++){\n    for(var j = 0; j < m; j++){\n      minPathSumHelper(i,\
    \ j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    var n = grid.length;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var visited = [];\n\
    \    for(var i = 0; i < n; i++){\n        visited.push([]);\n        for(var j\
    \ = 0; j < n; j++){\n            visited[i].push(false);\n        }\n    }\n \
    \   var dfs = function(i, j, path, pathSum){\n        if(i < 0 || i >= n || j\
    \ < 0 || j >= n || visited[i][j]){\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        visited[i][j] = true;\n        if(path.length\
    \ === k){\n            if(pathSum < minPathSum){\n                minPathSum =\
    \ pathSum;\n                minPath = path.slice();\n            }\n        }else{\n\
    \            dfs(i - 1, j, path, pathSum);\n            dfs(i + 1, j, path, pathSum);\n\
    \            dfs(i, j - 1, path, pathSum);\n            dfs(i, j + 1, path, pathSum);\n\
    \        }\n        path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    };\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j\
    \ < n; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let visited\
    \ = new Set();\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs\
    \ = (i, j, path, sum) => {\n        if (visited.has(i + ',' + j)) return;\n  \
    \      if (path.length === k) {\n            if (sum < minSum) {\n           \
    \     minSum = sum;\n                minPath = path;\n            }\n        \
    \    return;\n        }\n        visited.add(i + ',' + j);\n        for (let dir\
    \ of dirs) {\n            let x = i + dir[0];\n            let y = j + dir[1];\n\
    \            if (x < 0 || x >= n || y < 0 || y >= m) continue;\n            dfs(x,\
    \ y, path.concat(grid[x][y]), sum + grid[x][y]);\n        }\n        visited.delete(i\
    \ + ',' + j);\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j =\
    \ 0; j < m; j++) {\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n       \
    \ }\n    }\n    return minPath;\n}\n", "  let n = grid.length;\n  let minPath\
    \ = [];\n  let minPathSum = Infinity;\n  let visited = [];\n  for(let i = 0; i\
    \ < n; i++){\n    visited.push([]);\n    for(let j = 0; j < n; j++){\n      visited[i].push(false);\n\
    \    }\n  }\n  function dfs(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0\
    \ || j >= n || visited[i][j]){\n      return;\n    }\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    visited[i][j] = true;\n    if(path.length === k){\n\
    \      if(sum < minPathSum){\n        minPathSum = sum;\n        minPath = path.slice();\n\
    \      }\n    }else{\n      dfs(i + 1, j, path, sum);\n      dfs(i - 1, j, path,\
    \ sum);\n      dfs(i, j + 1, path, sum);\n      dfs(i, j - 1, path, sum);\n  \
    \  }\n    path.pop();\n    visited[i][j] = false;\n  }\n  for(let i = 0; i < n;\
    \ i++){\n    for(let j = 0; j < n; j++){\n      dfs(i, j, [], 0);\n    }\n  }\n\
    \  return minPath;\n}\n", "  let n = grid.length;\n  let minPath = [];\n  let\
    \ minSum = Infinity;\n  let minSumPath = [];\n  let visited = new Set();\n  let\
    \ queue = [];\n  let start = [0, 0];\n  queue.push(start);\n  while(queue.length){\n\
    \    let curr = queue.shift();\n    let [x, y] = curr;\n    if(visited.has(curr))\
    \ continue;\n    visited.add(curr);\n    let sum = grid[x][y];\n    let path =\
    \ [grid[x][y]];\n    let queue2 = [];\n    queue2.push(curr);\n    while(queue2.length){\n\
    \      let curr2 = queue2.shift();\n      let [x2, y2] = curr2;\n      if(visited.has(curr2))\
    \ continue;\n      visited.add(curr2);\n      let sum2 = sum + grid[x2][y2];\n\
    \      let path2 = path.concat(grid[x2][y2]);\n      if(path2.length === k){\n\
    \        if(sum2 < minSum){\n          minSum = sum2;\n          minSumPath =\
    \ path2;\n        } else if(sum2 === minSum){\n          if(path2 < minSumPath){\n\
    \            minSumPath = path2;\n          }\n        }\n      } else {\n   \
    \     queue2.push([x2 + 1, y2]);\n        queue2.push([x2 - 1, y2]);\n       \
    \ queue2.push([x2, y2 + 1]);\n        queue2.push([x2, y2 - 1]);\n      }\n  \
    \  }\n    queue.push([x + 1, y]);\n    queue.push([x - 1, y]);\n    queue.push([x,\
    \ y + 1]);\n    queue.push([x, y - 1]);\n  }\n  return minSumPath;\n}\n\nlet grid\
    \ = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        dp[i] = new Array(m);\n        for(let j = 0; j < m; j++){\n\
    \            dp[i][j] = new Array(k + 1);\n            for(let l = 0; l <= k;\
    \ l++){\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = Infinity;\n                dp[i][j][l][1] = [];\n            }\n        }\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1] = [grid[i][j]];\n\
    \        }\n    }\n    for(let l = 2; l <= k; l++){\n        for(let i = 0; i\
    \ < n; i++){\n            for(let j = 0; j < m; j++){\n                if(i >\
    \ 0){\n                    if(dp[i - 1][j][l - 1][0] < dp[i][j][l][0]){\n    \
    \                    dp[i][j][l][0] = dp[i - 1][j][l - 1][0];\n              \
    \          dp[i][j][l][1] = dp[i - 1][j][l - 1][1].slice();\n                \
    \    }\n                    else if(dp[i - 1][j][l - 1][0] == dp[i][j][l][0]){\n\
    \                        let temp = dp[i - 1][j][l - 1][1].slice();\n        \
    \                if(temp.length == 0 || temp[temp.length - 1] < grid[i][j]){\n\
    \                            temp.push(grid[i][j]);\n                        \
    \    if(temp.length == dp[i][j][l][1].length){\n", "    let n = grid.length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let currPath = [];\n            let currSum = 0;\n            dfs(i,\
    \ j, 0, k, currPath, currSum);\n        }\n    }\n    return minPath;\n\n    function\
    \ dfs(i, j, currK, k, currPath, currSum){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= n || visited[i][j] || currK > k){\n            return;\n        }\n\
    \        visited[i][j] = true;\n        currPath.push(grid[i][j]);\n        currSum\
    \ += grid[i][j];\n        if(currK === k){\n            if(currSum < minSum){\n\
    \                minSum = currSum;\n                minPath = currPath.slice();\n\
    \            }\n            else if(currSum === minSum){\n                if(currPath.toString()\
    \ < minPath.toString()){\n                    minPath = currPath.slice();\n  \
    \              }\n            }\n        }\n        else{\n            dfs(i +\
    \ 1, j, currK + 1, k, currPath, currSum);\n            dfs(i - 1, j, currK + 1,\
    \ k, currPath, currSum);\n            dfs(i, j + 1, currK + 1, k, currPath, currSum);\n\
    \            dfs(i, j - 1, currK + 1, k, currPath, currSum);\n        }\n    \
    \    visited[i][j] = false;\n        currPath.pop();\n    }\n}\n", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let minSum\
    \ = Infinity;\n    let minPath = [];\n    let visited = new Set();\n    let dfs\
    \ = function(i, j, sum, path){\n        if(visited.has(i + ',' + j)) return;\n\
    \        if(path.length === k){\n            if(sum < minSum){\n             \
    \   minSum = sum;\n                minPath = path;\n            }\n          \
    \  return;\n        }\n        visited.add(i + ',' + j);\n        if(i > 0) dfs(i\
    \ - 1, j, sum + grid[i - 1][j], path.concat(grid[i - 1][j]));\n        if(i <\
    \ n - 1) dfs(i + 1, j, sum + grid[i + 1][j], path.concat(grid[i + 1][j]));\n \
    \       if(j > 0) dfs(i, j - 1, sum + grid[i][j - 1], path.concat(grid[i][j -\
    \ 1]));\n        if(j < m - 1) dfs(i, j + 1, sum + grid[i][j + 1], path.concat(grid[i][j\
    \ + 1]));\n        visited.delete(i + ',' + j);\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, grid[i][j],\
    \ [grid[i][j]]);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPathSum3\
    \ = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPathSum13\
    \ = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15 = Infinity;\n\
    \    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let minPathSum18\
    \ = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20 = Infinity;\n\
    \    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n    let minPathSum23\
    \ = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25 = Infinity;\n\
    \    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n    let minPathSum28\
    \ = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30 = Infinity;\n\
    \    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n    let minPathSum33\
    \ = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35 = Infinity;\n\
    \    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n    let minPathSum38\
    \ = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40 = Infinity;\n\
    \    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n    let minPathSum43\
    \ = Infinity;\n    let minPathSum44 = Infinity;\n    let minPathSum45 = Infinity;\n",
  "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(() => new\
    \ Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n      \
    \      let path = [];\n            let sum = 0;\n            dfs(i, j, 0, path,\
    \ sum);\n        }\n    }\n    return minPath;\n\n    function dfs(i, j, step,\
    \ path, sum){\n        if(step === k){\n            if(sum < minSum){\n      \
    \          minSum = sum;\n                minPath = path.slice();\n          \
    \  }\n            return;\n        }\n        if(i < 0 || i >= n || j < 0 || j\
    \ >= n || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  dfs(i - 1, j, step + 1, path, sum);\n        dfs(i + 1, j, step + 1, path,\
    \ sum);\n        dfs(i, j - 1, step + 1, path, sum);\n        dfs(i, j + 1, step\
    \ + 1, path, sum);\n        path.pop();\n        visited[i][j] = false;\n    }\n\
    }\n", "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let minPathsIndex = 0;\n    let minPathsIndexSum = 0;\n    let minPathsIndexSum2\
    \ = 0;\n    let minPathsIndexSum3 = 0;\n    let minPathsIndexSum4 = 0;\n    let\
    \ minPathsIndexSum5 = 0;\n    let minPathsIndexSum6 = 0;\n    let minPathsIndexSum7\
    \ = 0;\n    let minPathsIndexSum8 = 0;\n    let minPathsIndexSum9 = 0;\n    let\
    \ minPathsIndexSum10 = 0;\n    let minPathsIndexSum11 = 0;\n    let minPathsIndexSum12\
    \ = 0;\n    let minPathsIndexSum13 = 0;\n    let minPathsIndexSum14 = 0;\n   \
    \ let minPathsIndexSum15 = 0;\n    let minPathsIndexSum16 = 0;\n    let minPathsIndexSum17\
    \ = 0;\n    let minPathsIndexSum18 = 0;\n    let minPathsIndexSum19 = 0;\n   \
    \ let minPathsIndexSum20 = 0;\n    let minPathsIndexSum21 = 0;\n    let minPathsIndexSum22\
    \ = 0;\n    let minPathsIndexSum23 = 0;\n    let minPathsIndexSum24 = 0;\n   \
    \ let minPathsIndexSum25 = 0;\n    let minPathsIndexSum26 = 0;\n    let minPathsIndexSum27\
    \ = 0;\n    let minPathsIndexSum28 = 0;\n    let minPathsIndexSum29 = 0;\n   \
    \ let minPathsIndexSum30 = 0;\n    let minPathsIndexSum31 = 0;\n    let minPathsIndexSum32\
    \ = 0;\n    let minPathsIndexSum33 = 0;\n    let minPathsIndexSum34 = 0;\n   \
    \ let minPathsIndexSum35 = 0;\n    let minPaths", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n        \
    \    if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path;\n            }\n        }\n    }\n    return minPath;\n}\n", "    var\
    \ n = grid.length;\n    var m = grid[0].length;\n    var visited = [];\n    for(var\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(var j = 0; j < m;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    var minPath\
    \ = [];\n    var minPathSum = Infinity;\n    for(var i = 0; i < n; i++){\n   \
    \     for(var j = 0; j < m; j++){\n            var path = [];\n            var\
    \ pathSum = 0;\n            dfs(i, j, k, path, pathSum);\n        }\n    }\n \
    \   return minPath;\n    \n    function dfs(i, j, k, path, pathSum){\n       \
    \ if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n        dfs(i\
    \ + 1, j, k, path, pathSum);\n        dfs(i - 1, j, k, path, pathSum);\n     \
    \   dfs(i, j + 1, k, path, pathSum);\n        dfs(i, j - 1, k, path, pathSum);\n\
    \        path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j] =\
    \ false;\n    }\n}\n", "  let n = grid.length;\n  let visited = new Set();\n \
    \ let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsSumMap = {};\n \
    \ let minPathsMap = {};\n  let minPathsMapSum = {};\n  let minPathsMapSumMap =\
    \ {};\n  let minPathsMapSumMapMap = {};\n  let minPathsMapSumMapMapMap = {};\n\
    \  let minPathsMapSumMapMapMapMap = {};\n  let minPathsMapSumMapMapMapMapMap =\
    \ {};\n  let minPathsMapSumMapMapMapMapMapMap = {};\n  let minPathsMapSumMapMapMapMapMapMapMap\
    \ = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMap = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMap\
    \ = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMap = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMap = {};\n  let\
    \ minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n\
    \  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n\
    \  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n\
    \  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap =\
    \ {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n  let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n    let visited\
    \ = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let\
    \ j = 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n\
    \    function dfs(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if(path.length === k){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minSumPath = path.slice();\n            }\n        \
    \    else if(sum === minSum){\n                if(path.toString() < minSumPath.toString()){\n\
    \                    minSumPath = path.slice();\n                }\n         \
    \   }\n        }\n        else{\n            dfs(i + 1, j, path, sum);\n     \
    \       dfs(i - 1, j, path, sum);\n            dfs(i, j + 1, path, sum);\n   \
    \         dfs(i, j - 1, path, sum);\n        }\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return minSumPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let visited = new Set();\n    let\
    \ dfs = function(i, j, path, sum){\n        if(sum > minPathSum){\n          \
    \  return;\n        }\n        if(path.length === k){\n            if(sum < minPathSum){\n\
    \                minPathSum = sum;\n                minPath = path;\n        \
    \    }\n            return;\n        }\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m){\n            return;\n        }\n        if(visited.has(i + ',' + j)){\n\
    \            return;\n        }\n        visited.add(i + ',' + j);\n        dfs(i\
    \ + 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i - 1, j, path.concat(grid[i][j]),\
    \ sum + grid[i][j]);\n        dfs(i, j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \        dfs(i, j - 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        visited.delete(i\
    \ + ',' + j);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0;\
    \ j < m; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathIndex = Infinity;\n    let minPathIndexSum\
    \ = Infinity;\n    let minPathIndexIndex = Infinity;\n    let minPathIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndex = Infinity;\n   \
    \ let minPathIndexIndexIndexIndexIndexIndexSum = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n\
    \    let minPathIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n    let\
    \ minPathIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let min", "    let n = grid.length;\n    let visited = new\
    \ Array(n).fill(0).map(() => new Array(n).fill(false));\n    let minPath = new\
    \ Array(k).fill(Infinity);\n    let minPaths = [];\n    let min = Infinity;\n\
    \    let minPaths = [];\n    let dfs = (i, j, path, visited) => {\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= n || visited[i][j]) return;\n        if(path.length\
    \ === k){\n            let sum = path.reduce((acc, cur) => acc + cur, 0);\n  \
    \          if(sum < min){\n                min = sum;\n                minPaths\
    \ = [path];\n            }else if(sum === min){\n                minPaths.push(path);\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        dfs(i + 1, j, path.concat(grid[i][j]), visited);\n        dfs(i - 1,\
    \ j, path.concat(grid[i][j]), visited);\n        dfs(i, j + 1, path.concat(grid[i][j]),\
    \ visited);\n        dfs(i, j - 1, path.concat(grid[i][j]), visited);\n      \
    \  visited[i][j] = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < n; j++){\n            dfs(i, j, [grid[i][j]], visited);\n       \
    \ }\n    }\n    return minPaths.reduce((acc, cur) => {\n        if(acc.length\
    \ === 0) return cur;\n        for(let i = 0; i < cur.length; i++){\n         \
    \   if(cur[i] < acc[i]) return cur;\n            if(cur[i] > acc[i]) return acc;\n\
    \        }\n        return acc;\n    }, []);\n}\n", "    let n = grid.length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n\
    \    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minSum3 = Infinity;\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minSum4 = Infinity;\n\
    \    let minPathSum5 = Infinity;\n    let minPath5 = [];\n    let minSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minSum8 = Infinity;\n\
    \    let minPathSum9 = Infinity;\n    let minPath9 = [];\n    let minSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minSum10 =\
    \ Infinity;\n    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let\
    \ minSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPath12 =\
    \ [];\n    let minSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let\
    \ minPath13 = [];\n    let minSum13 = Infinity;\n    let minPathSum14 = Infinity;\n\
    \    let minPath14 = [];\n    let minSum14 = Infinity;\n    let minPathSum15 =\
    \ Infinity;\n    let minPath15 = [];\n    let minSum15 = Infinity;\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minSum16 = Infinity;\n    let\
    \ minPathSum17 = Infinity;\n    let minPath17 = [];\n    let minSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minSum18 =\
    \ Infinity;\n    let minPathSum19 = Infinity;\n    let minPath19 = [];\n   ",
  "  let n = grid.length;\n  let m = grid[0].length;\n  let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let dfs = function(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j]) return;\n    if(path.length === k){\n      if(sum < minSum){\n\
    \        minSum = sum;\n        minPath = path;\n      }\n      return;\n    }\n\
    \    visited[i][j] = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    dfs(i + 1, j, path, sum);\n    dfs(i - 1, j, path, sum);\n    dfs(i, j +\
    \ 1, path, sum);\n    dfs(i, j - 1, path, sum);\n    path.pop();\n    visited[i][j]\
    \ = false;\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(false));\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 = [];\n\
    \  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n\
    \  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n  let minPath4 = [];\n\
    \  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n  let minPath5 = [];\n\
    \  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n\
    \  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n  let minPath7 = [];\n\
    \  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n  let minPath8 = [];\n\
    \  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n\
    \  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n  let minPath10 =\
    \ [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n  let minPath11\
    \ = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n  let minPath12\
    \ = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n  let minPath13\
    \ = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n  let minPath14\
    \ = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n  let minPath15\
    \ = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n  let minPath16\
    \ = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n  let minPath17\
    \ = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity", "    let\
    \ n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n    let\
    \ minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 =\
    \ [];\n    let minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPath3\
    \ = [];\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let\
    \ minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n   ", "    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSumIndex = 0;\n    let minPathSumIndex2 = 0;\n \
    \   let minPathSumIndex3 = 0;\n    let minPathSumIndex4 = 0;\n    let minPathSumIndex5\
    \ = 0;\n    let minPathSumIndex6 = 0;\n    let minPathSumIndex7 = 0;\n    let\
    \ minPathSumIndex8 = 0;\n    let minPathSumIndex9 = 0;\n    let minPathSumIndex10\
    \ = 0;\n    let minPathSumIndex11 = 0;\n    let minPathSumIndex12 = 0;\n    let\
    \ minPathSumIndex13 = 0;\n    let minPathSumIndex14 = 0;\n    let minPathSumIndex15\
    \ = 0;\n    let minPathSumIndex16 = 0;\n    let minPathSumIndex17 = 0;\n    let\
    \ minPathSumIndex18 = 0;\n    let minPathSumIndex19 = 0;\n    let minPathSumIndex20\
    \ = 0;\n    let minPathSumIndex21 = 0;\n    let minPathSumIndex22 = 0;\n    let\
    \ minPathSumIndex23 = 0;\n    let minPathSumIndex24 = 0;\n    let minPathSumIndex25\
    \ = 0;\n    let minPathSumIndex26 = 0;\n    let minPathSumIndex27 = 0;\n    let\
    \ minPathSumIndex28 = 0;\n    let minPathSumIndex29 = 0;\n    let minPathSumIndex30\
    \ = 0;\n    let minPathSumIndex31 = 0;\n    let minPathSumIndex32 = 0;\n    let\
    \ minPathSumIndex33 = 0;\n    let minPathSumIndex34 = 0;\n    let minPathSumIndex35\
    \ = 0;\n    let minPathSumIndex36 = 0;\n    let minPathSumIndex37 = 0;\n    let\
    \ minPathSumIndex38 = 0;\n    let minPathSumIndex39 = 0;\n    let minPathSumIndex40\
    \ = 0;\n    let minPathSumIndex41 = 0;\n    let minPathSumIndex42 = 0;\n    let\
    \ minPathSumIndex43 = 0;\n    let minPathSumIndex44 = 0;\n    let minPathSumIndex45\
    \ = 0;\n   ", "    let n = grid.length;\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ visited = new Set();\n    let visited2 = new Set();\n    let visited3 = new\
    \ Set();\n    let visited4 = new Set();\n    let visited5 = new Set();\n    let\
    \ visited6 = new Set();\n    let visited7 = new Set();\n    let visited8 = new\
    \ Set();\n    let visited9 = new Set();\n    let visited10 = new Set();\n    let\
    \ visited11 = new Set();\n    let visited12 = new Set();\n    let visited13 =\
    \ new Set();\n    let visited14 = new Set();\n    let visited15 = new Set();\n\
    \    let visited16 = new Set();\n    let visited17 = new Set();\n    let visited18\
    \ = new Set();\n    let visited19 = new Set();\n    let visited20 = new Set();\n\
    \    let visited21 = new Set();\n    let visited22 = new Set();\n    let visited23\
    \ = new Set();\n    let visited24 = new Set();\n    let visited25 = new Set();\n\
    \    let visited26 = new Set();\n    let visited27 = new Set();\n    let visited28\
    \ = new Set();\n    let visited29 = new Set();\n    let visited30 = new Set();\n\
    \    let visited31 = new Set();\n    let visited32 = new Set();\n    let visited33\
    \ = new Set();\n    let visited34 = new Set();\n    let visited35 = new Set();\n\
    \    let visited36 = new Set();\n    let visited37 = new Set();\n    let visited38\
    \ = new Set();\n    let visited39 = new Set();\n    let visited40 = new Set();\n\
    \    let visited41 = new Set();\n    let visited42 = new Set();\n    let visited43\
    \ = new Set();\n    let visited44 = new Set();\n    let visited45 = new Set();\n\
    \    let visited46 = new Set();\n    let visited47 = new Set();\n    let visited48\
    \ = new Set();\n    let visited49 = new Set();\n    let visited50 = new Set();\n\
    \    let visited51 = new Set();\n    let visited52 = new Set();\n   ", "  // your\
    \ code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n  \
    \  let min = [];\n    let min_sum = Infinity;\n    let min_path = [];\n    let\
    \ visited = new Set();\n    let dfs = function(i, j, sum, path){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited.has(i + ',' + j)){\n           \
    \ return;\n        }\n        if(sum + grid[i][j] > min_sum){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum + grid[i][j] <\
    \ min_sum){\n                min_sum = sum + grid[i][j];\n                min_path\
    \ = path.slice();\n                min_path.push(grid[i][j]);\n            }\n\
    \            return;\n        }\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        dfs(i + 1, j, sum + grid[i][j], path);\n        dfs(i - 1, j, sum + grid[i][j],\
    \ path);\n        dfs(i, j + 1, sum + grid[i][j], path);\n        dfs(i, j - 1,\
    \ sum + grid[i][j], path);\n        path.pop();\n        visited.delete(i + ','\
    \ + j);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            dfs(i, j, 0, []);\n        }\n    }\n    return min_path;\n\
    }\n", "    let n = grid.length;\n    let visited = new Array(n);\n    for(let\
    \ i = 0; i < n; i++){\n        visited[i] = new Array(n).fill(false);\n    }\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < n; j++){\n            let path = [];\n   \
    \         let sum = 0;\n            dfs(i, j, k, path, sum);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return minPath;\n\n    function dfs(i, j, k,\
    \ path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        visited[i][j] = true;\n        if(path.length === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path.slice();\n            }\n            else if(sum === minSum){\n\
    \                if(path.join('') < minPath.join('')){\n                    minPath\
    \ = path.slice();\n                }\n            }\n        }\n        else{\n\
    \            dfs(i + 1, j, k, path, sum);\n            dfs(i - 1, j, k, path,\
    \ sum);\n            dfs(i, j + 1, k, path, sum);\n            dfs(i, j - 1, k,\
    \ path, sum);\n        }\n        visited[i][j] = false;\n        path.pop();\n\
    \    }\n}\n", "  // your code here\n}\n", "  let n = grid.length;\n  let minPath\
    \ = [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n    for(let\
    \ j = 0; j < n; j++){\n      let path = [];\n      let sum = 0;\n      let visited\
    \ = new Set();\n      visited.add(`${i},${j}`);\n      dfs(i, j, 1);\n      visited.delete(`${i},${j}`);\n\
    \    }\n  }\n  return minPath;\n  function dfs(i, j, depth){\n    if(depth > k){\n\
    \      return;\n    }\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n  \
    \  if(depth === k){\n      if(sum < minSum){\n        minSum = sum;\n        minPath\
    \ = path.slice();\n      }\n      return;\n    }\n    if(i > 0 && !visited.has(`${i-1},${j}`)){\n\
    \      visited.add(`${i-1},${j}`);\n      dfs(i-1, j, depth+1);\n      visited.delete(`${i-1},${j}`);\n\
    \    }\n    if(i < n-1 && !visited.has(`${i+1},${j}`)){\n      visited.add(`${i+1},${j}`);\n\
    \      dfs(i+1, j, depth+1);\n      visited.delete(`${i+1},${j}`);\n    }\n  \
    \  if(j > 0 && !visited.has(`${i},${j-1}`)){\n      visited.add(`${i},${j-1}`);\n\
    \      dfs(i, j-1, depth+1);\n      visited.delete(`${i},${j-1}`);\n    }\n  \
    \  if(j < n-1 && !visited.has(`${i},${j+1}`)){\n      visited.add(`${i},${j+1}`);\n\
    \      dfs(i, j+", "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n ||\
    \ j < 0 || j >= n || visited[i][j]) return;\n        visited[i][j] = true;\n \
    \       path.push(grid[i][j]);\n        sum += grid[i][j];\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }\n            if(sum === minSum){\n\
    \                if(path < minPath){\n                    minPath = path.slice();\n\
    \                }\n            }\n            visited[i][j] = false;\n      \
    \      path.pop();\n            return;\n        }\n        dfs(i + 1, j, path,\
    \ sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n\
    \        dfs(i, j - 1, path, sum);\n        visited[i][j] = false;\n        path.pop();\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath\
    \ = [];\n    let path = [];\n    let sum = 0;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            dfs(i, j, 0);\n        }\n \
    \   }\n    return minSumPath;\n    function dfs(i, j, depth){\n        if(depth\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minSumPath = path.slice();\n            }\n            return;\n\
    \        }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i, j + 1, depth + 1);\n        dfs(i,\
    \ j - 1, depth + 1);\n        dfs(i + 1, j, depth + 1);\n        dfs(i - 1, j,\
    \ depth + 1);\n        path.pop();\n        sum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    }\n}\n", "    // Write your code here\n    let n = grid.length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n\
    \    let minPath = new Array(k).fill(Infinity);\n    let minPathVal = Infinity;\n\
    \    let minPathGrid = new Array(n).fill(0).map(() => new Array(n).fill(0));\n\
    \    let dfs = (i, j, path, pathVal) => {\n        if (i < 0 || i >= n || j <\
    \ 0 || j >= n || visited[i][j]) return;\n        if (path.length === k) {\n  \
    \          if (pathVal < minPathVal) {\n                minPathVal = pathVal;\n\
    \                minPath = path.slice();\n                minPathGrid = grid.map(arr\
    \ => arr.slice());\n            }\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        pathVal += grid[i][j];\n  \
    \      dfs(i + 1, j, path, pathVal);\n        dfs(i - 1, j, path, pathVal);\n\
    \        dfs(i, j + 1, path, pathVal);\n        dfs(i, j - 1, path, pathVal);\n\
    \        path.pop();\n        pathVal -= grid[i][j];\n        visited[i][j] =\
    \ false;\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j\
    \ < n; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let result = [];\n    let min = Infinity;\n\
    \    let visited = {};\n    let dfs = function(i, j, k, sum, path){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= n || k < 0 || visited[i + ',' + j]){\n      \
    \      return;\n        }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        if(k === 0){\n            if(sum < min){\n                min = sum;\n\
    \                result = path.slice();\n            }\n            path.pop();\n\
    \            return;\n        }\n        visited[i + ',' + j] = true;\n      \
    \  dfs(i - 1, j, k - 1, sum, path);\n        dfs(i + 1, j, k - 1, sum, path);\n\
    \        dfs(i, j - 1, k - 1, sum, path);\n        dfs(i, j + 1, k - 1, sum, path);\n\
    \        visited[i + ',' + j] = false;\n        path.pop();\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i,\
    \ j, k, 0, []);\n        }\n    }\n    return result;\n}\n", "    let n = grid.length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n\
    \    let min = [];\n    let minSum = Infinity;\n    let minPath = [];\n    let\
    \ dfs = (i, j, path, sum) => {\n        if (sum > minSum) return;\n        if\
    \ (path.length === k) {\n            if (sum < minSum) {\n                minSum\
    \ = sum;\n                minPath = path;\n            }\n            return;\n\
    \        }\n        if (i < 0 || i >= n || j < 0 || j >= n || visited[i][j]) return;\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path,\
    \ sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n\
    \        path.pop();\n        sum -= grid[i][j];\n        visited[i][j] = false;\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n \
    \   let minPathSum = Infinity;\n    let minPaths = [];\n    let visited = new\
    \ Set();\n    let queue = [];\n    let start = [0, 0];\n    queue.push(start);\n\
    \    visited.add(start.toString());\n    while(queue.length){\n        let curr\
    \ = queue.shift();\n        let [x, y] = curr;\n        if(x === n - 1 && y ===\
    \ n - 1){\n            if(minPath.length === k){\n                minPaths.push(minPath);\n\
    \            }\n            if(minPathSum > minSum){\n                minPathSum\
    \ = minSum;\n                minPaths = [minPath];\n            }\n          \
    \  continue;\n        }\n        if(minPath.length === k){\n            continue;\n\
    \        }\n        minPath.push(grid[x][y]);\n        minSum += grid[x][y];\n\
    \        if(x + 1 < n && !visited.has([x + 1, y].toString())){\n            queue.push([x\
    \ + 1, y]);\n            visited.add([x + 1, y].toString());\n        }\n    \
    \    if(y + 1 < n && !visited.has([x, y + 1].toString())){\n            queue.push([x,\
    \ y + 1]);\n            visited.add([x, y + 1].toString());\n        }\n     \
    \   if(x - 1 >= 0 && !visited.has([x - 1, y].toString())){\n            queue.push([x\
    \ - 1, y]);\n            visited.add([x - 1, y].toString());\n        }\n    \
    \    if(y - 1 >= 0 && !visited.has([x, y - 1].toString())){\n            queue.push([x,\
    \ y - 1]);\n            visited.add([x, y - 1].toString());\n        }\n     \
    \   minPath.pop();\n        minSum -= grid[x][y];\n    }\n    return minPaths.sort((a,\
    \ b) => {\n        for(let i = 0; i <", "    let n = grid.length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathSum2\
    \ = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n    let minPathSum3\
    \ = Infinity;\n    let minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5\
    \ = Infinity;\n    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6\
    \ = Infinity;\n    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7\
    \ = Infinity;\n    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10\
    \ = Infinity;\n    let minPath10 = [];\n    let minSum10 = Infinity;\n    let\
    \ minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPath12 = [];\n    let minSum12 =\
    \ Infinity;\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n    let\
    \ minSum13 = Infinity;\n    let minPathSum14 = Infinity;\n    let minPath14 =\
    \ [];\n    let minSum14 = Infinity;\n    let minPathSum15 = Infinity;\n    let\
    \ minPath15 = [];\n    let minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPath16 = [];\n    let minSum16 = Infinity;\n    let minPathSum17 =\
    \ Infinity;\n    let minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18\
    \ = Infinity;\n    let minPath18 = [];\n    let minSum18 = Infinity;\n    let\
    \ minPathSum19 = Infinity;\n    let minPath19 = [];\n   ", "    let n = grid.length;\n\
    \    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] =\
    \ new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = new\
    \ Array(k+1);\n            for(let l = 0; l <= k; l++){\n                dp[i][j][l]\
    \ = {\n                    path: [],\n                    min: Infinity\n    \
    \            };\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            dp[i][j][1].path = [grid[i][j]];\n\
    \            dp[i][j][1].min = grid[i][j];\n        }\n    }\n    for(let l =\
    \ 2; l <= k; l++){\n        for(let i = 0; i < n; i++){\n            for(let j\
    \ = 0; j < n; j++){\n                let min = Infinity;\n                let\
    \ path = [];\n                if(i > 0){\n                    let curr = dp[i-1][j][l-1];\n\
    \                    if(curr.min < min){\n                        min = curr.min;\n\
    \                        path = curr.path;\n                    }\n          \
    \      }\n                if(i < n-1){\n                    let curr = dp[i+1][j][l-1];\n\
    \                    if(curr.min < min){\n                        min = curr.min;\n\
    \                        path = curr.path;\n                    }\n          \
    \      }\n                if(j > 0){\n                    let curr = dp[i][j-1][l-1];\n\
    \                    if(curr.min < min){\n                        min = curr.min;\n\
    \                        path = curr.path;\n                    }\n          \
    \      }\n                if(j < n-1){\n                    let curr = dp[i][j+1][l-1];\n\
    \                    if(curr.min < min){\n                        min = curr.min;\n\
    \                       ", "  let n = grid.length;\n  let visited = new Set();\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsSet = new Set();\n\
    \  let minPathsSumSet = new Set();\n  let minPathsSumMap = new Map();\n  let minPathsMap\
    \ = new Map();\n  let minPathsSumMap2 = new Map();\n  let minPathsMap2 = new Map();\n\
    \  let minPathsSumMap3 = new Map();\n  let minPathsMap3 = new Map();\n  let minPathsSumMap4\
    \ = new Map();\n  let minPathsMap4 = new Map();\n  let minPathsSumMap5 = new Map();\n\
    \  let minPathsMap5 = new Map();\n  let minPathsSumMap6 = new Map();\n  let minPathsMap6\
    \ = new Map();\n  let minPathsSumMap7 = new Map();\n  let minPathsMap7 = new Map();\n\
    \  let minPathsSumMap8 = new Map();\n  let minPathsMap8 = new Map();\n  let minPathsSumMap9\
    \ = new Map();\n  let minPathsMap9 = new Map();\n  let minPathsSumMap10 = new\
    \ Map();\n  let minPathsMap10 = new Map();\n  let minPathsSumMap11 = new Map();\n\
    \  let minPathsMap11 = new Map();\n  let minPathsSumMap12 = new Map();\n  let\
    \ minPathsMap12 = new Map();\n  let minPathsSumMap13 = new Map();\n  let minPathsMap13\
    \ = new Map();\n  let minPathsSumMap14 = new Map();\n  let minPathsMap14 = new\
    \ Map();\n  let minPathsSumMap15 = new Map();\n  let minPathsMap15 = new Map();\n\
    \  let minPathsSumMap16 = new Map();\n  let minPathsMap16 = new Map();\n  let\
    \ minPathsSumMap17 = new Map();\n  let minPathsMap17 = new Map();\n  let minPathsSumMap",
  "    let n = grid.length;\n    let visited = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        visited[i] = new Array(n).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n       \
    \ for(let j = 0; j < n; j++){\n            let path = [];\n            let sum\
    \ = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path;\n\
    \            }\n            else if(sum === minSum){\n                if(path\
    \ < minPath){\n                    minPath = path;\n                }\n      \
    \      }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let minPathsSumMap = new Map();\n    let minPathsMap = new Map();\n\
    \    let minPathsSumMap2 = new Map();\n    let minPathsMap2 = new Map();\n   \
    \ let minPathsSumMap3 = new Map();\n    let minPathsMap3 = new Map();\n    let\
    \ minPathsSumMap4 = new Map();\n    let minPathsMap4 = new Map();\n    let minPathsSumMap5\
    \ = new Map();\n    let minPathsMap5 = new Map();\n    let minPathsSumMap6 = new\
    \ Map();\n    let minPathsMap6 = new Map();\n    let minPathsSumMap7 = new Map();\n\
    \    let minPathsMap7 = new Map();\n    let minPathsSumMap8 = new Map();\n   \
    \ let minPathsMap8 = new Map();\n    let minPathsSumMap9 = new Map();\n    let\
    \ minPathsMap9 = new Map();\n    let minPathsSumMap10 = new Map();\n    let minPathsMap10\
    \ = new Map();\n    let minPathsSumMap11 = new Map();\n    let minPathsMap11 =\
    \ new Map();\n    let minPathsSumMap12 = new Map();\n    let minPathsMap12 = new\
    \ Map();\n    let minPathsSumMap13 = new Map();\n    let minPathsMap13 = new Map();\n\
    \    let minPathsSumMap14 = new Map();\n    let minPathsMap14 = new Map();\n \
    \   let minPathsSumMap15 = new Map();\n    let minPathsMap15 = new Map();\n  \
    \  let minPathsSumMap16 = new Map();\n    let minPathsMap16 = new Map();\n   \
    \ let minPathsSumMap17 = new Map();\n    let minPathsMap17 = new Map();\n", " \
    \ let n = grid.length;\n  let m = grid[0].length;\n  let minPath = [];\n  let\
    \ minPathSum = Infinity;\n  let visited = [];\n  for(let i = 0; i < n; i++){\n\
    \    visited.push([]);\n    for(let j = 0; j < m; j++){\n      visited[i].push(false);\n\
    \    }\n  }\n  function dfs(i, j, path, sum){\n    if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j]) return;\n    if(path.length === k){\n      if(sum\
    \ < minPathSum){\n        minPathSum = sum;\n        minPath = path;\n      }\n\
    \      return;\n    }\n    visited[i][j] = true;\n    dfs(i + 1, j, path.concat(grid[i][j]),\
    \ sum + grid[i][j]);\n    dfs(i - 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \    dfs(i, j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n    dfs(i, j -\
    \ 1, path.concat(grid[i][j]), sum + grid[i][j]);\n    visited[i][j] = false;\n\
    \  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i,\
    \ j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var visited = [];\n    for(var i = 0; i < n;\
    \ i++){\n        visited.push(new Array(m).fill(false));\n    }\n    var minPath\
    \ = [];\n    var minPathSum = Infinity;\n    for(var i = 0; i < n; i++){\n   \
    \     for(var j = 0; j < m; j++){\n            var path = [];\n            var\
    \ pathSum = 0;\n            dfs(grid, i, j, k, path, pathSum, visited);\n    \
    \        if(pathSum < minPathSum){\n                minPathSum = pathSum;\n  \
    \              minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let\
    \ j = 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            let currPath = [];\n\
    \            let currSum = 0;\n            dfs(i, j, k, currPath, currSum);\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, k, currPath, currSum){\n\
    \        if(k === 0){\n            if(currSum < minSum){\n                minSum\
    \ = currSum;\n                minPath = currPath.slice();\n            }\n   \
    \         return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= m ||\
    \ visited[i][j]){\n            return;\n        }\n        visited[i][j] = true;\n\
    \        currPath.push(grid[i][j]);\n        currSum += grid[i][j];\n        dfs(i\
    \ + 1, j, k - 1, currPath, currSum);\n        dfs(i - 1, j, k - 1, currPath, currSum);\n\
    \        dfs(i, j + 1, k - 1, currPath, currSum);\n        dfs(i, j - 1, k - 1,\
    \ currPath, currSum);\n        visited[i][j] = false;\n        currPath.pop();\n\
    \    }\n}\n", "  let n = grid.length;\n  let visited = new Set();\n  let minPath\
    \ = [];\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2\
    \ = [];\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n  let minPathSum4\
    \ = Infinity;\n  let minPath4 = [];\n  let minPathSum5 = Infinity;\n  let minPath5\
    \ = [];\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n  let minPathSum7\
    \ = Infinity;\n  let minPath7 = [];\n  let minPathSum8 = Infinity;\n  let minPath8\
    \ = [];\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n  let minPathSum10\
    \ = Infinity;\n  let minPath10 = [];\n  let minPathSum11 = Infinity;\n  let minPath11\
    \ = [];\n  let minPathSum12 = Infinity;\n  let minPath12 = [];\n  let minPathSum13\
    \ = Infinity;\n  let minPath13 = [];\n  let minPathSum14 = Infinity;\n  let minPath14\
    \ = [];\n  let minPathSum15 = Infinity;\n  let minPath15 = [];\n  let minPathSum16\
    \ = Infinity;\n  let minPath16 = [];\n  let minPathSum17 = Infinity;\n  let minPath17\
    \ = [];\n  let minPathSum18 = Infinity;\n  let minPath18 = [];\n  let minPathSum19\
    \ = Infinity;\n  let minPath19 = [];\n  let minPathSum20 = Infinity;\n  let minPath20\
    \ = [];\n  let minPathSum21 = Infinity;\n  let minPath21 = [];\n  let minPathSum22\
    \ = Infinity;\n  let minPath22 = [];\n  let minPathSum23 = Infinity;\n  let minPath23\
    \ = [];\n  let minPathSum24 = Infinity;\n  let minPath24 = [];\n  let minPathSum25\
    \ = Infinity;\n  let minPath25 = [];\n  let minPathSum26 = Infinity;\n  let minPath26\
    \ = [];\n  let minPathSum27 = Infinity;\n  let minPath27 = [];\n  let minPathSum28\
    \ = Infinity;\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let min = [];\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < m; j++){\n            let curr = [];\n\
    \            dfs(i, j, k, grid, visited, curr, min);\n        }\n    }\n    return\
    \ min;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ grid, visited, path, sum);\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minPath = path;\n            }\n        }\n    }\n \
    \   return minPath;\n}\n", "  let n = grid.length;\n  let visited = new Set();\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsVisited = [];\n\
    \  let minPathsVisitedSum = [];\n  let minPathsVisitedSumSet = new Set();\n  let\
    \ minPathsVisitedSumSetSize = 0;\n  let minPathsVisitedSumSetSizeMax = 1;\n  let\
    \ minPathsVisitedSumSetSizeMaxMax = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMax = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMax = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMax = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 1;\n \
    \ let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ = 1;\n  let minPathsVisitedSumSetSizeMaxMaxMax", "    let n = grid.length;\n\
    \    let dp = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));\n \
    \   let q = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n;\
    \ j++){\n            if(grid[i][j] === 1){\n                dp[i][j] = 0;\n  \
    \              q.push([i, j]);\n            }\n        }\n    }\n    while(q.length){\n\
    \        let [i, j] = q.shift();\n        for(let [di, dj] of [[-1, 0], [1, 0],\
    \ [0, -1], [0, 1]]){\n            let ni = i + di;\n            let nj = j + dj;\n\
    \            if(ni < 0 || ni >= n || nj < 0 || nj >= n) continue;\n          \
    \  if(dp[ni][nj] > dp[i][j] + 1){\n                dp[ni][nj] = dp[i][j] + 1;\n\
    \                q.push([ni, nj]);\n            }\n        }\n    }\n    let ans\
    \ = [];\n    let min = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < n; j++){\n            if(dp[i][j] === k){\n                if(grid[i][j]\
    \ < min){\n                    min = grid[i][j];\n                    ans = [grid[i][j]];\n\
    \                }\n                else if(grid[i][j] === min){\n           \
    \         ans.push(grid[i][j]);\n                }\n            }\n        }\n\
    \    }\n    return ans;\n}\n", "    let n = grid.length;\n    let visited = new\
    \ Array(n).fill(0).map(() => new Array(n).fill(false));\n    let minPath = new\
    \ Array(k).fill(Infinity);\n    let minPaths = [];\n    let minPathsCount = 0;\n\
    \    let minPathsSum = Infinity;\n    let minPathsSumCount = 0;\n    let minPathsSumIndex\
    \ = 0;\n    let minPathsSumIndexCount = 0;\n    let minPathsSumIndexSum = Infinity;\n\
    \    let minPathsSumIndexSumCount = 0;\n    let minPathsSumIndexSumIndex = 0;\n\
    \    let minPathsSumIndexSumIndexCount = 0;\n    let minPathsSumIndexSumIndexSum\
    \ = Infinity;\n    let minPathsSumIndexSumIndexSumCount = 0;\n    let minPathsSumIndexSumIndexSumIndex\
    \ = 0;\n    let minPathsSumIndexSumIndexSumIndexCount = 0;\n    let minPathsSumIndexSumIndexSumIndexSum\
    \ = Infinity;\n    let minPathsSumIndexSumIndexSumIndexSumCount = 0;\n    let\
    \ minPathsSumIndexSumIndexSumIndexSumIndex = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexCount\
    \ = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSum = Infinity;\n    let\
    \ minPathsSumIndexSumIndexSumIndexSumIndexSumCount = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSumIndexCount = 0;\n \
    \   let minPathsSumIndexSumIndexSumIndexSumIndexSumIndexSum = Infinity;\n    let\
    \ minPathsSumIndexSumIndexSumIndexSumIndexSumIndexSumCount = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexCount\
    \ = 0;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum =\
    \ Infinity;\n    let minPathsSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumCount\
    \ = 0;\n    let minPathsSumIndexSumIndexSumIndexSum", "    let n = grid.length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let currPath = [];\n            let currSum = 0;\n            dfs(i,\
    \ j, k, currPath, currSum);\n        }\n    }\n    return minPath;\n\n    function\
    \ dfs(i, j, k, currPath, currSum){\n        if(i < 0 || i >= n || j < 0 || j >=\
    \ n || visited[i][j]){\n            return;\n        }\n        if(currPath.length\
    \ === k){\n            if(currSum < minSum){\n                minSum = currSum;\n\
    \                minPath = currPath.slice();\n            }\n            return;\n\
    \        }\n        visited[i][j] = true;\n        currPath.push(grid[i][j]);\n\
    \        currSum += grid[i][j];\n        dfs(i - 1, j, k, currPath, currSum);\n\
    \        dfs(i + 1, j, k, currPath, currSum);\n        dfs(i, j - 1, k, currPath,\
    \ currSum);\n        dfs(i, j + 1, k, currPath, currSum);\n        visited[i][j]\
    \ = false;\n        currPath.pop();\n        currSum -= grid[i][j];\n    }\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = new Array(k);\n    let minPathSum\
    \ = Infinity;\n    let minPathIndex = 0;\n    for(let i = 0; i < n; i++){\n  \
    \      for(let j = 0; j < m; j++){\n            let path = [];\n            let\
    \ pathSum = 0;\n            let pathIndex = 0;\n            dfs(i, j, 0);\n  \
    \      }\n    }\n    return minPath;\n    function dfs(i, j, index){\n       \
    \ if(index === k){\n            if(pathSum < minPathSum){\n                minPathSum\
    \ = pathSum;\n                minPathIndex = pathIndex;\n                minPath\
    \ = path.slice();\n            }\n            else if(pathSum === minPathSum){\n\
    \                for(let i = 0; i < k; i++){\n                    if(path[i] <\
    \ minPath[i]){\n                        minPathIndex = pathIndex;\n          \
    \              minPath = path.slice();\n                        break;\n     \
    \               }\n                    else if(path[i] > minPath[i]){\n      \
    \                  break;\n                    }\n                }\n        \
    \    }\n            return;\n        }\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path[pathIndex++] = grid[i][j];\n        pathSum += grid[i][j];\n\
    \        dfs(i - 1, j, index + 1);\n        dfs(i + 1, j, index + 1);\n      \
    \  dfs(i, j - 1, index + 1);\n        dfs(i, j + 1, index + 1);\n        visited[i][j]\
    \ = false;\n        pathIndex--;\n        pathSum -= grid[i][j];\n    }\n}\n",
  "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n \
    \   let minPathSum = Infinity;\n    let visited = new Set();\n    let path = [];\n\
    \    let sum = 0;\n    let pathSum = 0;\n    let minPaths = [];\n    let minSums\
    \ = [];\n    let minPathSums = [];\n    let minPathsIndex = 0;\n    let minSumsIndex\
    \ = 0;\n    let minPathSumsIndex = 0;\n    let minPathsIndexes = [];\n    let\
    \ minSumsIndexes = [];\n    let minPathSumsIndexes = [];\n    let minPathsIndexesIndex\
    \ = 0;\n    let minSumsIndexesIndex = 0;\n    let minPathSumsIndexesIndex = 0;\n\
    \    let minPathsIndexesIndexes = [];\n    let minSumsIndexesIndexes = [];\n \
    \   let minPathSumsIndexesIndexes = [];\n    let minPathsIndexesIndexesIndex =\
    \ 0;\n    let minSumsIndexesIndexesIndex = 0;\n    let minPathSumsIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexes = [];\n    let minSumsIndexesIndexesIndexes\
    \ = [];\n    let minPathSumsIndexesIndexesIndexes = [];\n    let minPathsIndexesIndexesIndexesIndex\
    \ = 0;\n    let minSumsIndexesIndexesIndexesIndex = 0;\n    let minPathSumsIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexesIndexes = [];\n    let minSumsIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathSumsIndexesIndexesIndexesIndexes = [];\n    let minPathsIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minSumsIndexesIndexesIndexesIndexesIndex = 0;\n    let minPathSumsIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathsIndexesIndexesIndexesIndexesIndexes = [];\n    let minSumsIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathSumsIndexesIndexesIndexesIndex", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, visited, path,\
    \ sum, k);\n            if(sum < minSum){\n                minSum = sum;\n   \
    \             minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n\
    \    let minSum = Infinity;\n    let minPath = [];\n    let visited = [];\n  \
    \  for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let j =\
    \ 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            dfs(i, j, k, path, sum);\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, k, path, sum){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n          \
    \  return;\n        }\n        if(path.length === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1,\
    \ j, k, path, sum);\n        dfs(i - 1, j, k, path, sum);\n        dfs(i, j +\
    \ 1, k, path, sum);\n        dfs(i, j - 1, k, path, sum);\n        path.pop();\n\
    \        sum -= grid[i][j];\n        visited[i][j] = false;\n    }\n}", "    //\
    \ your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new\
    \ Array(k + 1).fill(Infinity)));\n    let queue = [];\n    let ans = [];\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   dp[i][j][1] = grid[i][j];\n            queue.push([i, j, 1]);\n        }\n\
    \    }\n    while(queue.length){\n        let [i, j, l] = queue.shift();\n   \
    \     if(l > k) continue;\n        if(i > 0 && dp[i - 1][j][l + 1] > dp[i][j][l]\
    \ + grid[i - 1][j]){\n            dp[i - 1][j][l + 1] = dp[i][j][l] + grid[i -\
    \ 1][j];\n            queue.push([i - 1, j, l + 1]);\n        }\n        if(i\
    \ < n - 1 && dp[i + 1][j][l + 1] > dp[i][j][l] + grid[i + 1][j]){\n          \
    \  dp[i + 1][j][l + 1] = dp[i][j][l] + grid[i + 1][j];\n            queue.push([i\
    \ + 1, j, l + 1]);\n        }\n        if(j > 0 && dp[i][j - 1][l + 1] > dp[i][j][l]\
    \ + grid[i][j - 1]){\n            dp[i][j - 1][l + 1] = dp[i][j][l] + grid[i][j\
    \ - 1];\n            queue.push([i, j - 1, l + 1]);\n        }\n        if(j <\
    \ m - 1 && dp[i][j + 1][l + 1] > dp[i][j][l] + grid[i][j + 1]){\n            dp[i][",
  "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n \
    \   let minPathSum = Infinity;\n    let visited = new Set();\n    let dfs = function(x,\
    \ y, path, sum){\n        if(visited.has(x + ',' + y)) return;\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path;\n            }\n            return;\n        }\n\
    \        visited.add(x + ',' + y);\n        if(x > 0) dfs(x - 1, y, path.concat(grid[x\
    \ - 1][y]), sum + grid[x - 1][y]);\n        if(x < n - 1) dfs(x + 1, y, path.concat(grid[x\
    \ + 1][y]), sum + grid[x + 1][y]);\n        if(y > 0) dfs(x, y - 1, path.concat(grid[x][y\
    \ - 1]), sum + grid[x][y - 1]);\n        if(y < n - 1) dfs(x, y + 1, path.concat(grid[x][y\
    \ + 1]), sum + grid[x][y + 1]);\n        visited.delete(x + ',' + y);\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n      \
    \      dfs(i, j, [grid[i][j]], grid[i][j]);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let min = new Array(k).fill(Infinity);\n    let minPath = new Array(k);\n\
    \    let dfs = function(i, j, path, pathLength){\n        if(pathLength === k){\n\
    \            if(path < min){\n                min = path;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n   \
    \     dfs(i + 1, j, path, pathLength + 1);\n        dfs(i - 1, j, path, pathLength\
    \ + 1);\n        dfs(i, j + 1, path, pathLength + 1);\n        dfs(i, j - 1, path,\
    \ pathLength + 1);\n        path.pop();\n        visited[i][j] = false;\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(Infinity));\n    let min = Infinity;\n    let minPath =\
    \ [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            if(i === 0 && j === 0){\n                dp[i][j] = 0;\n        \
    \    }\n            if(i > 0){\n                dp[i][j] = Math.min(dp[i][j],\
    \ dp[i - 1][j] + 1);\n            }\n            if(j > 0){\n                dp[i][j]\
    \ = Math.min(dp[i][j], dp[i][j - 1] + 1);\n            }\n            if(dp[i][j]\
    \ <= k && grid[i][j] < min){\n                min = grid[i][j];\n            \
    \    minPath = [grid[i][j]];\n            }\n            else if(dp[i][j] <= k\
    \ && grid[i][j] === min){\n                minPath.push(grid[i][j]);\n       \
    \     }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let visited = [];\n    for(let\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(let j = 0; j < m;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            dfs(grid, i, j, k, path, visited);\n            if(min.length\
    \ === 0 || path < min){\n                min = path;\n            }\n        }\n\
    \    }\n    return min;\n}\n", "    let n = grid.length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let minSumPath = [];\n    let visited = new Set();\n\
    \    let queue = [[0,0,0]];\n    while(queue.length){\n        let [i,j,sum] =\
    \ queue.shift();\n        if(visited.has(i+','+j)) continue;\n        visited.add(i+','+j);\n\
    \        sum += grid[i][j];\n        if(sum > minSum) continue;\n        if(i\
    \ === n-1 && j === n-1){\n            if(sum < minSum){\n                minSum\
    \ = sum;\n                minSumPath = [grid[i][j]];\n            }\n        \
    \    continue;\n        }\n        if(sum === minSum){\n            minSumPath.push(grid[i][j]);\n\
    \        }\n        if(sum < minSum){\n            minSum = sum;\n           \
    \ minSumPath = [grid[i][j]];\n        }\n        if(i+1 < n){\n            queue.push([i+1,j,sum]);\n\
    \        }\n        if(j+1 < n){\n            queue.push([i,j+1,sum]);\n     \
    \   }\n    }\n    let sum = 0;\n    for(let i = 0; i < minSumPath.length; i++){\n\
    \        sum += minSumPath[i];\n        if(sum === k){\n            return minSumPath.slice(0,i+1);\n\
    \        }\n    }\n    return minSumPath;\n}\n", "  // your code here\n}\n", " \
    \   // Write your code here\n    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(0));\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let dfs = (i, j, path, sum)\
    \ => {\n        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || sum\
    \ >= minSum) {\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if (path.length === k) {\n            if\
    \ (sum < minSum) {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        visited[i][j] = 1;\n \
    \       dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n       \
    \ dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n        visited[i][j]\
    \ = 0;\n        path.pop();\n    }\n    for (let i = 0; i < n; i++) {\n      \
    \  for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n        }\n \
    \   }\n    return minPath;\n}\n", "    // your code here\n}\n", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var visited = [];\n    for(var i = 0; i < n;\
    \ i++){\n        visited.push([]);\n        for(var j = 0; j < m; j++){\n    \
    \        visited[i].push(false);\n        }\n    }\n    var minPath = [];\n  \
    \  var minSum = Number.MAX_VALUE;\n    for(var i = 0; i < n; i++){\n        for(var\
    \ j = 0; j < m; j++){\n            var currPath = [];\n            var currSum\
    \ = 0;\n            dfs(grid, i, j, k, visited, currPath, currSum);\n        \
    \    if(currSum < minSum){\n                minSum = currSum;\n              \
    \  minPath = currPath;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSumIndex = 0;\n    let minPathSumIndexes = [];\n    let minPathSumIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexes = [];\n    let minPathSumIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexes = [];\n    let minPathSumIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexes = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndexes = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexes = [];\n \
    \   let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndex = 0;\n    let\
    \ minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexes = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexes\
    \ = [];\n    let minPathSumIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndexesIndex\
    \ = 0;\n    let minPathSumIndexesIndexesIndexesIndexesIndex", "    // Write your\
    \ code here\n    let n = grid.length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathLength = Infinity;\n    let minPathIndex\
    \ = Infinity;\n    let minPathIndexSum = Infinity;\n    let minPathIndexLength\
    \ = Infinity;\n    let minPathIndexIndex = Infinity;\n    let minPathIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexLength = Infinity;\n    let minPathIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexSum = Infinity;\n    let minPathIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexLength = Infinity;\n    let\
    \ minPathIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexLength = Infinity;\n  \
    \  let minPathIndexIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexLength = Infinity;\n\
    \    let minPathIndexIndexIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexLength = Infinity;\n\
    \    let minPathIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n    let\
    \ minPathIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndex =\
    \ Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexSum =\
    \ Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndex", "    let n = grid.length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    let minPathsSum = [];\n    let dfs = function(i,\
    \ j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j])\
    \ return;\n        if(path.length === k){\n            if(sum < minSum){\n   \
    \             minSum = sum;\n                minPath = path;\n            }\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i\
    \ - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1,\
    \ path, sum);\n        path.pop();\n        visited[i][j] = false;\n    }\n  \
    \  for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n        \
    \    dfs(i, j, [], 0);\n        }\n    }\n    for(let i = 0; i < n; i++){\n  \
    \      for(let j = 0; j < n; j++){\n            visited = new Array(n).fill(0).map(()\
    \ => new Array(n).fill(false));\n            dfs(i, j, [], 0);\n            if(minPathSum\
    \ > minSum){\n                minPathSum = minSum;\n                minPaths =\
    \ [minPath];\n            }else if(minPathSum === minSum){\n                minPaths.push(minPath);\n\
    \            }\n        }\n    }\n    minPaths.sort((a, b) => {\n        for(let\
    \ i = 0; i < a.length; i++){\n            if(a[i] < b[i]) return -1;\n", "  //\
    \ your code here\n}\n", "  let n = grid.length;\n  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n \
    \ let minPath2 = [];\n  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n\
    \  let minPath4 = [];\n  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n\
    \  let minPath5 = [];\n  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n\
    \  let minPath7 = [];\n  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n\
    \  let minPath8 = [];\n  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n\
    \  let minPath10 = [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n\
    \  let minPath11 = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n\
    \  let minPath13 = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n\
    \  let minPath14 = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n\
    \  let minPath16 = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n\
    \  let minPath17 = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minSum18 = Infinity;\n  let minPathSum19 = Infinity;\n\
    \  let minPath19 = [];\n ", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited[i][j] || sum > minSum || path.length > k){\n          \
    \  return;\n        }\n        if(path.length === k){\n            if(sum < minPathSum){\n\
    \                minPathSum = sum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1,\
    \ j, path, sum);\n        dfs(i - 1, j, path, sum);\n        dfs(i, j + 1, path,\
    \ sum);\n        dfs(i, j - 1, path, sum);\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dfs(i, j, [], 0);\n            minSum = minPathSum;\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n\
    \    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minSum3 = Infinity;\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minSum4 = Infinity;\n\
    \    let minPathSum5 = Infinity;\n    let minPath5 = [];\n    let minSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minSum8 = Infinity;\n\
    \    let minPathSum9 = Infinity;\n    let minPath9 = [];\n    let minSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minSum10 =\
    \ Infinity;\n    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let\
    \ minSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPath12 =\
    \ [];\n    let minSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let\
    \ minPath13 = [];\n    let minSum13 = Infinity;\n    let minPathSum14 = Infinity;\n\
    \    let minPath14 = [];\n    let minSum14 = Infinity;\n    let minPathSum15 =\
    \ Infinity;\n    let minPath15 = [];\n    let minSum15 = Infinity;\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minSum16 = Infinity;\n    let\
    \ minPathSum17 = Infinity;\n    let minPath17 = [];\n    let minSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minSum18 =\
    \ Infinity;\n    let minPathSum19 = Infinity;\n    let minPath19 = [];\n   ",
  "    // Write your code here\n    const n = grid.length;\n    const visited = new\
    \ Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(n).fill(false);\n\
    \    }\n    const queue = [];\n    const start = {\n        x: 0,\n        y:\
    \ 0,\n        path: [grid[0][0]],\n        length: 1\n    };\n    queue.push(start);\n\
    \    visited[0][0] = true;\n    let minPath = [];\n    while(queue.length > 0){\n\
    \        const cur = queue.shift();\n        if(cur.length === k){\n         \
    \   if(minPath.length === 0 || cur.path < minPath){\n                minPath =\
    \ cur.path;\n            }\n        }\n        if(cur.length < k){\n         \
    \   const neighbors = getNeighbors(cur, grid, visited);\n            for(let i\
    \ = 0; i < neighbors.length; i++){\n                queue.push(neighbors[i]);\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "    // Write your\
    \ code here\n    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    let minPath = new\
    \ Array(k);\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n\
    \    let minPathSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5\
    \ = Infinity;\n    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10\
    \ = Infinity;\n    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n\
    \    let minPathSum13 = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15\
    \ = Infinity;\n    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20\
    \ = Infinity;\n    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n\
    \    let minPathSum23 = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25\
    \ = Infinity;\n    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n\
    \    let minPathSum28 = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30\
    \ = Infinity;\n    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n\
    \    let minPathSum33 = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35\
    \ = Infinity;\n    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n\
    \    let minPathSum38 = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40\
    \ = Infinity;\n    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n\
    \    let minPathSum43 = Infinity;\n    let minPathSum44 = Infinity;\n    let minPathSum45\
    \ =", "  // your code here\n}\n", "  let n = grid.length;\n  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n\
    \  let minPath2 = [];\n  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n\
    \  let minPath3 = [];\n  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n\
    \  let minPath4 = [];\n  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n\
    \  let minPath5 = [];\n  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n\
    \  let minPath6 = [];\n  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n\
    \  let minPath7 = [];\n  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n\
    \  let minPath8 = [];\n  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n\
    \  let minPath9 = [];\n  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n\
    \  let minPath10 = [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n\
    \  let minPath11 = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n\
    \  let minPath12 = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n\
    \  let minPath13 = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n\
    \  let minPath14 = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n\
    \  let minPath15 = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n\
    \  let minPath16 = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n\
    \  let minPath17 = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity;\n\
    \  let minPath18 = [];\n  let minSum18 = Infinity;\n  let minPathSum19 = Infinity;\n\
    \  let minPath19 = [];\n ", "    let n = grid.length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let visited = new Set();\n    let visited2 = new Set();\n    let\
    \ queue = [];\n    let queue2 = [];\n    let start = [0, 0];\n    let start2 =\
    \ [n - 1, n - 1];\n    queue.push([start, [grid[0][0]], 0]);\n    queue2.push([start2,\
    \ [grid[n - 1][n - 1]], 0]);\n    while(queue.length > 0){\n        let [curr,\
    \ path, sum] = queue.shift();\n        let [curr2, path2, sum2] = queue2.shift();\n\
    \        if(sum > minPathSum || sum2 > minPathSum2){\n            continue;\n\
    \        }\n        if(sum === k){\n            if(sum < minPathSum){\n      \
    \          minPathSum = sum;\n                minPath = path;\n            }\n\
    \            continue;\n        }\n        if(sum2 === k){\n            if(sum2\
    \ < minPathSum2){\n                minPathSum2 = sum2;\n                minPath2\
    \ = path2;\n            }\n            continue;\n        }\n        let [i, j]\
    \ = curr;\n        let [i2, j2] = curr2;\n        if(i > 0 && !visited.has(`${i\
    \ - 1},${j}`)){\n            visited.add(`${i - 1},${j}`);\n            queue.push([[i\
    \ - 1, j], [...path, grid[i - 1][j]], sum + 1]);\n        }\n        if(i < n\
    \ - 1 && !visited.has(`${i + 1},${j}`)){\n            visited.add(`${i + 1},${j}`);\n\
    \            queue.push([[i + 1, j], [...path, grid[i + 1][j]], sum + 1]);\n \
    \       }\n        if(j > 0 && !visited.has(`${i},${j - 1}`)){\n", "    let n\
    \ = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n\
    \    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let minPath4\
    \ = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n   ", "\tvar n = grid.length;\n\tvar m =\
    \ grid[0].length;\n\tvar min = [];\n\tvar min_val = Infinity;\n\tvar visited =\
    \ [];\n\tfor(var i = 0; i < n; i++){\n\t\tvisited.push([]);\n\t\tfor(var j = 0;\
    \ j < m; j++){\n\t\t\tvisited[i].push(false);\n\t\t}\n\t}\n\tvar dfs = function(i,\
    \ j, k, curr){\n\t\tif(k === 0){\n\t\t\tvar val = curr.reduce(function(a, b){\n\
    \t\t\t\treturn a + b;\n\t\t\t});\n\t\t\tif(val < min_val){\n\t\t\t\tmin_val =\
    \ val;\n\t\t\t\tmin = curr;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(i < 0 || i\
    \ >= n || j < 0 || j >= m || visited[i][j]){\n\t\t\treturn;\n\t\t}\n\t\tvisited[i][j]\
    \ = true;\n\t\tcurr.push(grid[i][j]);\n\t\tdfs(i - 1, j, k - 1, curr);\n\t\tdfs(i\
    \ + 1, j, k - 1, curr);\n\t\tdfs(i, j - 1, k - 1, curr);\n\t\tdfs(i, j + 1, k\
    \ - 1, curr);\n\t\tcurr.pop();\n\t\tvisited[i][j] = false;\n\t};\n\tfor(var i\
    \ = 0; i < n; i++){\n\t\tfor(var j = 0; j < m; j++){\n\t\t\tdfs(i, j, k, []);\n\
    \t\t}\n\t}\n\treturn min;\n}\n", "    let n = grid.length;\n    let visited =\
    \ new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i] = new Array(n).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < n; j++){\n            let currPath\
    \ = [];\n            let currSum = 0;\n            dfs(i, j, k, currPath, currSum);\n\
    \        }\n    }\n    return minPath;\n\n    function dfs(i, j, k, currPath,\
    \ currSum){\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n\
    \            return;\n        }\n        if(currPath.length === k){\n        \
    \    if(currSum < minSum){\n                minSum = currSum;\n              \
    \  minPath = currPath.slice();\n            }\n            return;\n        }\n\
    \        visited[i][j] = true;\n        currPath.push(grid[i][j]);\n        currSum\
    \ += grid[i][j];\n        dfs(i + 1, j, k, currPath, currSum);\n        dfs(i\
    \ - 1, j, k, currPath, currSum);\n        dfs(i, j + 1, k, currPath, currSum);\n\
    \        dfs(i, j - 1, k, currPath, currSum);\n        visited[i][j] = false;\n\
    \        currPath.pop();\n        currSum -= grid[i][j];\n    }\n}\n", "    //\
    \ Write your code here\n    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(0));\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let dfs = (i, j, path, sum) => {\n        if (i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j] || sum > minSum) {\n            return;\n        }\n\
    \        visited[i][j] = 1;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        if (path.length === k) {\n            if (sum < minPathSum) {\n     \
    \           minPathSum = sum;\n                minPath = path.slice();\n     \
    \       } else if (sum === minPathSum) {\n                if (path.join('') <\
    \ minPath.join('')) {\n                    minPath = path.slice();\n         \
    \       }\n            }\n        } else {\n            dfs(i + 1, j, path, sum);\n\
    \            dfs(i - 1, j, path, sum);\n            dfs(i, j + 1, path, sum);\n\
    \            dfs(i, j - 1, path, sum);\n        }\n        path.pop();\n     \
    \   visited[i][j] = 0;\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n            minSum\
    \ = minPathSum;\n        }\n    }\n    return minPath;\n}\n", "    // Write your\
    \ code here\n    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let visited = new Set();\n    let dirs\
    \ = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs = (i, j, path, sum) => {\n\
    \        if (sum > minSum) return;\n        if (path.length === k) {\n       \
    \     if (sum < minSum) {\n                minSum = sum;\n                minPath\
    \ = path;\n            }\n            return;\n        }\n        for (let dir\
    \ of dirs) {\n            let x = i + dir[0];\n            let y = j + dir[1];\n\
    \            if (x < 0 || x >= n || y < 0 || y >= m || visited.has(x + ',' + y))\
    \ continue;\n            visited.add(x + ',' + y);\n            dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n            visited.delete(x + ',' + y);\n        }\n  \
    \  }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n\
    \            visited.add(i + ',' + j);\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n\
    \            visited.delete(i + ',' + j);\n        }\n    }\n    return minPath;\n\
    }\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let visited = new\
    \ Array(n).fill(0).map(() => new Array(m).fill(false));\n  let min = [];\n  let\
    \ minSum = Infinity;\n  let minPath = [];\n  let dfs = function(i, j, sum, path)\
    \ {\n    if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n      return;\n\
    \    }\n    if (path.length === k) {\n      if (sum < minSum) {\n        minSum\
    \ = sum;\n        minPath = path;\n      }\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i + 1,\
    \ j, sum, path);\n    dfs(i - 1, j, sum, path);\n    dfs(i, j + 1, sum, path);\n\
    \    dfs(i, j - 1, sum, path);\n    path.pop();\n    visited[i][j] = false;\n\
    \  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n   \
    \   dfs(i, j, 0, []);\n    }\n  }\n  return minPath;\n}\n", "    // Write your\
    \ code here\n    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathValue\
    \ = Infinity;\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs\
    \ = (i, j, path, pathSum, pathValue) => {\n        if (path.length > k) {\n  \
    \          return;\n        }\n        if (path.length === k) {\n            if\
    \ (pathSum < minSum) {\n                minSum = pathSum;\n                minPath\
    \ = path;\n                minPathSum = pathSum;\n                minPathValue\
    \ = pathValue;\n            } else if (pathSum === minSum) {\n               \
    \ if (pathValue < minPathValue) {\n                    minPath = path;\n     \
    \               minPathSum = pathSum;\n                    minPathValue = pathValue;\n\
    \                }\n            }\n            return;\n        }\n        for\
    \ (let dir of dirs) {\n            let x = i + dir[0];\n            let y = j\
    \ + dir[1];\n            if (x < 0 || x >= n || y < 0 || y >= m || visited[x][y])\
    \ {\n                continue;\n            }\n            visited[x][y] = 1;\n\
    \            dfs(x, y, path.concat(grid[x][y]), pathSum + grid[x][y], pathValue\
    \ * 10 + grid[x][y]);\n            visited[x][y] = 0;\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   visited[i][j] = 1;\n            dfs(i, j, [grid[i][j]], grid[i][j], grid[i][j]);\n\
    \            visited[i][j] = 0;\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(() => new\
    \ Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let dfs = (i, j, path, sum) => {\n        if (i < 0 || i >= n || j < 0 ||\
    \ j >= n || visited[i][j]) return;\n        if (path.length === k) {\n       \
    \     if (sum < minSum) {\n                minSum = sum;\n                minPath\
    \ = path;\n            }\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        dfs(i + 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \        dfs(i - 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i,\
    \ j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i, j - 1, path.concat(grid[i][j]),\
    \ sum + grid[i][j]);\n        visited[i][j] = false;\n    }\n    for (let i =\
    \ 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n\
    \    let visited = new Set();\n    let dfs = function(i, j, path, length){\n \
    \       if(length > k) return;\n        if(length === k){\n            let curr\
    \ = path.slice();\n            if(curr < minPath){\n                minPath =\
    \ curr;\n            }\n            return;\n        }\n        let key = i +\
    \ ',' + j;\n        if(visited.has(key)) return;\n        visited.add(key);\n\
    \        path.push(grid[i][j]);\n        if(i > 0) dfs(i - 1, j, path, length\
    \ + 1);\n        if(i < n - 1) dfs(i + 1, j, path, length + 1);\n        if(j\
    \ > 0) dfs(i, j - 1, path, length + 1);\n        if(j < m - 1) dfs(i, j + 1, path,\
    \ length + 1);\n        path.pop();\n        visited.delete(key);\n    }\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let path = [];\n    let min\
    \ = [];\n    let minSum = Infinity;\n    let minPath = [];\n    let visited =\
    \ [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let\
    \ j = 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      path.push(grid[i][j]);\n            visited[i][j] = true;\n           \
    \ dfs(i, j, 1);\n            path.pop();\n            visited[i][j] = false;\n\
    \        }\n    }\n    return minPath;\n    function dfs(i, j, depth){\n     \
    \   if(depth === k){\n            let sum = 0;\n            for(let i = 0; i <\
    \ path.length; i++){\n                sum += path[i];\n            }\n       \
    \     if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ > 0 && !visited[i - 1][j]){\n            path.push(grid[i - 1][j]);\n      \
    \      visited[i - 1][j] = true;\n            dfs(i - 1, j, depth + 1);\n    \
    \        path.pop();\n            visited[i - 1][j] = false;\n        }\n    \
    \    if(i < n - 1 && !visited[i + 1][j]){\n            path.push(grid[i + 1][j]);\n\
    \            visited[i + 1][j] = true;\n            dfs(i + 1, j, depth + 1);\n\
    \            path.pop();\n            visited[i + 1][j] = false;\n        }\n\
    \        if(j > 0 && !visited[i][j - 1]){\n            path.push(grid[i][j - 1]);\n\
    \            visited[i][j - 1] = true;\n            d", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let\
    \ minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity",
  "  let n = grid.length;\n  let minPath = [];\n  let minSum = Infinity;\n  let visited\
    \ = new Set();\n  let dfs = function(row, col, path, sum){\n    if(sum > minSum){\n\
    \      return;\n    }\n    if(path.length === k){\n      if(sum < minSum){\n \
    \       minSum = sum;\n        minPath = path;\n      }\n      return;\n    }\n\
    \    if(row < 0 || row >= n || col < 0 || col >= n){\n      return;\n    }\n \
    \   if(visited.has(row + ',' + col)){\n      return;\n    }\n    visited.add(row\
    \ + ',' + col);\n    dfs(row + 1, col, path.concat(grid[row][col]), sum + grid[row][col]);\n\
    \    dfs(row - 1, col, path.concat(grid[row][col]), sum + grid[row][col]);\n \
    \   dfs(row, col + 1, path.concat(grid[row][col]), sum + grid[row][col]);\n  \
    \  dfs(row, col - 1, path.concat(grid[row][col]), sum + grid[row][col]);\n   \
    \ visited.delete(row + ',' + col);\n  }\n  for(let i = 0; i < n; i++){\n    for(let\
    \ j = 0; j < n; j++){\n      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n\
    }\n", "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let visited = new\
    \ Set();\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs = (i,\
    \ j, path, sum) => {\n        if (path.length === k) {\n            if (sum <\
    \ minSum) {\n                minSum = sum;\n                minPaths = [path];\n\
    \            } else if (sum === minSum) {\n                minPaths.push(path);\n\
    \            }\n            return;\n        }\n        for (let dir of dirs)\
    \ {\n            let x = i + dir[0];\n            let y = j + dir[1];\n      \
    \      if (x < 0 || x >= n || y < 0 || y >= n || visited.has(x * n + y)) continue;\n\
    \            visited.add(x * n + y);\n            dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n            visited.delete(x * n + y);\n        }\n    }\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          visited.add(i * n + j);\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n\
    \            visited.delete(i * n + j);\n        }\n    }\n    for (let path of\
    \ minPaths) {\n        let sum = path.reduce((a, b) => a + b);\n        if (sum\
    \ < minPathSum) {\n            minPathSum = sum;\n            minPath = path;\n\
    \        } else if (sum === minPathSum) {\n            for (let i = 0; i < path.length;\
    \ i++) {\n                if (path[i] < minPath[i]) {\n                    minPath\
    \ = path;\n                    break;\n                } else if (path[i] > minPath[i])\
    \ {\n                    break;\n                }\n            }", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n  \
    \  for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let\
    \ j = 0; j < m; j++){\n            dp[i][j] = new Array(k+1);\n            for(let\
    \ l = 0; l <= k; l++){\n                dp[i][j][l] = new Array(2);\n        \
    \        dp[i][j][l][0] = Number.MAX_SAFE_INTEGER;\n                dp[i][j][l][1]\
    \ = [];\n            }\n        }\n    }\n    for(let i = 0; i < n; i++){\n  \
    \      for(let j = 0; j < m; j++){\n            dp[i][j][1][0] = grid[i][j];\n\
    \            dp[i][j][1][1].push(grid[i][j]);\n        }\n    }\n    for(let l\
    \ = 2; l <= k; l++){\n        for(let i = 0; i < n; i++){\n            for(let\
    \ j = 0; j < m; j++){\n                if(i > 0){\n                    let tmp\
    \ = dp[i-1][j][l-1][0] + grid[i][j];\n                    if(tmp < dp[i][j][l][0]){\n\
    \                        dp[i][j][l][0] = tmp;\n                        dp[i][j][l][1]\
    \ = dp[i-1][j][l-1][1].slice();\n                        dp[i][j][l][1].push(grid[i][j]);\n\
    \                    }\n                    else if(tmp == dp[i][j][l][0]){\n\
    \                        let tmpArr = dp[i-1][j][l-1][1].slice();\n          \
    \              tmpArr.push(grid[i][j]);\n                        if(compare(tmpArr,\
    \ dp[i][j][l][1])){\n                            dp", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n\
    \    let min_path = [];\n    let min_path_sum = Infinity;\n    let visited = [];\n\
    \    for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let j\
    \ = 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n \
    \   function dfs(i, j, path, sum){\n        if(sum > min_sum){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum < min_sum){\n \
    \               min_sum = sum;\n                min = path;\n            }\n \
    \           else if(sum === min_sum){\n                if(path < min){\n     \
    \               min = path;\n                }\n            }\n            return;\n\
    \        }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        dfs(i\
    \ + 1, j, path.concat(grid[i][j]), sum + grid[i][j]);\n        dfs(i - 1, j, path.concat(grid[i][j]),\
    \ sum + grid[i][j]);\n        dfs(i, j + 1, path.concat(grid[i][j]), sum + grid[i][j]);\n\
    \        dfs(i, j - 1, path.concat(grid[i][j]), sum + grid[i][j]);\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return min;\n\
    }\n", "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPath3 = [];\n    let minPathSum3 = Infinity;\n    let minSum2\
    \ = Infinity;\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n   ", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n   \
    \         let sum = 0;\n            dfs(i, j, 0, path, sum);\n        }\n    }\n\
    \    return minPath;\n    function dfs(i, j, step, path, sum){\n        if(step\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }\n            return;\n   \
    \     }\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n  \
    \          return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i - 1, j, step + 1, path, sum);\n   \
    \     dfs(i + 1, j, step + 1, path, sum);\n        dfs(i, j - 1, step + 1, path,\
    \ sum);\n        dfs(i, j + 1, step + 1, path, sum);\n        path.pop();\n  \
    \      sum -= grid[i][j];\n        visited[i][j] = false;\n    }\n}\n", "    var\
    \ n = grid.length;\n    var m = grid[0].length;\n    var visited = new Array(n);\n\
    \    for(var i = 0; i < n; i++){\n        visited[i] = new Array(m);\n       \
    \ for(var j = 0; j < m; j++){\n            visited[i][j] = false;\n        }\n\
    \    }\n    var minPath = [];\n    var minSum = Number.MAX_VALUE;\n    for(var\
    \ i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n            var path\
    \ = [];\n            var sum = 0;\n            dfs(i, j, k, path, sum);\n    \
    \    }\n    }\n    return minPath;\n    function dfs(i, j, k, path, sum){\n  \
    \      if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n\
    \        }\n        if(k === 0){\n            if(sum < minSum){\n            \
    \    minSum = sum;\n                minPath = path.slice();\n            }\n \
    \           return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i - 1, j, k - 1, path, sum);\n      \
    \  dfs(i + 1, j, k - 1, path, sum);\n        dfs(i, j - 1, k - 1, path, sum);\n\
    \        dfs(i, j + 1, k - 1, path, sum);\n        visited[i][j] = false;\n  \
    \      path.pop();\n    }\n}\n", "  let n = grid.length;\n  let visited = new\
    \ Set();\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPathSum2 = Infinity;\n  let minPathSum3 = Infinity;\n  let minPathSum4\
    \ = Infinity;\n  let minPathSum5 = Infinity;\n  let minPathSum6 = Infinity;\n\
    \  let minPathSum7 = Infinity;\n  let minPathSum8 = Infinity;\n  let minPathSum9\
    \ = Infinity;\n  let minPathSum10 = Infinity;\n  let minPathSum11 = Infinity;\n\
    \  let minPathSum12 = Infinity;\n  let minPathSum13 = Infinity;\n  let minPathSum14\
    \ = Infinity;\n  let minPathSum15 = Infinity;\n  let minPathSum16 = Infinity;\n\
    \  let minPathSum17 = Infinity;\n  let minPathSum18 = Infinity;\n  let minPathSum19\
    \ = Infinity;\n  let minPathSum20 = Infinity;\n  let minPathSum21 = Infinity;\n\
    \  let minPathSum22 = Infinity;\n  let minPathSum23 = Infinity;\n  let minPathSum24\
    \ = Infinity;\n  let minPathSum25 = Infinity;\n  let minPathSum26 = Infinity;\n\
    \  let minPathSum27 = Infinity;\n  let minPathSum28 = Infinity;\n  let minPathSum29\
    \ = Infinity;\n  let minPathSum30 = Infinity;\n  let minPathSum31 = Infinity;\n\
    \  let minPathSum32 = Infinity;\n  let minPathSum33 = Infinity;\n  let minPathSum34\
    \ = Infinity;\n  let minPathSum35 = Infinity;\n  let minPathSum36 = Infinity;\n\
    \  let minPathSum37 = Infinity;\n  let minPathSum38 = Infinity;\n  let minPathSum39\
    \ = Infinity;\n  let minPathSum40 = Infinity;\n  let minPathSum41 = Infinity;\n\
    \  let minPathSum42 = Infinity;\n  let minPathSum43 = Infinity;\n  let minPathSum44\
    \ = Infinity;\n  let minPathSum45 = Infinity;\n  let minPathSum46 = Infinity;\n\
    \  let minPathSum47 = Infinity;\n  let minPathSum48 = Infinity;\n", "    let n\
    \ = grid.length;\n    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n\
    \        visited[i] = new Array(n).fill(false);\n    }\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < n; j++){\n            let currPath = [];\n            let currSum\
    \ = 0;\n            dfs(grid, i, j, k, visited, currPath, currSum);\n        \
    \    if(currSum < minSum){\n                minSum = currSum;\n              \
    \  minPath = currPath;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    var n = grid.length;\n    var m = grid[0].length;\n    var minPath\
    \ = [];\n    var minPathSum = Infinity;\n    var minPathSumIndex = 0;\n    var\
    \ minPathSumIndex2 = 0;\n    var minPathSumIndex3 = 0;\n    var minPathSumIndex4\
    \ = 0;\n    var minPathSumIndex5 = 0;\n    var minPathSumIndex6 = 0;\n    var\
    \ minPathSumIndex7 = 0;\n    var minPathSumIndex8 = 0;\n    var minPathSumIndex9\
    \ = 0;\n    var minPathSumIndex10 = 0;\n    var minPathSumIndex11 = 0;\n    var\
    \ minPathSumIndex12 = 0;\n    var minPathSumIndex13 = 0;\n    var minPathSumIndex14\
    \ = 0;\n    var minPathSumIndex15 = 0;\n    var minPathSumIndex16 = 0;\n    var\
    \ minPathSumIndex17 = 0;\n    var minPathSumIndex18 = 0;\n    var minPathSumIndex19\
    \ = 0;\n    var minPathSumIndex20 = 0;\n    var minPathSumIndex21 = 0;\n    var\
    \ minPathSumIndex22 = 0;\n    var minPathSumIndex23 = 0;\n    var minPathSumIndex24\
    \ = 0;\n    var minPathSumIndex25 = 0;\n    var minPathSumIndex26 = 0;\n    var\
    \ minPathSumIndex27 = 0;\n    var minPathSumIndex28 = 0;\n    var minPathSumIndex29\
    \ = 0;\n    var minPathSumIndex30 = 0;\n    var minPathSumIndex31 = 0;\n    var\
    \ minPathSumIndex32 = 0;\n    var minPathSumIndex33 = 0;\n    var minPathSumIndex34\
    \ = 0;\n    var minPathSumIndex35 = 0;\n    var minPathSumIndex36 = 0;\n    var\
    \ minPathSumIndex37 = 0;\n    var minPathSumIndex38 = 0;\n    var minPathSumIndex39\
    \ = 0;\n    var minPathSumIndex40 = 0;\n    var minPathSumIndex41 = 0;\n    var\
    \ minPathSumIndex42 = 0;\n    var minPathSumIndex43 = 0;\n    var min", "  let\
    \ n = grid.length;\n  let visited = new Set();\n  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let minPathSum = Infinity;\n  let minPaths = [];\n  let minPathsSum\
    \ = [];\n  let minPathsVisited = [];\n  let minPathsVisitedSum = [];\n  let minPathsVisitedSumMap\
    \ = new Map();\n  let minPathsVisitedSumMap2 = new Map();\n  let minPathsVisitedSumMap3\
    \ = new Map();\n  let minPathsVisitedSumMap4 = new Map();\n  let minPathsVisitedSumMap5\
    \ = new Map();\n  let minPathsVisitedSumMap6 = new Map();\n  let minPathsVisitedSumMap7\
    \ = new Map();\n  let minPathsVisitedSumMap8 = new Map();\n  let minPathsVisitedSumMap9\
    \ = new Map();\n  let minPathsVisitedSumMap10 = new Map();\n  let minPathsVisitedSumMap11\
    \ = new Map();\n  let minPathsVisitedSumMap12 = new Map();\n  let minPathsVisitedSumMap13\
    \ = new Map();\n  let minPathsVisitedSumMap14 = new Map();\n  let minPathsVisitedSumMap15\
    \ = new Map();\n  let minPathsVisitedSumMap16 = new Map();\n  let minPathsVisitedSumMap17\
    \ = new Map();\n  let minPathsVisitedSumMap18 = new Map();\n  let minPathsVisitedSumMap19\
    \ = new Map();\n  let minPathsVisitedSumMap20 = new Map();\n  let minPathsVisitedSumMap21\
    \ = new Map();\n  let minPathsVisitedSumMap22 = new Map();\n  let minPathsVisitedSumMap23\
    \ = new Map();\n  let minPathsVisitedSumMap24 = new Map();\n  let minPathsVisitedSumMap25\
    \ = new Map();\n  let minPathsVisitedSumMap26 = new Map();\n  let minPathsVisitedSumMap27\
    \ = new Map();\n  let minPathsVisitedSumMap28 = new Map();\n  let minPathsVisitedSumMap29\
    \ = new Map", "    let n = grid.length;\n    let minPath = [];\n    let minSum\
    \ = Infinity;\n    let minPathSum = Infinity;\n    let visited = new Set();\n\
    \    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs = (i, j, path,\
    \ sum) => {\n        if (visited.has(i + '-' + j)) return;\n        if (path.length\
    \ === k) {\n            if (sum < minPathSum) {\n                minPathSum =\
    \ sum;\n                minPath = path;\n            }\n            return;\n\
    \        }\n        visited.add(i + '-' + j);\n        for (let dir of dirs) {\n\
    \            let x = i + dir[0];\n            let y = j + dir[1];\n          \
    \  if (x < 0 || x >= n || y < 0 || y >= n) continue;\n            dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n        }\n        visited.delete(i + '-' + j);\n    }\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          dfs(i, j, [grid[i][j]], grid[i][j]);\n        }\n    }\n    return\
    \ minPath;\n}\n", "    var n = grid.length;\n    var visited = new Array(n);\n\
    \    for(var i = 0; i < n; i++){\n        visited[i] = new Array(n);\n       \
    \ for(var j = 0; j < n; j++){\n            visited[i][j] = false;\n        }\n\
    \    }\n    var minPath = [];\n    var minSum = Infinity;\n    var minSumPath\
    \ = [];\n    var dfs = function(grid, i, j, path, sum){\n        if(i < 0 || i\
    \ >= n || j < 0 || j >= n || visited[i][j]){\n            return;\n        }\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        if(path.length === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minSumPath = path.slice();\n \
    \           }\n            else if(sum === minSum){\n                if(path.toString()\
    \ < minSumPath.toString()){\n                    minSumPath = path.slice();\n\
    \                }\n            }\n        }\n        else{\n            dfs(grid,\
    \ i + 1, j, path, sum);\n            dfs(grid, i - 1, j, path, sum);\n       \
    \     dfs(grid, i, j + 1, path, sum);\n            dfs(grid, i, j - 1, path, sum);\n\
    \        }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for(var\
    \ i = 0; i < n; i++){\n        for(var j = 0; j < n; j++){\n            dfs(grid,\
    \ i, j, [], 0);\n        }\n    }\n    return minSumPath;\n}\n", "    let n =\
    \ grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n\
    \    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n    let minPath4\
    \ = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n   ", "    let minPath = [];\n    let minSum\
    \ = Infinity;\n    let minPaths = [];\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            let path = [];\n\
    \            let sum = 0;\n            let paths = [];\n            findPath(grid,\
    \ i, j, k, path, sum, paths);\n            if(paths.length === 0) continue;\n\
    \            if(paths[0].sum < minSum){\n                minSum = paths[0].sum;\n\
    \                minPath = paths[0].path;\n                minPaths = paths;\n\
    \            }\n            else if(paths[0].sum === minSum){\n              \
    \  if(paths[0].path < minPath){\n                    minPath = paths[0].path;\n\
    \                    minPaths = paths;\n                }\n            }\n   \
    \     }\n    }\n    return minPaths;\n}\n", "  const n = grid.length;\n  const\
    \ m = grid[0].length;\n  const visited = new Set();\n  const queue = [];\n  const\
    \ paths = [];\n  const path = [];\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = Infinity;\n  let minPathsCount = Infinity;\n\
    \  let minPathsCountSum = Infinity;\n  let minPathsCountSumPaths = [];\n  let\
    \ minPathsCountSumPathsSum = Infinity;\n  let minPathsCountSumPathsSumPaths =\
    \ [];\n  let minPathsCountSumPathsSumPathsCount = Infinity;\n  let minPathsCountSumPathsSumPathsCountPaths\
    \ = [];\n  let minPathsCountSumPathsSumPathsCountPathsCount = Infinity;\n  let\
    \ minPathsCountSumPathsSumPathsCountPathsCountPaths = [];\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCount\
    \ = Infinity;\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPaths\
    \ = [];\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCount\
    \ = Infinity;\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPaths\
    \ = [];\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPathsCount\
    \ = Infinity;\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPathsCountPaths\
    \ = [];\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPathsCountPathsCount\
    \ = Infinity;\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPathsCountPathsCountPaths\
    \ = [];\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPathsCountPathsCountPathsCount\
    \ = Infinity;\n  let minPathsCountSumPathsSumPathsCountPathsCountPathsCountPathsCountPathsCountPathsCountPathsCountPaths\
    \ = [];", "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let\
    \ minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n   ", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i <\
    \ n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n   \
    \         let sum = 0;\n            dfs(i, j, 0, path, sum);\n        }\n    }\n\
    \    return minPath;\n\n    function dfs(i, j, steps, path, sum){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j] || steps > k){\n         \
    \   return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(steps === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            else if(sum === minSum){\n                if(path.slice().sort().join()\
    \ < minPath.slice().sort().join()){\n                    minPath = path.slice();\n\
    \                }\n            }\n        }\n        else{\n            dfs(i\
    \ + 1, j, steps + 1, path, sum);\n            dfs(i - 1, j, steps + 1, path, sum);\n\
    \            dfs(i, j + 1, steps + 1, path, sum);\n            dfs(i, j - 1, steps\
    \ + 1, path, sum);\n        }\n        visited[i][j] = false;\n        path.pop();\n\
    \    }\n}\n", "  var n = grid.length;\n  var minPath = [];\n  var minSum = Infinity;\n\
    \  var visited = [];\n  for(var i = 0; i < n; i++){\n    visited.push([]);\n \
    \   for(var j = 0; j < n; j++){\n      visited[i].push(false);\n    }\n  }\n \
    \ for(var i = 0; i < n; i++){\n    for(var j = 0; j < n; j++){\n      var path\
    \ = [];\n      var sum = 0;\n      dfs(i, j, k, path, sum);\n    }\n  }\n  return\
    \ minPath;\n  function dfs(i, j, k, path, sum){\n    if(i < 0 || i >= n || j <\
    \ 0 || j >= n || visited[i][j]) return;\n    path.push(grid[i][j]);\n    sum +=\
    \ grid[i][j];\n    visited[i][j] = true;\n    if(path.length === k){\n      if(sum\
    \ < minSum){\n        minSum = sum;\n        minPath = path.slice();\n      }\n\
    \      else if(sum === minSum){\n        if(path < minPath){\n          minPath\
    \ = path.slice();\n        }\n      }\n    }\n    else{\n      dfs(i + 1, j, k,\
    \ path, sum);\n      dfs(i - 1, j, k, path, sum);\n      dfs(i, j + 1, k, path,\
    \ sum);\n      dfs(i, j - 1, k, path, sum);\n    }\n    path.pop();\n    visited[i][j]\
    \ = false;\n  }\n}\n", "  let n = grid.length;\n  let visited = new Set();\n \
    \ let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPaths = [];\n  let minPathsSum = [];\n  let minPathsVisited = [];\n\
    \  let minPathsVisitedSum = [];\n  let minPathsVisitedSumSet = new Set();\n  let\
    \ minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet\
    \ = new Set();\n  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet\
    \ = new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n\
    \  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet = new Set();\n\
    \  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet\
    \ = new Set();\n  let minPathsVisitedSet = new Set();\n  let minPathsSet = new\
    \ Set();\n  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet = new\
    \ Set();\n  let minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n\
    \  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet = new Set();\n\
    \  let minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n  let\
    \ minPathsSumSet = new Set();\n  let minPathsVisitedSumSet = new Set();\n  let\
    \ minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet\
    \ = new Set();\n  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet\
    \ = new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n\
    \  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet = new Set();\n\
    \  let minPaths", "    // Write your code here\n    let n = grid.length;\n   \
    \ let m = grid[0].length;\n    let min = Number.MAX_SAFE_INTEGER;\n    let minPath\
    \ = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            let visited = new Set();\n          \
    \  dfs(grid, i, j, k, path, visited);\n            if(path.length < min){\n  \
    \              min = path.length;\n                minPath = path;\n         \
    \   }else if(path.length === min){\n                if(path < minPath){\n    \
    \                minPath = path;\n                }\n            }\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathSumIndex\
    \ = 0;\n    let minPathSumIndex2 = 0;\n    let minPathSumIndex3 = 0;\n    let\
    \ minPathSumIndex4 = 0;\n    let minPathSumIndex5 = 0;\n    let minPathSumIndex6\
    \ = 0;\n    let minPathSumIndex7 = 0;\n    let minPathSumIndex8 = 0;\n    let\
    \ minPathSumIndex9 = 0;\n    let minPathSumIndex10 = 0;\n    let minPathSumIndex11\
    \ = 0;\n    let minPathSumIndex12 = 0;\n    let minPathSumIndex13 = 0;\n    let\
    \ minPathSumIndex14 = 0;\n    let minPathSumIndex15 = 0;\n    let minPathSumIndex16\
    \ = 0;\n    let minPathSumIndex17 = 0;\n    let minPathSumIndex18 = 0;\n    let\
    \ minPathSumIndex19 = 0;\n    let minPathSumIndex20 = 0;\n    let minPathSumIndex21\
    \ = 0;\n    let minPathSumIndex22 = 0;\n    let minPathSumIndex23 = 0;\n    let\
    \ minPathSumIndex24 = 0;\n    let minPathSumIndex25 = 0;\n    let minPathSumIndex26\
    \ = 0;\n    let minPathSumIndex27 = 0;\n    let minPathSumIndex28 = 0;\n    let\
    \ minPathSumIndex29 = 0;\n    let minPathSumIndex30 = 0;\n    let minPathSumIndex31\
    \ = 0;\n    let minPathSumIndex32 = 0;\n    let minPathSumIndex33 = 0;\n    let\
    \ minPathSumIndex34 = 0;\n    let minPathSumIndex35 = 0;\n    let minPathSumIndex36\
    \ = 0;\n    let minPathSumIndex37 = 0;\n    let minPathSumIndex38 = 0;\n    let\
    \ minPathSumIndex39 = 0;\n    let minPathSumIndex40 = 0;\n    let minPathSumIndex41\
    \ = 0;\n    let minPathSumIndex42 = 0;\n    let minPathSumIndex43 = 0;\n    let\
    \ minPathSumIndex", "    let n = grid.length;\n    let m = grid[0].length;\n \
    \   let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let currPath = [];\n            let currSum = 0;\n            dfs(i,\
    \ j, k, grid, visited, currPath, currSum);\n            if(currSum < minSum){\n\
    \                minSum = currSum;\n                minPath = currPath;\n    \
    \        }\n        }\n    }\n    return minPath;\n}\n", "    let result = [];\n\
    \    let min = Infinity;\n    let path = [];\n    let visited = [];\n    for(let\
    \ i = 0; i < grid.length; i++){\n        visited.push([]);\n        for(let j\
    \ = 0; j < grid[0].length; j++){\n            visited[i].push(false);\n      \
    \  }\n    }\n    function dfs(i, j, k, path){\n        if(i < 0 || i >= grid.length\
    \ || j < 0 || j >= grid[0].length || visited[i][j]) return;\n        if(k ===\
    \ 0){\n            let sum = path.reduce((a, b) => a + b);\n            if(sum\
    \ < min){\n                min = sum;\n                result = path.slice();\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        path.push(grid[i][j]);\n        dfs(i + 1, j, k - 1, path);\n       \
    \ dfs(i - 1, j, k - 1, path);\n        dfs(i, j + 1, k - 1, path);\n        dfs(i,\
    \ j - 1, k - 1, path);\n        path.pop();\n        visited[i][j] = false;\n\
    \    }\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j <\
    \ grid[0].length; j++){\n            dfs(i, j, k, path);\n        }\n    }\n \
    \   return result;\n}\n", "    let n = grid.length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(n).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < n; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, 0, k, grid, visited, path, sum);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "  let n = grid.length;\n  let visited = [];\n  for(let i = 0; i < n; i++){\n  \
    \  visited.push([]);\n    for(let j = 0; j < n; j++){\n      visited[i].push(false);\n\
    \    }\n  }\n  let min = [];\n  for(let i = 0; i < n; i++){\n    for(let j = 0;\
    \ j < n; j++){\n      let path = [];\n      let res = dfs(grid, i, j, k, visited,\
    \ path);\n      if(res.length > 0){\n        if(min.length === 0){\n         \
    \ min = res;\n        }else{\n          for(let i = 0; i < res.length; i++){\n\
    \            if(res[i] < min[i]){\n              min = res;\n              break;\n\
    \            }else if(res[i] > min[i]){\n              break;\n            }\n\
    \          }\n        }\n      }\n    }\n  }\n  return min;\n}\n", "    // Write\
    \ your code here\n    let n = grid.length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let dfs = (i, j, path, sum) => {\n        if (i < 0 || i >= n || j\
    \ < 0 || j >= n || visited[i][j] || path.length > k) {\n            return;\n\
    \        }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n     \
    \   visited[i][j] = true;\n        if (path.length === k) {\n            if (sum\
    \ < minSum) {\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            if (sum === minSum) {\n                minPaths.push(path.slice());\n\
    \                minPathsSum.push(sum);\n            }\n        }\n        dfs(i\
    \ - 1, j, path, sum);\n        dfs(i + 1, j, path, sum);\n        dfs(i, j - 1,\
    \ path, sum);\n        dfs(i, j + 1, path, sum);\n        path.pop();\n      \
    \  visited[i][j] = false;\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < n; j++) {\n            dfs(i, j, [], 0);\n        }\n    }\n\
    \    let minPathIndex = 0;\n    for (let i = 0; i < minPaths.length; i++) {\n\
    \        if (minPaths[i] < minPaths[minPathIndex]) {\n            minPathIndex\
    \ = i;\n        }\n    }\n    return minPaths[minPathIndex];\n}\n", "    let n\
    \ = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n    let\
    \ minSum = Infinity;\n    let minPathSum = Infinity;\n    let minPathSumIndex\
    \ = 0;\n    let minPathSumIndex2 = 0;\n    let minPathSumIndex3 = 0;\n    let\
    \ minPathSumIndex4 = 0;\n    let minPathSumIndex5 = 0;\n    let minPathSumIndex6\
    \ = 0;\n    let minPathSumIndex7 = 0;\n    let minPathSumIndex8 = 0;\n    let\
    \ minPathSumIndex9 = 0;\n    let minPathSumIndex10 = 0;\n    let minPathSumIndex11\
    \ = 0;\n    let minPathSumIndex12 = 0;\n    let minPathSumIndex13 = 0;\n    let\
    \ minPathSumIndex14 = 0;\n    let minPathSumIndex15 = 0;\n    let minPathSumIndex16\
    \ = 0;\n    let minPathSumIndex17 = 0;\n    let minPathSumIndex18 = 0;\n    let\
    \ minPathSumIndex19 = 0;\n    let minPathSumIndex20 = 0;\n    let minPathSumIndex21\
    \ = 0;\n    let minPathSumIndex22 = 0;\n    let minPathSumIndex23 = 0;\n    let\
    \ minPathSumIndex24 = 0;\n    let minPathSumIndex25 = 0;\n    let minPathSumIndex26\
    \ = 0;\n    let minPathSumIndex27 = 0;\n    let minPathSumIndex28 = 0;\n    let\
    \ minPathSumIndex29 = 0;\n    let minPathSumIndex30 = 0;\n    let minPathSumIndex31\
    \ = 0;\n    let minPathSumIndex32 = 0;\n    let minPathSumIndex33 = 0;\n    let\
    \ minPathSumIndex34 = 0;\n    let minPathSumIndex35 = 0;\n    let minPathSumIndex36\
    \ = 0;\n    let minPathSumIndex37 = 0;\n    let minPathSumIndex38 = 0;\n    let\
    \ minPathSumIndex39 = 0;\n    let minPathSumIndex40 = 0;\n    let minPathSumIndex41\
    \ = 0;\n    let minPathSumIndex42 = 0;\n    let minPathSumIndex", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i\
    \ < n; i++){\n    visited[i] = new Array(m).fill(false);\n  }\n  let minPath =\
    \ [];\n  let minSum = Number.MAX_SAFE_INTEGER;\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n \
    \     dfs(grid, i, j, k, path, sum, visited);\n      if(sum < minSum){\n     \
    \   minSum = sum;\n        minPath = path;\n      }\n    }\n  }\n  return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n    let dfs\
    \ = function(i, j, path, sum, pathSum){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j] || path.length > k){\n            return;\n        }\n\
    \        if(path.length === k){\n            if(sum < minSum){\n             \
    \   minSum = sum;\n                minPath = path;\n                minPathSum\
    \ = pathSum;\n            }else if(sum === minSum && pathSum < minPathSum){\n\
    \                minPath = path;\n                minPathSum = pathSum;\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        pathSum +=\
    \ grid[i][j] * path.length;\n        dfs(i + 1, j, path, sum, pathSum);\n    \
    \    dfs(i - 1, j, path, sum, pathSum);\n        dfs(i, j + 1, path, sum, pathSum);\n\
    \        dfs(i, j - 1, path, sum, pathSum);\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dfs(i, j, [], 0, 0);\n        }\n    }\n    return minPath;\n\
    }\n\ngrid = [[1,2,3],[4,5,6],[7,8,9]];\nk = 5;", "    let n = grid.length;\n \
    \   let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let currPath = [];\n            let currSum = 0;\n            dfs(grid,\
    \ i, j, k, visited, currPath, currSum);\n            if(currSum < minSum){\n \
    \               minSum = currSum;\n                minPath = currPath;\n     \
    \       }\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, 0,\
    \ k, path, sum);\n            visited[i][j] = false;\n        }\n    }\n    return\
    \ minPath;\n\n    function dfs(i, j, count, k, path, sum){\n        if(count ===\
    \ k){\n            if(sum < minSum){\n                minSum = sum;\n        \
    \        minPath = path.slice();\n            }\n            return;\n       \
    \ }\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n      \
    \      return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, count + 1, k, path, sum);\n\
    \        dfs(i - 1, j, count + 1, k, path, sum);\n        dfs(i, j + 1, count\
    \ + 1, k, path, sum);\n        dfs(i, j - 1, count + 1, k, path, sum);\n     \
    \   path.pop();\n        sum -= grid[i][j];\n        visited[i][j] = false;\n\
    \    }\n}\n", "    let n = grid.length;\n    let minPath = [];\n    let minSum\
    \ = Infinity;\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n\
    \    let minPath2 = [];\n    let minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n\
    \    let minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n   ", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n\
    \        dp[i] = new Array(m);\n        for(let j = 0; j < m; j++){\n        \
    \    dp[i][j] = new Array(k + 1);\n            for(let l = 0; l <= k; l++){\n\
    \                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0] =\
    \ Infinity;\n                dp[i][j][l][1] = [];\n            }\n        }\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1] = [grid[i][j]];\n\
    \        }\n    }\n    for(let l = 2; l <= k; l++){\n        for(let i = 0; i\
    \ < n; i++){\n            for(let j = 0; j < m; j++){\n                if(i >\
    \ 0){\n                    let newVal = dp[i - 1][j][l - 1][0] + grid[i][j];\n\
    \                    if(newVal < dp[i][j][l][0]){\n                        dp[i][j][l][0]\
    \ = newVal;\n                        dp[i][j][l][1] = dp[i - 1][j][l - 1][1].concat(grid[i][j]);\n\
    \                    }\n                }\n                if(j > 0){\n      \
    \              let newVal = dp[i][j - 1][l - 1][0] + grid[i][j];\n           \
    \         if(newVal < dp[i][j][l][0]){\n                        dp[i][j][l][0]\
    \ = newVal;\n                        dp[i][j][l][1] = dp[i][j - 1][l - 1][1].con",
  "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n \
    \   let minPathSum = Infinity;\n    let visited = new Set();\n    let dirs = [[1,\
    \ 0], [-1, 0], [0, 1], [0, -1]];\n    let dfs = (i, j, path, sum) => {\n     \
    \   if (sum > minSum) return;\n        if (path.length === k) {\n            if\
    \ (sum < minPathSum) {\n                minPathSum = sum;\n                minPath\
    \ = path;\n            }\n            return;\n        }\n        for (let dir\
    \ of dirs) {\n            let x = i + dir[0];\n            let y = j + dir[1];\n\
    \            if (x < 0 || x >= n || y < 0 || y >= n || visited.has(x * n + y))\
    \ continue;\n            visited.add(x * n + y);\n            dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n            visited.delete(x * n + y);\n        }\n    }\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n  \
    \          visited.add(i * n + j);\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n\
    \            visited.delete(i * n + j);\n        }\n    }\n    return minPath;\n\
    }\n", "  var min = [];\n  var minSum = Infinity;\n  var minPath = [];\n  var minPathSum\
    \ = Infinity;\n  var minPathLength = Infinity;\n  var minPathIndex = Infinity;\n\
    \  var minPathIndexSum = Infinity;\n  var minPathIndexLength = Infinity;\n  var\
    \ minPathIndexIndex = Infinity;\n  var minPathIndexIndexSum = Infinity;\n  var\
    \ minPathIndexIndexLength = Infinity;\n  var minPathIndexIndexIndex = Infinity;\n\
    \  var minPathIndexIndexIndexSum = Infinity;\n  var minPathIndexIndexIndexLength\
    \ = Infinity;\n  var minPathIndexIndexIndexIndex = Infinity;\n  var minPathIndexIndexIndexIndexSum\
    \ = Infinity;\n  var minPathIndexIndexIndexIndexLength = Infinity;\n  var minPathIndexIndexIndexIndexIndex\
    \ = Infinity;\n  var minPathIndexIndexIndexIndexIndexSum = Infinity;\n  var minPathIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndex = Infinity;\n  var\
    \ minPathIndexIndexIndexIndexIndexIndexSum = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndexIndex = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n \
    \ var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexLength = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexLength = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n\
    \  var minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n\
    \  var minPathIndexIndexIndexIndex", "    let n = grid.length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let visited = {};\n    let dfs = (row,\
    \ col, path, sum) => {\n        if (row < 0 || row >= n || col < 0 || col >= n\
    \ || visited[row + ',' + col]) return;\n        path.push(grid[row][col]);\n \
    \       sum += grid[row][col];\n        visited[row + ',' + col] = true;\n   \
    \     if (path.length === k) {\n            if (sum < minSum) {\n            \
    \    minSum = sum;\n                minPath = path.slice();\n            }\n \
    \           path.pop();\n            sum -= grid[row][col];\n            visited[row\
    \ + ',' + col] = false;\n            return;\n        }\n        dfs(row + 1,\
    \ col, path, sum);\n        dfs(row - 1, col, path, sum);\n        dfs(row, col\
    \ + 1, path, sum);\n        dfs(row, col - 1, path, sum);\n        path.pop();\n\
    \        sum -= grid[row][col];\n        visited[row + ',' + col] = false;\n \
    \   }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++)\
    \ {\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}",
  "    var n = grid.length;\n    var minPath = [];\n    var minSum = Infinity;\n \
    \   var minPathSum = Infinity;\n    var visited = [];\n    for(var i = 0; i <\
    \ n; i++){\n        visited.push([]);\n        for(var j = 0; j < n; j++){\n \
    \           visited[i].push(false);\n        }\n    }\n    var dfs = function(i,\
    \ j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(path.length === k){\n            if(sum\
    \ < minPathSum){\n                minPathSum = sum;\n                minPath =\
    \ path.slice();\n            }\n            else if(sum === minPathSum){\n   \
    \             for(var i = 0; i < path.length; i++){\n                    if(path[i]\
    \ < minPath[i]){\n                        minPath = path.slice();\n          \
    \              break;\n                    }\n                    else if(path[i]\
    \ > minPath[i]){\n                        break;\n                    }\n    \
    \            }\n            }\n        }\n        else{\n            dfs(i - 1,\
    \ j, path, sum);\n            dfs(i + 1, j, path, sum);\n            dfs(i, j\
    \ - 1, path, sum);\n            dfs(i, j + 1, path, sum);\n        }\n       \
    \ path.pop();\n        visited[i][j] = false;\n    }\n    for(var i = 0; i < n;\
    \ i++){\n        for(var j = 0; j < n; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let visited = [];\n    for(let\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(let j = 0; j < n;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n            else if(sum === minSum){\n    \
    \            if(path < minPath){\n                    minPath = path;\n      \
    \          }\n            }\n        }\n    }\n    return minPath;\n}\n", "  \
    \  let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            let path = [];\n            let sum = 0;\n\
    \            dfs(i, j, k, path, sum);\n        }\n    }\n    return minPath;\n\
    \    function dfs(i, j, k, path, sum){\n        if(k === 0){\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        if(i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n       \
    \ visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        dfs(i + 1, j, k - 1, path, sum);\n        dfs(i - 1, j, k - 1, path,\
    \ sum);\n        dfs(i, j + 1, k - 1, path, sum);\n        dfs(i, j - 1, k - 1,\
    \ path, sum);\n        visited[i][j] = false;\n        path.pop();\n    }\n}\n",
  "    let n = grid.length;\n    let min = [];\n    let minSum = Infinity;\n    let\
    \ minPath = [];\n    let visited = [];\n    for(let i = 0; i < n; i++){\n    \
    \    visited.push([]);\n        for(let j = 0; j < n; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ n; j++){\n            minPath = [];\n            minPath.push(grid[i][j]);\n\
    \            visited[i][j] = true;\n            dfs(grid, i, j, k, visited, minPath,\
    \ minSum, min);\n            visited[i][j] = false;\n        }\n    }\n    return\
    \ min;\n}\n", "    var n = grid.length;\n    var m = grid[0].length;\n    var\
    \ visited = new Array(n);\n    for(var i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m);\n        for(var j = 0; j < m; j++){\n            visited[i][j]\
    \ = false;\n        }\n    }\n    var minPath = [];\n    var minSum = Infinity;\n\
    \    for(var i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n      \
    \      var path = [];\n            var sum = 0;\n            dfs(i, j, k, path,\
    \ sum);\n            if(sum < minSum){\n                minSum = sum;\n      \
    \          minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let minPath\
    \ = [];\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n   \
    \ let minPath2 = [];\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n   \
    \ let dfs = function(i, j, path, pathSum){\n        if(i < 0 || i >= n || j <\
    \ 0 || j >= m || visited[i][j]){\n            return;\n        }\n        if(path.length\
    \ === k){\n            if(pathSum < minPathSum){\n                minPathSum =\
    \ pathSum;\n                minPath = path.slice();\n            }\n         \
    \   if(pathSum < minPathSum2){\n                minPathSum2 = pathSum;\n     \
    \           minPath2 = path.slice();\n            }\n            return;\n   \
    \     }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n     \
    \   pathSum += grid[i][j];\n        for(let dir of dirs){\n            dfs(i +\
    \ dir[0], j + dir[1], path, pathSum);\n        }\n        path.pop();\n      \
    \  pathSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPathSum === minPathSum2 ? minPath\
    \ : minPath2;\n}", "    let n = grid.length;\n    let minPath = [];\n    let minSum\
    \ = Infinity;\n    let minPathSum = Infinity;\n    let minPaths = [];\n    let\
    \ minPathsSum = [];\n    let minPathsSumIndex = [];\n    let minPathsSumIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndex = [];\n    let minPathsSumIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndex = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndex = [];\n    let\
    \ minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n    let minPathsSumIndexIndexIndexIndex", "  let n = grid.length;\n \
    \ let m = grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(false));\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 = [];\n\
    \  let minSum2 = Infinity;\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n\
    \  let minSum3 = Infinity;\n  let minPathSum4 = Infinity;\n  let minPath4 = [];\n\
    \  let minSum4 = Infinity;\n  let minPathSum5 = Infinity;\n  let minPath5 = [];\n\
    \  let minSum5 = Infinity;\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n\
    \  let minSum6 = Infinity;\n  let minPathSum7 = Infinity;\n  let minPath7 = [];\n\
    \  let minSum7 = Infinity;\n  let minPathSum8 = Infinity;\n  let minPath8 = [];\n\
    \  let minSum8 = Infinity;\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n\
    \  let minSum9 = Infinity;\n  let minPathSum10 = Infinity;\n  let minPath10 =\
    \ [];\n  let minSum10 = Infinity;\n  let minPathSum11 = Infinity;\n  let minPath11\
    \ = [];\n  let minSum11 = Infinity;\n  let minPathSum12 = Infinity;\n  let minPath12\
    \ = [];\n  let minSum12 = Infinity;\n  let minPathSum13 = Infinity;\n  let minPath13\
    \ = [];\n  let minSum13 = Infinity;\n  let minPathSum14 = Infinity;\n  let minPath14\
    \ = [];\n  let minSum14 = Infinity;\n  let minPathSum15 = Infinity;\n  let minPath15\
    \ = [];\n  let minSum15 = Infinity;\n  let minPathSum16 = Infinity;\n  let minPath16\
    \ = [];\n  let minSum16 = Infinity;\n  let minPathSum17 = Infinity;\n  let minPath17\
    \ = [];\n  let minSum17 = Infinity;\n  let minPathSum18 = Infinity", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let min = [];\n    let minSum = Infinity;\n\
    \    let minPath = [];\n    let dfs = function(i, j, sum, path){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]) return;\n        if(sum +\
    \ grid[i][j] > minSum) return;\n        if(path.length === k){\n            if(sum\
    \ + grid[i][j] < minSum){\n                minSum = sum + grid[i][j];\n      \
    \          min = path.slice();\n                min.push(grid[i][j]);\n      \
    \      }\n            else if(sum + grid[i][j] === minSum){\n                let\
    \ tmp = path.slice();\n                tmp.push(grid[i][j]);\n               \
    \ if(tmp.join('') < min.join('')){\n                    min = tmp;\n         \
    \       }\n            }\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        dfs(i + 1, j, sum + grid[i][j],\
    \ path);\n        dfs(i - 1, j, sum + grid[i][j], path);\n        dfs(i, j + 1,\
    \ sum + grid[i][j], path);\n        dfs(i, j - 1, sum + grid[i][j], path);\n \
    \       path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, 0,\
    \ []);\n        }\n    }\n    return min;\n}\n", "  let n = grid.length;\n  let\
    \ visited = new Set();\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum\
    \ = Infinity;\n  let minPaths = [];\n  let minPathsSum = [];\n  function dfs(i,\
    \ j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= n || visited.has(i +\
    \ ',' + j)) return;\n    visited.add(i + ',' + j);\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minSum){\n\
    \        minSum = sum;\n        minPath = path.slice();\n      }\n      else if(sum\
    \ === minSum){\n        if(path.join('') < minPath.join('')){\n          minPath\
    \ = path.slice();\n        }\n      }\n      visited.delete(i + ',' + j);\n  \
    \    path.pop();\n      return;\n    }\n    dfs(i + 1, j, path, sum);\n    dfs(i\
    \ - 1, j, path, sum);\n    dfs(i, j + 1, path, sum);\n    dfs(i, j - 1, path,\
    \ sum);\n    visited.delete(i + ',' + j);\n    path.pop();\n  }\n  for(let i =\
    \ 0; i < n; i++){\n    for(let j = 0; j < n; j++){\n      dfs(i, j, [], 0);\n\
    \    }\n  }\n  return minPath;\n}", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    let minPathsSum = [];\n    let dirs = [[-1, 0], [1,\
    \ 0], [0, -1], [0, 1]];\n    let dfs = function(i, j, path, sum){\n        if(sum\
    \ > minSum){\n            return;\n        }\n        if(path.length === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n                minPathSum = sum;\n                minPaths\
    \ = [path];\n                minPathsSum = [sum];\n            }\n           \
    \ else if(sum === minSum){\n                minPaths.push(path);\n           \
    \     minPathsSum.push(sum);\n            }\n            return;\n        }\n\
    \        for(let dir of dirs){\n            let x = i + dir[0];\n            let\
    \ y = j + dir[1];\n            if(x < 0 || x >= n || y < 0 || y >= m || visited[x][y]){\n\
    \                continue;\n            }\n            visited[x][y] = true;\n\
    \            dfs(x, y, path.concat(grid[x][y]), sum + grid[x][y]);\n         \
    \   visited[x][y] = false;\n        }\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            visited[i][j] = true;\n    \
    \        dfs(i, j, [grid[i][j]], grid[i][j]);\n            visited[i][j] = false;\n\
    \        }\n    }\n    let minPathsIndex = 0;\n    for(let i = 1; i < minPaths.length;\
    \ i++){\n        if(minPaths[i] < minPaths[minPathsIndex]){\n            min",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let min = [Infinity, []];\n    let dirs =\
    \ [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    function dfs(i, j, path, sum){\n  \
    \      if(sum >= min[0]) return;\n        if(path.length === k){\n           \
    \ if(sum < min[0]){\n                min[0] = sum;\n                min[1] = path;\n\
    \            }\n            return;\n        }\n        for(let dir of dirs){\n\
    \            let x = i + dir[0];\n            let y = j + dir[1];\n          \
    \  if(x < 0 || x >= n || y < 0 || y >= m || visited[x][y]) continue;\n       \
    \     visited[x][y] = true;\n            dfs(x, y, path.concat(grid[x][y]), sum\
    \ + grid[x][y]);\n            visited[x][y] = false;\n        }\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            visited[i][j]\
    \ = true;\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n            visited[i][j]\
    \ = false;\n        }\n    }\n    return min[1];\n}\n", "    let n = grid.length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    function dfs(i, j, path, sum, pathSum){\n       \
    \ if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum < minSum){\n  \
    \              minSum = sum;\n                minPath = path;\n              \
    \  minPathSum = pathSum;\n                minPaths = [path];\n            } else\
    \ if(sum === minSum){\n                if(pathSum < minPathSum){\n           \
    \         minPathSum = pathSum;\n                    minPath = path;\n       \
    \             minPaths = [path];\n                } else if(pathSum === minPathSum){\n\
    \                    minPaths.push(path);\n                }\n            }\n\
    \            return;\n        }\n        visited[i][j] = true;\n        dfs(i\
    \ + 1, j, path.concat(grid[i][j]), sum + grid[i][j], pathSum + (path.length +\
    \ 1) * grid[i][j]);\n        dfs(i - 1, j, path.concat(grid[i][j]), sum + grid[i][j],\
    \ pathSum + (path.length + 1) * grid[i][j]);\n        dfs(i, j + 1, path.concat(grid[i][j]),\
    \ sum + grid[i][j], pathSum + (path.length + 1) * grid[i][j]);\n        dfs(i,\
    \ j - 1, path.concat(grid[i][j]), sum + grid[i][j], pathSum + (path.length + 1)\
    \ * grid[i][j]);\n        visited[i][j] = false;\n    }\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i, j, [], 0,\
    \ 0", "  let n = grid.length;\n  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPathSum = Infinity;\n  let minPathSumPath = [];\n  let visited = new\
    \ Set();\n  let path = [];\n  let sum = 0;\n  let pathSum = 0;\n  let pathSumPath\
    \ = [];\n  let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  function dfs(i, j,\
    \ k){\n    if(k === 0){\n      if(sum < minSum){\n        minSum = sum;\n    \
    \    minPath = path.slice();\n      }\n      if(pathSum < minPathSum){\n     \
    \   minPathSum = pathSum;\n        minPathSumPath = pathSumPath.slice();\n   \
    \   }\n      return;\n    }\n    for(let dir of dirs){\n      let x = i + dir[0];\n\
    \      let y = j + dir[1];\n      if(x < 0 || x >= n || y < 0 || y >= n || visited.has(x\
    \ * n + y)){\n        continue;\n      }\n      visited.add(x * n + y);\n    \
    \  path.push(grid[x][y]);\n      sum += grid[x][y];\n      pathSumPath.push(grid[x][y]);\n\
    \      pathSum = pathSumPath.join('');\n      dfs(x, y, k - 1);\n      path.pop();\n\
    \      sum -= grid[x][y];\n      pathSumPath.pop();\n      pathSum = pathSumPath.join('');\n\
    \      visited.delete(x * n + y);\n    }\n  }\n  for(let i = 0; i < n; i++){\n\
    \    for(let j = 0; j < n; j++){\n      visited.add(i * n + j);\n      path.push(grid[i][y]);\n\
    \      sum += grid[i][y];\n      pathSumPath.push(grid[i][y]);\n      pathSum\
    \ = pathSumPath.join('');\n      dfs(i, j, k - 1);\n      path.pop();\n      sum",
  "  let n = grid.length;\n  let minPath = [];\n  let minSum = Infinity;\n  let minPaths\
    \ = [];\n  let minPathsSum = [];\n  let minPathsSumIndex = [];\n  let minPathsSumIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndex = [];\n  let minPathsSumIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndex = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndex = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndex = [];\n\
    \  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = [];\n \
    \ let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = [];\n\
    \  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = [];\n  let minPathsSumIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex",
  "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(() => new\
    \ Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let path = [];\n\
    \    let sum = 0;\n    let paths = [];\n    let dfs = function(row, col, k){\n\
    \        if(k === 0){\n            if(sum < minSum){\n                minSum =\
    \ sum;\n                minPaths = paths.slice();\n            }\n           \
    \ return;\n        }\n        if(sum > minSum) return;\n        if(row < 0 ||\
    \ row >= n || col < 0 || col >= n) return;\n        if(visited[row][col]) return;\n\
    \        visited[row][col] = true;\n        sum += grid[row][col];\n        path.push(grid[row][col]);\n\
    \        paths.push(path.slice());\n        dfs(row + 1, col, k - 1);\n      \
    \  dfs(row - 1, col, k - 1);\n        dfs(row, col + 1, k - 1);\n        dfs(row,\
    \ col - 1, k - 1);\n        visited[row][col] = false;\n        sum -= grid[row][col];\n\
    \        path.pop();\n        paths.pop();\n    }\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            dfs(i, j, k);\n        }\n \
    \   }\n    for(let i = 0; i < minPaths.length; i++){\n        if(minPaths[i].reduce((a,\
    \ b) => a + b) < minPathSum){\n            minPathSum = minPaths[i].reduce((a,\
    \ b) => a + b);\n            minPath = minPaths[i];\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let min = Infinity;\n    let minPath = [];\n    let visited = new Set();\n \
    \   let dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0\
    \ || j >= m || visited.has(i + ',' + j)){\n            return;\n        }\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        visited.add(i\
    \ + ',' + j);\n        if(path.length === k){\n            if(sum < min){\n  \
    \              min = sum;\n                minPath = path.slice();\n         \
    \   }\n            visited.delete(i + ',' + j);\n            path.pop();\n   \
    \         return;\n        }\n        dfs(i + 1, j, path, sum);\n        dfs(i\
    \ - 1, j, path, sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1,\
    \ path, sum);\n        visited.delete(i + ',' + j);\n        path.pop();\n   \
    \ }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n  \
    \          dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", " \
    \ let n = grid.length;\n  let minPath = [];\n  let minSum = Infinity;\n  let minSumPath\
    \ = [];\n  let visited = new Set();\n  let dfs = function(i, j, path, sum){\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minSumPath = path;\n      }\n      return;\n    }\n    if(i < 0 || i\
    \ >= n || j < 0 || j >= n || visited.has(`${i},${j}`)){\n      return;\n    }\n\
    \    visited.add(`${i},${j}`);\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n\
    \    dfs(i - 1, j, path, sum);\n    dfs(i + 1, j, path, sum);\n    dfs(i, j -\
    \ 1, path, sum);\n    dfs(i, j + 1, path, sum);\n    path.pop();\n    visited.delete(`${i},${j}`);\n\
    \  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < n; j++){\n      dfs(i,\
    \ j, [], 0);\n    }\n  }\n  return minSumPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            dfs(i, j, k, path, sum);\n        }\n    }\n    return\
    \ minPath;\n    function dfs(i, j, k, path, sum){\n        if(k === 0){\n    \
    \        if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  visited[i][j] = true;\n        dfs(i + 1, j, k - 1, path, sum);\n        dfs(i\
    \ - 1, j, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n     \
    \   dfs(i, j - 1, k - 1, path, sum);\n        visited[i][j] = false;\n       \
    \ path.pop();\n    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minPathValue = Infinity;\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let pathValue = 0;\n            let visited = new Set();\n      \
    \      visited.add(i + ',' + j);\n            path.push(grid[i][j]);\n       \
    \     pathValue += grid[i][j];\n            dfs(i, j, 1);\n        }\n    }\n\
    \    return minPath;\n    function dfs(i, j, depth){\n        if(depth === k){\n\
    \            if(pathValue < minPathValue){\n                minPathValue = pathValue;\n\
    \                minPath = path.slice();\n            }\n            return;\n\
    \        }\n        if(i > 0 && !visited.has((i - 1) + ',' + j)){\n          \
    \  visited.add((i - 1) + ',' + j);\n            path.push(grid[i - 1][j]);\n \
    \           pathValue += grid[i - 1][j];\n            dfs(i - 1, j, depth + 1);\n\
    \            path.pop();\n            pathValue -= grid[i - 1][j];\n         \
    \   visited.delete((i - 1) + ',' + j);\n        }\n        if(i < n - 1 && !visited.has((i\
    \ + 1) + ',' + j)){\n            visited.add((i + 1) + ',' + j);\n           \
    \ path.push(grid[i + 1][j]);\n            pathValue += grid[i + 1][j];\n     \
    \       dfs(i + 1, j, depth + 1);\n            path.pop();\n            pathValue\
    \ -= grid[i + 1][j];\n            visited.delete((i + 1) + ',' + j);\n       \
    \ }\n        if(j > 0 && !visited.has(i + ',' + (j - 1))){\n            visited.add(i\
    \ + ',' + (j - 1));\n            path.push(grid[i][j - 1]);\n            pathValue\
    \ +=", "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPathSum3\
    \ = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPathSum13\
    \ = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15 = Infinity;\n\
    \    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let minPathSum18\
    \ = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20 = Infinity;\n\
    \    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n    let minPathSum23\
    \ = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25 = Infinity;\n\
    \    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n    let minPathSum28\
    \ = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30 = Infinity;\n\
    \    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n    let minPathSum33\
    \ = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35 = Infinity;\n\
    \    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n    let minPathSum38\
    \ = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40 = Infinity;\n\
    \    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n    let minPathSum43\
    \ = Infinity;\n    let minPathSum44 = Infinity;\n    let minPathSum45 = Infinity;\n\
    \    let minPathSum46 = Infinity;\n    let minPathSum47 = Infinity;\n    let minPathSum48\
    \ = Infinity;\n    let minPathSum49 = Infinity", "  let n = grid.length;\n  let\
    \ minPath = [];\n  let minSum = Infinity;\n  let minSumPath = [];\n  let visited\
    \ = [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n    for(let j =\
    \ 0; j < n; j++){\n      visited[i].push(false);\n    }\n  }\n  for(let i = 0;\
    \ i < n; i++){\n    for(let j = 0; j < n; j++){\n      minPath = [];\n      minSum\
    \ = Infinity;\n      minSumPath = [];\n      for(let i = 0; i < n; i++){\n   \
    \     for(let j = 0; j < n; j++){\n          visited[i][j] = false;\n        }\n\
    \      }\n      dfs(grid, i, j, k, 0, 0, minPath, minSum, minSumPath, visited);\n\
    \      if(minSumPath.length > 0){\n        return minSumPath;\n      }\n    }\n\
    \  }\n  return minSumPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ path, sum);\n        }\n    }\n    return minPath;\n    function dfs(i, j, k,\
    \ path, sum){\n        if(k == 0){\n            if(sum < minSum){\n          \
    \      minSum = sum;\n                minPath = path.slice();\n            }\n\
    \            return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= m\
    \ || visited[i][j]){\n            return;\n        }\n        visited[i][j] =\
    \ true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i\
    \ - 1, j, k - 1, path, sum);\n        dfs(i + 1, j, k - 1, path, sum);\n     \
    \   dfs(i, j - 1, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n\
    \        visited[i][j] = false;\n        path.pop();\n    }\n}\n", "  let minPath\
    \ = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2\
    \ = Infinity;\n  let minPath2 = [];\n  let minSum2 = Infinity;\n  let minPathSum3\
    \ = Infinity;\n  let minPath3 = [];\n  let minSum3 = Infinity;\n  let minPathSum4\
    \ = Infinity;\n  let minPath4 = [];\n  let minSum4 = Infinity;\n  let minPathSum5\
    \ = Infinity;\n  let minPath5 = [];\n  let minSum5 = Infinity;\n  let minPathSum6\
    \ = Infinity;\n  let minPath6 = [];\n  let minSum6 = Infinity;\n  let minPathSum7\
    \ = Infinity;\n  let minPath7 = [];\n  let minSum7 = Infinity;\n  let minPathSum8\
    \ = Infinity;\n  let minPath8 = [];\n  let minSum8 = Infinity;\n  let minPathSum9\
    \ = Infinity;\n  let minPath9 = [];\n  let minSum9 = Infinity;\n  let minPathSum10\
    \ = Infinity;\n  let minPath10 = [];\n  let minSum10 = Infinity;\n  let minPathSum11\
    \ = Infinity;\n  let minPath11 = [];\n  let minSum11 = Infinity;\n  let minPathSum12\
    \ = Infinity;\n  let minPath12 = [];\n  let minSum12 = Infinity;\n  let minPathSum13\
    \ = Infinity;\n  let minPath13 = [];\n  let minSum13 = Infinity;\n  let minPathSum14\
    \ = Infinity;\n  let minPath14 = [];\n  let minSum14 = Infinity;\n  let minPathSum15\
    \ = Infinity;\n  let minPath15 = [];\n  let minSum15 = Infinity;\n  let minPathSum16\
    \ = Infinity;\n  let minPath16 = [];\n  let minSum16 = Infinity;\n  let minPathSum17\
    \ = Infinity;\n  let minPath17 = [];\n  let minSum17 = Infinity;\n  let minPathSum18\
    \ = Infinity;\n  let minPath18 = [];\n  let minSum18 = Infinity;\n  let minPathSum19\
    \ = Infinity;\n  let minPath19 = [];\n  let minSum19 = Infinity;\n ", "    let\
    \ n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n    let\
    \ minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPathSum3\
    \ = Infinity;\n    let minPathSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPathSum7 = Infinity;\n    let minPathSum8\
    \ = Infinity;\n    let minPathSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPathSum13\
    \ = Infinity;\n    let minPathSum14 = Infinity;\n    let minPathSum15 = Infinity;\n\
    \    let minPathSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let minPathSum18\
    \ = Infinity;\n    let minPathSum19 = Infinity;\n    let minPathSum20 = Infinity;\n\
    \    let minPathSum21 = Infinity;\n    let minPathSum22 = Infinity;\n    let minPathSum23\
    \ = Infinity;\n    let minPathSum24 = Infinity;\n    let minPathSum25 = Infinity;\n\
    \    let minPathSum26 = Infinity;\n    let minPathSum27 = Infinity;\n    let minPathSum28\
    \ = Infinity;\n    let minPathSum29 = Infinity;\n    let minPathSum30 = Infinity;\n\
    \    let minPathSum31 = Infinity;\n    let minPathSum32 = Infinity;\n    let minPathSum33\
    \ = Infinity;\n    let minPathSum34 = Infinity;\n    let minPathSum35 = Infinity;\n\
    \    let minPathSum36 = Infinity;\n    let minPathSum37 = Infinity;\n    let minPathSum38\
    \ = Infinity;\n    let minPathSum39 = Infinity;\n    let minPathSum40 = Infinity;\n\
    \    let minPathSum41 = Infinity;\n    let minPathSum42 = Infinity;\n    let minPathSum43\
    \ = Infinity;\n    let minPathSum44 = Infinity;\n    let minPathSum45 = Infinity;\n\
    \    let minPathSum46 = Infinity;\n    let minPathSum47 = Infinity;\n    let minPathSum48\
    \ = Infinity;\n    let minPathSum49 = Infinity", "    let n = grid.length;\n \
    \   let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let minPathsIndex = [];\n    let minPathsIndexSum = [];\n    let minPathsIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSum = [];\n    let minPathsIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSum = [];\n    let minPathsIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSum = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSum = [];\n    let\
    \ minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndex = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSum\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex\
    \ = [];\n    let minPathsIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndexSumIndex",
  "    let n = grid.length;\n    let visited = new Array(n).fill(0).map(() => new\
    \ Array(n).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    let minPathsSum =\
    \ [];\n    let minPathsSumMap = {};\n    let minPathsMap = {};\n    let minPathsMapSum\
    \ = {};\n    let minPathsMapSumMap = {};\n    let minPathsMapSumMapMap = {};\n\
    \    let minPathsMapSumMapMapMap = {};\n    let minPathsMapSumMapMapMapMap = {};\n\
    \    let minPathsMapSumMapMapMapMapMap = {};\n    let minPathsMapSumMapMapMapMapMapMap\
    \ = {};\n    let minPathsMapSumMapMapMapMapMapMapMap = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMap\
    \ = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMapMap = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMap = {};\n    let\
    \ minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMap = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n\
    \    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n \
    \   let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n\
    \    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap = {};\n\
    \    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n    let minPathsMapSumMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMapMap\
    \ = {};\n    let min", "  // your code here\n}\n", "    let n = grid.length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let visited = new Set();\n\
    \    let dfs = function(i, j, path, sum){\n        if(path.length === k){\n  \
    \          if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path;\n            }\n            return;\n        }\n        if(i < 0 ||\
    \ i >= n || j < 0 || j >= n || visited.has(i + ',' + j)){\n            return;\n\
    \        }\n        visited.add(i + ',' + j);\n        path.push(grid[i][j]);\n\
    \        dfs(i - 1, j, path, sum + grid[i][j]);\n        dfs(i + 1, j, path, sum\
    \ + grid[i][j]);\n        dfs(i, j - 1, path, sum + grid[i][j]);\n        dfs(i,\
    \ j + 1, path, sum + grid[i][j]);\n        path.pop();\n        visited.delete(i\
    \ + ',' + j);\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0;\
    \ j < n; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n\
    }\n", "    let n = grid.length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minSumPath = [];\n    let visited = [];\n    for(let i = 0; i < n; i++){\n\
    \        visited.push([]);\n        for(let j = 0; j < n; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    function dfs(i, j, path, sum){\n        if(i < 0 || i >=\
    \ n || j < 0 || j >= n || visited[i][j]){\n            return;\n        }\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        visited[i][j]\
    \ = true;\n        if(path.length === k){\n            if(sum < minSum){\n   \
    \             minSum = sum;\n                minSumPath = path.slice();\n    \
    \        }\n            else if(sum === minSum){\n                if(path.join('')\
    \ < minSumPath.join('')){\n                    minSumPath = path.slice();\n  \
    \              }\n            }\n        }\n        else{\n            dfs(i +\
    \ 1, j, path, sum);\n            dfs(i - 1, j, path, sum);\n            dfs(i,\
    \ j + 1, path, sum);\n            dfs(i, j - 1, path, sum);\n        }\n     \
    \   path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return minSumPath;\n}\n", "  let n = grid.length;\n  let\
    \ visited = new Set();\n  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum\
    \ = Infinity;\n  let minPathLength = Infinity;\n  let minPathVisited = new Set();\n\
    \  let minPathVisitedSum = Infinity;\n  let minPathVisitedLength = Infinity;\n\
    \  let minPathVisitedSumLength = Infinity;\n  let minPathVisitedSumLengthVisited\
    \ = new Set();\n  let minPathVisitedSumLengthVisitedSum = Infinity;\n  let minPathVisitedSumLengthVisitedLength\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLength = Infinity;\n  let\
    \ minPathVisitedSumLengthVisitedSumLengthVisited = new Set();\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSum\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisitedLength = Infinity;\n\
    \  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLength = Infinity;\n \
    \ let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisited = new Set();\n\
    \  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSum = Infinity;\n\
    \  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedLength =\
    \ Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLength\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisited\
    \ = new Set();\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSum\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedLength\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLength\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisited\
    \ = new Set();\n  let minPathVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSumLengthVisitedSum\
    \ = Infinity;\n  let minPathVisitedSumLengthVisitedSumLengthVisited", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minPathSum = Number.MAX_SAFE_INTEGER;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      let path = [];\n            let pathSum = 0;\n            dfs(i, j, k,\
    \ path, pathSum);\n        }\n    }\n    return minPath;\n\n    function dfs(i,\
    \ j, k, path, pathSum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]\
    \ || path.length > k){\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        pathSum += grid[i][j];\n        visited[i][j] = true;\n        if(path.length\
    \ === k){\n            if(pathSum < minPathSum){\n                minPathSum =\
    \ pathSum;\n                minPath = path.slice();\n            }\n         \
    \   else if(pathSum === minPathSum){\n                if(path.toString() < minPath.toString()){\n\
    \                    minPath = path.slice();\n                }\n            }\n\
    \        }\n        else{\n            dfs(i + 1, j, k, path, pathSum);\n    \
    \        dfs(i - 1, j, k, path, pathSum);\n            dfs(i, j + 1, k, path,\
    \ pathSum);\n            dfs(i, j - 1, k, path, pathSum);\n        }\n       \
    \ path.pop();\n        pathSum -= grid[i][j];\n        visited[i][j] = false;\n\
    \    }\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let\
    \ min = [];\n    let minSum = Infinity;\n    let minPath = [];\n    let dfs =\
    \ function(i, j, sum, path){\n        if(i < 0 || i >= n || j < 0 || j >= m ||\
    \ visited[i][j]) return;\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        if(path.length === k){\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path.slice();\n\
    \            }\n            else if(sum === minSum){\n                for(let\
    \ i = 0; i < k; i++){\n                    if(path[i] < minPath[i]){\n       \
    \                 minPath = path.slice();\n                        break;\n  \
    \                  }\n                    else if(path[i] > minPath[i]) break;\n\
    \                }\n            }\n        }\n        else{\n            dfs(i\
    \ - 1, j, sum, path);\n            dfs(i + 1, j, sum, path);\n            dfs(i,\
    \ j - 1, sum, path);\n            dfs(i, j + 1, sum, path);\n        }\n     \
    \   path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, 0, []);\n\
    \        }\n    }\n    return minPath;\n}\n", "  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let minPathSum = Infinity;\n  let minPathSumIndex = Infinity;\n\
    \  let minPathSumIndex2 = Infinity;\n  let minPathSumIndex3 = Infinity;\n  let\
    \ minPathSumIndex4 = Infinity;\n  let minPathSumIndex5 = Infinity;\n  let minPathSumIndex6\
    \ = Infinity;\n  let minPathSumIndex7 = Infinity;\n  let minPathSumIndex8 = Infinity;\n\
    \  let minPathSumIndex9 = Infinity;\n  let minPathSumIndex10 = Infinity;\n  let\
    \ minPathSumIndex11 = Infinity;\n  let minPathSumIndex12 = Infinity;\n  let minPathSumIndex13\
    \ = Infinity;\n  let minPathSumIndex14 = Infinity;\n  let minPathSumIndex15 =\
    \ Infinity;\n  let minPathSumIndex16 = Infinity;\n  let minPathSumIndex17 = Infinity;\n\
    \  let minPathSumIndex18 = Infinity;\n  let minPathSumIndex19 = Infinity;\n  let\
    \ minPathSumIndex20 = Infinity;\n  let minPathSumIndex21 = Infinity;\n  let minPathSumIndex22\
    \ = Infinity;\n  let minPathSumIndex23 = Infinity;\n  let minPathSumIndex24 =\
    \ Infinity;\n  let minPathSumIndex25 = Infinity;\n  let minPathSumIndex26 = Infinity;\n\
    \  let minPathSumIndex27 = Infinity;\n  let minPathSumIndex28 = Infinity;\n  let\
    \ minPathSumIndex29 = Infinity;\n  let minPathSumIndex30 = Infinity;\n  let minPathSumIndex31\
    \ = Infinity;\n  let minPathSumIndex32 = Infinity;\n  let minPathSumIndex33 =\
    \ Infinity;\n  let minPathSumIndex34 = Infinity;\n  let minPathSumIndex35 = Infinity;\n\
    \  let minPathSumIndex36 = Infinity;\n  let minPathSumIndex37 = Infinity;\n  let\
    \ minPathSumIndex38 = Infinity;\n  let minPathSumIndex39 = Infinity;\n  let minPathSumIndex40\
    \ = Infinity;\n  let minPathSumIndex41 = Infinity;\n  let minPathSumIndex42 =\
    \ Infinity;\n  let minPathSumIndex43 = Infinity;\n  let minPathSumIndex44 = Infinity;\n\
    \  let minPath", "    let n = grid.length;\n    let minPath = [];\n    let minSum\
    \ = Infinity;\n    let minPathSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            let path = [];\n           \
    \ let pathSum = 0;\n            let sum = 0;\n            let visited = new Set();\n\
    \            dfs(i, j, 0);\n        }\n    }\n    return minPath;\n    function\
    \ dfs(i, j, depth){\n        if(depth === k){\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            return;\n        }\n        if(i < 0 || i >= n ||\
    \ j < 0 || j >= n || visited.has(i * n + j)){\n            return;\n        }\n\
    \        visited.add(i * n + j);\n        path.push(grid[i][j]);\n        pathSum\
    \ += grid[i][j];\n        dfs(i + 1, j, depth + 1);\n        dfs(i - 1, j, depth\
    \ + 1);\n        dfs(i, j + 1, depth + 1);\n        dfs(i, j - 1, depth + 1);\n\
    \        path.pop();\n        pathSum -= grid[i][j];\n        visited.delete(i\
    \ * n + j);\n    }\n}\n", "    // Write your code here\n    let n = grid.length;\n\
    \    let dp = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));\n \
    \   let path = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));\n\
    \    let min = Infinity;\n    let minPath = [];\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < n; j++){\n            if(i === 0 && j === 0){\n  \
    \              dp[i][j] = 0;\n                path[i][j] = grid[i][j];\n     \
    \       }\n            else if(i === 0){\n                dp[i][j] = dp[i][j -\
    \ 1] + 1;\n                path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n  \
    \          }\n            else if(j === 0){\n                dp[i][j] = dp[i -\
    \ 1][j] + 1;\n                path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n\
    \            }\n            else{\n                dp[i][j] = Math.min(dp[i -\
    \ 1][j], dp[i][j - 1]) + 1;\n                if(dp[i - 1][j] < dp[i][j - 1]){\n\
    \                    path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n        \
    \        }\n                else{\n                    path[i][j] = path[i][j\
    \ - 1] * 10 + grid[i][j];\n                }\n            }\n            if(dp[i][j]\
    \ === k && path[i][j] < min){\n                min = path[i][j];\n           \
    \     minPath = [];\n                let temp = min;\n                while(temp\
    \ > 0){\n                    minPath.push(temp % 10);\n                    temp\
    \ = Math.floor(temp / 10);\n                }\n            }\n        }\n    }\n\
    \    return minPath;\n}\n", "    // Write your code here\n}\n", "    let n = grid.length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        for(let j\
    \ = 0; j < n; j++){\n            let path = [];\n            let sum = 0;\n  \
    \          dfs(i, j, 0, k, path, sum);\n            if(sum < minSum){\n      \
    \          minSum = sum;\n                minPath = path;\n            }\n   \
    \     }\n    }\n    return minPath;\n}\n", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let min = [];\n  let min_sum = Infinity;\n  let min_path\
    \ = [];\n  let visited = [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n\
    \    for(let j = 0; j < m; j++){\n      visited[i].push(false);\n    }\n  }\n\
    \  function dfs(i, j, sum, path){\n    if(sum > min_sum){\n      return;\n   \
    \ }\n    if(path.length === k){\n      if(sum < min_sum){\n        min_sum = sum;\n\
    \        min_path = path;\n      }\n      return;\n    }\n    if(i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j]){\n      return;\n    }\n    visited[i][j]\
    \ = true;\n    dfs(i + 1, j, sum + grid[i][j], path.concat(grid[i][j]));\n   \
    \ dfs(i - 1, j, sum + grid[i][j], path.concat(grid[i][j]));\n    dfs(i, j + 1,\
    \ sum + grid[i][j], path.concat(grid[i][j]));\n    dfs(i, j - 1, sum + grid[i][j],\
    \ path.concat(grid[i][j]));\n    visited[i][j] = false;\n  }\n  for(let i = 0;\
    \ i < n; i++){\n    for(let j = 0; j < m; j++){\n      dfs(i, j, 0, []);\n   \
    \ }\n  }\n  return min_path;\n}\n", "  var minPath = [];\n  var min = Infinity;\n\
    \  var path = [];\n  var visited = {};\n  var rows = grid.length;\n  var cols\
    \ = grid[0].length;\n  var dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  var dfs\
    \ = function(r, c, k){\n    if(r < 0 || r >= rows || c < 0 || c >= cols || k <\
    \ 0) return;\n    if(k === 0){\n      if(grid[r][c] < min){\n        min = grid[r][c];\n\
    \        minPath = path.slice();\n      }\n      return;\n    }\n    for(var i\
    \ = 0; i < dirs.length; i++){\n      var newR = r + dirs[i][0];\n      var newC\
    \ = c + dirs[i][1];\n      if(visited[newR + ',' + newC]) continue;\n      visited[newR\
    \ + ',' + newC] = true;\n      path.push(grid[newR][newC]);\n      dfs(newR, newC,\
    \ k - 1);\n      path.pop();\n      visited[newR + ',' + newC] = false;\n    }\n\
    \  };\n  for(var i = 0; i < rows; i++){\n    for(var j = 0; j < cols; j++){\n\
    \      visited[i + ',' + j] = true;\n      path.push(grid[i][j]);\n      dfs(i,\
    \ j, k - 1);\n      path.pop();\n      visited[i + ',' + j] = false;\n    }\n\
    \  }\n  return minPath;\n}\n", "  let minPath = [];\n  let minSum = Infinity;\n\
    \  let minPaths = [];\n  let sum = 0;\n  let paths = [];\n  let path = [];\n \
    \ let row = 0;\n  let col = 0;\n  let visited = [];\n  for(let i = 0; i < grid.length;\
    \ i++){\n    visited.push([]);\n    for(let j = 0; j < grid[i].length; j++){\n\
    \      visited[i].push(false);\n    }\n  }\n  findPath(grid, row, col, k, sum,\
    \ path, paths, visited);\n  for(let i = 0; i < paths.length; i++){\n    let sum\
    \ = 0;\n    for(let j = 0; j < paths[i].length; j++){\n      sum += paths[i][j];\n\
    \    }\n    if(sum < minSum){\n      minSum = sum;\n      minPaths = [paths[i]];\n\
    \    } else if(sum === minSum){\n      minPaths.push(paths[i]);\n    }\n  }\n\
    \  if(minPaths.length === 1){\n    return minPaths[0];\n  }\n  for(let i = 0;\
    \ i < minPaths.length; i++){\n    if(minPaths[i] < minPath){\n      minPath =\
    \ minPaths[i];\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(n).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ path, sum);\n            visited[i][j] = false;\n        }\n    }\n    return\
    \ minPath;\n\n    function dfs(i, j, k, path, sum){\n        if(i < 0 || i >=\
    \ n || j < 0 || j >= n || visited[i][j]){\n            return;\n        }\n  \
    \      if(path.length === k){\n            if(sum < minSum){\n               \
    \ minSum = sum;\n                minPath = path.slice();\n            }\n    \
    \        return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k, path, sum);\n        dfs(i\
    \ - 1, j, k, path, sum);\n        dfs(i, j + 1, k, path, sum);\n        dfs(i,\
    \ j - 1, k, path, sum);\n        path.pop();\n        sum -= grid[i][j];\n   \
    \     visited[i][j] = false;\n    }\n}\n", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n\
    \  let min = [];\n  let minSum = Infinity;\n  let minPath = [];\n  let dirs =\
    \ [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  let dfs = (i, j, path, sum) => {\n  \
    \  if (sum > minSum) return;\n    if (path.length === k) {\n      if (sum < minSum)\
    \ {\n        minSum = sum;\n        minPath = path;\n      }\n      return;\n\
    \    }\n    for (let dir of dirs) {\n      let x = i + dir[0];\n      let y =\
    \ j + dir[1];\n      if (x < 0 || x >= n || y < 0 || y >= m || visited[x][y])\
    \ continue;\n      visited[x][y] = true;\n      dfs(x, y, path.concat(grid[x][y]),\
    \ sum + grid[x][y]);\n      visited[x][y] = false;\n    }\n  }\n  for (let i =\
    \ 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      visited[i][j] = true;\n\
    \      dfs(i, j, [grid[i][j]], grid[i][j]);\n      visited[i][j] = false;\n  \
    \  }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let minPath = [];\n\
    \  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPathSumIndex\
    \ = 0;\n  let minPathSumIndex2 = 0;\n  let minPathSumIndex3 = 0;\n  let minPathSumIndex4\
    \ = 0;\n  let minPathSumIndex5 = 0;\n  let minPathSumIndex6 = 0;\n  let minPathSumIndex7\
    \ = 0;\n  let minPathSumIndex8 = 0;\n  let minPathSumIndex9 = 0;\n  let minPathSumIndex10\
    \ = 0;\n  let minPathSumIndex11 = 0;\n  let minPathSumIndex12 = 0;\n  let minPathSumIndex13\
    \ = 0;\n  let minPathSumIndex14 = 0;\n  let minPathSumIndex15 = 0;\n  let minPathSumIndex16\
    \ = 0;\n  let minPathSumIndex17 = 0;\n  let minPathSumIndex18 = 0;\n  let minPathSumIndex19\
    \ = 0;\n  let minPathSumIndex20 = 0;\n  let minPathSumIndex21 = 0;\n  let minPathSumIndex22\
    \ = 0;\n  let minPathSumIndex23 = 0;\n  let minPathSumIndex24 = 0;\n  let minPathSumIndex25\
    \ = 0;\n  let minPathSumIndex26 = 0;\n  let minPathSumIndex27 = 0;\n  let minPathSumIndex28\
    \ = 0;\n  let minPathSumIndex29 = 0;\n  let minPathSumIndex30 = 0;\n  let minPathSumIndex31\
    \ = 0;\n  let minPathSumIndex32 = 0;\n  let minPathSumIndex33 = 0;\n  let minPathSumIndex34\
    \ = 0;\n  let minPathSumIndex35 = 0;\n  let minPathSumIndex36 = 0;\n  let minPathSumIndex37\
    \ = 0;\n  let minPathSumIndex38 = 0;\n  let minPathSumIndex39 = 0;\n  let minPathSumIndex40\
    \ = 0;\n  let minPathSumIndex41 = 0;\n  let minPathSumIndex42 = 0;\n  let minPathSumIndex43\
    \ = 0;\n  let minPathSumIndex", "  var n = grid.length;\n  var minPath = [];\n\
    \  var minSum = Infinity;\n  var minPathSum = Infinity;\n  var visited = [];\n\
    \  for(var i = 0; i < n; i++){\n    visited.push([]);\n    for(var j = 0; j <\
    \ n; j++){\n      visited[i].push(false);\n    }\n  }\n  var dfs = function(i,\
    \ j, path, sum){\n    if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j]){\n\
    \      return;\n    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n\
    \    sum += grid[i][j];\n    if(path.length === k){\n      if(sum < minPathSum){\n\
    \        minPathSum = sum;\n        minPath = path.slice();\n      }\n      else\
    \ if(sum === minPathSum){\n        if(path < minPath){\n          minPath = path.slice();\n\
    \        }\n      }\n    }\n    else{\n      dfs(i - 1, j, path, sum);\n     \
    \ dfs(i + 1, j, path, sum);\n      dfs(i, j - 1, path, sum);\n      dfs(i, j +\
    \ 1, path, sum);\n    }\n    path.pop();\n    visited[i][j] = false;\n  };\n \
    \ for(var i = 0; i < n; i++){\n    for(var j = 0; j < n; j++){\n      dfs(i, j,\
    \ [], 0);\n    }\n  }\n  return minPath;\n}\n", "  let n = grid.length;\n  let\
    \ minPath = [];\n  let minSum = Infinity;\n  let minSumPath = [];\n  let visited\
    \ = {};\n  let dfs = function(row, col, path, sum){\n    if(row < 0 || row >=\
    \ n || col < 0 || col >= n || visited[row + ',' + col]){\n      return;\n    }\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minSumPath = path;\n      }\n      return;\n    }\n    visited[row +\
    \ ',' + col] = true;\n    path.push(grid[row][col]);\n    sum += grid[row][col];\n\
    \    dfs(row + 1, col, path, sum);\n    dfs(row - 1, col, path, sum);\n    dfs(row,\
    \ col + 1, path, sum);\n    dfs(row, col - 1, path, sum);\n    path.pop();\n \
    \   sum -= grid[row][col];\n    visited[row + ',' + col] = false;\n  }\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < n; j++){\n      dfs(i, j, [], 0);\n\
    \    }\n  }\n  return minSumPath;\n}\n", "    let n = grid.length;\n    let min\
    \ = [];\n    let minSum = Infinity;\n    let minPath = [];\n    let visited =\
    \ new Set();\n    let dfs = function(i, j, path, sum){\n        if(visited.has(i\
    \ + ',' + j)) return;\n        if(path.length === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path;\n            }\n\
    \            return;\n        }\n        visited.add(i + ',' + j);\n        if(i\
    \ > 0) dfs(i - 1, j, path.concat(grid[i - 1][j]), sum + grid[i - 1][j]);\n   \
    \     if(i < n - 1) dfs(i + 1, j, path.concat(grid[i + 1][j]), sum + grid[i +\
    \ 1][j]);\n        if(j > 0) dfs(i, j - 1, path.concat(grid[i][j - 1]), sum +\
    \ grid[i][j - 1]);\n        if(j < n - 1) dfs(i, j + 1, path.concat(grid[i][j\
    \ + 1]), sum + grid[i][j + 1]);\n        visited.delete(i + ',' + j);\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n      \
    \      dfs(i, j, [grid[i][j]], grid[i][j]);\n        }\n    }\n    return minPath;\n\
    }\n", "  let n = grid.length;\n  let visited = new Set();\n  let minPath = [];\n\
    \  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n  let minPath2 =\
    \ [];\n  let minPathSum3 = Infinity;\n  let minPath3 = [];\n  let minPathSum4\
    \ = Infinity;\n  let minPath4 = [];\n  let minPathSum5 = Infinity;\n  let minPath5\
    \ = [];\n  let minPathSum6 = Infinity;\n  let minPath6 = [];\n  let minPathSum7\
    \ = Infinity;\n  let minPath7 = [];\n  let minPathSum8 = Infinity;\n  let minPath8\
    \ = [];\n  let minPathSum9 = Infinity;\n  let minPath9 = [];\n  let minPathSum10\
    \ = Infinity;\n  let minPath10 = [];\n  let minPathSum11 = Infinity;\n  let minPath11\
    \ = [];\n  let minPathSum12 = Infinity;\n  let minPath12 = [];\n  let minPathSum13\
    \ = Infinity;\n  let minPath13 = [];\n  let minPathSum14 = Infinity;\n  let minPath14\
    \ = [];\n  let minPathSum15 = Infinity;\n  let minPath15 = [];\n  let minPathSum16\
    \ = Infinity;\n  let minPath16 = [];\n  let minPathSum17 = Infinity;\n  let minPath17\
    \ = [];\n  let minPathSum18 = Infinity;\n  let minPath18 = [];\n  let minPathSum19\
    \ = Infinity;\n  let minPath19 = [];\n  let minPathSum20 = Infinity;\n  let minPath20\
    \ = [];\n  let minPathSum21 = Infinity;\n  let minPath21 = [];\n  let minPathSum22\
    \ = Infinity;\n  let minPath22 = [];\n  let minPathSum23 = Infinity;\n  let minPath23\
    \ = [];\n  let minPathSum24 = Infinity;\n  let minPath24 = [];\n  let minPathSum25\
    \ = Infinity;\n  let minPath25 = [];\n  let minPathSum26 = Infinity;\n  let minPath26\
    \ = [];\n  let minPathSum27 = Infinity;\n  let minPath27 = [];\n  let minPathSum28\
    \ = Infinity;\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let min = [];\n    let minSum = Infinity;\n    let minPath = [];\n    let visited\
    \ = new Set();\n    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    let dfs\
    \ = (i, j, sum, path) => {\n        if (sum > minSum) return;\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minPath = path;\n            }\n            return;\n        }\n\
    \        for (let dir of dirs) {\n            let x = i + dir[0];\n          \
    \  let y = j + dir[1];\n            if (x < 0 || x >= n || y < 0 || y >= m ||\
    \ visited.has(x * m + y)) continue;\n            visited.add(x * m + y);\n   \
    \         dfs(x, y, sum + grid[x][y], path.concat(grid[x][y]));\n            visited.delete(x\
    \ * m + y);\n        }\n    }\n    for (let i = 0; i < n; i++) {\n        for\
    \ (let j = 0; j < m; j++) {\n            visited.add(i * m + j);\n           \
    \ dfs(i, j, grid[i][j], [grid[i][j]]);\n            visited.delete(i * m + j);\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let visited = new Set();\n    let minPaths = [];\n    let minPathsSum = [];\n\
    \    let minPathsVisited = [];\n    let minPathsVisitedSum = [];\n    let minPathsVisitedSumSet\
    \ = new Set();\n    let minPathsVisitedSet = new Set();\n    let minPathsSet =\
    \ new Set();\n    let minPathsSumSet = new Set();\n    let minPathsSumVisitedSet\
    \ = new Set();\n    let minPathsSumVisited = [];\n    let minPathsSumVisitedSum\
    \ = [];\n    let minPathsSumVisitedSumSet = new Set();\n    let minPathsSumVisitedSet\
    \ = new Set();\n    let minPathsSumSet = new Set();\n    let minPathsSumSum =\
    \ [];\n    let minPathsSumSumSet = new Set();\n    let minPathsSumSumVisited =\
    \ [];\n    let minPathsSumSumVisitedSet = new Set();\n    let minPathsSumSumVisitedSum\
    \ = [];\n    let minPathsSumSumVisitedSumSet = new Set();\n    let minPathsSumSumVisitedSumSum\
    \ = [];\n    let minPathsSumSumVisitedSumSumSet = new Set();\n    let minPathsSumSumVisitedSumSumVisited\
    \ = [];\n    let minPathsSumSumVisitedSumSumVisitedSet = new Set();\n    let minPathsSumSumVisitedSumSumVisitedSum\
    \ = [];\n    let minPathsSumSumVisitedSumSumVisitedSumSet = new Set();\n    let\
    \ minPathsSumSumVisitedSumSumVisitedSumSum = [];\n    let minPathsSumSumVisitedSumSumVisitedSumSumSet\
    \ = new Set();\n    let minPathsSumSumVisitedSumSumVisitedSumSumSum = [];\n  \
    \  let minPathsSumSumVisitedSumSumVisitedSumSumSumSet = new Set();\n    let minPathsSumSumVisitedSumSumVisitedSumSumSumSum\
    \ = [];\n    let minPathsSumSumVisitedSumSumVisitedSumSumSumSumSet = new Set();",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let\
    \ visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    minPathHelper(grid, k, 0, 0, [], min, visited);\n    return\
    \ min;\n}\n", "  let n = grid.length;\n  let visited = new Set();\n  let minPath\
    \ = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n  let minPaths\
    \ = [];\n  let minPathsSum = [];\n  let minPathsVisited = [];\n  let minPathsVisitedSum\
    \ = [];\n  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet =\
    \ new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n\
    \  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet = new Set();\n\
    \  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet\
    \ = new Set();\n  let minPathsVisitedSet = new Set();\n  let minPathsSet = new\
    \ Set();\n  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet = new\
    \ Set();\n  let minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n\
    \  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet = new Set();\n\
    \  let minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n  let\
    \ minPathsSumSet = new Set();\n  let minPathsVisitedSumSet = new Set();\n  let\
    \ minPathsVisitedSet = new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet\
    \ = new Set();\n  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet\
    \ = new Set();\n  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n\
    \  let minPathsVisitedSumSet = new Set();\n  let minPathsVisitedSet = new Set();\n\
    \  let minPathsSet = new Set();\n  let minPathsSumSet = new Set();\n  let minPathsVisitedSumSet\
    \ = new Set();\n  let minPathsVisitedSet = new Set();\n  let minPaths"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
