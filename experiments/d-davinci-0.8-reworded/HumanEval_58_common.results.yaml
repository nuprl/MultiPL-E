name: HumanEval_58_common
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n    if (l1.length > l2.length) {\n        auto tmp = l1;\n        l1 = l2;\n\
    \        l2 = tmp;\n    }\n    return sort(array(l1).map!(a => a in l2).filter!(a\
    \ => a).keys);\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfc0nrewr.d(13): Error: cannot use function constraints for non-template\
    \ functions. Use `static if` instead\\n/tmp/tmpfc0nrewr.d(13): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpfc0nrewr.d(15): Error: no identifier for declarator\
    \ `l1`\\n/tmp/tmpfc0nrewr.d(15): Error: declaration expected, not `=`\\n/tmp/tmpfc0nrewr.d(16):\
    \ Error: no identifier for declarator `l2`\\n/tmp/tmpfc0nrewr.d(16): Error: declaration\
    \ expected, not `=`\\n/tmp/tmpfc0nrewr.d(17): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfc0nrewr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[];\n    auto i1 = l1.dup.sort;\n    auto i2 =\
    \ l2.dup.sort;\n    foreach(i, x; i1)\n    {\n        foreach(j, y; i2)\n    \
    \    {\n            if(x == y)\n            {\n                i2.remove(j);\n\
    \                ret ~= x;\n                break;\n            }\n        }\n\
    \    }\n    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwhqkbtfe.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpwhqkbtfe.d(15): Error: no property\
    \ `sort` for type `long[]`\\n/tmp/tmpwhqkbtfe.d(16): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwhqkbtfe.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    size_t l1s = l1.length;\n    size_t l2s = l2.length;\n    if(l1s ==\
    \ 0 || l2s == 0)\n    {\n        return [];\n    }\n    if(l1s > l2s)\n    {\n\
    \        long[] temp = l1;\n        l1 = l2;\n        l2 = temp;\n    }\n    size_t\
    \ l2s2 = l2.length;\n    Map!(long, bool) l1_m = Map!(long, bool)();\n    foreach(item;\
    \ l1)\n    {\n        l1_m[item] = true;\n    }\n    long[] ret_arr = [];\n  \
    \  foreach(item; l2)\n    {\n        if(l1_m.contains(item))\n        {\n    \
    \        ret_arr ~= item;\n        }\n    }\n    return ret_arr;\n}\n//difference\
    \ of two lists\nlong[] difference(long[] l1, long[] l2) \n{\n    size_t l1s =\
    \ l1.length;\n    size_t l2s = l2.length;\n    if(l1s == 0 || l2s == 0)\n    {\n\
    \        return [];\n    }\n    if(l1s > l2s)\n    {\n        long[] temp = l1;\n\
    \        l1 = l2;\n        l2 = temp;\n    }\n    size_t l2s2 = l2.length;\n \
    \   Map!(long, bool) l1_m = Map!(long, bool)();\n    foreach(item; l1)\n    {\n\
    \        l1_m[item] = true;\n    }\n    long[] ret_arr = [];\n    foreach(item;\
    \ l2)\n    {\n        if(!l1_m.contains(item))\n        {\n            ret_arr\
    \ ~= item;\n        }\n    }\n    return ret_arr;\n}\n/*\nReturn sorted unique\
    \ common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L,\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8j5lasex.d(73): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8j5lasex.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n     if (l1.length == 0 || l2.length == 0) return new long[0];\n    auto\
    \ lSet = new HashSet!(long)(l1);\n    auto lOut = [];\n    foreach (e; l2)\n \
    \   {\n        if (lSet.contains(e))\n        {\n            lOut ~= e;\n    \
    \    }\n    }\n    lOut.sort;\n    return lOut;\n}\n/*\nReturn sorted unique elements\
    \ that are in one of the arrays but not both.\n    >>> extra([1L, 4L, 3L, 34L,\
    \ 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [2L, 3L, 4L, 7L, 9L, 34L,\
    \ 121L]\n    >>> extra([5L, 3L, 2L, 8L], [3L, 2L])\n    [5L, 8L]\n*/\nlong[] extra(long[]\
    \ l1, long[] l2) \n{\n    if (l1.length == 0 && l2.length == 0) return new long[0];\n\
    \    if (l1.length == 0) return l2;\n    if (l2.length == 0) return l1;\n    auto\
    \ lSet = new HashSet!(long)(l1);\n    auto lOut = [];\n    foreach (e; l2)\n \
    \   {\n        if (!lSet.contains(e))\n        {\n            lOut ~= e;\n   \
    \     }\n    }\n    lOut.sort;\n    return lOut;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjl_tsi5s.d(15): Error: template instance `HashSet!long` template\
    \ `HashSet` is not defined\\n/tmp/tmpjl_tsi5s.d(21): Error: cannot append type\
    \ `long` to type `void[]`\\n/tmp/tmpjl_tsi5s.d(24): Error: no property `sort`\
    \ for type `void[]`\\n/tmp/tmpjl_tsi5s.d(25): Error: cannot implicitly convert\
    \ expression `lOut` of type `void[]` to `long[]`\\n/tmp/tmpjl_tsi5s.d(39): Error:\
    \ template instance `HashSet!long` template `HashSet` is not defined\\n/tmp/tmpjl_tsi5s.d(45):\
    \ Error: cannot append type `long` to type `void[]`\\n/tmp/tmpjl_tsi5s.d(48):\
    \ Error: no property `sort` for type `void[]`\\n/tmp/tmpjl_tsi5s.d(49): Error:\
    \ cannot implicitly convert expression `lOut` of type `void[]` to `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjl_tsi5s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    SortedRange!long set1 = l1;\n    SortedRange!long set2 = l2;\n    ulong[]\
    \ common = new ulong[](min(set1.length, set2.length));\n    ulong[] common_out\
    \ = common.dup;\n    ulong c;\n    c = set1.common(set2, common);\n    common_out.length\
    \ = c;\n    return common_out;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb7xrhwu7.d(14): Error: template instance `SortedRange!long` template\
    \ `SortedRange` is not defined\\n/tmp/tmpb7xrhwu7.d(15): Error: template instance\
    \ `SortedRange!long` template `SortedRange` is not defined\\n/tmp/tmpb7xrhwu7.d(16):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpb7xrhwu7.d(21):\
    \ Error: cannot implicitly convert expression `common_out` of type `ulong[]` to\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb7xrhwu7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = null;\n    long[] l = merge(l1, l2);\n    l = sort(l);\n\
    \    l = unique(l);\n    if (l.length == 0)\n    {\n        return ret;\n    }\n\
    \    else\n    {\n        ulong cnt = l.length;\n        foreach (i; l)\n    \
    \    {\n            if (cnt == l.length)\n            {\n                ret ~=\
    \ i;\n            }\n            else\n            {\n                if (i !=\
    \ ret[$ - 1])\n                {\n                    ret ~= i;\n            \
    \    }\n            }\n            cnt--;\n        }\n        return ret;\n  \
    \  }\n}\n/*\nReturn sorted unique elements from both arrays.\n    >>> merge([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L,\
    \ 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> merge([4L, 3L, 2L, 8L], [3L, 2L])\n\
    \    [2L, 3L, 4L, 8L]\n    >>> merge([1L, 2L, 3L], [1L, 2L, 3L])\n    [1L, 2L,\
    \ 3L]\n*/\nlong[] merge(long[] l1, long[] l2) \n{\n    long[] ret = null;\n  \
    \  foreach (i; l1)\n    {\n        ret ~= i;\n    }\n    foreach (i; l2)\n   \
    \ {\n        ret ~= i;\n    }\n    ret = sort(ret);\n    ret = unique(ret);\n\
    \    return ret;\n}\n/*\nReturn sorted unique elements from array.\n    >>> unique([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L])\n    [1L, 2L, 3L, 4L, 5L, 34L, 653L]\n    >>> unique([5L,\
    \ 7L, 1L, 5L\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9w1wmq18.d(67): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9w1wmq18.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = null;\n    long length = 0;\n    if (l1.length > l2.length)\
    \ \n    {\n        result = l1.dup;\n        length = l2.length;\n    }\n    else\
    \ \n    {\n        result = l2.dup;\n        length = l1.length;\n    }\n    for\
    \ (int i = 0; i < length; i++) \n    {\n        if (l1[i] != l2[i]) \n       \
    \ {\n            result = result[0..$-1];\n        }\n    }\n    return result.sort.unique;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwagcviac.d(35): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwagcviac.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tauto l3 = l1.sorted;\n\tauto l4 = l2.sorted;\n\tlong[] result;\n\twhile(l3.length\
    \ != 0 && l4.length != 0)\n\t{\n\t\tif(l3[0] == l4[0])\n\t\t{\n\t\t\tresult ~=\
    \ l3[0];\n\t\t\tl3 = l3[1..$];\n\t\t\tl4 = l4[1..$];\n\t\t}\n\t\telse if(l3[0]\
    \ < l4[0])\n\t\t{\n\t\t\tl3 = l3[1..$];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl4 = l4[1..$];\n\
    \t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfqcbyq_9.d(14): Error: no property `sorted` for type `long[]`\\\
    n/tmp/tmpfqcbyq_9.d(15): Error: no property `sorted` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfqcbyq_9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    Map!(dchar, size_t) map1 = new Map!(dchar, size_t)();\n    size_t[]\
    \ l1_uniq = new size_t[];\n    foreach (i, v; l1) \n    {\n        map1[v] = i;\n\
    \        l1_uniq ~= v;\n    }\n    long[] l1_uniq_sorted = sort(l1_uniq);\n  \
    \  long[] res = new long[];\n    foreach (i, v; l2) \n    {\n        if (map1.count(v))\
    \ \n        {\n            res ~= v;\n        }\n    }\n    return sort(res);\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj867boww.d(14): Error: template instance `Map!(dchar, size_t)`\
    \ template `Map` is not defined\\n/tmp/tmpj867boww.d(14): Error: template instance\
    \ `Map!(dchar, size_t)` template `Map` is not defined\\n/tmp/tmpj867boww.d(15):\
    \ Error: new can only create structs, dynamic arrays or class objects, not `ulong[]`\\\
    's\\n/tmp/tmpj867boww.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpj867boww.d(22): Error: new can only create structs,\
    \ dynamic arrays or class objects, not `long[]`\\'s\\n/tmp/tmpj867boww.d(30):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj867boww.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long len1 = l1.length;\n    long len2 = l2.length;\n    if (len1 ==\
    \ 0L || len2 == 0L)\n    {\n        return new long[0L];\n    }\n    if (len1\
    \ == 1L)\n    {\n        if (cast(long)l2.count(l1[0L]) > 0L)\n        {\n   \
    \         return l1;\n        }\n        else\n        {\n            return new\
    \ long[0L];\n        }\n    }\n    if (len2 == 1L)\n    {\n        if (cast(long)l1.count(l2[0L])\
    \ > 0L)\n        {\n            return l2;\n        }\n        else\n        {\n\
    \            return new long[0L];\n        }\n    }\n    return std.algorithm.setIntersection(l1,\
    \ l2).array();\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpto_jdzpv.d(22): Error: no property `count` for type `long[]`\\\
    n/tmp/tmpto_jdzpv.d(33): Error: no property `count` for type `long[]`\\n/tmp/tmpto_jdzpv.d(42):\
    \ Error: undefined identifier `algorithm` in package `std`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpto_jdzpv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tstatic if (__VERSION__ >= 2060) \n    {\n        auto hash = new HashTable!(long,\
    \ long);\n        foreach (i; 0 .. l1.length) hash[l1[i]] = 1;\n        foreach\
    \ (i; 0 .. l2.length) hash[l2[i]] = hash[l2[i]] == 1 ? 2 : 0;\n        hash.popFront();\n\
    \        return hash.byKey.sort.filter!(a => a.value > 1).map!(a => a.key).array;\n\
    \    } \n    else \n    {\n        sort(l1);\n        sort(l2);\n        return\
    \ filter!(a => a[0] == a[1])(zip(l1, l2)).map!(a => a[0]).array;\n    }\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjf0kxj8n.d(16): Error: template instance `HashTable!(long, long)`\
    \ template `HashTable` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjf0kxj8n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    assert(l1.length > 0);\n    assert(l2.length > 0);\n    auto s1 = l1.sort();\n\
    \    auto s2 = l2.sort();\n    long[][] tmp = [s1, s2];\n    auto s3 = tmp.sort();\n\
    \    long[] c1 = l1.sort();\n    long[] c2 = l2.sort();\n    long[] c3 = [];\n\
    \    for (int i = 0; i < s1.length; i++)\n    {\n        if (s1[i] == s2[i])\n\
    \        {\n            c3 ~= s1[i];\n        }\n    }\n    return c3;\n}\n/*\n\
    Create a 2-D array from 1-D\n    >>> create_2d([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L,\
    \ 9L], 3L)\n    [[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]]\n*/\nlong[][] create_2d(long[]\
    \ data, size_t dim1) \n{\n    assert(data.length > 0);\n    long[][] res = [];\n\
    \    size_t i = 0;\n    while (i < data.length)\n    {\n        res ~= data[i..i\
    \ + dim1];\n        i += dim1;\n    }\n    return res;\n}\n/*\nPair an array with\
    \ the cumulative sum of its elements\n    >>> cumulate([1L, 2L, 3L, 4L])\n   \
    \ [(1L, 1L), (2L, 3L), (3L, 6L), (4L, 10L)]\n    >>> cumulate([5L, 6L, 7L, 8L,\
    \ 9L])\n    [(5L, 5L), (6L, 11L), (7L, 18L), (8L, 26L), (9L, 35L)]\n*/\nTuple!(long,\
    \ long)[][] cumulate(long[] data) \n{\n    assert(data.length > 0);\n    Tuple!(long,\
    \ long)[][]\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgrcfeh1k.d(60): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpgrcfeh1k.d(69): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpgrcfeh1k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\treturn std.algorithm.setIntersection(l1, l2).array();\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuvge7zd5.d(14): Error: undefined identifier `algorithm` in package\
    \ `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvge7zd5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto us = union(l1, l2);\n    auto is = intersection(l1, l2);\n   \
    \ return(is);\n}\n/*\nRemove all duplicate elements.\n    >>> unique([1L, 4L,\
    \ 3L, 2L, 34L, 653L, 2L, 5L])\n    [1L, 4L, 3L, 2L, 34L, 653L, 5L]\n    >>> unique([2L,\
    \ 3L, 2L, 3L, 2L, 3L])\n    [2L, 3L]\n*/\nlong[] unique(long[] l) \n{\n    l.sort();\n\
    \    return(l.uniq);\n}\n/*\nGiven two arrays, return all of the elements that\
    \ are in both arrays.\n    >>> intersection([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> intersection([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n*/\nlong[] intersection(long[] l1, long[]\
    \ l2) \n{\n    auto us = union(l1, l2);\n    return(us.uniq);\n}\n/*\nGiven two\
    \ arrays, return all of the elements that are in only one array.\n    >>> difference([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [4L, 3L,\
    \ 34L, 2L]\n    >>> difference([5L, 3L, 2L, 8L], [3L, 2L])\n    [5L, 8L]\n*/\n\
    long[] difference(long[] l1, long[] l2) \n{\n    auto us = union(l1, l2);\n  \
    \  auto is = intersection(l1, l2);\n    return(us.difference(is));\n}\n/*\nReturn\
    \ the elements that are only in one array.\n    >>>\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgg2o14qp.d(14): Error: expression expected, not `union`\\n/tmp/tmpgg2o14qp.d(15):\
    \ Error: basic type expected, not `is`\\n/tmp/tmpgg2o14qp.d(15): Error: no identifier\
    \ for declarator `_error_`\\n/tmp/tmpgg2o14qp.d(15): Error: `type identifier :\
    \ specialization` expected following `is`\\n/tmp/tmpgg2o14qp.d(15): Error: found\
    \ `intersection` when expecting `;` following statement\\n/tmp/tmpgg2o14qp.d(16):\
    \ Error: `type identifier : specialization` expected following `is`\\n/tmp/tmpgg2o14qp.d(16):\
    \ Error: found `;` when expecting `)`\\n/tmp/tmpgg2o14qp.d(17): Error: found `}`\
    \ when expecting `;` following `return` statement\\n/tmp/tmpgg2o14qp.d(39): Error:\
    \ expression expected, not `union`\\n/tmp/tmpgg2o14qp.d(51): Error: expression\
    \ expected, not `union`\\n/tmp/tmpgg2o14qp.d(52): Error: basic type expected,\
    \ not `is`\\n/tmp/tmpgg2o14qp.d(52): Error: no identifier for declarator `_error_`\\\
    n/tmp/tmpgg2o14qp.d(52): Error: `type identifier : specialization` expected following\
    \ `is`\\n/tmp/tmpgg2o14qp.d(52): Error: found `intersection` when expecting `;`\
    \ following statement\\n/tmp/tmpgg2o14qp.d(53): Error: `type identifier : specialization`\
    \ expected following `is`\\n/tmp/tmpgg2o14qp.d(53): Error: found `;` when expecting\
    \ `)`\\n/tmp/tmpgg2o14qp.d(54): Error: found `}` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpgg2o14qp.d(55): Error: unterminated /* */ comment\\\
    n/tmp/tmpgg2o14qp.d(67): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpgg2o14qp.d(67): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgg2o14qp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    l1.sort;\n    l2.sort;\n    return l1.uniq.filter!(x => x in l2.uniq).idup;\n\
    }\n/*\nYou have a function rand7() that generates a random integer from 1 to 7.\
    \ Use it to write a function rand5() that generates a random integer from 1 to\
    \ 5.\n    rand7() returns each integer with equal probability. rand5() must also\
    \ return each integer with equal probability.\n    >>> rand5() in [1L, 2L, 3L,\
    \ 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>>\
    \ rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L,\
    \ 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5()\
    \ in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n\
    \    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5()\
    \ in [1L, 2L, 3L, 4L, 5L]\n    True\n    >>> rand5() in [1L, 2L, 3L, 4L, 5L]\n\
    \    True\n*/\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptewydimn.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmptewydimn.d(15): Error: no property `sort` for type `long[]`\\n/tmp/tmptewydimn.d(16):\
    \ Error: no property `uniq` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptewydimn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    size_t n1 = l1.length;\n    size_t n2 = l2.length;\n    long[][] arr\
    \ = [l1, l2];\n    size_t[] n = [n1, n2];\n    size_t[] idx = [0, 0];\n    long[]\
    \ value = [l1[0], l2[0]];\n    size_t m = 0;\n    long[] result = new long[min(n1,\
    \ n2)];\n    while(true) \n    {\n        if (idx[0] == n[0] || idx[1] == n[1])\n\
    \            break;\n        auto a = idx[0];\n        auto b = idx[1];\n    \
    \    if (value[0] == value[1]) \n        {\n            result[m] = value[0];\n\
    \            value[0] = arr[0][++a];\n            value[1] = arr[1][++b];\n  \
    \          idx[0] = a;\n            idx[1] = b;\n            m++;\n        }\n\
    \        else if (value[0] < value[1]) \n        {\n            value[0] = arr[0][++a];\n\
    \            idx[0] = a;\n        }\n        else \n        {\n            value[1]\
    \ = arr[1][++b];\n            idx[1] = b;\n        }\n    }\n    return result[0..m];\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcr3a3fx0.d(21): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcr3a3fx0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto unique1 = set(l1);\n    auto unique2 = set(l2);\n    return unique1.intersection(unique2).array;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4j5zl53n.d(14): Error: undefined identifier `set`, did you mean\
    \ template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\\n/tmp/tmp4j5zl53n.d(15):\
    \ Error: undefined identifier `set`, did you mean template `get(K, V)(inout(V[K])\
    \ aa, K key, lazy inout(V) defaultValue)`?\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp4j5zl53n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = l1.dup;\n    foreach(e; l2)\n    {\n        auto index\
    \ = result.indexOf(e);\n        if(index > -1)\n        {\n            result[index]\
    \ = 0;\n        }\n    }\n    return result.filter!(x => x > 0).array;\n}\n/*\n\
    Return sorted unique common elements for two arrays.\n    >>> common([1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx43_2p1i.d(25): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx43_2p1i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  return sort(toSet(l1) & toSet(l2));\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpepe3z9ku.d(14): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepe3z9ku.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    \n    long[] first = l1.sort.unique;\n    long[] second = l2.sort.unique;\n\
    \    auto res = long[].init;\n    for (int i = 0; i < first.length; i++) \n  \
    \  {\n        for (int j = 0; j < second.length; j++) \n        {\n          \
    \  if (first[i] == second[j]) \n            {\n                res ~= first[i];\n\
    \            }\n        }\n    }\n    return res;\n}\n/*\nFind if string is made\
    \ up of number characters.\n    >>> is_number(\"123\")\n    true\n    >>> is_number(\"\
    123abc\")\n    false\n    >>> is_number(\"12 3\")\n    false\n*/\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplx1hd7rw.d(17): Error: found `[` when expecting `.` following\
    \ long\\n/tmp/tmplx1hd7rw.d(17): Error: found `]` when expecting identifier following\
    \ `long`.\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplx1hd7rw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
