name: HumanEval_134_check_if_last_char_is_a_letter
language: d
prompt: "import std.math;\n/*\n\n    Create a function that returns true if the last\
  \ character\n    of a given string is an alphabetical character and is not\n   \
  \ a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters\
  \ separated by space.\n\n    Examples:\n    >>> check_if_last_char_is_a_letter(\"\
  apple pie\")\n    false\n    >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\
  \    true\n    >>> check_if_last_char_is_a_letter(\"apple pi e \")\n    false\n\
  \    >>> check_if_last_char_is_a_letter(\"\")\n    false\n    \n*/\nbool check_if_last_char_is_a_letter(string\
  \ txt) \n"
tests: "unittest\n{\n    alias candidate = check_if_last_char_is_a_letter;\n\n   \
  \ assert(candidate(\"apple\") == false);\n    assert(candidate(\"apple pi e\") ==\
  \ true);\n    assert(candidate(\"eeeee\") == false);\n    assert(candidate(\"A\"\
  ) == true);\n    assert(candidate(\"Pumpkin pie \") == false);\n    assert(candidate(\"\
  Pumpkin pie 1\") == false);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
  eeeee e \") == false);\n    assert(candidate(\"apple pie\") == false);\n    assert(candidate(\"\
  apple pi e \") == false);\n}\nvoid main(){}"
completions: ["{\n    return (isalpha(txt[txt.length - 1]) && !isspace(txt[txt.length\
    \ - 2]));\n}", "{\n    return txt.length && !isalpha(txt[$-1]) && (isalpha(txt[$-2])\
    \ || $<=2);\n}", "{\n    if (txt.size() <= 0) return false;\n    if (isalpha(txt[txt.size()-1]))\n\
    \    {\n        if (txt.size() == 1) return true;\n        else if (isspace(txt[txt.size()-2]))\
    \ return true;\n    }\n    return false;\n}", "{\n    int len = txt.length();\n\
    \    if (len == 0)\n        return false;\n    char last = txt[len-1];\n    bool\
    \ is_alpha = isalpha(last);\n    bool is_space = isspace(last);\n    bool is_word\
    \ = (txt[len-2] != ' ');\n    return is_alpha && !is_space && !is_word;\n}\n/*\n\
    \    Create a function that finds the sum of all the elements of a list\n    of\
    \ integers.", "{\n    int length = txt.length;\n    if (length == 0)\n       \
    \ return false;\n    char lastChar = txt[length - 1];\n    if (lastChar == ' ')\n\
    \        return false;\n    if (isalpha(lastChar))\n        return true;\n   \
    \ return false;\n}", "{\n    int len = txt.length;\n    // check if the last char\
    \ is a letter, else return false\n    if (len == 0)\n        return false;\n \
    \   if (!isalpha(txt[len-1]))\n        return false;\n    // check if the last\
    \ char is a part of a word\n    // by checking if the char before it is a space\n\
    \    if (len == 1)\n        return true;\n    return isspace(txt[len-2]);\n}\n\
    /*\n    Create a function that returns true if the given string\n    doesn't contain\
    \ any consecutive spaces, and false otherwise.", "{\n    return isalpha(txt[txt.length-1])\
    \ && txt[txt.length-2] == ' ';\n}", "{\n    size_t pos = txt.length();\n    if\
    \ (pos == 0) return false;\n    char c = txt[pos-1];\n    if (isalpha(c))\n  \
    \  {\n        if (pos == 1) return true;\n        c = txt[pos-2];\n        if\
    \ (c == ' ') return true;\n    }\n    return false;\n}", "{\n    if (txt.length()\
    \ == 0)\n        return false;\n    if (txt[txt.length() - 1] == ' ')\n      \
    \  return false;\n    if (txt[txt.length() - 1] != ' ')\n    {\n        foreach\
    \ (c; txt)\n        {\n            if (c == ' ')\n            {\n            \
    \    if (txt[$ - 1] == ' ')\n                    return false;\n            }\n\
    \        }\n    }\n    return true;\n}", "{\n    return (txt.size() != 0) && (isalpha(txt[txt.size()\
    \ - 1]) == true) && (isalpha(txt[txt.size() - 2]) == false);\n}", "{\n    int\
    \ length = txt.length;\n    int last = length - 1;\n    string last_letter = txt[last..$];\n\
    \    string last_but_one = txt[0..$-1];\n    string check_letter = regex_replace(last_letter,\
    \ \"[^a-zA-Z]\", \"\");\n    string check_word = regex_replace(last_but_one, \"\
    [^a-zA-Z]\", \"\");\n    return check_letter != \"\" && check_word == \"\";\n}",
  "{\n    if (txt.length == 0)\n        return false;\n    return isalpha(txt[$-1])\
    \ && (txt.length == 1 || !isalpha(txt[$-2]));\n}", "{\n    if (txt.length == 0)\n\
    \        return false;\n    char last = txt[txt.length - 1];\n    if (last >=\
    \ 'a' && last <= 'z')\n        return true;\n    if (last >= 'A' && last <= 'Z')\n\
    \        return true;\n    return false;\n}", "{\n    if (txt.empty()) { return\
    \ false; }\n    int char_code = txt.back();\n    return (char_code >= 65 && char_code\
    \ <= 90) || (char_code >= 97 && char_code <= 122);\n}", "{\n    bool isALetter;\n\
    \    // get last character of txt\n    char lastChar = txt[$-1];\n    // check\
    \ if last character is alphabetical\n    if (isalpha(lastChar))\n    {\n     \
    \   // check if last character is not part of a word\n        if (lastChar ==\
    \ ' ')\n        {\n            isALetter = false;\n        }\n        else\n \
    \       {\n            isALetter = true;\n        }\n    }\n    else\n    {\n\
    \        isALetter = false;\n    }\n    return isALetter;\n}", "{\n    return\
    \ txt.length > 0 && isalpha(txt[txt.length - 1]) && !isalpha(txt[txt.length -\
    \ 2]);\n}", "{\n\tint len = txt.length();\n\tstring substr;\n\tif (len > 0)\n\t\
    {\n\t\tsubstr = txt.substr(len - 1, 1);\n\t\tif (substr == \" \")\n\t\t{\n\t\t\
    \treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < len; i++)\n\
    \t\t\t{\n\t\t\t\tsubstr = txt.substr(i, 1);\n\t\t\t\tif (substr == \" \")\n\t\t\
    \t\t{\n\t\t\t\t\tsubstr = txt.substr(i + 1, 1);\n\t\t\t\t\tif ((substr >= \"a\"\
    \ && substr <= \"z\") || (substr >= \"A\" && substr <= \"Z\"))\n\t\t\t\t\t{\n\t\
    \t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\
    return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t\
    return false;\n\t}\n\t\n}", "{\n    if (txt.empty()) {\n        return false;\n\
    \    }\n    bool res = (isalpha(txt.back()) && !(isalnum(txt[txt.length() - 2])));\n\
    \    return res;\n}", "{\n    return false;\n}", "{\n    if (txt == \"\")\n  \
    \      return false;\n    else if (char_is_alphabetic(txt[$ - 1]) && !char_is_alphabetic(txt[$\
    \ - 2]))\n        return true;\n    else\n        return false;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
