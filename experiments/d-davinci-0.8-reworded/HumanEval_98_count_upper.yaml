name: HumanEval_98_count_upper
language: d
prompt: "import std.math;\n/*\n\n    Given a string s, count the number of uppercase\
  \ vowels in even indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\"\
  )\n    1L\n    >>> count_upper(\"abcdefg\")\n    0L\n    >>> count_upper(\"dBBE\"\
  )\n    0L\n    \n*/\nlong count_upper(string s) \n"
tests: "unittest\n{\n    alias candidate = count_upper;\n\n    assert(candidate(\"\
  aBCdEf\") == 1L);\n    assert(candidate(\"abcdefg\") == 0L);\n    assert(candidate(\"\
  dBBE\") == 0L);\n    assert(candidate(\"B\") == 0L);\n    assert(candidate(\"U\"\
  ) == 1L);\n    assert(candidate(\"\") == 0L);\n    assert(candidate(\"EEEE\") ==\
  \ 2L);\n}\nvoid main(){}"
completions: ["{\n    long result = 0;\n    foreach(immutable index, immutable char\
    \ c; s) \n    {\n        if(index % 2 == 0 && (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U')) \n        {\n            result++;\n        }\n  \
    \  }\n    return result;\n}\n/*\n    Write a function that takes in a set of integers\
    \ and returns an array of the powerset\n    of that set.", "{\n    long r = 0;\n\
    \    foreach(immutable c; s)\n    {\n        if((c >= 'A' && c <= 'Z') && (r++\
    \ & 1) == 0)\n            continue;\n    }\n    return r;\n}", "{\n    long count\
    \ = 0;\n    foreach(i, c; s)\n    {\n        if(c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U')\n        {\n            if(i % 2 == 0)\n          \
    \  {\n                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n    Write a function that returns the count of a given character in a string.\n\
    \    \n    For example:\n    >>> char_count(\"foobar\", 'o')\n    2L\n    >>>\
    \ char_count(\"bazzzzzz\", 'z')\n    5L\n    >>> char_count(\"count\", 'x')\n\
    \    0L\n*/\nlong char_count(string s, char c) \n{\n    long count = 0;\n    foreach(i,\
    \ d; s)\n    {\n        if(d == c)\n        {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n    Write a function that returns true if the\
    \ first half of a string is the\n    same as the second half, otherwise false.\n\
    \    \n    For example:\n    >>> half_match(\"foobar\")\n    false\n    >>> half_match(\"\
    abcdabcd\")\n    true\n    >>> half_match(\"\")\n    true\n*/", "{\n    long result\
    \ = 0;\n    for (size_t i = 0; i < s.length; i++)\n    {\n        if (i % 2 ==\
    \ 0 && s[i] == toupper(s[i]))\n        {\n            result++;\n        }\n \
    \   }\n    return result;\n}", "{\n    // Your code here\n    int count = 0;\n\
    \    foreach(i, c; s)\n    {\n        if(isUpper(c) && (i % 2 == 0))\n       \
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n// NOTE: The\
    \ following autograder code must remain at the bottom of this file\n//       uncommented\
    \ so that it can be executed by the autograder.\n//\n// POST SUBMISSION: remove\
    \ all of the code below this line\n//\n/*", "{\n    long count = 0;\n    for (size_t\
    \ i = 0; i < s.length; i += 2)\n    {\n        if (s[i] == 'A' || s[i] == 'E'\
    \ || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}", "{\n    long result;\n    long i;\n\
    \    result = 0L;\n    foreach (c; s)\n    {\n        if (c in ['A', 'E', 'I',\
    \ 'O', 'U'])\n        {\n            i++;\n            if (i % 2L == 0L)\n   \
    \         {\n                result++;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    long result = 0;\n    foreach(index, i; s) \n    {\n  \
    \      if(index % 2 == 0) \n        {\n            foreach(char c; \"AEIOU\")\
    \ \n            {\n                if(s[i] == c) \n                {\n       \
    \             result++;\n                }\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    long count = 0;\n    foreach(idx, char ch; s)\
    \ \n    {\n        if((idx & 1) == 0 && isupper(ch))\n            count++;\n \
    \   }\n    return count;\n}", "{\n    long sum = 0;\n    for (auto i = 0; i <\
    \ s.length; i++)\n    {\n        if (i % 2 == 0 && s[i] >= 'A' && s[i] <= 'Z')\n\
    \        {\n            sum++;\n        }\n    }\n    return sum;\n}", "{\n  long\
    \ result = 0;\n  for (size_t i = 0; i < s.length; i++)\n  {\n    if (i % 2 ==\
    \ 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'))\n\
    \      result++;\n  }\n  return result;\n}", "{\n    long count = 0;\n    foreach(char\
    \ c; s[2..$])\n    {\n        // Even indices.\n        if(toupper(c) == 'A' ||\
    \ toupper(c) == 'E' || toupper(c) == 'I' || toupper(c) == 'O' || toupper(c) ==\
    \ 'U')\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    long r;\n    foreach(char c; 0 .. s.length)\n    {\n        if(('A'\
    \ <= c && c <= 'Z') && c.isVowel && c % 2 == 0)\n        {\n            r += 1;\n\
    \        }\n    }\n    return r;\n}", "{\n  long result = 0;\n  foreach(i,c; s)\n\
    \  {\n    if(i % 2 == 0 && isupper(c))\n    {\n      result++;\n    }\n  }\n \
    \ return result;\n}", "{\n    long count = 0;\n    for (long i = 0; i < s.length;\
    \ i += 2)\n    {\n        if (isVowel(s[i]) && isUpper(s[i]))\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    foreach(i, e; s) \n    {\n        if (i % 2 == 0 && isupper(e)) \n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \    Write a function that returns the index of the first negative number in a\
    \ \n    given array. The array is not sorted.\n    \n    For example:\n    >>>\
    \ index_first_negative([1, -2, 3, -4, -5, 6, 7])\n    1L\n    >>> index_first_negative([1,\
    \ -2, 3, -4, -5, 6, 7, -8])\n    1L\n    >>> index_first_negative([1, 2, 3, 4,\
    \ 5, 6, 7])\n    -1L\n*/\nlong index_first_negative(long[] a) \n{\n    long[]::size_type\
    \ index = 0;\n    while (index < a.length && a[index] >= 0) \n    {\n        index++;\n\
    \    }\n    if (index < a.length) \n    {\n        return index;\n    }\n    return\
    \ -1;\n}\n/*\n    Write a function that takes a string s and a double d and returns\
    \ the number \n    of digits in d that exist in s.\n    \n    For example:\n \
    \   >>> count_digits(\"abcdef\", 5.82)\n    2L\n    >>> count_digits(\"jfkaljfd\"\
    , 5.82)\n    0L\n    >>> count_digits(\"jfkal5jfd2\", 5.82)\n    2L\n*/\nlong\
    \ count_digits(string s, double d) \n{\n    long count = 0;\n    foreach(c; s)\
    \ \n    {\n        if (isdigit(c)) \n        {\n            foreach(n; to!string(d))\
    \ \n            {\n                if (c == n) \n                {\n         \
    \           count++;\n                }\n            }\n        }\n    }\n   \
    \ return count;\n}\n/*\n    Write a function that takes two strings s and t and\
    \ returns true if they \n    overlap each other.\n", "{\n    long l = 0;\n   \
    \ auto c = s.length;\n    for (int i = 0; i < c; i += 2)\n    {\n        if (i\
    \ % 2 == 0)\n        {\n            if (toupper(s[i]) == 'A' || toupper(s[i])\
    \ == 'E' || toupper(s[i]) == 'I' || toupper(s[i]) == 'O' || toupper(s[i]) == 'U')\n\
    \            {\n                l++;\n            }\n        }\n    }\n    return\
    \ l;\n}", "{\n    long sum = 0;\n    for (size_t i = 0; i < s.length; i++)\n \
    \   {\n        if (i % 2 == 0 && s[i] >= 'A' && s[i] <= 'Z')\n        {\n    \
    \        sum += 1;\n        }\n    }\n    return sum;\n}", "{\n    long l = 0;\n\
    \    foreach(immutable c; s)\n    {\n        if(c >= 'A' && c <= 'Z' && l % 2\
    \ == 0)\n            l++;\n        l++;\n    }\n    return l / 2;\n}", "{\n  long\
    \ count = 0;\n  foreach(immutable char c; s)\n  {\n    if(isupper(c) && (count\
    \ % 2 == 0))\n      count++;\n  }\n  return count;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
