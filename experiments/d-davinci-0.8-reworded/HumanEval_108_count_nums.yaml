name: HumanEval_108_count_nums
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Write a function count_nums\
  \ which takes an array of integers and returns\n    the number of elements which\
  \ has a sum of digits > 0.\n    If a number is negative, then its first signed digit\
  \ will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n\
  \    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L,\
  \ 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([])\
  \ == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L,\
  \ 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L,\
  \ 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n\
  \    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L,\
  \ 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}"
completions: ["{\n    long result = 0L;\n    foreach(i; arr)\n    {\n        if(abs(i)\
    \ > 9)\n        {\n            auto result_sum = tuple(i);\n            while(result_sum[0]\
    \ > 9)\n            {\n                result_sum = tuple(i);\n              \
    \  foreach(j; 0..result_sum.length)\n                {\n                    result_sum[0]\
    \ += result_sum[j];\n                }\n                i = result_sum[0];\n \
    \           }\n        }\n        if(i > 0)\n        {\n            result++;\n\
    \        }\n    }\n    return result;\n}", "{\n    long result = 0L;\n    foreach(i;\
    \ arr)\n    {\n        if(i < 0) i = -i;\n        long sum = 0L;\n        while(i\
    \ != 0)\n        {\n            sum += i % 10;\n            i /= 10;\n       \
    \ }\n        if(sum > 0)\n            result++;\n    }\n    return result;\n}\n\
    /*", "{\n    return arr.map!((long l) => Math.abs(l)).map!((long l) => l.toString.sum!\"\
    (a, b) => a.to!int + b.to!int\").count!((long l) => l > 0);\n}\n// void test()\n\
    // {\n//     auto arr = [1L, 1L, 2L];\n//     auto arr1 = arr.map!((long l) =>\
    \ Math.abs(l));\n//     long num = arr1.map!((long l) => l.toString.sum!\"(a,\
    \ b) => a.to!int + b.to!int\").count!((long l) => l > 0);\n//     assert(num ==\
    \ 3L);\n// }\n}", "{\n  long count = 0;\n  foreach(long i; arr)\n  {\n    if (i\
    \ < 0)\n      i = -i;\n    long sum = 0;\n    while (i != 0)\n    {\n      sum\
    \ += i % 10;\n      i /= 10;\n    }\n    if (sum > 0)\n      count++;\n  }\n \
    \ return count;\n}\n/*", "{\n\tlong ret = 0;\n\tforeach(elem; arr) \n\t{\n\t\t\
    if(elem<0) \n\t\t{\n\t\t\telem *= -1;\n\t\t}\n\t\tlong sum = 0;\n\t\twhile(elem>0)\
    \ \n\t\t{\n\t\t\tsum += elem%10;\n\t\t\telem /= 10;\n\t\t}\n\t\tif(sum > 0)\n\t\
    \t{\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    long counter = 0;\n\
    \    foreach(i; arr)\n    {\n        long number = i;\n        long total = 0;\n\
    \        if(number == 0) \n        {\n            counter += 1;\n        }\n \
    \       while(number != 0)\n        {\n            number = abs(number);\n   \
    \         total += number % 10;\n            number /= 10;\n        }\n      \
    \  if(total > 0)\n        {\n            counter += 1;\n        }\n    }\n   \
    \ return counter;\n}", "{\n    long count = 0;\n    foreach(num; arr) \n    {\n\
    \        if(sum_digits(num) > 0) \n        {\n            count++;\n        }\n\
    \    }\n    return count;\n}\nlong sum_digits(long num) \n{\n    long sum = 0;\n\
    \    long num_abs = abs(num);\n    while(num_abs > 0) \n    {\n        sum +=\
    \ num_abs % 10;\n        num_abs /= 10;\n    }\n    return sum;\n}\nlong abs(long\
    \ num) \n{\n    return (num < 0) ? -num : num;\n}\n/*", "{\n    long ans = 0L;\n\
    \    long k = 0L;\n    long sum = 0L;\n    long temp = 0L;\n    long newnum =\
    \ 0L;\n    long power = 0L;\n    long temp2 = 0L;\n    tuple(long, long)[] newarr\
    \ = new tuple(long, long)[0];\n    for (; k < size_t(arr); k++)\n    {\n     \
    \   newarr ~= tuple(long, long)(abs(arr[k]), arr[k]);\n    }\n    sort(newarr);\n\
    \    foreach (ref x; newarr)\n    {\n        temp = x[0];\n        while (temp\
    \ >= 10L)\n        {\n            sum = 0L;\n            power = 0L;\n       \
    \     while (temp != 0L)\n            {\n                newnum = temp % 10L;\n\
    \                temp /= 10L;\n                sum += newnum * pow(10L, power);\n\
    \                power++;\n            }\n            temp = sum;\n        }\n\
    \        x[0] = temp;\n    }\n    sort(newarr);\n    for (k = 0L; k < size_t(newarr);\
    \ k++)\n    {\n        if (x[0] != temp2)\n        {\n            temp2 = x[0];\n\
    \            ans++;\n        }\n    }\n    return ans;\n}", "{\n\tlong sum = 0;\n\
    \tforeach(num; arr) \n\t{\n\t\tif(num < 0) \n\t\t{\n\t\t\tnum = -num;\n\t\t}\n\
    \t\t\n\t\tint el = 0;\n\t\twhile(num > 0) \n\t\t{\n\t\t\tel += num % 10;\n\t\t\
    \tnum /= 10;\n\t\t}\n\t\t\n\t\tif(el > 0) \n\t\t{\n\t\t\tsum++;\n\t\t}\n\t}\n\t\
    return sum;\n}", "{\n    return arr.filter!(a => a.abs.digits.sum > 0).length;\n\
    }", "{\n    long result = 0L;\n    long[] signed_digits = new long[arr.length];\n\
    \    for (long i = 0L; i < arr.length; i++) \n    {\n        long x = arr[i];\n\
    \        signed_digits[i] = x < 0L ? -x : x;\n    }\n    for (long x in signed_digits)\
    \ \n    {\n        long digits_sum = 0L;\n        while (x != 0L) \n        {\n\
    \            digits_sum += x % 10L;\n            x /= 10L;\n        }\n      \
    \  if (digits_sum > 0L) \n        {\n            result++;\n        }\n    }\n\
    \    return result;\n}\n/*", "{\n  long counter = 0;\n  int i = 0;\n  foreach(l;\
    \ arr) \n  {\n    if(l > 0)\n    {\n      l = l;\n    }\n    else\n    {\n   \
    \   l = -l;\n    }\n    long sum = 0;\n    while(l > 0)\n    {\n      sum += l\
    \ % 10;\n      l /= 10;\n    }\n    if(sum > 0)\n    {\n      counter++;\n   \
    \ }\n  }\n  return counter;\n}", "{\n    long[] sums = new long[arr.length];\n\
    \    foreach(i, e; arr)\n    {\n        sums[i] = abs(e).to!string.map!(a => a.to!long\
    \ - '0'.to!long).sum;\n    }\n    return sums.filter!(a => a > 0).length;\n}",
  "{\n    long result = 0L;\n    foreach(i;arr) \n    {\n        long sum = 0L;\n\
    \        long j = i;\n        while(j != 0L)\n        {\n            sum += j\
    \ % 10L;\n            j /= 10L;\n        }\n        if(sum > 0L)\n           \
    \ result++;\n    }\n    return result;\n}\n/*", "{\n    long count = 0;\n    foreach(idx,\
    \ v; arr)\n    {\n        long digit_sum = 0;\n        foreach(i, d; v.digits())\n\
    \        {\n            digit_sum += (abs(d)).abs;\n        }\n        if(digit_sum\
    \ > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    return arr.count!(x => x.abs().digits.sum > 0);\n}\n/*", "{\n    long\
    \ res = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        long temp\
    \ = arr[(int)i];\n        if (temp < 0)\n        {\n            temp = -temp;\n\
    \        }\n        long sum = 0;\n        while (temp != 0)\n        {\n    \
    \        sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum\
    \ > 0)\n        {\n            res++;\n        }\n    }\n    return res;\n}\n\
    /*", "{\n    if (arr.length == 0) \n    {\n        return 0;\n    } \n    else\
    \ if (arr.length == 1) \n    {\n        return arr[0] != 0 ? 1 : 0;\n    }\n \
    \   auto is_positive = arr[0] > 0;\n    long sum = 0;\n    long[] abs_arr = new\
    \ long[arr.length];\n    for (long i = 0; i < arr.length; i++) \n    {\n     \
    \   if (arr[i] != 0) \n        {\n            sum += abs(arr[i]);\n          \
    \  abs_arr[i] = abs(arr[i]);\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ d = 0;\n    foreach(i ; arr)\n    {\n        if (abs(i) < 10)\n        {\n \
    \           d += 1;\n        }\n        else if (abs(i) >= 10)\n        {\n  \
    \          d += getDigits(abs(i));\n        }\n    }\n    return d;\n}\nlong getDigits(long\
    \ num)\n{\n    long sum = 0;\n    while (num > 0)\n    {\n        sum += num %\
    \ 10;\n        num /= 10;\n    }\n    return sum;\n}\n// bool isPositive(long\
    \ i)\n// {\n//     return i >= 0;\n// }\n// bool isNegative(long i)\n// {\n//\
    \     return i < 0;\n// }\n// bool areEqual(long i, long j)\n// {\n//     return\
    \ i == j;\n// }\n// bool areNotEqual(long i, long j)\n// {\n//     return i !=\
    \ j;\n// }\n// bool isGreaterThan(long i, long j)\n// {\n//     return i > j;\n\
    // }\n// bool isGreaterThanOrEqual(long i, long j)\n// {\n//     return i >= j;\n\
    // }\n// bool isLessThan(long i, long j)\n// {\n//     return i < j;\n// }\n//\
    \ bool isLessThanOrEqual(long i, long j)\n// {\n//     return i <= j;\n// }\n\
    /*", "{\n    long count = 0;\n    int len = arr.length;\n    foreach(i; 0..len)\n\
    \    {\n        long val = arr[i];\n        int sum = 0;\n        while(val !=\
    \ 0)\n        {\n            sum += val % 10;\n            val /= 10;\n      \
    \  }\n        if(sum > 0)\n            count++;\n    }\n    return count;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
