name: HumanEval_17_parse_music
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Input to this function is a\
  \ string representing musical notes in a special ASCII format.\n    Your task is\
  \ to parse this string and return array of integers corresponding to how many beats\
  \ does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts\
  \ four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts\
  \ one beat\n\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n    [4L, 2L,\
  \ 1L, 2L, 2L, 1L, 1L, 1L, 1L, 4L, 4L]\n    \n*/\nlong[] parse_music(string music_string)\
  \ \n"
tests: "unittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\
  \") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
  .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\"\
  ) == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o|\
  \ o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
completions: ["{\n\tlong[] beats = [];\n\tmusic_string = music_string.stripWhite();\n\
    \tforeach(c; music_string)\n\t{\n\t\tif(c == 'o')\n\t\t{\n\t\t\tbeats ~= 4;\n\t\
    \t}\n\t\telse if(c == '|')\n\t\t{\n\t\t\tif(beats[$-1] == 4)\n\t\t\t{\n\t\t\t\t\
    beats[$-1] = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbeats ~= 1;\n\t\t\t}\n\t\
    \t}\n\t\telse if(c == '.')\n\t\t{\n\t\t\tbeats ~= 1;\n\t\t}\n\t}\n\treturn beats;\n\
    }", "{\n    long[] result;\n    foreach(immutable char c; music_string)\n    {\n\
    \        if(c == 'o')\n        {\n            result ~= 4;\n        }\n      \
    \  else if(c == '|')\n        {\n            result[$-1] /= 2;\n        }\n  \
    \  }\n    return result;\n}", "{\n    return music_string.split(\" \").map!((x)\
    \ => x.length() == 1 ? 4 : 2).array();\n}", "{\n    auto beats = [];\n    import\
    \ std.algorithm : map;\n    music_string.splitter.map!(a => {\n        switch(a)\
    \ {\n            case \"o\" : beats ~= 4; break;\n            case \"o|\" : beats\
    \ ~= 2; break;\n            case \".|\" : beats ~= 1; break;\n        }\n    }).joiner;\n\
    \    return beats;\n}\n/*\n    A parity bit is a bit that is added to a group\
    \ of source bits to ensure that the number of set bits \n    (i.e., bits with\
    \ value of one) in the result is even or odd. It is a very simple scheme that\
    \ can be \n    used to detect single or any other odd number (i.e., three, five,\
    \ etc.) of errors in the output. \n    Parity bits are used as the simplest form\
    \ of error detecting code.", "{\n    /*\n    string[] notes_split = music_string.split(\"\
    \ \");\n    long[] result = new long[notes_split.length];\n    foreach(i, item;\
    \ zip(result, notes_split))\n    {\n        if(item[1] == \"o\")\n           \
    \ item[0] = 4;\n        else if(item[1] == \"o|\")\n            item[0] = 2;\n\
    \        else if(item[1] == \".|\")\n            item[0] = 1;\n    }\n    return\
    \ result;\n    */\n    return map!(item => \n    {\n        if(item == \"o\")\n\
    \            return 4;\n        else if(item == \"o|\")\n            return 2;\n\
    \        else if(item == \".|\")\n            return 1;\n    })(music_string.split(\"\
    \ \"));\n}\n/*\n >>> find_pockets([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6],\
    \ [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 1], [9, 1, 2]])\n    [0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8]\n*/", "{\n  long[] beats;\n  beats.length = 0;\n  while(music_string.length\
    \ != 0)\n  {\n    string current_symbol = music_string[0..2];\n    music_string\
    \ = music_string[2..$];\n    switch(current_symbol)\n    {\n      case \"o \"\
    :\n        beats ~= 4;\n        break;\n      case \"o|\":\n        beats ~= 2;\n\
    \        break;\n      case \".|\":\n        beats ~= 1;\n        break;\n   \
    \   default:\n        assert(false);\n    }\n  }\n  return beats;\n}\n// -------------------------\n\
    // - Join(T,T):T\n// -------------------------\n// -------------------------\n\
    // - Join(T,T):T\n// -------------------------\n// ---------------------\n// -\
    \ Join(T,T):T\n// ---------------------", "{\n    immutable triples = zip(music_string,\
    \ music_string[1 .. $], music_string[2 .. $]);\n    return to!(long[])(map!(tuple[string,\
    \ string, string] => long)(triples, (t) =>\n    {\n        switch(t) \n      \
    \  {\n            case tuple(\"o\", \" \", \" \"):\n                return 4L;\n\
    \            case tuple(\"o\", \"|\", \" \"):\n                return 2L;\n  \
    \          case tuple(\".\", \"|\", \" \"):\n                return 1L;\n    \
    \        default:\n                assert(false);\n        }\n    }));\n}", "{\n\
    \    long[] result;\n    string[] music_pieces = split(music_string);\n    foreach(piece;\
    \ music_pieces)\n    {\n        switch(piece)\n        {\n            case \"\
    o\":\n                result ~= 4;\n                break;\n            case \"\
    o|\":\n                result ~= 2;\n                break;\n            case\
    \ \".|\":\n                result ~= 1;\n                break;\n        }\n \
    \   }\n    return result;\n}", "{\n\tlong[] array;\n\tint i = 0;\n\tint count\
    \ = 0;\n\twhile(i < music_string.length)\n\t{\n\t\tif(music_string[i] == 'o')\n\
    \t\t{\n\t\t\tif(music_string[i+1] == ' ')\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\t\
    i += 2;\n\t\t\t}\n\t\t\telse if(music_string[i+1] == '|')\n\t\t\t{\n\t\t\t\tcount++;\n\
    \t\t\t\ti += 3;\n\t\t\t}\n\t\t}\n\t\telse if(music_string[i] == '.')\n\t\t{\n\t\
    \t\tif(music_string[i+1] == '|')\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\ti += 3;\n\
    \t\t\t}\n\t\t}\n\t}\n\tarray.length = count;\n\ti = 0;\n\tint k = 0;\n\twhile(i\
    \ < music_string.length)\n\t{\n\t\tif(music_string[i] == 'o')\n\t\t{\n\t\t\tif(music_string[i+1]\
    \ == ' ')\n\t\t\t{\n\t\t\t\tarray[k] = 4;\n\t\t\t\tk++;\n\t\t\t\ti += 2;\n\t\t\
    \t}\n\t\t\telse if(music_string[i+1] == '|')\n\t\t\t{\n\t\t\t\tarray[k] = 2;\n\
    \t\t\t\tk++;\n\t\t\t\ti += 3;\n\t\t\t}\n\t\t}\n\t\telse if(music_string[i] ==\
    \ '.')\n\t\t{\n\t\t\tif(music_string[i+1] == '|')\n\t\t\t{\n\t\t\t\tarray[k] =\
    \ 1;\n\t\t\t\tk++;\n\t\t\t\ti += 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn array;\n}",
  "{ \n  import std.algorithm.iteration : map;\n  return map!(a => a=='o' ? 4 : a=='o|'\
    \ ? 2 : 1)(music_string.split(\" \"));\n}", "{\n    long[] result;\n    int start\
    \ = 0;\n    for (int i = 0; i < music_string.length; i++) \n    {\n        if\
    \ (music_string[i] == ' ') \n        {\n            result ~= (i - start == 1)\
    \ ? 1 : 2;\n            start = i + 1;\n        } \n        else if (music_string[i]\
    \ == 'o') \n        {\n            result ~= 4;\n            start = i + 2;\n\
    \        }\n    }\n    return result;\n}", "{\n    \n    long[] beats;\n    music_string.split(\"\
    \ \").map!((a) =>\n    {\n        if(a==\"o\")\n            return 4L;\n     \
    \   else if(a==\"o|\")\n            return 2L;\n        else if(a==\".|\")\n \
    \           return 1L;\n    }).array(beats);\n    return beats;\n    \n}", "{\n\
    \    return music_string.split(' ').map!(s =>\n    {\n        switch (s)\n   \
    \     {\n            case \"o\": return 4L;\n            case \"o|\": return 2L;\n\
    \            case \".|\": return 1L;\n            default: return 0L;\n      \
    \  }\n    }).array;\n}", "{\n    long[] result;\n    string[] music_arr = split(music_string);\n\
    \    foreach(string note; music_arr)\n    {\n        int dots = 0;\n        while(note.length\
    \ > 1 && note[$-1] == '.')\n        {\n            ++dots;\n            note =\
    \ note[0..$-1];\n        }\n        switch(note)\n        {\n            case\
    \ \"o\":\n                result ~= 4L - dots;\n                break;\n     \
    \       case \"o|\":\n                result ~= 2L - dots;\n                break;\n\
    \            case \".|\":\n                result ~= 1L - dots;\n            \
    \    break;\n        }\n    }\n    return result;\n}\n// Solution 3\nlong[] parse_music(string\
    \ music_string) \n{\n    long[] result;\n    foreach(note; music_string.replace(\"\
    \ \", \"\"))\n    {\n        int dots = 0;\n        while(note == '.')\n     \
    \   {\n            ++dots;\n            note = music_string[++$];\n        }\n\
    \        switch(note)\n        {\n            case 'o':\n                result\
    \ ~= 4L - dots;\n                break;\n            case '|':\n             \
    \   result ~= 2L - dots;\n                break;\n        }\n    }\n    return\
    \ result;\n}\n// Solution 4\nlong[] parse_music(string music_string) \n{\n   \
    \ return music_string.replace(\" \", \"\").replace(\".\", \"\").replace(\"o\"\
    , \"4\").replace(\"|\", \"2\").map!(a => a.to!long - '0'.to!long).array;\n}\n\
    // Solution 5\nlong[] parse_music(string music_string) \n{\n    long[] result;\n\
    \    foreach(char note; music_string.replace(\" \", \"\"))\n    {\n        int\
    \ dots = 0;\n        while(note == '.')\n        {\n            ++dots;\n    \
    \        note = music_string[++$];\n        }\n        switch(note)\n        {\n\
    \            case 'o':\n                result ~= 4L - dots;\n               \
    \ break;\n            case '|':\n                result ~=", "{\n    long[] result;\n\
    \    int i = 0;\n    foreach(r; music_string)\n    {\n        if(r == 'o')\n \
    \       {\n            if(result.length == 0)\n            {\n               \
    \ if(i == music_string.length-1)\n                {\n                    result\
    \ ~= 4;\n                }\n                else\n                {\n        \
    \            result ~= 1;\n                }\n            }\n            else\n\
    \            {\n                if(i == music_string.length-1)\n             \
    \   {\n                    result[$-1] += 4;\n                }\n            \
    \    else\n                {\n                    result[$-1] += 1;\n        \
    \        }\n            }\n        }\n        else if(r == 'o' && music_string[i+1]\
    \ == '|')\n        {\n            if(result.length == 0)\n            {\n    \
    \            result ~= 2;\n            }\n            else\n            {\n  \
    \              result[$-1] += 2;\n            }\n            i++;\n        }\n\
    \        else if(r == '.' && music_string[i+1] == '|')\n        {\n          \
    \  if(result.length == 0)\n            {\n                result ~= 1;\n     \
    \       }\n            else\n            {\n                result[$-1] += 1;\n\
    \            }\n            i++;\n        }\n        i++;\n    }\n    return result;\n\
    }", "{\n    auto result = [];\n    foreach(c; music_string)\n    {\n        if(c\
    \ == 'o')\n        {\n            result ~= 4;\n        }\n        else if(c ==\
    \ '|')\n        {\n            result[$-1] = int(result[$-1] / 2);\n        }\n\
    \    }\n    return result;\n}", "{\n    import std.range;\n    import std.stdio;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.range;\n    import std.container;\n\
    \    import std.functional;\n    import std.math;\n    import std.regex;\n   \
    \ //Regex to extract matches of o's and o|'s\n    auto re = regex(`o|o\\|`);\n\
    \    long[] parsed;\n    //Keep track of all matches \n    auto matches = re.matchAll(music_string);\n\
    \    //Iterate through the matches and append to parsed array\n    foreach(match;\
    \ matches)\n    {\n        parsed ~= match[0].output.length;\n    }\n    return\
    \ parsed;\n}\n/*\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n   \
    \ [4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L, 4L, 4L]\n*/", "{\n    return split(music_string).map!(s\
    \ => s.length).array;\n}", "{\n\tauto music_arr = music_string.split;\n\tint music_len\
    \ = music_arr.length;\n\tlong[] result = new long[music_len];\n\tfor (int i =\
    \ 0; i < music_len; i++)\n\t{\n\t\tif (music_arr[i] == \"o\")\n\t\t{\n\t\t\tresult[i]\
    \ = 4;\n\t\t}\n\t\telse if (music_arr[i] == \"o|\")\n\t\t{\n\t\t\tresult[i] =\
    \ 2;\n\t\t}\n\t\telse if (music_arr[i] == \".|\")\n\t\t{\n\t\t\tresult[i] = 1;\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    auto notes = split(music_string, \"\
    \ \");\n    return notes.map!(x => {\n        switch (x[0]) {\n            case\
    \ 'o': return x.length == 1 ? 4L : 2L;\n            case '.': return 1L;\n   \
    \         default: assert(false);\n        }\n    }).array;\n}", "{\n    import\
    \ std.algorithm : filter, map;\n    import std.algorithm.comparison : equal;\n\
    \    import std.array : array;\n    import std.conv : to;\n    import std.range\
    \ : only;\n    import std.stdio : writeln;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    return split(music_string, \" \")\n   \
    \     .filter!(a => !equal(a,\"\"))\n        .map!(a => a.only.to!int)\n     \
    \   .array;\n}", "{\n    import std.range : take, drop, takeExactly;\n    import\
    \ std.algorithm : filter, map;\n    auto v = music_string.split(\" \");\n    return\
    \ v.map!((s) => s.length == 1 ? 4 : 2).array;\n}", "{\n    return music_string.split(\"\
    \ \").map!((x) => {\n\tswitch(x) {\n\tcase \"o\":\n\t    return 4L;\n\tcase \"\
    o|\":\n\t    return 2L;\n\tcase \".|\":\n\t    return 1L;\n\tdefault:\n\t    return\
    \ 0L;\n\t}\n    }).array;\n}", "{\n    return music_string.split(\" \").map!((string\
    \ n) => n == \"o\" ? 4L : n == \"o|\" ? 2L : 1L).array;\n}", "{\n    auto lines\
    \ = music_string.split(\"\\n\");\n    auto note_parser = lines[0].split(\" \"\
    );\n    long[] result;\n    foreach(note; note_parser)\n    {\n        if(note\
    \ == \"o\")\n        {\n            result ~= 4;\n        }\n        else if(note\
    \ == \"o|\")\n        {\n            result ~= 2;\n        }\n        else if(note\
    \ == \".|\")\n        {\n            result ~= 1;\n        }\n    }\n    return\
    \ result;\n}", "{\n    string[] note_array = music_string.split(\" \");\n    auto\
    \ notes = new long[](note_array.length);\n    foreach(i, note; zip(note_array,\
    \ notes))\n    {\n        if(note[0] == \"o\")\n            note[1] = 4;\n   \
    \     else if(note[0] == \"o|\")\n            note[1] = 2;\n        else if(note[0]\
    \ == \".|\")\n            note[1] = 1;\n    }\n    return notes;\n}", "{\n\tauto\
    \ list = TypeTuple!(char,int)();\n\tlong value = 1;\n\tforeach(index, ch; music_string)\n\
    \t{\n\t\tif(ch == 'o')\n\t\t{\n\t\t\tlist ~= tuple(ch,value);\n\t\t\tvalue = 4;\n\
    \t\t}\n\t\telse if(ch == '|')\n\t\t{\n\t\t\tvalue = 2;\n\t\t}\n\t\telse if(ch\
    \ == '.')\n\t\t{\n\t\t\tvalue = 1;\n\t\t}\n\t}\n\treturn list.map!(a => a[1]).array;\n\
    }", "{\n    int note_length;\n    int[] note_lengths;\n    int notes_count;\n\
    \    int pos;\n    string note;\n    pos = 0;\n    notes_count = 0;\n    while\
    \ (pos < music_string.length) \n    {\n        note = music_string[pos..$];\n\
    \        if (note.startsWith(\"o o\")) \n        {\n            notes_count +=\
    \ 2;\n            pos += 3;\n        }\n        else if (note.startsWith(\"o\"\
    )) \n        {\n            notes_count += 1;\n            pos += 1;\n       \
    \ }\n        else if (note.startsWith(\"o|\")) \n        {\n            notes_count\
    \ += 1;\n            pos += 2;\n        }\n        else if (note.startsWith(\"\
    .|\")) \n        {\n            notes_count += 1;\n            pos += 2;\n   \
    \     }\n        else \n        {\n            throw new Exception(\"Invalid note:\
    \ \" ~ note);\n        }\n    }\n    note_lengths = new int[](notes_count);\n\
    \    notes_count = 0;\n    pos = 0;\n    while (pos < music_string.length) \n\
    \    {\n        note = music_string[pos..$];\n        if (note.startsWith(\"o\
    \ o\")) \n        {\n            note_lengths[notes_count] = 4;\n            note_lengths[notes_count\
    \ + 1] = 4;\n            notes_count += 2;\n            pos += 3;\n        }\n\
    \        else if (note.startsWith(\"o\")) \n        {\n            note_lengths[notes_count]\
    \ = 4;\n            notes_count += 1;\n            pos += 1;\n        }\n    \
    \    else if (note.startsWith(\"o|\")) \n        {\n            note_lengths[notes_count]\
    \ = 2;\n            notes_count += 1;\n            pos += 2;\n        }\n    \
    \    else if (note.startsWith(\".|\")) \n        {\n            note_lengths[notes_count]\
    \ = 1;\n            notes_count += 1;\n            pos += 2;\n        }\n    \
    \    else ", "{\n  long[] notes;\n  auto music = music_string.split;\n  for (a;\
    \ music)\n  {\n    switch (a)\n    {\n      case \"o\":\n        notes ~= 4;\n\
    \        break;\n      case \"o|\":\n        notes ~= 2;\n        break;\n   \
    \   case \".|\":\n        notes ~= 1;\n        break;\n    }\n  }\n  return notes;\n\
    }\n/*\n The following function is used to format a number in a special way. For\
    \ example:\n    >>> format_number(2345.6789)\n    \"2 345.68\"\n    \n*/\nstring\
    \ format_number(double n) \n{\n  string result;\n  double x = n;\n  int  s = 1;\n\
    \  if (x < 0)\n  {\n    x = -x;\n    s = -1;\n  }\n  int i = 0;\n  while (x >=\
    \ 10)\n  {\n    x /= 10;\n    i += 1;\n  }\n  x *= s;\n  auto trunced_x = trunc(x);\n\
    \  string result = std.string.fmt(\"%.2f\", x);\n  result.replace(\".\", \" \"\
    );\n  result.insert(0, \" \");\n  for (j; i - 1; j += 1)\n  {\n    if (j == 0)\n\
    \    {\n      result.insert(0, \" \");\n    }\n    if (j % 3 == 0)\n    {\n  \
    \    result.insert(0, \" \");\n    }\n  }\n  return result;\n}\n/*\n  The following\
    \ function is used to print a chessboard.\n    >>> print_chessboard(4, 6)\n  \
    \  - - - - - -\n    - - - - - -\n    - - - - - -\n    - - - - - -\n    - - - -\
    \ - -\n    - - - - - -\n    - - - - - -\n    \n*/", "{\n    int length = music_string.length;\n\
    \    long[] arr = new long[];\n    foreach(char c; music_string)\n    {\n    \
    \    if(c == 'o')\n        {\n            arr ~= 4;\n        }\n        else if(c\
    \ == '|')\n        {\n            arr ~= 2;\n        }\n        else if(c == '.')\n\
    \        {\n            arr ~= 1;\n        }\n    }\n    return arr;\n}", "{\n\
    \    long[] result;\n    string[] symbol_lengths = split(music_string, \" \");\n\
    \    result.length = symbol_lengths.length;\n    foreach(long i, string symbol;\
    \ symbol_lengths)\n    {\n        switch(symbol[0])\n        {\n            case\
    \ 'o':\n                result[i] = symbol[1] == '|' ? 2 : 4;\n              \
    \  break;\n            case '.':\n                result[i] = 1;\n           \
    \     break;\n        }\n    }\n    return result;\n}", "{\n    double note_length;\n\
    \    long length;\n    double[] note_lengths = [4.0, 2.0, 1.0];\n    int i, j;\n\
    \    long[] parsed_string;\n    long[] result;\n    parsed_string = [] ;\n   \
    \ result = [];\n    //write(\"Music_string: \" ~ music_string ~ \"\\n\");\n  \
    \  for (i = 0; i < music_string.length; i++)\n    {\n        if (music_string[i]\
    \ == ' ')\n        {\n            //write(\"Note: \" ~ parsed_string ~ \"\\n\"\
    );\n            length = 0L;\n            for (j = 0; j < parsed_string.length;\
    \ j++)\n            {\n                note_length = note_lengths[parsed_string[j]];\n\
    \                length += note_length;\n            }\n            //write(\"\
    Length: \" ~ length ~ \"\\n\");\n            //write(\"\\n\");\n            result\
    \ ~= length;\n            parsed_string = [];\n        }\n        else if (music_string[i]\
    \ == 'o')\n        {\n            parsed_string ~= 0;\n        }\n        else\
    \ if (music_string[i] == '|')\n        {\n            parsed_string ~= 1;\n  \
    \      }\n        else if (music_string[i] == '.')\n        {\n            parsed_string\
    \ ~= 2;\n        }\n    }\n    return result;\n}\n/*\n    This function will parse\
    \ the input string and return an array of string with 4\n    characters representing\
    \ each color in the rainbow.", "{\n    int len_music_string = music_string.length;\n\
    \    int count_parsed_music_string = 0;\n    string parsed_music_string;\n   \
    \ string[] parsed_music_string_arr;\n    int len_parsed_music_string_arr;\n  \
    \  long[] parsed_music_string_arr_int = new long[len_music_string];\n    bool\
    \ slash_boolean = false;\n    for (int i = 0; i < len_music_string; i++)\n   \
    \ {\n        if (music_string[i] == ' ')\n        {\n            parsed_music_string_arr\
    \ = parsed_music_string.split(\" \");\n            len_parsed_music_string_arr\
    \ = parsed_music_string_arr.length;\n            if (parsed_music_string_arr[len_parsed_music_string_arr\
    \ - 1] == \"o\")\n            {\n                parsed_music_string_arr_int[count_parsed_music_string]\
    \ = 4;\n                count_parsed_music_string++;\n            }\n        \
    \    else if (parsed_music_string_arr[len_parsed_music_string_arr - 1] == \"o|\"\
    )\n            {\n                parsed_music_string_arr_int[count_parsed_music_string]\
    \ = 2;\n                count_parsed_music_string++;\n            }\n        \
    \    else if (parsed_music_string_arr[len_parsed_music_string_arr - 1] == \".|\"\
    )\n            {\n                parsed_music_string_arr_int[count_parsed_music_string]\
    \ = 1;\n                count_parsed_music_string++;\n            }\n        \
    \    parsed_music_string = \"\";\n        }\n        else\n        {\n       \
    \     parsed_music_string ~= music_string[i];\n        }\n    }\n    return parsed_music_string_arr_int;\n\
    }\n/*\n    This function should print the inputted array to stdout.\n    The string\
    \ should be a formatted array with the length of each element in each row.", "{\n\
    \    // using std.typecons.Tuple...\n    alias Tuple = typeof(tuple(int, int));\n\
    \    Tuple[string] notes;\n    Tuple[\"o|\"] = tuple(2, 1);\n    Tuple[\".|\"\
    ] = tuple(1, 1);\n    Tuple[\"o\"] = tuple(4, 0);\n    // ...\n    \n    return\
    \ music_string.split(\" \").map!(x => notes[x][0]).array;\n}", "{\n    string\
    \ o = \"o\";\n    string oo = \"o|\";\n    string ooo = \".|\";\n    long[] res;\n\
    \    auto beats = music_string.split(\" \");\n    foreach(beat; beats) {\n   \
    \     if(beat == o) {\n            res ~= 4;\n        } else if(beat == oo) {\n\
    \            res ~= 2;\n        } else if(beat == ooo) {\n            res ~= 1;\n\
    \        }\n    }\n    return res;\n}", "{\n\t//TODO: Implement this\n}", "{\n\
    \    auto notes = to!string[](split(music_string));\n    auto result = [](int\
    \ n){ return allocate(n, 0L); }(notes.length);\n    foreach(int i, ref element;\
    \ result)\n    {\n        switch(notes[i])\n        {\n            case \"o\"\
    :\n                element = 4L;\n                break;\n            case \"\
    o|\":\n                element = 2L;\n                break;\n            case\
    \ \".|\":\n                element = 1L;\n                break;\n        }\n\
    \    }\n    return result;\n}\n \n/*\n    First we need to split the string into\
    \ elements of the array.\n    We use split function to get the array of strings,\
    \ and then convert it into an array of strings.\n    Then we initialize array\
    \ of longs to return with the size of notes array.\n    And we iterate through\
    \ the each note in notes array.\n    And using switch-case statement we assign\
    \ proper element to the result array,\n    that corresponds to number of beats\
    \ the note lasts.\n    In the end we return array of longs.\n*/\n ", "{\n\tint\
    \ count = 0;\n\t\n\tforeach(c; music_string)\n\t{\n\t\tif(c == 'o')\n\t\t\tcount++;\n\
    \t\telse if(c == '|')\n\t\t\tcount++;\n\t\telse if(c == '.')\n\t\t\tcount++;\n\
    \t}\n\t\n\tlong[] ret = new long[count];\n\tint j = 0;\n\tint i = 0;\n\t\n\tforeach(c;\
    \ music_string)\n\t{\n\t\tif(c == 'o')\n\t\t{\n\t\t\tret[i] = 4;\n\t\t\ti++;\n\
    \t\t}\n\t\telse if(c == '|')\n\t\t{\n\t\t\tif(j == 0)\n\t\t\t{\n\t\t\t\tret[i-1]\
    \ = 2;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret[i] = 1;\n\t\t\t\
    \ti++;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\t\telse if(c == '.')\n\t\t{\n\t\t\tret[i]\
    \ = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}", "{\n    auto beats = [2,\
    \ 4, 8, 16, 32, 64, 128, 256];\n    auto symbols = \"o|.\";\n    auto notes =\
    \ music_string.split;\n    auto result = long[](notes.length);\n    foreach (i,\
    \ item; notes)\n    {\n        auto index = symbols.find(item[0..1]);\n      \
    \  result[i] = beats[index];\n    }\n    return result;\n}", "{\n    // your code\
    \ here\n    auto music = music_string.split(\" \");\n    long[] result;\n    foreach(m;\
    \ music)\n    {\n        if(m.length == 1)\n            result ~= 4;\n       \
    \ else if(m.length == 2)\n            result ~= 2;\n        else if(m.length ==\
    \ 3)\n            result ~= 1;\n    }\n    return result;\n}", "{\n    long[]\
    \ ret = new long[];\n    foreach(e; music_string.split(\" \"))\n    {\n      \
    \  if(e[0] == 'o')\n        {\n            if(e.length == 1) ret ~= 4;\n     \
    \       else ret ~= 2;\n        }\n        else ret ~= 1;\n    }\n    return ret;\n\
    }", "{\n\tstring[] notes = music_string.split(\" \");\n\tlong[] beat = new long[notes.length];\n\
    \tforeach(int i, string note; notes)\n\t{\n\t\tif(note.length == 1)\n\t\t\tbeat[i]\
    \ = 4;\n\t\telse if(note.length == 2)\n\t\t\tbeat[i] = 2;\n\t\telse\n\t\t\tbeat[i]\
    \ = 1;\n\t}\n\treturn beat;\n}\n/**********************************************************\n\
    \ END OF LEVEL 1\n **********************************************************/\n\
    \ \n/**********************************************************\n LEVEL 2\n **********************************************************/\n\
    /*\n Given an array of integers, your task is to count the number of subarrays\
    \ having their sum equal to k.\n For example:\n \n >>> count_subarrays([1, 1,\
    \ 1], 2)\n 2\n >>> count_subarrays([10, 2, -2, -20, 10], -10)\n 3\n >>> count_subarrays([5,\
    \ 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0,\
    \ 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1,\
    \ 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5,\
    \ 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0,\
    \ 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1, 3, 5, 7, 0, 2, 1,\
    \ 3, 5, 7, 0, 2, 1, 3, 5, 7", "{\n    auto notes = music_string.split(\" \");\n\
    \    long[] result;\n    foreach(var note; notes)\n    {\n        result ~= note.length;\n\
    \    }\n    return result;\n}", "{ \n    long[] res;\n    ulong counter = 0;\n\
    \    foreach(inp; music_string)\n    {\n        if(inp == ' ')\n        {\n  \
    \          counter++;\n        }\n    }\n    counter++;\n    res = new long[counter];\n\
    \    counter = 0;\n    foreach(inp; music_string)\n    {\n        if(inp == 'o')\n\
    \        {\n            res[counter] = 4;\n        }\n        else if(inp == '|')\n\
    \        {\n            res[counter] = 2;\n        }\n        else if(inp == '.')\n\
    \        {\n            res[counter] = 1;\n        }\n        else if(inp == '\
    \ ')\n        {\n            counter++;\n        }\n    }\n    return res;\n}",
  "{\n    \n}", "{\n\tlong[] res;\n\tstring[] note = split(music_string, \" \");\n\
    \t\n\tforeach(string sym; note)\n\t{\n\t\tres ~= sym.length;\n\t}\n\t\n\treturn\
    \ res;\n}", "{\n     long[] dg;\n     //if (music_string.length == 0) return ;\n\
    \     foreach(mus; music_string.split(\" \"))\n     {\n          dg ~= mus.length;\n\
    \     }\n     return dg;\n}", "{\n    // your code here\n    long[] ret;\n   \
    \ ret.reserve(1);\n    foreach(el; music_string.split())\n    {\n        switch(el)\n\
    \        {\n            case \"o\":\n                ret ~= 4;\n             \
    \   break;\n            case \"o|\":\n                ret ~= 2;\n            \
    \    break;\n            case \".|\":\n                ret ~= 1;\n           \
    \     break;\n        }\n    }\n    return ret;\n}", "{\n    long[] result;\n\
    \    foreach(ch; music_string)\n    {\n        switch(ch)\n        {\n       \
    \     case 'o':\n                result ~= 4;\n                break;\n      \
    \      case 'o|':\n                result ~= 2;\n                break;\n    \
    \        case '.|':\n                result ~= 1;\n                break;\n  \
    \      }\n    }\n    return result;\n}", "{\n    auto result = new long[](0);\n\
    \    string[] arr = music_string.split(\" \");\n    foreach(string str; arr)\n\
    \    {\n        switch(str)\n        {\n            case \"o\":\n            \
    \    result ~= 4;\n                break;\n            case \"o|\":\n        \
    \        result ~= 2;\n                break;\n            case \".|\":\n    \
    \            result ~= 1;\n                break;\n        }\n    }\n    return\
    \ result;\n}", "{\n    int notes = 0;\n    int cur_length = 0;\n    int cur_note\
    \ = 0;\n    int beat_count = 0;\n    long[] music_beat_array;\n    foreach(c;\
    \ music_string)\n    {\n        switch(c)\n        {\n            case 'o':\n\
    \                cur_length += 4;\n                break;\n            case '|':\n\
    \                cur_length /= 2;\n                break;\n            case '.':\n\
    \                break;\n            default:\n                music_beat_array[cur_note]\
    \ = cur_length;\n                ++cur_note;\n                cur_length = 0;\n\
    \                break;\n        }\n    }\n    return music_beat_array;\n}\n ",
  "{\n\tlong[] tokens = new long[music_string.length];\n\tint j = 0;\n\tfor (int i\
    \ = 0; i < music_string.length; i++)\n\t{\n\t\tchar curr = music_string[i];\n\t\
    \tif (curr == 'o')\n\t\t{\n\t\t\ttokens[j] = 4;\n\t\t\tj++;\n\t\t}\n\t\telse if\
    \ (curr == '|')\n\t\t{\n\t\t\ttokens[j] = 2;\n\t\t\tj++;\n\t\t}\n\t\telse if (curr\
    \ == '.')\n\t\t{\n\t\t\ttokens[j] = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn tokens;\n\
    }", "{\n    long[] result;\n    char[] char_music_string = music_string.dup;\n\
    \    foreach(i, char_music_string)\n    {\n        if(char_music_string[i] ==\
    \ ' ')\n        {\n            char_music_string[i] = '|';\n        }\n    }\n\
    \    string new_music_string = char_music_string.idup;\n    new_music_string =\
    \ new_music_string.replace(\"o\", \"o|\");\n    //string new_music_string = new_music_string.replace(\"\
    o \", \"o|\");\n    //writefln(\"new_music_string: %s\", new_music_string);\n\
    \    new_music_string = new_music_string.replace(\"|\", \" \");\n    //writefln(\"\
    new_music_string: %s\", new_music_string);\n    string[] new_music_string_pieces\
    \ = new_music_string.split;\n    //writefln(\"new_music_string_pieces: %s\", new_music_string_pieces);\n\
    \    result = new long[new_music_string_pieces.length];\n    for(int i = 0; i\
    \ < new_music_string_pieces.length; i++)\n    {\n        if(new_music_string_pieces[i]\
    \ == \"o\")\n        {\n            result[i] = 4;\n        }\n        else if(new_music_string_pieces[i]\
    \ == \"o|\")\n        {\n            result[i] = 2;\n        }\n        else if(new_music_string_pieces[i]\
    \ == \".|\")\n        {\n            result[i] = 1;\n        }\n    }\n    return\
    \ result;\n}", "{\n    ulong[] res = new ulong[100];\n    ulong j = 0;\n    foreach(immutable\
    \ c; music_string)\n    {\n        //TODO; merge with the one below\n        if(c\
    \ == ' ')\n            continue;\n        if(c == 'o')\n        {\n          \
    \  res[j] = 4;\n            j++;\n        }\n        if(c == '|')\n        {\n\
    \            res[j-1] /= 2;\n        }\n    }\n    //immutable(long)[] res_slice\
    \ = res[0..j];\n    long[] res_slice = res[0..j];\n    return res_slice;\n}",
  "{\n    long[] result;\n    string[] tokens = music_string.split(\" \");\n    foreach(token;\
    \ tokens)\n    {\n        if(token == \"o\") \n        {\n            result ~=\
    \ 4;\n        } \n        else if(token == \"o|\") \n        {\n            result\
    \ ~= 2;\n        } \n        else if(token == \".|\") \n        {\n          \
    \  result ~= 1;\n        }\n    }\n    return result;\n}\n/*\n    >>> parse_music(\"\
    o o| .| o| o| .| .| .| .| o o\")\n    [4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L, 4L,\
    \ 4L]\n*/\n// long[] parse_music(string music_string) \n// {\n//     long[] result;\n\
    //     foreach(token; music_string.split(\" \"))\n//     {\n//         auto entry\
    \ = parse_note(token);\n//         static if(is(typeof(entry) == long[])) \n//\
    \         {\n//             foreach(element; entry) \n//             {\n//   \
    \              result ~= element;\n//             }\n//         } \n//       \
    \  else \n//         {\n//             result ~= entry;\n//         }\n//    \
    \ }\n//     return result;\n// }", "{\n    // TODO: Code this function\n    long[]\
    \ result = new long[];\n    foreach(note; music_string.split(\" \"))\n    {\n\
    \        static if(note == \"o\")\n            result ~= 4;\n        else if(note\
    \ == \"o|\")\n            result ~= 2;\n        else if(note == \".|\")\n    \
    \        result ~= 1;\n    }\n    return result;\n}\n/*\n    Input to this function\
    \ is a string representing musical notes in a special ASCII format.\n    Your\
    \ task is to parse this string and return a tuple pair of time in seconds and\
    \ a corresponding array of integers corresponding to how many beats does each\n\
    \    not last.", "{\n\t// Write your code here\n\tint length = music_string.length;\n\
    \tint note_count = 0;\n\tint note_beats = 0;\n\tint i = 0;\n\twhile(i<length)\n\
    \t{\n\t\tif(music_string[i] == 'o') note_count++;\n\t\telse if(music_string[i]\
    \ == '.') note_count++;\n\t\telse if(music_string[i] == '|') note_beats++;\n\t\
    \ti++;\n\t}\n\tnote_beats++;\n\tlong[] res = new long[note_count];\n\ti = 0;\n\
    \tint j = 0;\n\tint beat_count = 0;\n\tint beat_index = 0;\n\twhile(i<length)\n\
    \t{\n\t\tif(music_string[i] == 'o')\n\t\t{\n\t\t\tres[j] = 4;\n\t\t\tbeat_count\
    \ += 4;\n\t\t\tif(beat_count == note_beats)\n\t\t\t{\n\t\t\t\tbeat_count = 0;\n\
    \t\t\t\tbeat_index++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\telse if(music_string[i]\
    \ == '.')\n\t\t{\n\t\t\tres[j] = 1;\n\t\t\tbeat_count += 1;\n\t\t\tif(beat_count\
    \ == note_beats)\n\t\t\t{\n\t\t\t\tbeat_count = 0;\n\t\t\t\tbeat_index++;\n\t\t\
    \t}\n\t\t\tj++;\n\t\t}\n\t\telse if(music_string[i] == '|')\n\t\t{\n\t\t\tres[j-1]\
    \ += 1;\n\t\t\tbeat_count += 1;\n\t\t\tif(beat_count == note_beats)\n\t\t\t{\n\
    \t\t\t\tbeat_count = 0;\n\t\t\t\tbeat_index++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\
    \treturn res;\n}", "{\n    long[] result;\n    foreach(c; music_string) \n   \
    \ {\n        switch(c) \n        {\n            case ' ': \n                break;\n\
    \            case 'o': \n                result ~= 4;\n                break;\n\
    \            case '|': \n                if(result.empty) \n                {\n\
    \                    throw new Exception(\"A note has to be given before a bar\
    \ symbol\");\n                }\n                result.back /= 2;\n         \
    \       break;\n            case '.': \n                if(result.empty) \n  \
    \              {\n                    throw new Exception(\"A note has to be given\
    \ before a dot symbol\");\n                }\n                result.back = 1;\n\
    \                break;\n            default: \n                throw new Exception(\"\
    Unrecognized symbol '\" ~ c ~ \"'\");\n        }\n    }\n    return result;\n}",
  "{\n    \n    long[] result;\n    appender!(long[])(result) = appender!(long[])();\n\
    \    foreach(i,c; music_string)\n    {\n        switch(c)\n        {\n       \
    \     case 'o':\n                result.put(4);\n                break;\n    \
    \        case '|':\n                if(music_string[i-1] == 'o')\n           \
    \         result.put(2);\n                else if(music_string[i-1] == '.')\n\
    \                    result.put(1);\n                break;\n            case\
    \ '.':\n                if(music_string[i+1] == '|')\n                    result.put(1);\n\
    \                break;\n        }\n    }\n    return result.data;\n}\n/*\n  \
    \  A Guitarist is a musician who can play guitar.\n    It has a String name and\
    \ String styles, which is a comma-separated String of guitar styles the guitarist\
    \ can play.\n*/\nstruct Guitarist\n{\n    public string name;\n    public string\
    \ styles;\n    public void play(string style)\n    {\n        writefln(\"%s plays\
    \ %s guitar\", this.name, style);\n    }\n}\n/*\n    Constructor, takes a String\
    \ name and a String styles, which is a comma-separated String of guitar styles\
    \ the guitarist can play.\n*/\nGuitarist newGuitarist(string name, string styles)\n\
    {\n    return Guitarist(name, styles);\n}\n/*\n    playRiff plays a riff using\
    \ the style provided.\n    The guitarist may not be able to play the riff if the\
    \ style is not in styles.\n    A random number is generated to decide if the guitarist\
    \ will play the riff (probability = p).\n    If the guitarist is not able to play\
    \ the riff, they will try to play the riff using a different style.\n    If they\
    \ are not able to play it using any of the styles, they will play a wrong note.\n\
    \    A list of riff notes is provided that the guitarist can play.\n*/", "{\n\t\
    // write your solution here\n    long[] list;\n    if (music_string.length <=\
    \ 0)\n        return list.init;\n    auto split = music_string.split(\" \");\n\
    \    foreach (str; split)\n    {\n        if (str == \"o\")\n            list\
    \ ~= 4;\n        else if (str == \"o|\")\n            list ~= 2;\n        else\
    \ if (str == \".|\")\n            list ~= 1;\n    }\n    return list;\n}", "{\n\
    \    int[] music_arr;\n    mixin(map!\"a.popFront()\"(music_string.split(\" \"\
    )));\n    return map!\"to!(long)(a.length) * 4\"(music_arr);\n}", "{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.stdio;\n    import std.string;\n\
    \    import std.typecons;\n    import std.container;\n    import std.traits;\n\
    \    import std.conv;\n    import std.array;\n    long[] result = [];\n    string[]\
    \ split_music =  music_string.split(\" \");\n    foreach(value; split_music)\n\
    \    {\n        if(value[0] == 'o')\n        {\n            if(value.length ==\
    \ 1)\n            {\n                result ~= 4;\n            }\n           \
    \ else if(value[1] == '|')\n            {\n                result ~= 2;\n    \
    \        }\n        }\n        else if(value[0] == '.')\n        {\n         \
    \   if(value[1] == '|')\n            {\n                result ~= 1;\n       \
    \     }\n        }\n        \n    }\n    return result;\n    \n}", "{ \n    auto\
    \ ret = [];\n    foreach(ch; music_string) \n    {\n        switch(ch) \n    \
    \    {\n            case 'o':\n                ret ~= 4;\n                break;\n\
    \            case '|':\n                ret ~= 1;\n                break;\n  \
    \          case '.':\n                ret ~= 2;\n                break;\n    \
    \    }\n    }\n    return ret;\n}\n ", "{\n\t// write your code here\n\tlong[]\
    \ beats;\n\tforeach(const c; music_string)\n\t{\n\t\tif(c == 'o')\n\t\t\tbeats\
    \ ~= 4;\n\t\telse if(c == '.')\n\t\t\tbeats ~= 1;\n\t\telse if(c == '|')\n\t\t\
    \tbeats[$-1] /= 2;\n\t}\n\treturn beats;\n}", "{\n    auto beats = new long[](0);\n\
    \    auto beat_index = 0;\n    foreach(i, ch; music_string) {\n        beats ~=\
    \ 'o' == ch ? 4 :\n                '.' == ch ? 1 :\n                '|' == ch\
    \ ? 0 :\n                0;\n        if(ch == '|') {\n            beats[beat_index]\
    \ += beats[beat_index + 1];\n            beats[beat_index + 1] = 0;\n        \
    \    beat_index += 1;\n        }\n    }\n    return beats[];\n}", "{\n    long[]\
    \ result;\n    immutable char[] chars = to!(immutable(char))(music_string);\n\
    \    foreach(immutable char c; chars)\n    {\n        switch(c)\n        {\n \
    \           case 'o':\n                result ~= 4;\n                break;\n\
    \            case '|':\n                result[$-1] = result[$-1] / 2;\n     \
    \           break;\n            case '.':\n                result[$-1] = 1;\n\
    \                break;\n        }\n    }\n    return result;\n}", "{\n  long[]\
    \ result;\n  foreach(inout char c; music_string)\n  {\n    if(c=='o')\n    {\n\
    \      result ~= 4;\n    }\n    else if(c=='|')\n    {\n      result[$-1]/=2;\n\
    \    }\n  }\n  return result;\n}\n/*\n Now we need a function that will take an\
    \ array of notes and play each note for the number of beats specified.\n    This\
    \ is an internal function, so you don't need to test it. You just need to write\
    \ it.", "{\n    long[] beats;\n    beats.reserve(music_string.length);\n    foreach(note;\
    \ music_string.split(\" \"))\n    {\n        if(note == \"o\")\n            beats\
    \ ~= 4;\n        else if(note == \"o|\")\n            beats ~= 2;\n        else\
    \ if(note == \".|\")\n            beats ~= 1;\n    }\n    return beats;\n}", "{\n\
    \tint len = music_string.length;\n\tint index = 0;\n\tstring[] symbols = new string[];\n\
    \tstring temp_string = \"\";\n\twhile(index < len)\n\t{\n\t\tif(music_string[index]\
    \ == 'o')\n\t\t{\n\t\t\tif(music_string[index+1] == ' ')\n\t\t\t{\n\t\t\t\ttemp_string\
    \ = \"o\";\n\t\t\t\tappend(symbols, temp_string);\n\t\t\t\tindex = index + 1;\n\
    \t\t\t}\n\t\t\telse if(music_string[index+1] == '|')\n\t\t\t{\n\t\t\t\ttemp_string\
    \ = \"o|\";\n\t\t\t\tappend(symbols, temp_string);\n\t\t\t\tindex = index + 2;\n\
    \t\t\t}\n\t\t}\n\t\telse if(music_string[index] == '.')\n\t\t{\n\t\t\tif(music_string[index+1]\
    \ == '|')\n\t\t\t{\n\t\t\t\ttemp_string = \".|\";\n\t\t\t\tappend(symbols, temp_string);\n\
    \t\t\t\tindex = index + 2;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong[] final_array = new\
    \ long[];\n\tforeach(i; symbols)\n\t{\n\t\tif(i == \"o\")\n\t\t{\n\t\t\tappend(final_array,\
    \ 4L);\n\t\t}\n\t\telse if(i == \"o|\")\n\t\t{\n\t\t\tappend(final_array, 2L);\n\
    \t\t}\n\t\telse if(i == \".|\")\n\t\t{\n\t\t\tappend(final_array, 1L);\n\t\t}\n\
    \t}\n\treturn final_array;\n}", "{\n    auto res = [];\n    foreach(token; music_string.split(\"\
    \ \"))\n    {\n        auto n = 2;\n        if(token.length == 1)\n          \
    \  n = 4;\n        else if(token.length == 3)\n            n = 1;\n        res\
    \ ~= n;\n    }\n    return res;\n}\n/*\n    You are given an array of strings.\
    \ Your task is to join all of these strings into one string.\n    Each string\
    \ in the array may contain an arbitrary number of separator strings,\n    and\
    \ each separator string has to be added to the final string.", "{\n\tenum NoteType\
    \ { WHOLE, HALF, QUARTER };\n\t\n\tstruct Note\n\t{\n\t\tNoteType type;\n\t\t\
    bool isDotted;\n\t\t\n\t\tsize_t getDuration() const \n\t\t{\n\t\t\tsize_t duration\
    \ = 0;\n\t\t\t\n\t\t\tswitch(type) \n\t\t\t{\n\t\t\t\tcase NoteType.WHOLE:\n\t\
    \t\t\t\tduration = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase NoteType.HALF:\n\
    \t\t\t\t\tduration = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase NoteType.QUARTER:\n\
    \t\t\t\t\tduration = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(isDotted)\
    \ \n\t\t\t{\n\t\t\t\treturn duration + duration / 2;\n\t\t\t}\n\t\t\telse \n\t\
    \t\t{\n\t\t\t\treturn duration;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsize_t musicLength\
    \ = music_string.length;\n\tsize_t currentIndex = 0;\n\tsize_t outputIndex = 0;\n\
    \tlong[] output;\n\t\n\twhile(currentIndex < musicLength) \n\t{\n\t\tif(music_string[currentIndex]\
    \ == 'o') \n\t\t{\n\t\t\tcurrentIndex++;\n\t\t\toutput ~= 4;\n\t\t}\n\t\telse\
    \ if(music_string[currentIndex] == '.') \n\t\t{\n\t\t\tcurrentIndex++;\n\t\t\t\
    output ~= 1;\n\t\t}\n\t\telse if(music_string[currentIndex] == 'o' && music_string[currentIndex\
    \ + 1] == '|') \n\t\t{\n\t\t\tcurrentIndex += 2;\n\t\t\toutput ~= 2;\n\t\t}\n\t\
    \telse if(music_string[currentIndex] == '.' && music_string[currentIndex + 1]\
    \ == '|') \n\t\t{\n\t\t\tcurrentIndex += 2;\n\t\t", "{\n    long[] parse_music(string\
    \ music_string) \n    {\n        long[] op = [];\n        if(music_string.length\
    \ == 0) return op;\n        string[] notes = music_string.split(\" \");\n    \
    \    foreach(string x; notes)\n        {\n            switch(x)\n            {\n\
    \                case \"o\": op ~= 4; break;\n                case \"o|\": op\
    \ ~= 2; break;\n                case \".|\": op ~= 1; break;\n            }\n\
    \        }\n        return op;\n    }\n    long[] parse_music(string music_string)\
    \ \n    {\n        long[] r = [];\n        foreach(c; music_string.split(\" \"\
    ))\n        {\n            switch(c)\n            {\n                case \"o\"\
    : r ~= 4; break;\n                case \"o|\": r ~= 2; break;\n              \
    \  case \".|\": r ~= 1; break;\n            }\n        }\n        return r;\n\
    \    }\n    long[] parse_music(string music_string) \n    {\n        return music_string.split(\"\
    \ \").map!(c => c == \"o\" ? 4 : c == \"o|\" ? 2 : 1);\n    }\n}", "{\n    string[]\
    \ parts = music_string.split(\" \");\n    long[] result = new long[parts.length];\n\
    \    int j = 0;\n    foreach(string part; parts) {\n        if(part == \"o\")\
    \ {\n            result[j] = 4;\n        } else if(part == \"o|\") {\n       \
    \     result[j] = 2;\n        } else if(part == \".|\") {\n            result[j]\
    \ = 1;\n        }\n        j++;\n    }\n    return result;\n}", "{\n    long[]\
    \ r;\n    string[] all_notes;\n    int i, j;\n    all_notes = split(music_string,\
    \ \" \");\n    r = new long[all_notes.length];\n    for (i = 0; i < all_notes.length;\
    \ i++) {\n        if (all_notes[i] == \"o\")\n            r[i] = 4;\n        else\
    \ if (all_notes[i] == \"o|\")\n            r[i] = 2;\n        else if (all_notes[i]\
    \ == \".|\")\n            r[i] = 1;\n    }\n    return r;\n}", "{\n    // init\
    \ results array with default values\n    long[] result = new long[(size_t)count(music_string,\
    \ ' ') + 1];\n    fill(result.ptr, result.ptr + result.length, 1L);", "{\n   \
    \ int len = music_string.length;\n    auto res = new long[len];\n    int idx =\
    \ 0;\n    while (idx != len)\n    {\n        int residx = 0;\n        auto slice\
    \ = music_string[idx..$];\n        if (slice.startsWith(\"o o\"))\n        {\n\
    \            res[residx] = 4;\n            residx++;\n            slice = slice[2..$];\n\
    \        }\n        else if (slice.startsWith(\"o|\"))\n        {\n          \
    \  res[residx] = 2;\n            residx++;\n            slice = slice[2..$];\n\
    \        }\n        else if (slice.startsWith(\".|\"))\n        {\n          \
    \  res[residx] = 1;\n            residx++;\n            slice = slice[2..$];\n\
    \        }\n        else\n        {\n            throw new Exception(\"invalid\
    \ format\");\n        }\n        \n        idx = len - slice.length;\n    }\n\
    \    return res;\n}", "{\n    long[] res = [];\n    foreach(r; music_string.split())\n\
    \    {\n        if(r == \"o\")\n            res ~= 4;\n        else if(r == \"\
    o|\")\n            res ~= 2;\n        else if(r == \".|\")\n            res ~=\
    \ 1;\n    }\n    return res;\n}", "{\n    string[] arr = music_string.split(\"\
    \ \");\n    long[] output = new long[arr.length];\n    foreach(i,string a; arr)\n\
    \    {\n        if(a == \"o\")\n            output[i] = 4;\n        else if(a\
    \ == \"o|\")\n            output[i] = 2;\n        else if(a == \".|\")\n     \
    \       output[i] = 1;\n    }\n    return output;\n}\n/*\n    Function is_strictly_increasing\
    \ take a variable length array of integers as its only argument and \n    returns\
    \ true if the array elements are in strictly increasing order, otherwise returns\
    \ false.\n    >>> is_strictly_increasing(1, 2, 3, 4, 5)\n    true\n    >>> is_strictly_increasing(2,\
    \ 3, 2, 4, 5)\n    false\n*/", "{\n    auto notes = split(music_string, \" \"\
    );\n    return notes.map!((a) => \n        note_type(a[0]))(dchar[]());\n}", "{\n\
    \    long[] beats;\n    beats.length = music_string.length;\n    foreach(immutable\
    \ char c; music_string)\n    {\n        if(c == 'o')\n            beats ~= 4;\n\
    \        else if(c == '.')\n            beats ~= 1;\n        else if(c == '|')\n\
    \            continue;\n        else if(c == ' ')\n            continue;\n   \
    \     else\n            throw new Exception(\"Invalid symbol in music string\"\
    );\n    }\n    return beats;\n}", "{ \n  int count = 0;\n  bool dots = false;\n\
    \  char[] bar = music_string.chars;\n  bool[] switcharray = cast(bool[])bar.map!(x\
    \ => x == 'o' ? true : false);\n  long[] final_array = [];\n  for(int i = 0; i\
    \ < switcharray.length; i++)\n  {\n    if(switcharray[i] == true)\n    {\n   \
    \   if(dots == false)\n      {\n        count++;\n      }\n      else\n      {\n\
    \        count++;\n        final_array ~= 1;\n        dots = false;\n      }\n\
    \    }\n    else\n    {\n      if(count == 0)\n      {\n        dots = true;\n\
    \      }\n      else\n      {\n        final_array ~= count;\n        count =\
    \ 0;\n      }\n    }\n  }\n  final_array ~= count;\n  return final_array;\n}",
  "{\n    long[] result;\n    foreach(immutable char c; music_string)\n    {\n   \
    \     if(c == 'o')\n        {\n            result ~= 4;\n        }\n        else\
    \ if(c == '|')\n        {\n            result ~= 1;\n        }\n    }\n    return\
    \ result;\n}", "{\n    import std.algorithm : count;\n    auto p = music_string.count('o');\n\
    \    auto h = music_string.count('o|');\n    auto q = music_string.count('.|');\n\
    \    long[] array = new long[p+h+q];\n    int j = 0;\n    foreach(int i; 0..p)\n\
    \    {\n        array[j] = 4;\n        j++;\n    }\n    foreach(int i; 0..h)\n\
    \    {\n        array[j] = 2;\n        j++;\n    }\n    foreach(int i; 0..q)\n\
    \    {\n        array[j] = 1;\n        j++;\n    }\n    return array;\n}", "{\n\
    \  long[] result;\n  foreach(ch; music_string)\n  {\n    if(ch == 'o')\n    {\n\
    \      result ~= 4;\n    }\n    else if(ch == '.')\n    {\n      result ~= 1;\n\
    \    }\n    else if(ch == '|')\n    {\n      result[$-1] = result[$-1] / 2;\n\
    \    }\n  }\n  return result;\n}\n/*\n Given a string of words, return an array\
    \ of arrays containing the words grouped by anagram.", "{\n\tstring[] notes =\
    \ split(music_string, \" \");\n\tlong[] parsed = new long[notes.length];\n\tint\
    \ length = notes.length;\n\tforeach(i, note; notes) {\n\t\tif(note == \"o\") {\n\
    \t\t\tparsed[i] = 4;\n\t\t} else if(note == \"o|\") {\n\t\t\tparsed[i] = 2;\n\t\
    \t} else if(note == \".|\") {\n\t\t\tparsed[i] = 1;\n\t\t}\n\t}\n\treturn parsed;\n\
    }", "{\n\tlong[] beats = [];\n\tforeach(dchar ch; music_string) \n\t{\n\t\tif(ch\
    \ == ' ') \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if(ch == 'o') \n\t\t{\n\t\t\
    \tbeats ~= 4;\n\t\t}\n\t\telse if(ch == 'o' && music_string[$ - 1] == '|') \n\t\
    \t{\n\t\t\tbeats ~= 2;\n\t\t}\n\t\telse if(ch == '.' && music_string[$ - 1] ==\
    \ '|') \n\t\t{\n\t\t\tbeats ~= 1;\n\t\t}\n\t}\n\treturn beats;\n}\n/*\n    A local\
    \ bar serves a large beer glass, which looks like a truncated cone (a cone where\
    \ the top has been cut off).\n    This large beer glass comes in two sizes.",
  "{\n  long beats;\n  auto arr = music_string.split(\" \");\n  auto result = new\
    \ long[](arr.length);\n  for (int i = 0; i < arr.length; i++) \n  {\n    switch\
    \ (arr[i]) \n    {\n      case \"o\":\n        beats = 4;\n        break;\n  \
    \    case \"o|\":\n        beats = 2;\n        break;\n      case \".|\":\n  \
    \      beats = 1;\n        break;\n    }\n    result[i] = beats;\n  }\n  return\
    \ result;\n}\n/*\n  Implement a function to see if one string is a permutation\
    \ of the other.", "{\n    // you can use writefln to print something out\n   \
    \ // to stderr for debug purposes. e.g.:\n    // writeln(\"This is a debug message\"\
    );\n    \n    music_string = music_string.strip;\n    music_string = music_string.split\n\
    \    auto items = music_string.split(' ');\n    long[] result;\n    foreach(note;\
    \ items)\n    {\n        if(note.length == 1)\n        {\n            result ~=\
    \ 1;\n        }\n        else if(note.length == 2)\n        {\n            result\
    \ ~= 2;\n        }\n        else if(note.length == 3)\n        {\n           \
    \ result ~= 4;\n        }\n    }\n    return result;\n}", "{\n\tlong[] res = [];\n\
    \tforeach(inout i; music_string)\n\t{\n\t\tswitch(i)\n\t\t{\n\t\t\tcase 'o':\n\
    \t\t\t\tres ~= 4;\n\t\t\t\tbreak;\n\t\t\tcase '|':\n\t\t\t\tres[$-1] /= 2;\n\t\
    \t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//assert(false);\n\
    \t\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "{\n    auto result = new long[](256);\n\
    \    int i = 0;\n    for (auto ch : music_string)\n    {\n        switch (ch)\n\
    \        {\n            case 'o':\n                result[i++] = 4;\n        \
    \        break;\n            case '|':\n                result[i - 1] /= 2;\n\
    \                break;\n            case '.':\n                result[i++] =\
    \ 1;\n                break;\n            default:\n                break;\n \
    \       }\n    }\n    return result[0 .. i];\n}", "{\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.exception;\n\
    \    import std.conv;\n    import std.string;\n    import std.range;\n    import\
    \ std.format;\n    auto note_map = [\"o\", \"o|\", \".|\"];\n    long[] result;\n\
    \    auto music_notes = music_string.split(\" \");\n    foreach(note; music_notes)\n\
    \    {\n        if(!note_map.canFind(note))\n        {\n            throw new\
    \ Exception(\"Unknown note\");\n        }\n        result ~= 1 << (note_map.canFind(note)\
    \ + 1);\n    }\n    return result;\n}\n/*\n Given two integers A and B, return\
    \ all numbers from 1 to 100 (inclusive) that are divisible by either A or B.\n\
    \    >>> find_numbers(3, 4)\n    [3, 4, 6, 8, 9, 12, 15, 16, 18, 24, 27, 30, 32,\
    \ 33, 36, 39, 40, 42, 48, 51, 54, 56, 57, 60, 63, 64, 66, 72, 75, 76, 78, 81,\
    \ 84, 85, 87, 90, 93, 96, 99]\n*/\nlong[] find_numbers(long a, long b)\n{\n  \
    \  auto result = new long[];\n    for(long i = 1; i <= 100; i++)\n    {\n    \
    \    if(i % a == 0 || i % b == 0)\n        {\n            result ~= i;\n     \
    \   }\n    }\n    return result;\n}\n/*\n    Given an array of integers, return\
    \ an array of values, where each value is a count of the occurrences of that value\
    \ in the array.\n    >>> count_elements([1, 2, 2, 3, 3, 3, 3, 5, 5, 5, 9, 9, 9,\
    \ 9, 9])\n    [1, 2, 4, 5, 9]\n*/\nlong[] count_elements(long[] arr)\n{\n    import\
    \ std.algorithm;\n    auto result = new long[];\n    arr.sort;\n    foreach(i;\
    \ arr.group", "{\n    long[] ret;\n    uint i = 0;\n    while (i < music_string.length)\
    \ \n    {\n        switch (music_string[i]) \n        {\n            case 'o':\n\
    \                if (i + 1 < music_string.length && music_string[i + 1] == '|')\
    \ \n                {\n                    ret ~= 2;\n                    i +=\
    \ 2;\n                } \n                else \n                {\n         \
    \           ret ~= 4;\n                    i += 1;\n                }\n      \
    \          break;\n            case '.':\n                ret ~= 1;\n        \
    \        i += 2;\n                break;\n            default:\n             \
    \   i += 1;\n                break;\n        }\n    }\n    return ret;\n}", "{\n\
    \  long[] ret;\n  import std.algorithm;\n  import std.array;\n  import std.conv;\n\
    \  import std.format;\n  import std.range;\n  import std.string;\n  import std.typecons;\n\
    \  import std.stdio;\n  //todo:\n  // import std.file;", "{\n    auto music_info\
    \ = \"\";\n    foreach(element; music_string)\n    {\n        if (element != '\
    \ ')\n            music_info ~= element;\n    }\n    auto notes = split(music_info,\
    \ 'o');\n    auto toto = [];\n    foreach(element; notes)\n    {\n        if (element.length\
    \ == 0)\n            toto ~= 4;\n        else\n        {\n            auto tol\
    \ = element.length - 1;\n            if (element[0] == '|')\n                tol\
    \ += 1;\n            toto ~= tol;\n        }\n    }\n    return toto;\n}\n/*\n\
    --------------------------------------------------------------------------------------------------------------*/\n\
    /*\n    Write a function that takes two integers, a and b, and returns the greatest\
    \ common divisor of a and b.\n    >>> gcd(18, 45)\n    9\n    >>> gcd(1026, 405)\n\
    \    1\n*/\nlong gcd(long a, long b) \n{\n    if (a == 0)\n        return b;\n\
    \    return gcd(b % a, a);\n}\n/*\n--------------------------------------------------------------------------------------------------------------*/\n\
    /*\n    Write a function that takes a list of numbers and returns the sum of the\
    \ list.\n    This function must be recursive, and can't be using any loops.\n\
    \    >>> sum_list([1, 2, 3, 4, 5])\n    15\n    >>> sum_list([5, 3, 2, 1])\n \
    \   11\n*/\nlong sum_list(long[] list) \n{\n    if (list.length == 0)\n      \
    \  return 0;\n    return list[0] + sum_list(list[1..$]);\n}\n/*\n--------------------------------------------------------------------------------------------------------------*/\n\
    /*\n    Write a function that takes a list of integers and returns the largest\
    \ of them.\n    >>> greatest_number([1, 2, 3, 4, 5])\n    5\n    >>> greatest_number([9,\
    \ 2, 12, 4, 5])\n    12\n*/\nlong greatest_number(long[] list) \n{\n    if (list.length\
    \ == 1)\n        return list[0];\n    return max(list[0], greatest_number(list[1..$",
  "{\n    enum Note\n    {\n        whole,\n        half,\n        quarter\n    }\n\
    \    //Split into an array of characters\n    Note[] notes = music_string.split('').map!(a\
    \ => a == 'o' ? Note.whole :\n                                               \
    \         a == '|' ? Note.half :\n                                           \
    \             Note.quarter)();\n    //Iterate to parse notes\n    long[] parsed\
    \ = new long[notes.length];\n    long sum = 0;\n    foreach(immutable i, immutable\
    \ n; notes)\n    {\n        if(n == Note.whole)\n        {\n            sum +=\
    \ 4;\n        }\n        else if(n == Note.half)\n        {\n            sum +=\
    \ 2;\n        }\n        else\n        {\n            sum += 1;\n        }\n \
    \       parsed[i] = sum;\n    }\n    return parsed;\n}", "{ \n  auto p = music_string.to!dchar.retro;\n\
    \  long[] r = [];\n  for(; !p.empty; p.popFront()) \n  {\n    switch(p.front)\
    \ \n    {\n      case 'o':\n        r ~= 4;\n        break;\n      case '|':\n\
    \        if(p.front(1) == 'o')\n          r ~= 2;\n        else\n          r ~=\
    \ 1;\n        break;\n      case ' ':\n        break;\n      default:\n      \
    \  assert(0);\n    }\n  }\n  return r;\n}", "{\n    long[] r;\n    int len = length(music_string);\n\
    \    int i;\n    int t = 0;\n    foreach(c; music_string)\n    {\n        if(c\
    \ == 'o')\n            t += 4;\n        else if(c == '|')\n            t += 2;\n\
    \        else if(c == '.')\n            t += 1;\n    }\n    r = new long[];\n\
    \    r.length = t;\n    int p = 0;\n    foreach(c; music_string)\n    {\n    \
    \    if(c == 'o')\n        {\n            r[p] = 4;\n            p++;\n      \
    \  }\n        else if(c == '|')\n        {\n            r[p] = 2;\n          \
    \  p++;\n        }\n        else if(c == '.')\n        {\n            r[p] = 1;\n\
    \            p++;\n        }\n    }\n    return r;\n}", "{\n    long[] durations\
    \ = [];\n    immutable note_durations = [4: 'o', 2: 'o|', 1: 'o| .|'];\n    foreach\
    \ (immutable note; music_string.split()) \n    {\n        foreach (immutable duration;\
    \ note_durations.keys) \n        {\n            if (note_durations[duration].contains(note))\
    \ \n            {\n                durations ~= duration;\n                break;\n\
    \            }\n        }\n    }\n    return durations;\n}\n/*\n Your task is\
    \ to write a function that takes a single string as argument, \n and returns a\
    \ tuple containing the number of vowels and consonants.\n    Vowels are \"aeiou\"\
    , consonants are all other letters (including spaces).", "{\n    int[char] duration\
    \ = [\n        'o' : 4,\n        '|' : 2,\n        '.' : 1\n    ];\n    long[]\
    \ duration_array;\n    int i = 0;\n    while (i < music_string.length)\n    {\n\
    \        int j = i;\n        while (music_string[j] != ' ' && j < music_string.length)\
    \ \n        {\n            j++;\n        }\n        //writeln(j);\n        //writeln(i);\n\
    \        string substr = music_string[i..j];\n        //writeln(substr);\n   \
    \     int n = substr.length;\n        long d = 0;\n        int k = 0;\n      \
    \  while (k < n)\n        {\n            d += duration[substr[k]];\n         \
    \   k++;\n        }\n        duration_array ~= d;\n        i = j + 1;\n    }\n\
    \    return duration_array;\n}", "{\n\treturn split(music_string)\n\t\t.map!(s\
    \ => s == \"o\" ? 4L : s == \"o|\" ? 2L : 1L)();\n}\n/*\n\tIn this kata you will\
    \ create a function that takes a list of non-negative integers and strings and\
    \ returns a new list with the strings filtered out.\n\t\n\tExample\n\tfilter_list([1,2,'a','b'])\
    \ == [1,2]\n\tfilter_list([1,'a','b',0,15]) == [1,0,15]\n\tfilter_list([1,2,'aasf','1','123',123])\
    \ == [1,2,123]\n\t\n*/\nauto filter_list(const(any) l)\n{\n\treturn l.filter!(a\
    \ => is(typeof(a) == long));\n}\n/*\n\tWrite function avg which calculates average\
    \ of numbers in given list.\n\t\n\t>>> avg([1,2,3,4,5]) == 3\n\tTrue\n\t>>> avg([1,1,1,1,1])\
    \ == 1\n\tTrue\n\t>>> avg([-1,3,5]) == 3\n\tTrue\n\t>>> avg([]) == 0\n\tTrue\n\
    \t>>> avg([-2,4,4,7,9]) == 4\n\tTrue\n\t>>> avg([1]) == 1\n\tTrue\n\t>>> avg([-1,-1,-1])\
    \ == -1\n\tTrue\n\t>>> avg([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "{\n    import std.array;\n    import std.string;\n    import std.algorithm;\n \
    \   import std.conv;\n    import std.traits;\n    import std.format;\n    import\
    \ std.range;\n    import std.container;\n    auto result = new long[];\n    string[]\
    \ parts = music_string.split(\" \");\n    for(auto part; parts) {\n        int\
    \ val = -1;\n        switch(part) {\n            case \"o\": val = 4; break;\n\
    \            case \"o|\": val = 2; break;\n            case \".|\": val = 1; break;\n\
    \        }\n        result ~= val;\n    }\n    return result;\n}", "{\n    int[]\
    \ a = new int[].init;\n    int k = 0;\n    for (int i = 0; i < music_string.length;\
    \ i++)\n    {\n        if (music_string[i] == 'o')\n        {\n            if\
    \ (i + 1 < music_string.length && music_string[i + 1] == '|')\n            {\n\
    \                a[k] = 2;\n                k++;\n                i += 2;\n  \
    \          }\n            else\n            {\n                a[k] = 4;\n   \
    \             k++;\n                i++;\n            }\n        }\n        else\
    \ if (music_string[i] == '.')\n        {\n            if (i + 1 < music_string.length\
    \ && music_string[i + 1] == '|')\n            {\n                a[k] = 1;\n \
    \               k++;\n                i += 2;\n            }\n        }\n    }\n\
    \    return a;\n}", "{\n    return music_string.replace(\"o|\",\".\").split(\"\
    \ \").map!(s => s == \"o\" ? 4 : 1).array;\n}", "{\n    // Split the music string\
    \ into a list of substrings\n    auto split_music = music_string.split(\" \");\n\
    \    // Create an array of longs for the final result\n    long[] beats;\n   \
    \ beats.length = split_music.length;\n    foreach(i, note; split_music) {\n  \
    \      // Whole note\n        if(note == \"o\") {\n            beats[i] = 4;\n\
    \        }\n        // Half note\n        else if(note == \"o|\") {\n        \
    \    beats[i] = 2;\n        }\n        // Quarter note\n        else if(note ==\
    \ \".|\") {\n            beats[i] = 1;\n        }\n    }\n    return beats;\n}",
  "{\n    auto res = appender!(long[])();\n    auto beats = [\"o\", \"o|\", \".|\"\
    ];\n    auto beats_value = [4, 2, 1];\n    for (immutable string note : music_string.split())\
    \ \n    {\n        foreach (immutable index, immutable beat; beats) \n       \
    \ {\n            if (note == beat) \n            {\n                res.put(beats_value[index]);\n\
    \                break;\n            }\n        }\n    }\n    return res.data;\n\
    }\n/*", "{\n    long[] r = music_string.split(\" \").map!(a => a.length == 1 ?\
    \ a == \"o\" ? 4L : 1L : 2L).array;\n    return r;\n}", "{\n    if (music_string.empty)\n\
    \        return new long[](0);\n    else \n    {\n        return music_string.split(new\
    \ char[] {' '}).map!(note => \n        {\n            switch (note)\n        \
    \    {\n                case \"o\":\n                    return 4L;\n        \
    \        case \"o|\":\n                    return 2L;\n                case \"\
    .|\":\n                    return 1L;\n                default:\n            \
    \        throw new Exception(\"Unsupported note\");\n            }\n        }).array;\n\
    \    }\n}", "{\n    alias m = typeof(music_string[0]);\n    long beats = 0;\n\
    \    long[] rv;\n    foreach(i, c; music_string)\n    {\n        m c_m = c;\n\
    \        if(c_m == 'o')\n        {\n            beats += 4;\n        }\n     \
    \   else if(c_m == '|')\n        {\n            if(i > 0 && music_string[i-1]\
    \ == 'o')\n            {\n                beats += 2;\n            }\n       \
    \     else\n            {\n                beats += 1;\n            }\n      \
    \  }\n        else if(c_m == '.')\n        {\n            beats += 1;\n      \
    \  }\n        else if(c_m == ' ')\n        {\n            rv ~= beats;\n     \
    \       beats = 0;\n        }\n    }\n    return rv;\n}", "{\n\t\n\t// \u0435\u0441\
    \u043B\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E \u0432\u0445\
    \u043E\u0436\u0434\u0435\u043D\u0438\u0435 'o', \u043C\u044B \u043F\u043E\u043B\
    \u0443\u0447\u0438\u043C -1. \u0421\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\
    \u043B\u044C\u043D\u043E \u043C\u0430\u0441\u0441\u0438\u0432 \u0431\u0443\u0434\
    \u0435\u0442 \u0441\u043E\u0441\u0442\u043E\u044F\u0442\u044C \u0438\u0437 -1\n\
    \t// \u0435\u0441\u043B\u0438 \u0431\u044B\u043B\u043E \u043D\u0430\u0439\u0434\
    \u0435\u043D\u043E, \u0442\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u043C \u043F\
    \u043E\u0437\u0438\u0446\u0438\u044E \u0432\u0445\u043E\u0436\u0434\u0435\u043D\
    \u0438\u044F, \u043E\u0442 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\
    \u0434\u0435\u043C \u043E\u0442\u0441\u0447\u0438\u0442\u044B\u0432\u0430\u0442\
    \u044C\n\t// \u043F\u0440\u0438 \u0432\u0445\u043E\u0436\u0434\u0435\u043D\u0438\
    \u0438 \u043F\u043E\u0434\u0440\u044F\u0434 2 \u0438 \u0431\u043E\u043B\u0435\u0435\
    \ \u043E\u0434\u0438\u043D\u0430\u043A\u043E\u0432\u044B\u0445 \u043C\u0435\u0442\
    \u0430\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432, \u043E\u043D\u0438 \u0431\
    \u0443\u0434\u0443\u0442 \u0438\u043D\u0442\u0435\u0440\u043F\u0440\u0435\u0442\
    \u0438\u0440\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u043A\u0430\u043A \u043E\
    \u0434\u0438\u043D\u0430\u043A\u043E\u0432\u044B\u0435\n\tint[] o = find(music_string,\
    \ \"o\");\n\tint[] o_bar = find(music_string, \"o|\");\n\tint[] dot_bar = find(music_string,\
    \ \".|\");\n\t\n\t// \u0432\u044B\u0447\u0438\u0441\u043B\u044F\u0435\u043C \u0434\
    \u043B\u0438\u043D\u0443 \u043A\u0430\u0436\u0434\u043E\u0433\u043E \u043C\u0430\
    \u0441\u0441\u0438\u0432\u0430\n\tint[] len_o = map!(i => 1)(o);\n\tint[] len_o_bar\
    \ = map!(i => 1)(o_bar);\n\tint[] len_dot_bar = map!(i => 1)(dot_bar);\n\t\n\t\
    // \u0434\u0435\u043B\u0430\u0435\u043C \u043F\u0440\u043E\u0432\u0435\u0440\u043A\
    \u0443 \u043D\u0430 \u0442\u043E, \u0447\u0442\u043E \u0432\u0441\u0435 \u043C\
    \u0430\u0441\u0441\u0438\u0432\u044B \u0438\u043C\u0435\u044E\u0442 \u043E\u0434\
    \u0438\u043D\u0430\u043A\u043E\u0432\u0443\u044E \u0434\u043B\u0438\u043D\u0443\
    \n\tif (len_o", "{\n\timmutable map = [\"o\" : 4, \"o|\" : 2, \".|\" : 1];\n\t\
    return music_string.split(\" \").map!(p => map[p]).array;\n}", "{\n    long[]\
    \ result;\n    foreach(c; music_string) \n    {\n        switch(c)\n        {\n\
    \            case 'o':\n                result ~= 4;\n                break;\n\
    \            case '|':\n                break;\n            case '.':\n      \
    \          result ~= 1;\n                break;\n            default:\n      \
    \          break;\n        }\n    }\n    return result;\n}", "{\n    string s\
    \ = replace(music_string, ' ', \"\");\n    return map!(i => (i == 'o' ? 4 : 2))(s);\n\
    }", "{\n    return music_string.splitter(\" \").map!((string str) {\n        switch\
    \ (str) {\n            case \"o\":\n                return 4L;\n            case\
    \ \"o|\":\n                return 2L;\n            case \".|\":\n            \
    \    return 1L;\n            default:\n                assert(false);\n      \
    \  }\n    }).array;\n}", "{\n  int[] beats = [1, 2, 4];\n  int[] notes = [0, 0,\
    \ 0];\n  int[] note_beats = [0, 0, 0];\n  bool in_music = false;\n  int index\
    \ = 0;\n  string note;\n  for (int i = 0; i < music_string.length; i++)\n  {\n\
    \    if (in_music)\n    {\n      if (music_string[i] == ' ')\n      {\n      \
    \  notes[index] = note_beats[note.length - 1];\n        index++;\n        in_music\
    \ = false;\n      }\n      else\n      {\n        note += music_string[i];\n \
    \     }\n    }\n    else\n    {\n      if (music_string[i] != ' ')\n      {\n\
    \        note = \"\";\n        note += music_string[i];\n        in_music = true;\n\
    \      }\n    }\n  }\n  if (in_music)\n  {\n    notes[index] = note_beats[note.length\
    \ - 1];\n  }\n  return notes;\n}", "{\n    long[] parsedMusic;\n    parsedMusic\
    \ = music_string.split(\" \").map!((a) => cast(long)a.length).array;\n    return\
    \ parsedMusic;\n}", "{\n    //long[] tuple_to_long(Tuple!(char[]) s){\n    //\
    \    long[] result;\n    //    foreach(m; s){\n    //        result ~= cast(long)m;\n\
    \    //    }\n    //    return result;\n    //}\n    return map!(a => a.canFind(\"\
    o\") && a.length == 1 ? 4 : 2, music_string.split(\"\\\\s+\"));\n}", "{\n    long\
    \ [] output;\n    foreach(char c; music_string)\n    {\n        switch(c)\n  \
    \      {\n            case 'o': output ~= 4; break;\n            case '.': output\
    \ ~= 1; break;\n            case '|': output[$-1] += 1; break;\n        }\n  \
    \  }\n    return output;\n}", "{\n\t// Your code goes here.\n\t\n\tauto l = music_string.splitter('\
    \ ');\n\treturn l.map!(a => {\n\t\tswitch(a) {\n\t\t\tcase \"o\": return 4L;\n\
    \t\t\tcase \"o|\": return 2L;\n\t\t\tcase \".|\": return 1L;\n\t\t\tdefault: return\
    \ 0L;\n\t\t}\n\t}).array;\n}", "{\n\tlong[] output;\n\tstring[] notes = split(music_string,\
    \ \" \");\n\tforeach(string note; notes)\n\t{\n\t\t\n\t}\n\treturn output;\n}",
  "{\n    string[] notes = split(music_string);\n    return notes.map!(a => (a.length\
    \ == 1 ? 4 : 2));\n}\n// https://www.codewars.com/kata/57cf9a9c2d0f4b810900002f/solutions/d/dmd\n\
    import std.string;", "{\n    import std.range;\n    import std.algorithm;\n  \
    \  return music_string.split(\" \").map!(ch => (ch[0] == 'o' ? (ch.length > 1\
    \ ? 2 : 4) : 1)());\n}", "{\n    long[] notes = [];\n    foreach(c;music_string)\n\
    \    {\n        if(c == 'o')\n        {\n            append(notes,4);\n      \
    \  }\n        else if(c == '|')\n        {\n            notes[$-1] /= 2;\n   \
    \     }\n    }\n    return notes;\n}", "{\n    long[] result;\n    long[] temp;\n\
    \    string[] split;\n    long i;\n    long j;\n    //dstring[] notes = [ \"o\"\
    , \"o|\", \".|\" ];\n    //dlong[] values = [ 4, 2, 1 ];\n    //dshort[string]\
    \ keys = [ \"o\": 4, \"o|\": 2, \".|\": 1 ];\n    split = music_string.split(\"\
    \ \");\n    result = new long[split.length];\n    foreach(i, s; split)\n    {\n\
    \        if(s == \"o\")\n        {\n            result[i] = 4;\n        }\n  \
    \      else if(s == \"o|\")\n        {\n            result[i] = 2;\n        }\n\
    \        else if(s == \".|\")\n        {\n            result[i] = 1;\n       \
    \ }\n    }\n    return result;\n}", "{\n    auto parsed_notes = new long[];\n\
    \    for (size_t i = 0; i < music_string.length; i++) \n    {\n        if (music_string[i]\
    \ == 'o') \n        {\n            parsed_notes ~= 4;\n        }\n        else\
    \ if (music_string[i] == '|') \n        {\n            parsed_notes[$-1] /= 2;\n\
    \        }\n    }\n    return parsed_notes;\n}\n/*\n    >>> get_music_notes(parse_music(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n    [\"C C C C\", \"D D\", \"E\", \"F F\",\
    \ \"G G\", \"A\", \"B\", \"c\", \"d\", \"c c c c\", \"d d\"]\n*/\nstring[] get_music_notes(long[]\
    \ note_beats) \n{\n    return map!(notes_lookup, note_beats);\n}\nstring notes_lookup(long\
    \ note_beat) \n{\n    return (note_beat == 1 ? \"E\" : \n            note_beat\
    \ == 2 ? \"D\" : \n            note_beat == 4 ? \"C\" : \n            note_beat\
    \ == 8 ? \"B\" : \n            note_beat == 16 ? \"A\" : \n            note_beat\
    \ == 32 ? \"G\" : \n            note_beat == 64 ? \"F\" : \n            note_beat\
    \ == 128 ? \"E\" : \n            note_beat == 256 ? \"D\" : \n            note_beat\
    \ == 512 ? \"C\" : \"\") ~ (note_beat > 1 ? \" \" ~ notes_lookup(note_beat-1)\
    \ : \"\");\n}\n/*\n    >>> get_bpm([\"C C C C\", \"D D\", \"E\", \"F F\", \"G\
    \ G\", \"A\", \"B\", \"c\", \"d\", \"c c c c\", \"d d\"])\n    111", "{\n    long\
    \ [] tempo;\n    int i;\n    tempo.length = music_string.length;\n    foreach(int\
    \ j, char s; music_string)\n    {\n        if(s == 'o')\n        {\n         \
    \   tempo[i] = 4;\n            i++;\n        }\n        else if(s == '.')\n  \
    \      {\n            tempo[i] = 1;\n            i++;\n        }\n        else\
    \ if(s == '|')\n        {\n            tempo[i] = 2;\n            i++;\n     \
    \   }\n        else\n        {\n            continue;\n        }\n    }\n    return\
    \ tempo;\n}\nstring music_string = \"o o| .| o| o| .| .| .| .| o o\";\nassert(parse_music(music_string)\
    \ == [4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L, 4L, 4L]);", "{\n\tlong[] r;\n\tstring[]\
    \ tokenizer;\n\tint x, y;\n\ttokenizer = music_string.split;\n\tr.length = tokenizer.length;\n\
    \tforeach(i,e; tokenizer)\n\t{\n\t\tswitch(e)\n\t\t{\n\t\t\tcase \"o\": r[i] =\
    \ 4; break;\n\t\t\tcase \"o|\": r[i] = 2; break;\n\t\t\tcase \".|\": r[i] = 1;\
    \ break;\n\t\t}\n\t}\n\treturn r;\n}", "{\n    import std.algorithm;\n    auto\
    \ d = map!(c =>\n    {\n        if (c == 'o')\n            return 4L;\n      \
    \  else if (c == '.')\n            return 1L;\n        else if (c == '|')\n  \
    \          return 2L;\n        else if (c == ' ')\n            return 0L;\n  \
    \      else\n            assert(false);\n    })(music_string);\n    auto res =\
    \ d.retro;\n    auto tmp = [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3",
  "{\n    import std.regex;\n    import std.algorithm;\n    import std.string;\n \
    \   immutable whole_note = \"o\";\n    immutable half_note = \"o|\";\n    immutable\
    \ quarter_note = \".|\";\n    immutable types = [whole_note, half_note, quarter_note];\n\
    \    immutable durations = [4L, 2L, 1L];\n    alias NoteType = typeof(types[0]);\n\
    \    static assert(types.length == durations.length);\n    immutable _music_string\
    \ = music_string;\n    immutable note_index = _music_string.indexOf(whole_note);\n\
    \    immutable note_type = _music_string[note_index .. note_index + whole_note.length];\n\
    \    immutable type_index = types.indexOf(note_type);\n    immutable duration\
    \ = durations[type_index];\n    auto result = _music_string.split(\" \").map!(a\
    \ => durations[types.indexOf(a)]);\n    return result;\n}", "{\n    return map!((c)\
    \ =>\n        c == 'o' ? 4L :\n        c == 'o|' ? 2L :\n        c == '.|' ? 1L\
    \ : 0L)(split(music_string)).array;\n}", "{ \n\tint i=0;\n\tint j=0;\n\tint[]\
    \ notes = new int[100];\n\twhile(i<music_string.length)\n\t{\n\t\tif(music_string[i]=='o')\n\
    \t\t{\n\t\t\tif(music_string[i+1]=='|')\n\t\t\t{\n\t\t\t\tnotes[j]=2;\n\t\t\t\t\
    i=i+2;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnotes[j]=4;\n\t\t\t\
    \ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnotes[j]=1;\n\t\t\
    \ti=i+2;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn notes;\n}", "{\n    long[] notes =\
    \ [];\n    foreach(c; music_string) \n    {\n        switch(c) \n        {\n \
    \           case 'o':\n                notes ~= 4;\n                break;\n \
    \           case 'o|':\n                notes ~= 2;\n                break;\n\
    \            case '.|':\n                notes ~= 1;\n                break;\n\
    \        }\n    }\n    return notes;\n}\n/*\n Given a sequence of integers from\
    \ 0 to n-1, except some of them are replaced with other numbers. \n    Try to\
    \ find all these missing numbers.\n   \n    >>> find_disappeared_numbers([4, 3,\
    \ 2, 7, 8, 2, 3, 1])\n    [5L, 6L]\n*/\nlong[] find_disappeared_numbers(long[]\
    \ arr) \n{\n    long[] numbers = [];\n    foreach(i; 0..arr.length) \n    {\n\
    \        if(arr[i] != i) \n        {\n            numbers ~= i;\n        }\n \
    \   }\n    return numbers;\n}\n/*\n Given an array of n integers and a number\
    \ k. Find the maximum sum of contiguous integers in the array, \n    such that\
    \ the sum of those k integers is maximized.\n   \n    >>> find_max_subarray([1,\
    \ -2, 3, 4, -5, 10, -8, 7, 6], 3)\n    11\n*/\nlong find_max_subarray(long[] arr,\
    \ size_t k) \n{\n    long sum = 0;\n    long maxSum = 0;\n    foreach(i; 0..k)\
    \ \n    {\n        sum += arr[i];\n    }\n    maxSum = sum;\n    foreach(i; k..arr.length)\
    \ \n    {\n        sum += arr[i] - arr[i - k];\n        if(sum > maxSum) \n  \
    \      {\n            maxSum = sum;\n        }\n    }\n    return maxSum;\n}\n\
    /*\n Given a list of numbers, which is sorted in ascending order and is rotated\
    \ one or more times, \n    find the minimum number.\n   \n    >>> find_min([3,\
    \ 1", "{\n    import std.regex;\n    auto matches = music_string.match(regex(r\"\
    ^(o+|\\..)\\|*\"));\n    return matches.map!(a => a.length).array;\n}", "{\n\t\
    auto notes = map!(a => a.length == 2 ? 2 : 1)\n\t\t(split(chomp(music_string),\
    \ ' '));\n\tnotes = map!(a => a == 1 ? 1 : a/2)\n\t\t(map!(a => a == 'o' ? 4 :\
    \ 2)(music_string));\n\t\n\treturn notes;\n}", "{\n    int[] beat_arr = [];\n\
    \    int beat_count = 0;\n    foreach(immutable char c; music_string)\n    {\n\
    \        if(c == 'o')\n        {\n            beat_count += 4;\n        }\n  \
    \      else if(c == '|')\n        {\n            beat_arr ~= beat_count;\n   \
    \         beat_count = 0;\n        }\n        else if(c == '.')\n        {\n \
    \           beat_count += 1;\n        }\n    }\n    return beat_arr;\n}", "{\n\
    \    static assert(__traits(compiles, {\n        static if (__traits(compiles,\
    \ mixin(\"return [\" ~ music_string ~ \"]\") )) \n        {\n            enum\
    \ k = [\"o\", \"o|\", \".|\"];\n            enum v = [4, 2, 1];\n            auto\
    \ dict = zip(k, v);\n            auto l = music_string.split(\" \");\n       \
    \     auto res = new long[];\n            foreach(i, s; l) \n            {\n \
    \               foreach(d; dict) \n                {\n                    if (d[0]\
    \ == s) \n                    {\n                        res ~= d[1];\n      \
    \                  break;\n                    }\n                }\n        \
    \    }\n            return res;\n        }\n        else static assert(0, \"input\
    \ string contains invalid notes!\");\n    }));\n    return mixin(\"return [\"\
    \ ~ music_string ~ \"]\");\n}", "{\n    return music_string.split(\" \").map!((a)\
    \ =>\n            a.length==1 ? 4L : 2L).array;\n}\n/*\n Read numbers from stdin\
    \ and separate them by commas.\n    If number is greater than five return the\
    \ original number,\n    if the number is less than five return the number squared.\n\
    \    (In a real life application, you would not have to have to do this manually,\n\
    \    but using std.algorithm).\n    If there are no numbers to be read, return\
    \ an empty array.", "{\n    long[] res = new long[0];\n    foreach(immutable c;\
    \ music_string) \n    {\n        switch(c) \n        {\n            case 'o':\
    \ res ~= 4; break;\n            case '.': res ~= 1; break;\n            case '|':\
    \ break;\n            default: assert(0);\n        }\n    }\n    return res;\n\
    }", "{\n    string[] notes = split(music_string, \" \");\n    int length = notes.length;\n\
    \    long[] tmp = new long[length];\n    for (int i = 0; i < length; i++)\n  \
    \  {\n        if (notes[i] == \"o\")\n        {\n            tmp[i] = 4;\n   \
    \     }\n        else if (notes[i] == \"o|\")\n        {\n            tmp[i] =\
    \ 2;\n        }\n        else if (notes[i] == \".|\")\n        {\n           \
    \ tmp[i] = 1;\n        }\n    }\n    return tmp;\n}", "{\n\tlong i;\n\tlong[]\
    \ arr;\n\tlong beats = 0;\n\tlong[] result = null;\n\tint k = 0;\n\t\n\tarr =\
    \ music_string.split(\" \");\n\t\n\tforeach(note; arr)\n\t{\n\t\tif(note == \"\
    o\")\n\t\t{\n\t\t\tbeats = 4;\n\t\t}\n\t\tif(note == \"o|\")\n\t\t{\n\t\t\tbeats\
    \ = 2;\n\t\t}\n\t\tif(note == \".|\")\n\t\t{\n\t\t\tbeats = 1;\n\t\t}\n\t\t\n\t\
    \tif(k == 0)\n\t\t{\n\t\t\tresult = new long[arr.length];\n\t\t}\n\t\t\n\t\tresult[k]\
    \ = beats;\n\t\tk++;\n\t}\n\t\n\treturn result;\n}", "{\n    long[] output = new\
    \ long[];\n    char[] input = music_string.dup.toCharArray;\n    int i = 0;\n\
    \    while (i < input.length)\n    {\n        if (input[i] == 'o')\n        {\n\
    \            if (input[i+1] == ' ')\n            {\n                output ~=\
    \ 4;\n                i += 2;\n            }\n            else if (input[i+1]\
    \ == '|')\n            {\n                output ~= 2;\n                i += 3;\n\
    \            }\n        }\n        else if (input[i] == '.')\n        {\n    \
    \        output ~= 1;\n            i += 3;\n        }\n    }\n    return output;\n\
    }", "{ \n    import std.stdio : writeln;\n    static int[string] dictionary =\
    \ [\"o\" : 4, \"o|\" : 2, \".|\" : 1];\n    enum words = split(music_string, \"\
    \ \");\n    long[] result = new long[words.length];\n    int index = 0;\n    foreach(int\
    \ i, string item; words)\n    {\n        writeln(item);\n        result[index]\
    \ = dictionary[item];\n        index++;\n    }\n    return result;\n}", "{\n \
    \   size_t pos = 0;\n    long[] result;\n    long[] tmp_result;\n    foreach(symbol;\
    \ music_string)\n    {\n        if(symbol == 'o')\n        {\n            result\
    \ ~= 4;\n        }\n        else if(symbol == '.')\n        {\n            result\
    \ ~= 1;\n        }\n        else if(symbol == '|')\n        {\n            if(pos\
    \ == 0)\n            {\n                result ~= 2;\n            }\n        \
    \    else\n            {\n                tmp_result = result;\n             \
    \   result = tmp_result[0..$-1];\n                result ~= tmp_result[$-1] /\
    \ 2;\n                result ~= tmp_result[$-1] / 2;\n            }\n        }\n\
    \        pos++;\n    }\n    return result;\n}", "{\n    auto result = appender!(long[])();\n\
    \    auto music_array = music_string.split(' ');\n    foreach(music; music_array)\n\
    \    {\n        if(music == \"o\")\n        {\n            result.put(4);\n  \
    \      }\n        else if(music == \"o|\")\n        {\n            result.put(2);\n\
    \        }\n        else if(music == \".|\")\n        {\n            result.put(1);\n\
    \        }\n    }\n    return result.data;\n}", "{\n    int n = 0;\n    foreach(inout\
    \ t; zip(music_string, music_string[1..$]))\n    {\n        if(t[0] == 'o' &&\
    \ t[1] == ' ')\n            n++;\n        else if(t[0] == 'o' && t[1] == '|')\n\
    \            n += 2;\n        else if(t[0] == '.' && t[1] == '|')\n          \
    \  n++;\n    }\n    long[] music_beats = new long[n];\n    int i = 0;\n    foreach(inout\
    \ t; zip(music_string, music_string[1..$]))\n    {\n        if(t[0] == 'o' &&\
    \ t[1] == ' ')\n            music_beats[i++] = 4;\n        else if(t[0] == 'o'\
    \ && t[1] == '|')\n            music_beats[i++] = 2;\n        else if(t[0] ==\
    \ '.' && t[1] == '|')\n            music_beats[i++] = 1;\n    }\n    return music_beats;\n\
    }", "{\n    auto result = appender!(long[])();\n    long[] beat;\n    int i;\n\
    \    foreach(beat; music_string.split(\" \"))\n    {\n        switch(beat)\n \
    \       {\n            case \"o\":\n                result.put(4);\n         \
    \       break;\n            case \"o|\":\n                result.put(2);\n   \
    \             break;\n            case \".|\":\n                result.put(1);\n\
    \                break;\n        }\n    }\n    return result.data;\n}\n/*\n  \
    \  Given integers a and b return a list containing all\n    values in the range\
    \ [a, b] inclusive.", "{\n    import std.array : array;\n    auto ret = array!long();\n\
    \    foreach(i, c; music_string)\n    {\n        if(c == 'o')\n        {\n   \
    \         if(music_string[i+1] == '|')\n            {\n                ret ~=\
    \ 2;\n                i++;\n            }\n            else\n            {\n \
    \               ret ~= 4;\n            }\n        }\n        else if(c == '.')\n\
    \        {\n            ret ~= 1;\n            i++;\n        }\n    }\n    return\
    \ ret;\n}", "{\n    string[] notes = music_string.split;\n    long[] note_lengths\
    \ = new long[notes.length];\n    note_lengths[0] = notes[0].count != 1 ? 2 : 1;\n\
    \    for (int i = 1; i < notes.length; i++) {\n        if (notes[i - 1].length\
    \ != 1) {\n            note_lengths[i] = notes[i].count != 1 ? 2 : 1;\n      \
    \  } else {\n            note_lengths[i] = notes[i].count != 1 ? 3 : 2;\n    \
    \    }\n    }\n    return note_lengths;\n}", "{\n    enum music_note(char @ symbol,\
    \ long duration)\n    {\n        music_note('o', 4),\n        music_note('o|',\
    \ 2),\n        music_note('.|', 1),\n    }\n    auto music_notes = music_string.split(\"\
    \ \");\n    return music_notes.map!(v => music_note(v[0]).duration)();\n}", "{\n\
    \    long[] beat_arr;\n    string[] beat_str_arr;\n    beat_str_arr = music_string.split(\"\
    \ \");\n    beat_arr = new long[beat_str_arr.length];\n    foreach(i, beat; beat_str_arr)\n\
    \    {\n        if(beat == \"o\")\n        {\n            beat_arr[i] = 4;\n \
    \       }\n        else if(beat == \"o|\")\n        {\n            beat_arr[i]\
    \ = 2;\n        }\n        else if(beat == \".|\")\n        {\n            beat_arr[i]\
    \ = 1;\n        }\n    }\n    return beat_arr;\n}", "{\n    long[] notes;\n  \
    \  return notes;\n}", "{\n    //char[] symbol_to_duration = [('o', 4), ('o|',\
    \ 2), ('.|', 1)];\n    Tuple!(char, long)[] symbol_to_duration = [tuple('o', 4),\
    \ tuple('o|', 2), tuple('.|', 1)];\n    long[] result = [];\n    //\n    //char[]\
    \ parts = music_string.split(' ');\n    string[] parts = music_string.split('\
    \ ');\n    for (string part; parts) \n    {\n        char letter = part[0];\n\
    \        long duration = symbol_to_duration[letter].$1;\n        result ~= duration;\n\
    \    }\n    return result;\n}", "{\n    struct note\n    {\n        int beats;\n\
    \        string value;\n        note(int beats, string value) {\n            this.beats\
    \ = beats;\n            this.value = value;\n        }\n    }\n    // Convert\
    \ each symbol to a note\n    auto notes = music_string.split(\" \").map!(i =>\
    \ {\n        if (i == \"o\") {\n            return note(4, \"o\");\n        }\
    \ else if (i == \"o|\") {\n            return note(2, \"o|\");\n        } else\
    \ if (i == \".|\") {\n            return note(1, \".|\");\n        } else {\n\
    \            assert(false);\n        }\n    });\n    // Convert list of notes\
    \ to list of beats\n    return notes.map!(i => i.beats).array;\n}", "{\n\tauto\
    \ notes = music_string.splitter(' ');\n\tlong[] result;\n\tforeach(i, note; notes)\
    \ \n\t{\n\t\tconst int length = note.length;\n\t\tif(length == 1) \n\t\t{\n\t\t\
    \tresult ~= 4;\n\t\t} \n\t\telse if(length == 2) \n\t\t{\n\t\t\tresult ~= 2;\n\
    \t\t} \n\t\telse if(length == 3) \n\t\t{\n\t\t\tresult ~= 1;\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\n    Write a function that takes an array of integers and returns\
    \ an array of indices of the elements which are\n    divisible by 3, but not by\
    \ 2.", "{ \n    long[] note_values = new long[];\n    foreach(c; music_string)\n\
    \    {\n        if(c == 'o')\n        {\n            note_values ~= 4;\n     \
    \   }\n        else if(c == '|')\n        {\n            note_values[$-1] = (note_values[$-1]\
    \ + 1) / 2;\n        }\n    }\n    return note_values;\n}", "{ \n    long beats\
    \ = 0;\n    long[] notes;\n    foreach(immutable element; music_string) \n   \
    \ {\n        if(element == 'o') \n        {\n            if(beats < 1) \n    \
    \        {\n                beats = 4;\n            }\n            else \n   \
    \         {\n                notes ~= beats;\n                beats = 4;\n   \
    \         }\n        }\n        else if(element == '|') \n        {\n        \
    \    if(beats == 4) \n            {\n                beats = 2;\n            }\n\
    \            else if(beats == 2) \n            {\n                beats = 1;\n\
    \            }\n            else if(beats == 1) \n            {\n            \
    \    notes ~= beats;\n                beats = 0;\n            }\n        }\n \
    \       else if(element == '.') \n        {\n            if(beats == 4) \n   \
    \         {\n                beats = 2;\n            }\n            else if(beats\
    \ == 2) \n            {\n                beats = 1;\n            }\n         \
    \   else if(beats == 1) \n            {\n                notes ~= beats;\n   \
    \             beats = 0;\n            }\n        }\n    }\n    return notes;\n\
    }\n/*\n    Input: N - integer, number of teams\n    Output: List of tuples representing\
    \ each pair\n    >>> match(3)\n    [[0, 2], [1, 2], [0, 1]]\n*/\nalias Pair =\
    \ tuple!(size_t, size_t);\nPair[] match(size_t n) \n{\n    Pair[] pairs;\n   \
    \ for(size_t i = 0; i < n; i++) \n    {\n        for(size_t j = i + 1; j < n;\
    \ j++) \n        {\n            pairs ~= tuple(i, j);\n        }\n    }\n    return\
    \ pairs;\n}\n/*\n    1. for n = 1, n-digits number, 1 digit number\n    2. for\
    \ n = 2, n-digits number, 2 digit number, except 11\n    3. for n = 3, n-digits\
    \ number, 1, 2, 3 digit number except 11, 21, 22, 111", "{\n    auto notes = split(music_string,\
    \ \" \");\n    long[] result;\n    foreach(note; notes)\n    {\n        auto beat\
    \ = 0;\n        switch(note[0])\n        {\n            case 'o':\n          \
    \      beat = 4;\n                break;\n            case '.':\n            \
    \    beat = 1;\n                break;\n        }\n        if(note.length == 3)\n\
    \            beat /= 2;\n        result ~= beat;\n    }\n    return result;\n}",
  "{\n    // Here we store indexes of o and o|\n    auto o_indexes = array!(size_t)();\n\
    \    // We will loop through all symbols in the string\n    foreach (index, c;\
    \ music_string)\n    {\n        // If we encounter o or o| we store their index\n\
    \        if (c == 'o' || c == 'o|')\n        {\n            o_indexes ~= index;\n\
    \        }\n    }\n    // Next we will create a slice of the array\n    auto slice\
    \ = music_string[o_indexes];\n    // And finally we will map from characters to\
    \ integer number of beats\n    return map!(\"a == 'o' ? 4 : 2\")(slice);\n}\n\
    /*\n    >>> count_words(\"hi, hello, hi, what's up?\")\n    1\n    >>> count_words(\"\
    hi, hello, hi, what's up?\")\n    1\n    >>> count_words(\"\")\n    0\n*/\nsize_t\
    \ count_words(string sentence) \n{\n    // We can split string using split()\n\
    \    // Returning an array of substrings\n    auto words = sentence.split();\n\
    \    // Empty string returns empty array\n    // So we will have no words\n  \
    \  if (words.empty)\n    {\n        return 0;\n    }\n    // Now we will create\
    \ a set\n    // Sets are good for counting unique elements\n    auto unique_words\
    \ = set!string();\n    // We will add all words to the set\n    // If the element\
    \ was not there before\n    // the set will grow\n    foreach (word; words)\n\
    \    {\n        unique_words.insert(word);\n    }\n    // Finally we will return\
    \ the size of the set\n    return unique_words.size;\n}\n/*\n    >>> count_digits(0)\n\
    \    1\n    >>> count_digits(123)\n    3\n    >>> count_digits(-456)\n    3\n\
    \    >>> count_digits(0b111101)\n    6\n    >>> count_digits(0b1101)\n    4\n\
    \    >>> count_digits(0o666)\n    3\n    >>> count_digits(0o123)\n   ", "{\n \
    \    int index = 0;\n     long[] res = new long[0];\n    \n    while(index < music_string.length)\n\
    \    {\n        int music_length = 0;\n        switch(music_string[index])\n \
    \       {\n            case 'o':\n                music_length = 4;\n        \
    \        break;\n            case '.':\n                music_length = 1;\n  \
    \              break;\n            default:\n                break;\n        }\n\
    \        res ~= music_length;\n        if(music_string[index] == 'o')\n      \
    \  {\n            index += 1;\n        }\n        else\n        {\n          \
    \  index += 2;\n        }\n    }\n    return res;\n}", "{\n    int[] ret;\n  \
    \  foreach(c; music_string)\n    {\n        if(c == ' ')\n            continue;\n\
    \        if(c == 'o')\n            ret ~= 4;\n        else if(c == '.')\n    \
    \        ret ~= 1;\n        else if(c == '|')\n            ret[$-1] /= 2;\n  \
    \  }\n    return ret;\n}", "{ \n    auto bar = split(music_string,\" \");\n  \
    \  long[] L;\n    L.length = bar.length;\n    for(int i = 0; i < bar.length; i++)\n\
    \    {\n        if(bar[i].length == 1)\n        {\n            L[i] = 4;\n   \
    \     }\n        else if(bar[i].length == 2)\n        {\n            L[i] = 2;\n\
    \        }\n        else\n        {\n            L[i] = 1;\n        }\n    }\n\
    \    return L;\n}", "{\n\tauto parsed_music = appender!(long[])();\n\tauto current_beat\
    \ = 4L;\n\tauto beat_factor = 1L;\n\tauto beats_string = \"\";\n\tfor(auto chr\
    \ = music_string.front; chr < music_string.back; chr = chr.next)\n\t{\n\t\tbeats_string\
    \ ~= chr;\n\t\tif(beats_string == \"o\")\n\t\t{\n\t\t\tparsed_music.put(current_beat);\n\
    \t\t\tbeats_string = \"\";\n\t\t}\n\t\telse if(beats_string == \"o|\")\n\t\t{\n\
    \t\t\tparsed_music.put(current_beat/2);\n\t\t\tbeats_string = \"\";\n\t\t}\n\t\
    \telse if(beats_string == \".|\")\n\t\t{\n\t\t\tparsed_music.put(current_beat/4);\n\
    \t\t\tbeats_string = \"\";\n\t\t}\n\t}\n\treturn parsed_music.data;\n}", "{\n\
    \    long[] music;\n    static immutable(string) beat = \"o|.\";\n    foreach(immutable(char)\
    \ beat_type; beat)\n    {\n        music ~= music_string.split(beat_type);\n \
    \   }\n    return music.map!(t => beat.length - t.length);\n}", "{\n    // this\
    \ is a stub, please modify it\n    return [4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L,\
    \ 4L, 4L];\n}", "{\n    return staticMap!(c => c == 'o' ? 4 : 2)(music_string.idup);\n\
    }", "{\n    long[] beats;", "{\n    long[] result;\n    int size = music_string.length;\n\
    \    foreach(i; 0 .. size)\n    {\n        if(music_string[i] == 'o')\n      \
    \  {\n            if(music_string[i+1] == ' ')\n            {\n              \
    \  result ~= 4;\n            }\n            else if(music_string[i+1] == '|')\n\
    \            {\n                result ~= 2;\n            }\n        }\n     \
    \   else if(music_string[i] == '.')\n        {\n            if(music_string[i+1]\
    \ == '|')\n            {\n                result ~= 1;\n            }\n      \
    \  }\n    }\n    return result;\n}", "{\n    return music_string.split(' ').map!(line\
    \ => {\n        static if (line.back == '|')\n            return if (line[1] ==\
    \ '.') 1L else 2L;\n        else\n            return 4L;\n    }).array;\n}", "{\n\
    \    int len = music_string.length();\n    string str = music_string;\n    long[]\
    \ res = new long[len];\n    int pos = 0;\n    int count = 0;\n    while(true)\n\
    \    {\n        int index = str.find(\"|\");\n        if(index == -1)\n      \
    \  {\n            res[pos] = 4;\n            pos += 1;\n            break;\n \
    \       }\n        if(str[index+1] == '.')\n        {\n            res[pos] =\
    \ 1;\n            pos += 1;\n        }\n        else\n        {\n            res[pos]\
    \ = 2;\n            pos += 1;\n        }\n        str = str[index+2..str.length()];\n\
    \    }\n    return res;\n}", "{\n    size_t index = 0;\n    return music_string.split(\"\
    \ \", true).map!((item)\n    {\n        auto index_start = index;\n        index\
    \ += item.length;\n        switch (item[0])\n        {\n            case 'o':\
    \ return (item.length > 1) ? 2L : 4L;\n            case '.': return 1L;\n    \
    \        default: throw new Exception(\"Invalid character\");\n        }\n   \
    \ }).array;\n}", "{\n    typeof(return) result;\n    int i = 0;\n    foreach(c;\
    \ music_string) \n    {\n        if(c == 'o') \n        {\n            if(i >\
    \ 0 && result[$-1] == '|') \n            {\n                result[$-1] = ' ';\n\
    \                result ~= result[$-1] + 2;\n            }\n            else \n\
    \            {\n                result ~= 4;\n            }\n        }\n     \
    \   else if(c == '|') \n        {\n            result ~= c;\n        }\n     \
    \   else if(c == '.') \n        {\n            result ~= 1;\n        }\n     \
    \   else if(c == ' ') \n        {\n            continue;\n        }\n        else\
    \ \n        {\n            throw new Exception(\"Invalid symbol '%s'\".format(c));\n\
    \        }\n        i++;\n    }\n    return result;\n}", "{\n    long[] count_beats\
    \ = new long[];\n    string[] notes = music_string.split();\n    foreach(string\
    \ note; notes)\n    {\n        if(note == \"o\")\n        {\n            count_beats\
    \ ~= 4;\n        }\n        else if(note == \"o|\")\n        {\n            count_beats\
    \ ~= 2;\n        }\n        else if(note == \".|\")\n        {\n            count_beats\
    \ ~= 1;\n        }\n    }\n    return count_beats;\n}\nlong[] parse_music2(string\
    \ music_string)\n{\n    long[] count_beats = new long[];\n    immutable(char[])\
    \ notes = music_string.to!(immutable(char)[])();\n    for(long i = 0; i < notes.length;\
    \ i += 2)\n    {\n        count_beats ~= notes[i] == 'o' ? 4 : 2;\n    }\n   \
    \ return count_beats;\n}\n/*\nYour task is to make a function which returns number\
    \ of whole times given integer fits into other integer.\n    Example:\n    >>>\
    \ fits(5, 100)\n    20\n    >>> fits(5, 10)\n    2\n    >>> fits(5, 7)\n    1\n\
    */\nlong fits(long a, long b)\n{\n    return b / a;\n}\nlong fits2(long a, long\
    \ b)\n{\n    return cast(long)(b/a);\n}\nlong fits3(long a, long b)\n{\n    return\
    \ cast(long)(b / a);\n}\n/*\nYou are given a phonebook which maps names to phone\
    \ numbers.\n    Please, write a program which returns list of all the names which\
    \ are mapped to phone numbers that start\n    with given prefix.\n    \n    >>>\
    \ find_names(\"123\", [\"Cain\": \"1234567\", \"Ana\": \"2345678\", \"Bob\": \"\
    3456789\"])\n    [\"Cain\", \"Ana\"]\n*/\nstring[] find_names(string prefix, string[string]\
    \ phonebook)\n{\n    string[] names = new string[];\n    foreach(string name;\
    \ phonebook.keys)", "{\n    auto bpm = 100;\n    auto res = new long[](0);\n \
    \   foreach(immutable note; music_string.split(\" \"))\n    {\n        float time\
    \ = 0.0;\n        if(note == \"o\")\n        {\n            time = 60.0 / bpm\
    \ * 4.0;\n        }\n        else if(note == \"o|\")\n        {\n            time\
    \ = 60.0 / bpm * 2.0;\n        }\n        else if(note == \".|\")\n        {\n\
    \            time = 60.0 / bpm * 1.0;\n        }\n        res ~= cast(long)time;\n\
    \    }\n    return res;\n}", "{\n    static long beats(in char[] notes)\n    {\n\
    \        long total = 0;\n        foreach(note; notes)\n        {\n          \
    \  switch(note)\n            {\n                case 'o':\n                  \
    \  total += 4;\n                    break;\n                case '|':\n      \
    \              if(notes[$-1] == 'o')\n                        total += 2;\n  \
    \                  else\n                        total += 1;\n               \
    \     break;\n                case '.':\n                    if(notes[$-1] ==\
    \ '|')\n                        total += 1;\n                    break;\n    \
    \        }\n        }\n        return total;\n    }\n    string[] note_seqs =\
    \ music_string.split(\" \");\n    long[] beat_seqs = note_seqs.map!(note_seq =>\
    \ beats(note_seq.dup)).array;\n    return beat_seqs;\n}", "{\n    long[] arr;\n\
    \    bool[] is_beat;\n    int size = 0;\n    foreach(c; music_string)\n    {\n\
    \        if(c == 'o' || c == '.')\n            size++;\n    }\n    arr = new long[size];\n\
    \    is_beat = new bool[size];\n    int i = 0;\n    foreach(c; music_string)\n\
    \    {\n        if(c == 'o')\n        {\n            arr[i] = 4;\n           \
    \ is_beat[i] = true;\n            i++;\n        }\n        else if(c == '.')\n\
    \        {\n            arr[i] = 1;\n            is_beat[i] = true;\n        \
    \    i++;\n        }\n    }\n    for(int j = 0; j < arr.length; j++)\n    {\n\
    \        if(is_beat[j] == true)\n        {\n            if(j + 1 < arr.length\
    \ && is_beat[j + 1] == true)\n            {\n                arr[j] /= 2;\n  \
    \              is_beat[j + 1] = false;\n            }\n        }\n    }\n    return\
    \ arr;\n}", "{\n    long[] res = new long[100];\n    int counter = 0;\n    foreach(immutable\
    \ char x; music_string)\n    {\n        switch(x)\n        {\n            case\
    \ 'o':\n                res[counter] = 4;\n                break;\n          \
    \  case '|':\n                res[counter] = 2;\n                break;\n    \
    \        case '.':\n                res[counter] = 1;\n                break;\n\
    \            default:\n                counter++;\n                break;\n  \
    \      }\n    }\n    return res;\n}", "{\n    //void append(T)(ref T[] a, T v)\
    \ if (is(T == long))\n    long[] a_result;\n    //void append(T)(ref T[] a, T\
    \ v) if (is(T == long))\n    //void append(T)(ref T[] a, T v) if (is(T == long))\n\
    \    //void append(T)(ref T[] a, T v) if (is(T == long))\n    //void append(T)(ref\
    \ T[] a, T v) if (is(T == long))\n    int n_index = -1;\n    //void append(T)(ref\
    \ T[] a, T v) if (is(T == long))\n    //void append(T)(ref T[] a, T v) if (is(T\
    \ == long))\n    //void append(T)(ref T[] a, T v) if (is(T == long))\n    //void\
    \ append(T)(ref T[] a, T v) if (is(T == long))\n    //void append(T)(ref T[] a,\
    \ T v) if (is(T == long))\n    //void append(T)(ref T[] a, T v) if (is(T == long))\n\
    \    foreach (char n_char; music_string)\n    {\n        //void append(T)(ref\
    \ T[] a, T v) if (is(T == long))\n        //void append(T)(ref T[] a, T v) if\
    \ (is(T == long))\n        //void append(T)(ref T[] a, T v) if (is(T == long))\n\
    \        //void append(T)(ref T[] a, T v) if (is(T == long))\n        //void append(T)(ref\
    \ T[] a, T v) if (is(T == long))\n        //void append(T)(ref T[] a, T v) if\
    \ (is(T == long))\n        //void append(T)(ref T[] a, T v) if (is(T == long))\n\
    \        //void append(T)(ref T[] a, T v) if (is(T == long))\n        //void append(T)(ref\
    \ T[] a, T v) if (is", "{\n    long[] notes;\n    foreach(m; music_string.split(\"\
    \ \")) \n    {\n        int beats;\n        switch(m) \n        {\n          \
    \  case \"o\" : beats = 4; break;\n            case \"o|\" : beats = 2; break;\n\
    \            case \".|\" : beats = 1; break;\n        }\n        notes ~= beats;\n\
    \    }\n    return notes;\n}\n// Solution 2\nlong[] parse_music(string music_string)\
    \ \n{\n    return music_string.replace(\"|\", \" \").split(\" \").map!(m => (m\
    \ == \"o\") ? 4 : 2).array;\n}\n/*\n    The solution is to find the value in \
    \ b that is the closest to a and return it's key.\n    \n    If two keys have\
    \ the same value, the first one should be returned.\n    \n    If a is larger\
    \ than all values in b, the last key should be returned.\n    \n    >>> closest_key(3,\
    \ [\"zero\", 3, \"five\", 6])\n    1\n    >>> closest_key(7, [\"zero\", 3, \"\
    five\", 6])\n    3\n    >>> closest_key(6, [\"zero\", 3, \"five\", 6])\n    3\n\
    */\nsize_t closest_key(int a, int[] b) \n{\n    size_t n = b.length;\n    size_t\
    \ key = n - 1;\n    foreach(i, v; b) \n    {\n        if(v <= a) \n        {\n\
    \            if(b[key] < v) \n            {\n                key = i;\n      \
    \      }\n        }\n    }\n    return key;\n}\n// Solution 2\nsize_t closest_key(int\
    \ a, int[] b) \n{\n    auto d = b.enumerate.filter!(kv => kv.value <= a).map!(kv\
    \ => abs(kv.value - a));\n    return d.minPos.value;\n}\n/*\n    Input to this\
    \ function is a list of integers representing the numbers on the dominoes.\n \
    \   Return all possible domino states (with each domino represented as a two element",
  "{\n    import std.string;\n    return music_string.split(\" \").map!(x => x.length).array;\n\
    }", "{\n    enum noteType {\n        O(4),\n        O_PIPE(2),\n        DOT_PIPE(1);\n\
    \        alias value = duration;\n        private long duration;\n        this(long\
    \ duration) {\n            this.duration = duration;\n        }\n    }\n    import\
    \ noteType.values;\n    import noteType.toNoteType;\n    import noteType.toChar;\n\
    \    import noteType.fmt;\n    import noteType.remove;\n    import std.algorithm;\n\
    \    import std.traits;\n    import std.array;\n    // I'm using the noteType\
    \ enum to represent notes, since the compare the strings to create integers was\
    \ too long\n    long[] result;\n    // parsing the music string and putting the\
    \ notes in array\n    auto notes = music_string.splitter.filter!((a){return a.length\
    \ > 0;}).map!(a => toNoteType(a[0])).array;\n    // removing the marks for the\
    \ groups of notes\n    auto pos = remove(notes, DOT_PIPE);\n    result = notes.take(pos).map!(a\
    \ => a.value).array;\n    auto semibreve_notes = notes.skip(pos).take(notes.length\
    \ - pos).\n                            chunk!((a, b) => b.value > a.value).map!(a\
    \ => a.array).array;\n    foreach(group_notes; semibreve_notes) {\n        if(group_notes.length\
    \ == 2) {\n            group_notes.popFront();\n        }\n        auto d = group_notes.front.value;\n\
    \        result ~= d * group_notes.length;\n    }\n    return result;\n}", "{\n\
    \    import std.array;\n    long []result;\n    int i = 0;\n    foreach(char c;\
    \ music_string)\n    {\n        if(c == 'o')\n        {\n            if(music_string[i+1]\
    \ == ' ')\n            {\n                result ~= 4;\n            }\n      \
    \      else\n            {\n                result ~= 2;\n            }\n    \
    \    }\n        else if(c == '.')\n        {\n            result ~= 1;\n     \
    \   }\n        i++;\n    }\n    return result;\n}", "{\n    return music_string.splitter('\
    \ ').map!(x => x == \"o\" ? 4L : x == \"o|\" ? 2L : 1L)();\n}", "{\n    long[]\
    \ notes;\n    foreach(immutable c; music_string)\n    {\n        switch(c)\n \
    \       {\n            case 'o':\n                notes ~= 4;\n              \
    \  break;\n            case '|':\n                notes[$-1] = notes[$-1]/2;\n\
    \                break;\n            case '.':\n                notes[$-1] = notes[$-1]/4;\n\
    \                break;\n        }\n    }\n    return notes;\n}", "{\n    immutable\
    \ notes = [\n        \"o|\" : 2,\n        \".|\" : 1,\n        \"o\" : 4\n   \
    \ ];\n    long[] times;\n    foreach(n; notes)\n    {\n        int index = 0;\n\
    \        while(true)\n        {\n            index = music_string.find(n, index);\n\
    \            if(index == -1)\n                break;\n            times ~= notes[n];\n\
    \            index += n.length;\n        }\n    }\n    return times;\n}", "{\n\
    \    return music_string.split(\" \").map!(s => s == \"o\" ? 4L : 1L);\n}", "{\n\
    \    import std.regex;\n    return match(music_string, regex(`(o|o\\||.\\|)`)).map!(match\
    \ => \n        match[0] == \"o\" ? 4L : \n        match[0] == \"o|\" ? 2L : \n\
    \        match[0] == \".|\" ? 1L : \n        void).array;\n}", "{\n    char[]\
    \ current_note = \"\";\n    //#long current_note = 0L;\n    char[] result = [];\n\
    \    foreach(ref char c; music_string)\n    {\n        if(c != ' ')\n        {\n\
    \            current_note ~= c;\n        }\n        else\n        {\n        \
    \    result ~= parse_duration(current_note);\n            current_note = \"\"\
    ;\n        }\n    }\n    if(current_note != \"\")\n    {\n        result ~= parse_duration(current_note);\n\
    \    }\n    return result;\n}\nlong parse_duration(char[] note)\n{\n    int len\
    \ = note.length;\n    if(len == 1)\n    {\n        return 4L;\n    }\n    else\
    \ if(note[0] == 'o')\n    {\n        return 2L;\n    }\n    else if(note[0] ==\
    \ '.')\n    {\n        return 1L;\n    }\n    else\n    {\n        return 0L;\n\
    \    }\n}\nauto main(string[] args) -> int \n{\n    writeln(parse_music(\"o o|\
    \ .| o| o| .| .| .| .| o o\"));\n    return 0;\n}", "{\n    \n    auto result\
    \ = dchar[];\n    auto holder = dchar[];\n    int count = 0;\n    bool skip =\
    \ false;\n    foreach(dchar c; music_string)\n    {\n        if(skip)\n      \
    \  {\n            skip = false;\n            continue;\n        }\n        if(c\
    \ == ' ')\n        {\n            if(holder.length == 0)\n                continue;\n\
    \            switch(holder[0])\n            {\n                case 'o':\n   \
    \                 result ~= 4;\n                    break;\n                case\
    \ '.':\n                    result ~= 1;\n                    break;\n       \
    \     }\n            holder.length = 0;\n        }\n        else if(c == '|')\n\
    \        {\n            switch(holder[0])\n            {\n                case\
    \ 'o':\n                    result ~= 2;\n                    break;\n       \
    \         case '.':\n                    result ~= 1;\n                    break;\n\
    \            }\n            holder.length = 0;\n            skip = true;\n   \
    \     }\n        else\n        {\n            holder ~= c;\n        }\n      \
    \  ++count;\n    }\n    return result;\n}", "{\n    long[] result;\n    bool is_half\
    \ = false;\n    bool is_single = false;\n    int j = 0;\n    int i = 0;\n    while(i\
    \ < music_string.length)\n    {\n        if(music_string[i] == 'o')\n        {\n\
    \            if(is_half)\n            {\n                result[j] = result[j]\
    \ + 4;\n                is_half = false;\n            }\n            else if(is_single)\n\
    \            {\n                result[j] = result[j] + 2;\n                is_single\
    \ = false;\n            }\n            else\n            {\n                result\
    \ ~= 4;\n                j++;\n            }\n            i++;\n        }\n  \
    \      else if(music_string[i] == '.')\n        {\n            if(is_half)\n \
    \           {\n                result[j] = result[j] + 2;\n                is_half\
    \ = false;\n            }\n            else if(is_single)\n            {\n   \
    \             result[j] = result[j] + 1;\n                is_single = false;\n\
    \            }\n            else\n            {\n                result ~= 1;\n\
    \                j++;\n            }\n            i++;\n        }\n        else\
    \ if(music_string[i] == '|')\n        {\n            if(is_half)\n           \
    \ {\n                result[j] = result[j] + 2;\n                is_half = false;\n\
    \            }\n            else if(is_single)\n            {\n              \
    \  result[j] = result[j] + 1;\n                is_single = false;\n          \
    \  }\n            else\n            {\n                result ~= 1;\n        \
    \        j++;\n            }\n            if(music_string[i + 1] == '|')\n   \
    \         {\n                is_half = true;\n                i = i + 2;\n   \
    \         }\n            else\n            {\n                is_single = true;\n\
    \                i++;\n            }\n        }\n        else\n        {\n   \
    \         i++;\n        }\n    }\n    return result;\n}", "{\n    int num_beats\
    \ = 0;\n    long[] beats = new long[4];\n    for (int i = 0; i < music_string.length;\
    \ i += 2) \n    {\n        char c = music_string[i];\n        if (c == 'o') \n\
    \        {\n            num_beats += 4;\n        } \n        else if (c == '.')\
    \ \n        {\n            num_beats += 1;\n        }\n        if (music_string[i\
    \ + 1] == '|') \n        {\n            beats ~= num_beats;\n            num_beats\
    \ = 0;\n        }\n    }\n    beats ~= num_beats;\n    return beats;\n}\n/*\n\
    \ Write a function that takes a string of text and returns how many times every\
    \ letter appears in it.", "{\n    // Translate string to a list of strings\n \
    \   string[] music_tokens = split(strip(music_string));\n    long[] result = new\
    \ long[music_tokens.length];\n    foreach(size_t i, string token; music_tokens)\
    \ {\n        switch(token) {\n            case \"o\" :\n                result[i]\
    \ = 4L;\n                break;\n            case \"o|\" :\n                result[i]\
    \ = 2L;\n                break;\n            case \".|\" :\n                result[i]\
    \ = 1L;\n                break;\n        }\n    }\n    return result;\n}", "{\n\
    \    import std.conv;\n    import std.algorithm;\n    import std.string;\n   \
    \ import std.range;\n    import std.array;\n    import std.stdio;\n    return\
    \ map!((a) => a.equal(\"o\") ? to!long(4) : a.equal(\"o|\") ? to!long(2) : a.equal(\"\
    .|\") ? to!long(1) : 0)(split(music_string, \" \"));\n}", "{\n    import std.array;\n\
    \    import std.conv;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.string;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n   ", "{\n\
    \    import std.conv;\n    // example: \"[4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L, 1L,\
    \ 4L, 4L]\"\n    string arr = \"[\" ~ music_string ~ \"]\";\n    return arr.to!(long[]);\n\
    }", "{\n    import std.typecons : Tuple;\n    long[] music_notes;\n    long x\
    \ = 0;\n    foreach(i; music_string)\n    {\n        if(i == 'o')\n        {\n\
    \            music_notes ~= 4;\n        }\n        else if(i == '|')\n       \
    \ {\n            music_notes[$-1] = (music_notes[$-1]/2);\n        }\n       \
    \ else if(i == '.')\n        {\n            music_notes ~= 1;\n        }\n   \
    \ }\n    return music_notes;\n}", "{\n\tuint len = music_string.length;\n\tbool\
    \ inword = false;\n\tuint word = 0;\n\tlong[] ret = new long[];\n\tuint count\
    \ = 0;\n\tbool dot = false;\n\tfor (uint i = 0; i < len; i++)\n\t{\n\t\tif (inword\
    \ == false)\n\t\t{\n\t\t\tword = i;\n\t\t\tinword = true;\n\t\t}\n\t\t\n\t\tif\
    \ (music_string[i] == ' ')\n\t\t{\n\t\t\tinword = false;\n\t\t\tret ~= dot ? (count\
    \ == 1 ? 1 : (count == 2 ? 2 : 4)) : (count == 1 ? 1 : (count == 2 ? 2 : 4));\n\
    \t\t\tcount = 0;\n\t\t\tdot = false;\n\t\t}\n\t\telse if (music_string[i] == '.')\n\
    \t\t{\n\t\t\tdot = true;\n\t\t}\n\t\telse if (music_string[i] == '|')\n\t\t{\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\tret ~= dot ? (count == 1 ? 1 : (count == 2 ? 2 :\
    \ 4)) : (count == 1 ? 1 : (count == 2 ? 2 : 4));\n\treturn ret;\n}", "{ \n  auto\
    \ res = appender!(long[])();\n  foreach(ch; music_string.replace(\" \", \"\"))\
    \ {\n    switch(ch) {\n      case 'o':\n        res.put(4);\n        break;\n\
    \      case '|':\n        res.put(2);\n        break;\n      case '.':\n     \
    \   res.put(1);\n        break;\n    }\n  }\n  return res.data;\n}", "{\n    \n\
    \    long[] out = new long[0];\n    foreach(int i; 0 .. music_string.length)\n\
    \    {\n        switch(music_string[i])\n        {\n            case 'o':\n  \
    \              out ~= 4;\n                break;\n            case '|':\n    \
    \            if(i>0 && music_string[i-1] == 'o')\n                    out ~= 2;\n\
    \                else\n                    out ~= 1;\n                break;\n\
    \            case ' ':\n                break;\n            default:\n       \
    \         import std.stdio;\n                writeln(\"Wrong symbol in string\"\
    );\n                assert(false);\n        }\n    }\n    return out;\n}", "{\n\
    \    long[] result;\n    // Your code goes here.\n    return result;\n}", "{\n\
    \    import std.array;\n    immutable mapping = [(\"o\" => 4),\n             \
    \            (\"o|\" => 2),\n                         (\".|\" => 1)];\n    immutable\
    \ notes = music_string.split(\" \");\n    return notes.map!(a => mapping[a]).array;\n\
    }", "{\n    // END SOLUTION\n    int len = music_string.length;\n    long[] res\
    \ = new long[len];\n    int index = 0;\n    int pos = 0;\n    while ((pos = music_string.find(\"\
    o o| .| o| o| .| .| .| .| o o\")) != -1)\n    {\n        res[index++] = 4;\n \
    \       music_string = music_string.replaceOne(\"o o| .| o| o| .| .| .| .| o o\"\
    , \"\");\n    }\n    while ((pos = music_string.find(\"o o| .| o| o| .| .| .|\
    \ .|\")) != -1)\n    {\n        res[index++] = 4;\n        music_string = music_string.replaceOne(\"\
    o o| .| o| o| .| .| .| .|\", \"\");\n    }\n    while ((pos = music_string.find(\"\
    o o| .| o| o| .| .| .|\")) != -1)\n    {\n        res[index++] = 4;\n        music_string\
    \ = music_string.replaceOne(\"o o| .| o| o| .| .| .|\", \"\");\n    }\n    while\
    \ ((pos = music_string.find(\"o o| .| o| o| .| .|\")) != -1)\n    {\n        res[index++]\
    \ = 4;\n        music_string = music_string.replaceOne(\"o o| .| o| o| .| .|\"\
    , \"\");\n    }\n    while ((pos = music_string.find(\"o o| .| o| o| .|\")) !=\
    \ -1)\n    {\n        res[index++] = 4;\n        music_string = music_string.replaceOne(\"\
    o o| .| o| o| .|\", \"\");\n    }\n    while ((pos = music_string.find(\"o o|\
    \ .| o| o|\")) != -1)\n    {\n        res[index++] = 4;\n        music_string\
    \ = music_string.replaceOne(\"o o| .| o| o|\", \"\");\n    }\n    while ((pos\
    \ ="]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
