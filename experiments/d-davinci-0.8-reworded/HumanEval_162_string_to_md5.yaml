name: HumanEval_162_string_to_md5
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Given a string 'text',\
  \ return its md5 hash equivalent string.\n    If 'text' is an empty string, return\
  \ null.\n\n    >>> string_to_md5(\"Hello world\")\n    \"3e25960a79dbc69b674cd4ec67a72c62\"\
  \n    \n*/\nNullable!(string) string_to_md5(string text) \n"
tests: "unittest\n{\n    alias candidate = string_to_md5;\n\n{\n        auto result\
  \ = candidate(\"Hello world\");\n        assert(!result.isNull && result.get ==\
  \ \"3e25960a79dbc69b674cd4ec67a72c62\");\n}\n\n{\n        auto result = candidate(\"\
  \");\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate(\"\
  A B C\");\n        assert(!result.isNull && result.get == \"0ef78513b0cb8cef12743f5aeb35f888\"\
  );\n}\n\n{\n        auto result = candidate(\"password\");\n        assert(!result.isNull\
  \ && result.get == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n\n}\nvoid main(){}"
completions: ["{\n    // Check if the string is null or empty. If so, return a null\
    \ string.\n    if (text.empty) return Nullable!(string).init;\n    \n    // Compute\
    \ the md5 hash of the given string.\n    auto md5 = new MD5;\n    md5.put(text);\n\
    \    return md5.finish().idup;\n}", "{\n    if (text.length == 0) return null;\n\
    \    import std.digest.md;\n    import std.conv;\n    return to!string(MD5(text));\n\
    }", "{\n    if (text.length == 0) \n    {\n        return null;\n    }\n    //md5\
    \ context\n    import std.digest.md;\n    import std.digest.md5;\n    MD5Context\
    \ ctx;\n    MD5Init(ctx);\n    MD5Update(ctx, cast(ubyte[])text);\n    ubyte[]\
    \ digest = new ubyte[16];\n    MD5Final(digest, ctx);\n    //returning hash\n\
    \    char[] str;\n    char[] alphabet = \"0123456789abcdef\";\n    foreach (i;\
    \ digest)\n    {\n        ubyte n = i;\n        str ~= alphabet[n >> 4];\n   \
    \     str ~= alphabet[n & 0xF];\n    }\n    return to!string(str);\n}\n/*", "{\n\
    \    // [!] Returns either null, or a not null md5 hash string\n    // [!] If\
    \ text is an empty string, return null\n    assert(text.length > 0);\n    Nullable!(string)\
    \ hash = null;\n    auto digest = text.toUTF8().sha1();\n    foreach(c; digest)\
    \ {\n        if (hash.isNull) {\n            hash = c.to!string;\n        } else\
    \ {\n            hash ~= c.to!string;\n        }\n    }\n    return hash;\n}\n\
    /*", "{\n    if (text.length == 0) return null;\n    import crypto.md5;\n    return\
    \ cast(Nullable!(string)) md5(text);\n}", "{\n    if (text.length == 0) \n   \
    \ {\n        return null;\n    }\n    import std.digest.md;\n    return cast(Nullable!(string))(md.md5(text));\n\
    }", "{\n\tif (text.length > 0) \n\t{\n\t\talias Hasher = HashMD5!();\n\t\tHasher.finish(cast(ubyte[])text);\n\
    \t\tauto md5 = text[0..Hasher.digestSize];\n\t\treturn md5.length == 0 ? null\
    \ : md5;\n\t}\n\treturn null;\n}", "{\n    Nullable!(string) string_to_md5(string\
    \ text)\n    {\n        if (text == \"\")\n        {\n            return null;\n\
    \        }\n        import std.md5;\n        return text.md5;\n    }\n}", "{\n\
    \    import std.digest.md;\n    import std.conv;\n    return (text.length!=0)\
    \ ? text.md5.to!string.toLower : null;\n}\n/*", "{\n    Nullable!(string) result;\n\
    \    if (text.length)\n    {\n        import std.md5;\n        import std.conv;\n\
    \        md5.Digest digest = to!md5.Digest(text);\n        result = to!string(digest);\n\
    \    }\n    return result;\n}", "{\n    import std.string;\n    import std.digest.md;\n\
    \    return text.length != 0 ? md5(text).encode!string.toLower : null;\n}", "{\n\
    \    import std.conv;\n    Nullable!(string) result;\n    if (text.length > 0)\n\
    \    {\n        auto digest = MD5(text.bytearray);\n        string str;\n    \
    \    foreach (const d; digest)\n        {\n            str ~= format(\"%02x\"\
    , cast(int)d);\n        }\n        result = str;\n    }\n    return result;\n}",
  "{\n    if (text == \"\")\n        return null;\n    \n    char[16] hash;\n    md5(toStringz(text),\
    \ hash.ptr);\n    return std.string.toStringz(std.string.format(\"%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x\"\
    , \n        hash[0], hash[1], hash[2], hash[3], \n        hash[4], hash[5], hash[6],\
    \ hash[7], \n        hash[8], hash[9], hash[10], hash[11], \n        hash[12],\
    \ hash[13], hash[14], hash[15]));\n}\n/*", "{\n    import std.digest.md;\n   \
    \ if (text.length > 0) {\n        return to!(Nullable!(string))(MD5(text));\n\
    \    }\n    return null;\n}\n/*", "{\n    static import std.digest.md5;\n    static\
    \ import std.conv;\n    static import std.array;\n    static import std.range;\n\
    \    static import std.string;\n    static import std.algorithm;\n    static import\
    \ std.format;\n    static import std.typecons;\n    if(text.length == 0)\n   \
    \     return Nullable!(string)();\n    else \n    {\n        auto md5 = MD5.toMD5(text);\n\
    \        return Nullable!(string)(to!string(md5));\n    }\n}", "{\n    if (text.length\
    \ == 0) return null;\n    return std.digest.md5(text);\n}", "{\n    import tango.core.convert.TextConvert;\n\
    \    import tango.core.hash.Md5;\n    import tango.core.Buffer;\n    import tango.core.ByteBuffer;\n\
    \    import tango.core.bitmanip.BitManip;\n    import tango.core.bitmanip.BitKeeper;\n\
    \    import tango.core.bitmanip.BitWriter;\n    import tango.core.bitmanip.BitReader;\n\
    \    import tango.core.bitmanip.BigEndian;\n    import tango.core.bitmanip.LittleEndian;\n\
    \    import tango.core.bitmanip.BigEndianUTF8;\n    import tango.core.bitmanip.LittleEndianUTF8;\n\
    \    import tango.core.bitmanip.UTF8BOM;\n    import tango.core.bitmanip.UTF16;\n\
    \    import tango.core.bitmanip.UTF32;\n    import tango.core.bitmanip.LE;\n \
    \   import tango.core.bitmanip.BE;\n    import tango.core.bitmanip.UTF8;\n   \
    \ import tango.core.bitmanip.UTF8BOM;\n    import tango.core.bitmanip.UTF16;\n\
    \    import tango.core.bitmanip.UTF32;\n    import tango.core.bitmanip.BITS;\n\
    \    import tango.core.bitmanip.BITS_MSB;\n    import tango.core.bitmanip.BITS_LSB;\n\
    \    import tango.core.bitmanip.BitConverter;\n    import tango.core.bitmanip.BitReader;\n\
    \    import tango.core.bitmanip.BitWriter;\n    import tango.core.bitmanip.BitKeeper;\n\
    \    import tango.core.bitmanip.BitKeeper;\n    import tango.core.bitmanip.BitReader;\n\
    \    import tango.core.bitmanip.BitWriter;\n    import tango.core.bitmanip.BitConverter;\n\
    \    import tango.core.bitmanip.ByteBuffer;\n", "{\n    if (text == \"\")\n  \
    \      return null;\n    import std.digest.md;\n    import std.conv;\n    return\
    \ to!string(MD5(text.toUtf8()));\n}", "{\n    Nullable!(string) res = Nullable!(string).init;\n\
    \    auto hash_values = md5(text);\n    size_t i = 0;\n    foreach(value; hash_values)\
    \ {\n        char buf[16];\n        ubyte uv = cast(ubyte)value;\n        // get\
    \ the hex representation and append to result string\n        auto hexstr = to!string(uv,\
    \ buf, 16);\n        if(i == 0) {\n            res.assign(hexstr);\n        }\
    \ else {\n            res.assign(res.get!string ~ hexstr);\n        }\n      \
    \  i++;\n    }\n    return res;\n}\n/*", "{\n    Nullable!(string) nullable_md5\
    \ = null;\n    if(text.length > 0) \n    {\n        import std.md5;\n        alias\
    \ md5 md5;\n        alias DigestType = ubyte[16];\n        DigestType digest =\
    \ text.md5();\n        nullable_md5 = digest.format(\"%02x\" * digest.length);\n\
    \    }\n    return nullable_md5;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
