name: HumanEval_132_is_nested
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
  \ takes a string as input which contains only square brackets.\n    The function\
  \ should return true if and only if there is a valid subsequence of brackets \n\
  \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
  [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
  [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\"\
  )\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
  \ string) \n"
tests: "unittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
  ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
  [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
  [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
  [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
  []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
  [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
  [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}"
completions: ["{\n    auto stack = Stack!(char)();\n    for (char c; c = string.popFront();)\n\
    \    {\n        if (c == '[')\n        {\n            stack.push(c);\n       \
    \ }\n        else if (c == ']')\n        {\n            if (stack.empty)\n   \
    \         {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return !stack.empty;\n}", "{\n    size_t brackets_count\
    \ = 0;\n    size_t nested_brackets_count = 0;\n    foreach(ch; string)\n    {\n\
    \        if(ch == '[')\n        {\n            ++brackets_count;\n           \
    \ ++nested_brackets_count;\n        }\n        else if(ch == ']')\n        {\n\
    \            if(brackets_count != 0)\n            {\n                --brackets_count;\n\
    \                if(nested_brackets_count != 0)\n                {\n         \
    \           --nested_brackets_count;\n                }\n            }\n     \
    \       else\n            {\n                return false;\n            }\n  \
    \      }\n    }\n    return nested_brackets_count != 0;\n}", "{\n    auto s =\
    \ string.representation;\n    auto len = s.length;\n    auto left = 0;\n    auto\
    \ right = 0;\n    foreach(i; 0..len) {\n        if (s[i] == '[') {\n         \
    \   left += 1;\n        }\n        else if (s[i] == ']') {\n            right\
    \ += 1;\n        }\n        if (right > left) {\n            return false;\n \
    \       }\n    }\n    return left == right && left > 0;\n}", "{\n    int c_left\
    \ = 0;\n    int c_right = 0;\n    foreach(char elem; string)\n    {\n        if(elem\
    \ == '[')\n        {\n            c_left++;\n        }\n        else if(elem ==\
    \ ']')\n        {\n            c_right++;\n        }\n        if(c_right > c_left)\n\
    \        {\n            return false;\n        }\n    }\n    return c_left ==\
    \ c_right && c_left != 0;\n}", "{\n\tint left_count = 0;\n\tint right_count =\
    \ 0;\n\tfor (int i = 0; i < string.length; i++)\n\t{\n\t\tif (string[i] == '[')\n\
    \t\t{\n\t\t\tleft_count++;\n\t\t}\n\t\telse if (string[i] == ']')\n\t\t{\n\t\t\
    \tright_count++;\n\t\t}\n\t\tif (right_count > left_count)\n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    // if string does not contain\
    \ square brackets return false\n    if (string.count('[') != string.count(']'))\n\
    \        return false;\n    else \n    {\n        immutable Stack!string open_brackets;\n\
    \        foreach (character; string)\n        {\n            if (character ==\
    \ '[')\n                open_brackets.push(character);\n            else if (character\
    \ == ']')\n            {\n                if (open_brackets.isEmpty())\n     \
    \               return false;\n                else\n                    open_brackets.pop();\n\
    \            }\n        }\n        return true;\n    }\n}", "{\n    auto sequence\
    \ = new bool[string.length];\n    bool open_bracket;\n    bool close_bracket;\n\
    \    bool bracket_pair = false;\n    size_t pos;\n    int open_count = 0;\n  \
    \  int close_count = 0;\n    for (size_t i = 0; i < string.length; i++) {\n  \
    \      if (string[i] == '[') {\n            open_bracket = true;\n           \
    \ open_count++;\n        } else {\n            close_bracket = true;\n       \
    \     close_count++;\n        }\n        if (open_bracket && close_bracket) {\n\
    \            bracket_pair = true;\n            open_bracket = false;\n       \
    \     close_bracket = false;\n        }\n        sequence[i] = bracket_pair;\n\
    \    }\n    if (open_count == close_count) {\n        return true;\n    } else\
    \ {\n        return false;\n    }\n}", "{\n    /*\n        For each ']' character,\
    \ find the first matching '[' that appears before it. \n        If no match can\
    \ be found, return false.\n        If a match can be found, remove the '[', ']'\
    \ pair from the string and repeat this process until there are no pairs.\n   \
    \     If only one bracket remains, return false.\n        Return true.\n    */\n\
    \    string pairs = \"[]\";\n    string::range r;\n    while ( (r = search(string,\
    \ pairs) ) != string.empty)\n    {\n        // Make sure the pair is not just\
    \ []\n        if (r.front == r.back)\n        {\n            // Find the matching\
    \ '[' character that goes with the ']'\n            auto idx = string.rfind(r.front,\
    \ r.back);\n            if (idx == string.notfound)\n            {\n         \
    \       return false;\n            }\n            else\n            {\n      \
    \          // Remove the pair from the string\n                string = erase(string,\
    \ idx, r.back);\n            }\n        }\n        else\n        {\n         \
    \   return false;\n        }\n    }\n    // If the string is not empty, it is\
    \ not nested\n    return string.empty;\n}", "{\n    auto brackets = std.algorithm.filter!(i\
    \ => i == '[' || i == ']') (string);\n    int count = 0;\n    bool open = false;\n\
    \    for (auto b : brackets) {\n        if (b == '[') {\n            if (open)\n\
    \                return false;\n            open = true;\n            count++;\n\
    \        } else {\n            if (!open)\n                return false;\n   \
    \         open = false;\n            count--;\n        }\n    }\n    return count\
    \ == 0;\n}", "{\n    int length = string.length;\n    int i = 0;\n    int nestCount\
    \ = 0;\n    while (i < length)\n    {\n        // open bracket found\n       \
    \ if (string[i] == '[')\n        {\n            nestCount++;\n        }\n    \
    \    // closed bracket found\n        else if (string[i] == ']')\n        {\n\
    \            nestCount--;\n        }\n        // if nest count ever drops below\
    \ 0, there is no possible way to have a nesting\n        if (nestCount < 0)\n\
    \        {\n            return false;\n        }\n        i++;\n    }\n    //\
    \ if nest count drops back to 0 at the end, a nesting exists\n    if (nestCount\
    \ == 0)\n    {\n        return true;\n    }\n    // if nest count doesn't drop\
    \ back to 0, there is an imbalance of open/closed brackets\n    else\n    {\n\
    \        return false;\n    }\n    \n}", "{\n    auto remaining_brackets = string.filter!(ch\
    \ => ch == '[' || ch == ']');\n    auto stack = Stack!(char)();\n    foreach (ch;\
    \ remaining_brackets) {\n        if (ch == '[') {\n            stack.push(ch);\n\
    \        } else {\n            if (stack.empty) {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    return !stack.empty;\n\
    }", "{\n    int open_count = 0;\n    int nest_count = 0;\n    bool first_open\
    \ = false;\n    bool first_nest = false;\n    auto a = new int[n];\n    foreach(ch;\
    \ string)\n    {\n        if(ch == '[')\n        {\n            if(first_open\
    \ == false)\n            {\n                open_count++;\n                first_open\
    \ = true;\n            }\n            if(nest_count > 0)\n            {\n    \
    \            return true;\n            }\n            else\n            {\n  \
    \              nest_count = 0;\n            }\n        }\n        else if(ch ==\
    \ ']')\n        {\n            if(first_nest == false)\n            {\n      \
    \          nest_count++;\n                first_nest = true;\n            }\n\
    \            if(open_count > 0)\n            {\n                return true;\n\
    \            }\n            else\n            {\n                open_count =\
    \ 0;\n            }\n        }\n    }\n    return false;\n}", "{\n    bool result\
    \ = false;\n    enum dir { left, right } ;\n    struct Bt {\n        dir direction;\n\
    \        string.RandomAccessRange.Tuple!(string, int, dir) range;\n    }\n   \
    \ auto ranges = map!(a => tuple(a, a[0], a[0] == '[' ? dir.left : dir.right))(string.split(\"\
    \"));\n    Stack!Bt stack;\n    for (auto r ; ranges) {\n        if (stack.empty\
    \ || r[2] == dir.left) {\n            stack.push(Bt(dir.left, r));\n        }\
    \ else {\n            if (stack.top.direction == dir.left) {\n               \
    \ stack.pop();\n            } else {\n                stack.push(Bt(dir.right,\
    \ r));\n            }\n        }\n    }\n    if (stack.empty) {\n        result\
    \ = true;\n    }\n    return result;\n}", "{\n    bool is_nested = false;\n  \
    \  if (string.length != 0) \n    {\n        bool is_open = false;\n        int\
    \ first_match = -1;\n        int last_match = -1;\n        int num_open = 0;\n\
    \        int num_close = 0;\n        for (int i = 0; i < string.length; i++) \n\
    \        {\n            if (string[i] == '[') \n            {\n              \
    \  num_open++;\n                if (!is_open) \n                {\n          \
    \          is_open = true;\n                    first_match = i;\n           \
    \     }\n            }\n            else if (string[i] == ']') \n            {\n\
    \                num_close++;\n                if (is_open) \n               \
    \ {\n                    is_open = false;\n                    last_match = i;\n\
    \                }\n            }\n        }\n        if (num_open == num_close\
    \ && (last_match > first_match)) \n        {\n            is_nested = true;\n\
    \        }\n    }\n    return is_nested;\n}", "{\n    auto stack = Stack!int([]);\n\
    \    foreach(character; string)\n    {\n        if(character == '[')\n       \
    \ {\n            stack.push(character);\n        }\n        else if(character\
    \ == ']')\n        {\n            if(stack.empty)\n            {\n           \
    \     return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    return stack.empty;\n}", "{\n    bool isNested = false;\n    int subNested\
    \ = 0;\n    int prevNested = 0;\n    int maxNested = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            subNested++;\n          \
    \  maxNested = max(maxNested, subNested);\n        }\n        else if(c == ']')\n\
    \        {\n            subNested--;\n        }\n        if(subNested < 0)\n \
    \       {\n            return false;\n        }\n        else if(prevNested >\
    \ 0 && subNested == 0)\n        {\n            prevNested = maxNested;\n     \
    \       maxNested = 0;\n        }\n        else if(prevNested > 0 && maxNested\
    \ > 0)\n        {\n            isNested = true;\n        }\n    }\n    return\
    \ (subNested == 0 && isNested);\n}", "{\n\tif (string.length < 2) return false;",
  "{\n    return true;\n}", "{\n    // Keeps track of the nesting level\n    // Should\
    \ never be more than 1\n    int level = 0;\n    foreach(c; string) {\n       \
    \ level += c == '[' ? 1 : -1;\n        if(level < 0) return false;\n    }\n  \
    \  return level == 0;\n}", "{\n    Stack!(char) stack;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else\n        {\n            if(stack.empty)\n            {\n       \
    \         return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    return stack.empty;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
