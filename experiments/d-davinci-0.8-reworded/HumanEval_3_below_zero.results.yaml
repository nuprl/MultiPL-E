language: d
name: HumanEval_3_below_zero
results:
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(item; operations) \n    {\n        balance\
    \ += item;\n        if (balance < 0L) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long account = 0L;\n    foreach(operation; operations) \n    {\n        account\
    \ += operation;\n        if (account < 0L) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\n/*\n You're given a 2D array(list in\
    \ python) of integers 'm' x 'n' that represents a painting canvas.\n The value\
    \ of each individual integer represents the color of a given pixel.\n    >>> image\
    \ = [\n    ...    [0, 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n    ...    [0,\
    \ 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n    ...    [0, 0, 0, 1, 1],\n   \
    \ ... ]\n    >>> max_square(image)\n    (1, 1, 2)\n    >>> image2 = [\n    ...\
    \    [0, 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n    ...    [0, 1, 0, 0, 0],\n\
    \    ...    [0, 1, 0, 0, 0],\n    ...    [0, 0, 0, 0, 0],\n    ... ]\n    >>>\
    \ max_square(image2)\n    (0, 0, 4)\n \n You should return the coordinates of\
    \ the top left pixel and the size of the largest\n square of uniform color in\
    \ the image.\n If you get stuck, you can also check for solution.\n*/\nTuple!(int,\
    \ int, int) max_square(int[][] image) \n{\n    int max_size = 0;\n    int max_col\
    \ = 0;\n    int max_row = 0;\n    // save the size of the current row in the matrix\n\
    \    int[int] row_sizes = [0 : row.length];\n    for (int row = 0; row < image.length;\
    \ row++) \n    {\n        // update row size at each column\n        for (int\
    \ col = 0; col < image[row].length; col++) \n        {\n            // If the\
    \ current pixel is different from the one on the left then reset row size\n  \
    \         \nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2x35rt2i.d(66): Error: found `unittest` instead of statement

    /tmp/tmp2x35rt2i.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp2x35rt2i.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2x35rt2i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations) \n    {\n        balance\
    \ += operation;\n        if (balance < 0L) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long currentBalance = 0L;\n    foreach(operation; operations)\n    {\n  \
    \      currentBalance += operation;\n        if(currentBalance < 0L)\n       \
    \ {\n            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (size_t i = 0UL; i < operations.length; i++)\
    \ \n    {\n        balance += operations[i];\n        if (balance < 0L) \n   \
    \     {\n            return true;\n        }\n    }\n    return false;\n}\n/*\n\
    You're given a two dimensional matrix of integers. Each value in a row is the\
    \ price\nof a single stock on a single day. Your task is to find the maximum profit\
    \ that can be made\nby buying and selling a single stock. Function should return\
    \ this maximum profit.\nThe input to this function is an array of arrays, where\
    \ each array is a series of integers\ncorresponding to the price of a stock over\
    \ a period of days.\nFor example, the array might look like this:\n[ 7, 6, 4,\
    \ 3, 1 ]\nIn this case, the function should return 5, because you could buy the\
    \ stock on the first day\nfor 7 and sell it on the last day for 1, for a profit\
    \ of 6.\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphndfnhds.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphndfnhds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long total = 0;\n    foreach(op; operations)\n    {\n        total += op;\n\
    \        if(total < 0)\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long amount = 0;\n    foreach(operation; operations)\n    {\n        amount\
    \ += operation;\n        if(amount < 0)\n            return true;\n    }\n   \
    \ return false;\n}\n/*\n You're given a sorted array of integers. You need to\
    \ check if there's a pair of integers in this\n    array that sums up to a certain\
    \ number. You function should return a tuple that contains the\n    indices of\
    \ the two integers. If no such pair exists, the function should return a tuple\
    \ of two\n    -1s.\n    >>> two_sum([1, 2, 4, 5, 6], 10)\n    (3, 4)\n    >>>\
    \ two_sum([1, 2, 4, 5, 6], 19)\n    (-1, -1)\n*/\nTuple!(long, long) two_sum(long[]\
    \ arr, long sum) \n{\n    long index1 = 0;\n    long index2 = arr.length - 1;\n\
    \    while(index1 < index2)\n    {\n        if(arr[index1] + arr[index2] == sum)\n\
    \            return tuple(index1, index2);\n        else if(arr[index1] + arr[index2]\
    \ < sum)\n            index1++;\n        else\n            index2--;\n    }\n\
    \    return tuple(-1L, -1L);\n}\n/*\n You're given an array of integers, where\
    \ all but one of them appears an even number of times,\n    and one of them appears\
    \ an odd number of times. Find the integer that appears an odd number of\n   \
    \ times.\n    >>> odd_times([1, 2, 3, 2, 3, 1, 3])\n    3\n*/\nlong odd_times(long[]\
    \ arr) \n{\n    long odd = 0;\n    foreach(elem; arr)\n        odd ^= elem;\n\
    \    return odd;\n}\n/*\n You're given an array of integers. You need to find\
    \ the maximal sum of a subarray of the array.\n    >>> max_subarray([-2, 1, -3,\
    \ 4, -1, 2, 1, -5, 4])\n    6\n*/\nlong max_subarray(long[] arr) \n{\n    long\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg5jnn793.d(71): Error: no identifier for declarator `long`

    /tmp/tmpg5jnn793.d(71): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5jnn793.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    auto acc = 0L;\n    for (op; operations)\n    {\n        acc += op;\n   \
    \     if (acc < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n  \
    \  alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4x78108e.d(16): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp4x78108e.d(21): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4x78108e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long currentBalance = 0L;\n    foreach(long item; operations)\n    {\n  \
    \      currentBalance += item;\n        if(currentBalance < 0L)\n        {\n \
    \           return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n\
    \    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n  \
    \  assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // auto[sum, _] = operations.reduce!(a, b => a + b);\n    auto sum = 0L;\n\
    \    foreach(i, v; operations)\n    {\n        sum += v;\n        if(sum < 0)\n\
    \            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations)\n    {\n        balance\
    \ += operation;\n        if(balance < 0L)\n            return true;\n    }\n \
    \   return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \  // Type: Array!(long) -> bool\n  //int balance = 0;\n  bool below_zero = false;\n\
    \  //foreach(val; operations)\n  //{\n  //  balance += val;\n  //  if(balance\
    \ < 0)\n  //  {\n  //    below_zero = true;\n  //    break;\n  //  }\n  //}\n\
    \  //return below_zero;\n  foreach(val; operations)\n  {\n    if(below_zero)\n\
    \    {\n      break;\n    }\n    if(val > 0)\n    {\n      continue;\n    }\n\
    \    if(val < 0)\n    {\n      below_zero = true;\n    }\n  }\n  return below_zero;\n\
    }\n/*\n    You're given an array of integers and an integer k. Your task is to\
    \ create an array of\n    integers containing the difference between the greatest\
    \ and smallest numbers in every\n    subarray of length k.\n    >>> delta(3, [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9])\n    [2, 2, 2, 2, 2, 2, 2]\n*/\n//int[] delta(int k,\
    \ int[] arr) \n//{\n//  // Type: int * Array!(int) -> Array!(int)\n//  int[] delta\
    \ = [0];\n//  for(int i = 0; i < arr.length - k; i++)\n//  {\n//    int big =\
    \ arr[i];\n//    int small = arr[i];\n//    for(int j = i; j < k + i; j++)\n//\
    \    {\n//      if(arr[j] > big)\n//      {\n//        big = arr[j];\n//     \
    \ }\n//      if(arr[j] < small)\n//      {\n//        small = arr[j];\n//    \
    \  }\n//    }\n//    delta ~= big - small;\n//  }\n//  return delta;\n//}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplt0kmdzk.d(80): unittest failure

    ----------------

    ??:? _d_unittestp [0x428255]

    ??:? void tmplt0kmdzk.__unittest_L75_C1() [0x427de6]

    ??:? void tmplt0kmdzk.__modtest() [0x427fd4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c23f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b0d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430265]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430714]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0a9]

    ??:? runModuleUnitTests [0x42c015]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4286a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\n/*\n\
    \    Given a string containing a text, determine if all parenthesis are matched\
    \ correctly\n    \"()\" -> true\n    \"(())\" -> true\n    \"((()))\" -> true\n\
    \    \"()()()\" -> true\n    \")\" -> false\n    \"()())\" -> false\n    \"(()()()\"\
    \ -> false\n    \"(a(b)c)\" -> true\n*/\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // Your solution\n    long tot = 0;\n    foreach(o; operations)\n    {\n\
    \        tot += o;\n        if(tot < 0)\n            return true;\n    }\n   \
    \ return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (long operation; operation in operations) \n\
    \    {\n        balance += operation;\n        if (balance < 0L) \n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\n/*\n    Your\
    \ task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return true. Otherwise it should return\
    \ false.\n*/\nauto is_below_zero(long[] operations)\n{\n    long balance = 0L;\n\
    \    for (long operation; operation in operations) \n    {\n        balance +=\
    \ operation;\n        if (balance < 0L) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvpog1f2e.d(16): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpvpog1f2e.d(24): Error: found `return` when expecting `)`

    /tmp/tmpvpog1f2e.d(33): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpvpog1f2e.d(41): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvpog1f2e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int j = operations.length;\n    long balance = 0;\n    for (int i = 0; i\
    \ < j; i++) \n    {\n        balance += operations[i];\n        if (balance <\
    \ 0) \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\n/*\n You're given an array of numbers. You need to find the average value of\
    \ the array.\n    >>> average([1L, 2L, 3L])\n    2.0\n*/\ndouble average(long[]\
    \ array) \n{\n    if (array.length == 0) \n    {\n        return 0;\n    }\n \
    \   else \n    {\n        long sum = 0;\n        foreach (long l; array) \n  \
    \      {\n            sum += l;\n        }\n        return (double)sum / array.length;\n\
    \    }\n}\n/*\n You're given an array of numbers. You need to find the lowest\
    \ value of the array.\n    >>> lowest([1L, 2L, 3L])\n    1\n*/\nlong lowest(long[]\
    \ array) \n{\n    if (array.length == 0) \n    {\n        return 0;\n    }\n \
    \   else \n    {\n        long min = array[0];\n        foreach (long l; array)\
    \ \n        {\n            if (l < min) \n            {\n                min =\
    \ l;\n            }\n        }\n        return min;\n    }\n}\n/*\nYou're given\
    \ an array of numbers. You need to find the highest value of the array.\n    >>>\
    \ highest([1L, 2L, 3L])\n    3\n*/\nlong highest(long[] array) \n{\n    if (array.length\
    \ == 0) \n    {\n        return 0;\n    }\n    else \n    {\n        long max\
    \ = array[0];\n        foreach (long l; array) \n        {\n            if (l\
    \ > max) \n            {\n                max = l;\n            }\n        }\n\
    \        return max;\n    }\n}\n/*\n You're given an array of strings. You need\
    \ to find longest common prefix of the array.\n    >>> lcp([\"apple\",\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0pj99x1n.d(45): Error: C style cast illegal, use `cast(double)sum`

    /tmp/tmp0pj99x1n.d(96): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0pj99x1n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    int sum = 0;\n\tfor (int i = 0; i < operations.length; i++)\n\t{\n\t\tsum += operations[i];\n\
    \t\tif (sum < 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool checker = false;\n    int localChecker = 0;\n    foreach(num; operations)\n\
    \    {\n        localChecker += num;\n        if(localChecker < 0)\n        {\n\
    \            checker = true;\n            break;\n        }\n    }\n    return\
    \ checker;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \  long balance = 0;\n  foreach(v; operations) \n  {\n    balance += v;\n    if\
    \ (balance < 0) \n    {\n      return true;\n    }\n  }\n  return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (auto x = operations.begin(); x < operations.end();\
    \ x++)\n    {\n        balance += *x;\n        if (balance < 0L) return true;\n\
    \    }\n    return false;\n}\n/*\n You're given an array of integer. You should\
    \ find the sum of the products of all possible pairs of elements from the array.\n\
    \    >>> sum_pairs([1, 2, 3])\n    17\n    >>> sum_pairs([4, 5, 6])\n    77\n\
    */\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbswifbcj.d(16): Error: no property `begin` for type `long[]`

    /tmp/tmpbswifbcj.d(16): Error: no property `end` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbswifbcj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int balance = 0;\n    foreach(operation; operations)\n    {\n        balance\
    \ += operation;\n        if(balance < 0) return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    long balance = 0;\n\tforeach(op; operations)\n\t{\n\t\tbalance += op;\n\t\tif(balance\
    \ < 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n/*\n Count the number of\
    \ elements that are smaller than the pivot.\n    >>> count_smaller(1, [1, 2, 3,\
    \ 4, 5])\n    0\n    >>> count_smaller(2, [1, 2, 3, 4, 5])\n    1\n    >>> count_smaller(3,\
    \ [1, 2, 3, 4, 5])\n    2\n    >>> count_smaller(4, [1, 2, 3, 4, 5])\n    3\n\
    \    >>> count_smaller(5, [1, 2, 3, 4, 5])\n    4\n    \n*/\nunittest\n{\n   \
    \ alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(val; operations)\n    {\n        balance\
    \ += val;\n        if(balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(o; operations)\n    {\n        balance +=\
    \ o;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\n/*\n\
    \    Given an array of bytes, return a new array of bytes where every byte is\
    \ duplicated.\n    For example:\n    >>> duplicate_byte([1, 2, 3])\n    [1, 1,\
    \ 2, 2, 3, 3]\n    >>> duplicate_byte([])\n    []\n*/\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    \n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuxahfeyw.d(13): Error: function `tmpuxahfeyw.below_zero` has no
    `return` statement, but is expected to return a value of type `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuxahfeyw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // write your code here\n    long sum = 0;\n    foreach(item; operations)\n\
    \    {\n        sum += item;\n        if(sum < 0) return true;\n    }\n    return\
    \ false;\n}\n/*\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvrnalulq.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrnalulq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int x = 0;\n    foreach(int i; operations)\n    {\n        x += i;\n    \
    \    if(x < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwcvdgk1p.d(16): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcvdgk1p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int balance = 0;\n    foreach(op; operations) \n    {\n        balance +=\
    \ op;\n        if (balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    if (operations.empty) return false;\n    auto acc = 0L;\n    foreach (op;\
    \ operations)\n    {\n        acc += op;\n        if (acc < 0) return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7577fd97.d(15): Error: no property `empty` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7577fd97.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int sum = 0;\n    foreach(i; operations) \n    {\n        sum += i;\n   \
    \     if (sum < 0) \n        {\n            return true;\n        }\n    }\n \
    \   return false;\n}\n/*\n Given an array of integers return an array of the same\
    \ length but with the items in reversed order.\n    >>> reverse([1, 2, 3, 4, 5])\n\
    \    [5, 4, 3, 2, 1]\n    >>> reverse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [10,\
    \ 9, 8, 7, 6, 5, 4, 3, 2, 1]\n*/\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long operation; operations)\n    {\n    \
    \    balance += operation;\n        if(balance < 0L) return true;\n    }\n   \
    \ return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(op; operations)\n    {\n        sum += op;\n \
    \       if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int sum = 0;\n    foreach(operation; operations)\n    {\n        if (operation\
    \ < 0)\n        {\n            sum += operation;\n            if (sum < 0)\n \
    \           {\n                return true;\n            }\n        }\n      \
    \  else\n        {\n            sum += operation;\n        }\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5eqgbijl.d(270): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5eqgbijl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // A big advantage of using immutable fields is that you can't change the\
    \ value of the field\n    // in the body of the function.\n    // If a function\
    \ doesn't modify a field, you should declare it as immutable\n    long balance\
    \ = 0L;\n    foreach(op; operations) \n    {\n        balance += op;\n       \
    \ if (balance < 0L) \n        {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n//You should declare functions as pure if they do not cause\
    \ any side effects, do not modify any\n//fields, and do not depend on the state\
    \ of program.\n//Declaring functions as pure makes code more robust, which improves\
    \ the code's readability.\nunittest\n{\n    alias candidate = below_zero;\n\n\
    \    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L,\
    \ -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n  \
    \  assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations) \n    {\n        balance\
    \ += operation;\n        if (balance < 0L) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n   \
    \ in {\n      assert(operations.length > 0);\n    } \n    body {\n        // Tuple\n\
    \        // (bool, long) is a tuple that has two fields, \n        // The first\
    \ field is a bool\n        // The second field is a long\n        // We use tuples\
    \ to have compound return values\n        // \n        // A tuple has two fields\n\
    \        //  1. A bool that indicate whether this is the first element\n     \
    \   //  2. An accumulator variable that hold the sum of all previous\n       \
    \ //     operations\n        // \n        // a = (true, 0)\n        //\n     \
    \   // b = (false, 0)\n        //\n        // c = (false, 1)\n        //\n   \
    \     // d = (false, 3)\n        //\n        //  a, b, c, d are all tuples\n \
    \       // \n        //  a._0 is a bool that indicates the first element\n   \
    \     //\n        //  a._1 is a long that indicates the sum of the first element\n\
    \        //\n        //\n        //  A tuple has three fields\n        //  1.\
    \ A bool that indicate whether this is the first element\n        //  2. An accumulator\
    \ variable that hold the sum of all previous\n        //     operations\n    \
    \    //  3. A boolean that indicates whether the account balance has\n       \
    \ //     gone below zero.\n        //\n        // a = (true, 0, false)\n     \
    \   //\n        // b = (false, 0, false)\n        //\n        // c = (false, 1,\
    \ false)\n        //\n        // d = (false, 3, false)\n        //\n        //\
    \  a, b, c, d are all tuples\n        // \n        //  a._0 is a bool that indicates\
    \ the first element\n        //\n        //  a._1 is a long that indicates the\
    \ sum of the first element\n        //\n        //  a._2 is a bool that indicates\
    \ whether the account has gone\n        //       below zero\n        //\n    \
    \    // \n        // The builtin function reduced takes two arguments\n      \
    \  // \n        // 1. A function\n        // \n        // 2. An array\n      \
    \  //\n        // The builtin function reduced applies the function f over\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0qtj7zsi.d(76): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0qtj7zsi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int balance = 0;\n    for (long i = 0; i < operations.length; i++){\n   \
    \     balance += operations[i];\n        if (balance < 0)\n            return\
    \ true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (long i = 0; i < operations.length; i++) \n \
    \   {\n        balance += operations[i];\n        if (balance < 0L) \n       \
    \ {\n            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(operation; operations) \n    {\n        sum +=\
    \ operation;\n        if (sum < 0)\n            return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    //long balance = 0L;\n    //for (long op in operations)\n    //    balance\
    \ += op;\n    long balance = foldr!q{a, b => a + b}(0L, operations);\n    return\
    \ balance < 0L;\n}\n/*\n You're given an array of deposit and withdrawal operations\
    \ on a bank account that starts with\n    zero balance. Your task is to detect\
    \ if at any point the balance of account fallls below zero, and\n    at that point\
    \ function should return that value. Otherwise it should return false.\n    >>>\
    \ lowest_balance([1L, 2L, 3L])\n    false\n    >>> lowest_balance([1L, 2L, -4L,\
    \ 5L])\n    -1L\n    \n*/\nlong lowest_balance(long[] operations) \n{\n    long\
    \ lowest_balance = 0L;\n    long balance = 0L;\n    foreach (op; operations)\n\
    \    {\n        balance += op;\n        if (balance < lowest_balance)\n      \
    \      lowest_balance = balance;\n    }\n    return (lowest_balance != 0L) ? lowest_balance\
    \ : long.init;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqd003mt.d(18): Error: template instance `foldr!"a, b => a + b"`
    template `foldr` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqd003mt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // Your code here\n    long sum = 0;\n    for(long i = 0; i < operations.length;\
    \ i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\n// Test\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*\n Write a function that takes an input\
    \ string and returns its value of type double.\n    When the string input doesn't\
    \ represent a valid double it should return -1.\n    >>> to_double(\"111.11\"\
    )\n    111.11\n    >>> to_double(\"bla\")\n    -1\n*/\ndouble to_double(string\
    \ input) \n{\n    double res;\n    if (input.to!double(res)) \n    {\n       \
    \ return -1;\n    }\n    return res;\n}\n/*\n Write a function that takes a vector\
    \ of integers and a number and returns true if the given number\n    exists in\
    \ the array, and false otherwise.\n    >>> find_number(1, [1, 2, 3])\n    true\n\
    \    >>> find_number(9, [1, 2, 3])\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphzpkc62h.d(37): Error: no property `to` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphzpkc62h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    return any!(l => l < 0)(scanl!((e, s) => e + s)(0L)(operations));\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcu5j2z4x.d(15): Error: template instance `any!((l) => l < 0)` template
    `any` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcu5j2z4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // you code here...\n    long acc = 0;\n    foreach(int x; operations)\n\
    \    {\n        acc += x;\n        if(acc < 0)\n            return true;\n   \
    \ }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n\
    \    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L,\
    \ -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n  \
    \  assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9fafewa2.d(17): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9fafewa2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long[] balance = [];\n    foreach(operation; operations)\n    {\n       \
    \ balance ~= operation;\n        if(balance.sum < 0)\n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwi37g_x.d(19): Error: no property `sum` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwi37g_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long current_balance = 0L;\n    foreach(op; operations) \n    {\n       \
    \ current_balance += op;\n        if (current_balance < 0L) \n        {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n \
    \   alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n   \
    \ assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    return any!\"(a < 0)(operations);\n}\nunittest\n{\n    alias candidate =\
    \ below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqu45j2kv.d(15): Error: unterminated string constant starting at
    /tmp/tmpqu45j2kv.d(15)

    /tmp/tmpqu45j2kv.d(28): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmpqu45j2kv.d(28): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqu45j2kv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(x; operations)\n    {\n        balance +=\
    \ x;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long accum = 0L;\n    for (long i = 0L; i < operations.length; i++) \n  \
    \  {\n        accum += operations[i];\n        if (accum < 0L) \n        {\n \
    \           return true;\n        }\n    }\n    return false;\n}\n/*\n You're\
    \ given an array of deposit and withdrawal operations on a bank account that starts\
    \ with\n    zero balance. Your task is to detect if at any point the balance of\
    \ account fallls below zero, and\n    at that point function should return true.\
    \ Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n\
    \    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \     long bal = 0;\n     foreach(op; operations)\n     {\n         bal += op;\n\
    \         if(bal < 0)\n         {\n             return true;\n         }\n   \
    \  }\n     return false;\n}\n/*\n    You are given an array of integers. Implement\
    \ a function that returns a new array which is the\n    reverse of the original\
    \ one.\n    >>> reverse_array([1, 2, 3, 4, 5])\n    [5, 4, 3, 2, 1]\n    >>> reverse_array([100,\
    \ 300, 300, -1])\n    [-1, 300, 300, 100]\n    >>> reverse_array([])\n    []\n\
    */\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \nin {\n\
    \    assert(operations.length > 0);\n}\nout(result) {\n    assert(result == (operations.sum\
    \ <= 0));\n}\nbody {\n    return operations.sum <= 0;\n}\n@*/\nunittest\n{\n \
    \   alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n   \
    \ assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnmwwmx1m.d(23): Error: @identifier or @(ArgumentList) expected,
    not `@*`

    /tmp/tmpnmwwmx1m.d(23): Error: valid attributes are `@property`, `@safe`, `@trusted`,
    `@system`, `@disable`, `@nogc`

    /tmp/tmpnmwwmx1m.d(23): Error: declaration expected, not `*`

    /tmp/tmpnmwwmx1m.d(28): Error: declaration expected, not `assert`

    /tmp/tmpnmwwmx1m.d(29): Error: declaration expected, not `assert`

    /tmp/tmpnmwwmx1m.d(30): Error: declaration expected, not `assert`

    /tmp/tmpnmwwmx1m.d(31): Error: declaration expected, not `assert`

    /tmp/tmpnmwwmx1m.d(32): Error: declaration expected, not `assert`

    /tmp/tmpnmwwmx1m.d(33): Error: declaration expected, not `assert`

    /tmp/tmpnmwwmx1m.d(34): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnmwwmx1m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // your code here\n    long[] lst = new long[];\n    foreach(op; operations)\n\
    \    {\n        if(lst.length == 0)\n        {\n            lst ~= op;\n     \
    \   }\n        else\n        {\n            lst ~= lst[$-1] + op;\n        }\n\
    \    }\n    bool below = false;\n    foreach(i; lst)\n    {\n        if(i < 0)\n\
    \        {\n            below = true;\n            break;\n        }\n    }\n\
    \    return below;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7168k2se.d(16): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7168k2se.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(i; operations) \n    {\n        sum += i;\n  \
    \      if (sum < 0) \n        {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n/*\n\u0414\u0430\u043D\u0430 \u0441\u0442\u0440\u043E\u043A\
    \u0430 \u0438\u0437 \u0441\u043A\u043E\u0431\u043E\u043A. \u041D\u0443\u0436\u043D\
    \u043E \u043F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0435\u0451 \u043F\
    \u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0438 \u0432\
    \u0435\u0440\u043D\u0443\u0442\u044C \u0431\u0443\u043B\u0435\u0432\u043E \u0437\
    \u043D\u0430\u0447\u0435\u043D\u0438\u0435.\n\u041F\u0440\u0430\u0432\u0438\u043B\
    \u044C\u043D\u043E\u0441\u0442\u044C \u043E\u043F\u0440\u0435\u0434\u0435\u043B\
    \u044F\u0435\u0442\u0441\u044F \u0442\u0430\u043A: \u043B\u044E\u0431\u0430\u044F\
    \ \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u044E\u0449\u0430\u044F \u0441\u043A\
    \u043E\u0431\u043A\u0430 \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\
    \u044C \u043F\u0440\u0435\u0434\u0448\u0435\u0441\u0442\u0432\u043E\u0432\u0430\
    \u043D\u0430 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u044E\u0449\u0435\u0439\
    .\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpetqvhxxo.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpetqvhxxo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations)\n    {\n        balance\
    \ += operation;\n        if(balance < 0L)\n            return true;\n    }\n \
    \   return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool b_ret = false;\n    long n_bal = 0;\n    foreach(op; operations)\n \
    \   {\n        n_bal += op;\n        if(n_bal < 0)\n        {\n            b_ret\
    \ = true;\n            break;\n        }\n    }\n    return b_ret;\n}\n/*\n Given\
    \ a positive integer 'n', return a byte array of length 'n' with all elements\
    \ set to zero.\n    >>> all_zeros(3)\n    [0, 0, 0]\n    >>> all_zeros(5)\n  \
    \  [0, 0, 0, 0, 0]\n    */\nubyte[] all_zeros(long n) \n{\n    ubyte[] b_ret =\
    \ new ubyte[n];\n    foreach(element; b_ret)\n    {\n        element = 0;\n  \
    \  }\n    return b_ret;\n}\n/*\n    Given a byte array of length 'n', return a\
    \ byte array of length 'n' with all elements set to \n    zero except for the\
    \ last element, which should be set to 1.\n    >>> all_zeros_except_last(3)\n\
    \    [0, 0, 1]\n    >>> all_zeros_except_last(5)\n    [0, 0, 0, 0, 1]\n*/\nubyte[]\
    \ all_zeros_except_last(long n) \n{\n    ubyte[] b_ret = new ubyte[n];\n    foreach(element;\
    \ b_ret)\n    {\n        element = 0;\n    }\n    b_ret[n-1] = 1;\n    return\
    \ b_ret;\n}\n/*\n    Given a string, return a list of all unique characters in\
    \ the string, order in which characters\n    appear does not matter.\n    >>>\
    \ unique_chars(\"acbacda\")\n    ['a', 'b', 'c', 'd']\n    >>> unique_chars(\"\
    1234\")\n    ['1', '2', '3', '4']\n*/\nchar[] unique_chars(string str) \n{\n \
    \   char[] c_ret;\n    foreach(character; str)\n    {\n        if(\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphjy3a700.d(76): Error: expression expected, not `unittest`

    /tmp/tmphjy3a700.d(77): Error: found `{` when expecting `)`

    /tmp/tmphjy3a700.d(87): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphjy3a700.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    bool b = false;\n\tlong sum = 0;\n\tforeach(i; operations) \n\t{\n\t\tsum += i;\n\
    \t\tif(sum < 0)\n\t\t{\n\t\t\tb = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn b;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int i = 0;\n    long sum = 0;\n    while (i < operations.length)\n    {\n\
    \        sum += operations[i];\n        if (sum < 0)\n        {\n            return\
    \ true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n \
    \   alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n   \
    \ assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool res = false;\n    long bal = 0;\n    foreach(operation; operations)\n\
    \    {\n        bal += operation;\n        if(bal < 0)\n        {\n          \
    \  res = true;\n            break;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (long i = 0; i < operations.length; i++)\n  \
    \  {\n        if (balance + operations[i] < 0)\n        {\n            return\
    \ true;\n        }\n        balance += operations[i];\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(operation; operations)\n    {\n        sum +=\
    \ operation;\n        if(sum < 0)\n            return true;\n    }\n    return\
    \ false;\n}\n/*\n    The amount of different ways to change sum amount of money.\n\
    \    >>> amount(1L)\n    1\n    >>> amount(2L)\n    2\n    >>> amount(3L)\n  \
    \  3\n*/\nlong amount(long money)\n{\n    long[uint] amount;\n    amount[0] =\
    \ 1;\n    for(long i = 1; i <= money; i++)\n    {\n        for(long j = 1; j <=\
    \ i; j++)\n        {\n            amount[i] += amount[i - j];\n        }\n   \
    \ }\n    return amount[money];\n}\n/*\n    Two timestamps: one starts at the beginning\
    \ of the year, the other\n    (stamp) starts at the end of the year. You need\
    \ to calculate the time\n    that has passed between the timestamps (in seconds).\n\
    \    >>> time(0L, 1L)\n    60\n    >>> time(1L, 1L)\n    0\n    >>> time(0L, 2L)\n\
    \    120\n*/\nlong time(long start, long stamp)\n{\n    return stamp - start;\n\
    }\n/*\n    Return a number of substrings of S that match the given condition:\n\
    \    all the characters in the substring are the same.\n    >>> count_substrings(\"\
    abc\")\n    0\n    >>> count_substrings(\"abcabc\")\n    3\n    >>> count_substrings(\"\
    aaaaa\")\n    15\n*/\nlong count_substrings(string S)\n{\n    long count = 0;\n\
    \    foreach(i; 0 .. S.length)\n    {\n        foreach(j; i .. S.length)\n   \
    \     {\n            foreach(k; i .. j)\n            {\n                if(S[k]\
    \ != S[i])\n                    break;\n                if(k == j - 1)\n     \
    \               count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n    You are given a list of integers, and an integer K\nunittest\n{\n \
    \   alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n   \
    \ assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm59io0wo.d(89): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm59io0wo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (long operation; operations) \n    {\n      \
    \  balance += operation;\n        if (balance < 0L)\n            return true;\n\
    \    }\n    return false;\n}\n/*\nYou are given an array of strings. You need\
    \ to find the number of times a given string occurs in\nthe array\n    >>> find_string_occurences([\"\
    dd\", \"dd\", \"aa\", \"bb\", \"aa\"], \"aa\")\n    2\n*/\nsize_t find_string_occurences(string[]\
    \ arr, string substring) \n{\n    size_t count = 0;\n    for (string s; arr)\n\
    \        if (s == substring)\n            count++;\n    return count;\n}\n/*\n\
    You are given an array of numbers. You need to sum even numbers that are followed\
    \ by an odd number,\ni.e. sum all even numbers that occur in the array before\
    \ an odd number is encountered.\n    >>> sum_before_odd([1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10])\n    20\n    >>> sum_before_odd([1, 3, 5, 7, 9])\n    0\n*/\nlong\
    \ sum_before_odd(long[] arr) \n{\n    long sum = 0L;\n    bool odd_encountered\
    \ = false;\n    for (long e; arr) \n    {\n        if (e % 2 == 0) \n        {\n\
    \            if (odd_encountered) \n                break;\n            sum +=\
    \ e;\n        }\n        else\n            odd_encountered = true;\n    }\n  \
    \  return sum;\n}\n/*\nYou are given an array of strings. You need to remove duplicates\
    \ and maintain the sequence of strings.\n    >>> remove_duplicates([\"aa\", \"\
    bb\", \"cc\", \"aa\", \"bb\", \"cc\", \"aa\", \"bb\", \"cc\"])\n    [\"aa\", \"\
    bb\", \"cc\"]\n*/\nstring[] remove_duplicates(string[] arr) \n{\n    string[]\
    \ result;\n    for (string s; arr) \n    {\n        if (std.array.find(result,\
    \ s) == std.array\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1urenzbp.d(16): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp1urenzbp.d(22): Error: found `return` when expecting `)`

    /tmp/tmp1urenzbp.d(33): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmp1urenzbp.d(34): Error: expression expected, not `if`

    /tmp/tmp1urenzbp.d(35): Error: found `count` when expecting `)`

    /tmp/tmp1urenzbp.d(35): Error: expression expected, not `;`

    /tmp/tmp1urenzbp.d(36): Error: found `return` when expecting `;` following statement

    /tmp/tmp1urenzbp.d(50): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmp1urenzbp.d(61): Error: found `return` when expecting `)`

    /tmp/tmp1urenzbp.d(71): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmp1urenzbp.d(74): Error: found `unittest` when expecting `)`

    /tmp/tmp1urenzbp.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp1urenzbp.d(85): Error: found `End of File` when expecting `)`

    /tmp/tmp1urenzbp.d(85): Error: found `End of'
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \  int sum = 0;\n  for (long operation : operations)\n  {\n    sum += operation;\n\
    \    if (sum < 0)\n      return true;\n  }\n  return false;\n}\n/*\n A word is\
    \ a palindrome if it is spelled the same forwards and backwards.\n    >>> is_palindrome(\"\
    radar\")\n    true\n    >>> is_palindrome(\"tractor\")\n    false\n*/\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvhqxrftx.d(16): Error: semicolon expected, not `:`

    /tmp/tmpvhqxrftx.d(16): Error: expression expected, not `:`

    /tmp/tmpvhqxrftx.d(16): Error: found `operations` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvhqxrftx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long currentBalance = 0L;\n    foreach(long operation; operations) \n   \
    \ {\n        currentBalance += operation;\n        if(currentBalance < 0L) \n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long a = 0;\n    int i = 0;\n    bool b = false;\n    while (i < operations.length)\n\
    \    {\n        a += operations[i];\n        if (a < 0)\n        {\n         \
    \   b = true;\n            break;\n        }\n        i++;\n    }\n    return\
    \ b;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \nin {\n\
    \    assert(operations.length > 0);\n} \nout (result) {\n    assert(!result ||\n\
    \           operations.filter!(a => a < 0).length > 0);\n}\nbody {\n    long balance\
    \ = 0;\n    foreach (deposit; operations) {\n        balance += deposit;\n   \
    \     if (balance < 0) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps3ckblpv.d(19): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3ckblpv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    foreach(i;0..operations.length)\n    {\n        if(operations[i]<0)\n   \
    \     {\n            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqrw1zy86.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x42824d]

    ??:? void tmpqrw1zy86.__unittest_L24_C1() [0x427de2]

    ??:? void tmpqrw1zy86.__modtest() [0x427fd0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c2ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b13e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4302d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430780]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43025d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]

    ??:? runModuleUnitTests [0x42c081]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428710]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(x; operations)\n    {\n        balance +=\
    \ x;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    for (auto op : operations)\n    {\n        sum += op;\n\
    \        if (sum < 0)\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplln6a053.d(16): Error: no identifier for declarator `op`

    /tmp/tmplln6a053.d(16): Error: expression expected, not `:`

    /tmp/tmplln6a053.d(16): Error: found `operations` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplln6a053.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n   \
    \ {\n    auto sum = 0L;\n    foreach(item; operations) \n        {\n        sum\
    \ += item;\n        if (sum < 0)\n            return true;\n        }\n    return\
    \ false;\n    }\n/*\n Given a list of strings, find the longest one which is a\
    \ palindrome.\n    >>> longest_palindrome([\"abcd\", \"abba\", \"aaa\"])\n   \
    \ \"abba\"\n    >>> longest_palindrome([\"abcd\", \"abacaxi\", \"aa\"])\n    \"\
    aa\"\n    \n*/\nstring longest_palindrome(string[] strings) \n    {\n    auto\
    \ res = std.algorithm.maxElement(\n        strings,\n        (string a, string\
    \ b) \n            {\n            return a.length < b.length || \n           \
    \        (a.length == b.length && \n                    a.front < b.front);\n\
    \            }\n        );\n    if (!res.isReverse) \n        {\n        return\
    \ res.base;\n        }\n    return \"\";\n    }\n// You're given a matrix of integers.\
    \ You need to find a row that has the most of equal adjacent\n//     elements.\n\
    //     >>> most_equal_row([[1, 2, 3], [4, 4, 4], [1, 1, 2]])\n//     [4, 4, 4]\n\
    //     >>> most_equal_row([[1, 2, 2], [4, 4, 4], [1, 1, 2]])\n//     [4, 4, 4]\n\
    //     >>> most_equal_row([[1, 2, 3], [4, 4, 4], [1, 1, 2]])\n//     [4, 4, 4]\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfywqmj76.d(34): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfywqmj76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    //return find!(op => op < 0)(operations);\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpceha4lzs.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpceha4lzs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\n/*\n    You're given a string, which can consist of any character. Your task\
    \ is to replace every occurrence\n    of any whitespace character by \"whitespace\"\
    , every occurrence of any punctuation character\n    by \"punctuation\", and every\
    \ occurrence of any alphanumeric character by \"alphanumeric\".\n    >>> replace_chars(\"\
    Hello, D!\")\n    \"alphanumeric, punctuation!\"\n    >>> replace_chars(\"Is this\
    \ a question?\")\n    \"alphanumeric whitespace alphanumeric whitespace alphanumeric\
    \ whitespace alphanumeric?\"\n*/\nstring replace_chars(string input) \n{\n   \
    \ string result = \"\";\n    foreach(ch; input)\n    {\n        if(isAlphanumeric(ch))\n\
    \            result ~= \"alphanumeric\";\n        else if(isPunctuation(ch))\n\
    \            result ~= \"punctuation\";\n        else if(isWhitespace(ch))\n \
    \           result ~= \"whitespace\";\n        else\n            result ~= ch;\n\
    \    }\n    return result;\n}\n/*\n    You're given an array of integers that\
    \ represent the intensity of light falling on a digital sensor.\n    Your task\
    \ is to find the minimum intensity of light that causes it to start working, and\
    \ the maximum\n    intensity at which it stops working.\n    >>> find_intensity([0,\
    \ 1, 2, 3, 0, 0, 3, 3, 3, 3, 3, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl4qv8pnd.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4qv8pnd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(item; operations)\n    {\n        balance\
    \ += item;\n        if(balance < 0L)\n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long a = 0;\n    foreach(i; operations)\n    {\n        a += i;\n       \
    \ if(a < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n \n/*\n  >>> partition([1, 2, 3, 4, 5,\
    \ 6, 7, 8], 4)\n  [1, 2, 3, 4, 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6,\
    \ 7, 8], 3)\n  [1, 2, 3, 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8],\
    \ 1)\n  [3, 4, 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], 0)\n  [1,\
    \ 2, 3, 4, 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], -1)\n  [1, 2,\
    \ 3, 4, 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], -3)\n  [1, 2, 3,\
    \ 4, 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], -8)\n  [1, 2, 3, 4,\
    \ 5, 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], -9)\n  [1, 2, 3, 4, 5,\
    \ 6, 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], 12)\n  [1, 2, 3, 4, 5, 6,\
    \ 7, 8]\n  >>> partition([1, 2, 3, 4, 5, 6, 7, 8], 20)\n  [1, 2, 3, 4, 5, 6, 7,\
    \ 8]\n*/\nlong[] partition(long[] input, long k) \n{\n    assert(k >= -(input.length\
    \ -\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdv08iy85.d(52): Error: expression expected, not `unittest`

    /tmp/tmpdv08iy85.d(51): Error: found `{` when expecting `)`

    /tmp/tmpdv08iy85.d(54): Error: found `alias` when expecting `)`

    /tmp/tmpdv08iy85.d(54): Error: found `candidate` when expecting `;` following
    statement

    /tmp/tmpdv08iy85.d(54): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdv08iy85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations) \n    {\n        balance\
    \ += operation;\n        if (balance < 0L) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\n/*\n Write a function that accepts an\
    \ array of integers and returns a tuple \n of the largets and the smallest value\
    \ in the array.\n    >>> largest_smallest([8, 20, 1, 4, 10])\n    (20, 1)\n  \
    \  >>> largest_smallest([14, 2, 16, 2, -10])\n    (16, -10)\n*/\nTuple!(long,\
    \ long) largest_smallest(long[] array) \n{\n    long max = array[0];\n    long\
    \ min = array[0];\n    foreach(value; array) \n    {\n        if (value > max)\
    \ \n        {\n            max = value;\n        }\n        if (value < min) \n\
    \        {\n            min = value;\n        }\n    }\n    return tuple(max,\
    \ min);\n}\n/*\n Write a function that accepts an array of integers as a parameter\
    \ and returns a new array\n containing only positive numbers.\n    >>> positive_array([-2,\
    \ -1, 0, 1, 2])\n    [1, 2]\n    >>> positive_array([-5, -4, -3, -2, -1, 0, 1,\
    \ 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n*/\nlong[] positive_array(long[] array) \n\
    {\n    long[] positive = new long[];\n    foreach(value; array) \n    {\n    \
    \    if (value > 0L) \n        {\n            positive ~= value;\n        }\n\
    \    }\n    return positive;\n}\n/*\n Write a function that accepts an array of\
    \ integers as a parameter and returns a tuple\n with the number of negative values\
    \ in the array as the first element,\n and the number of positive values in the\
    \ array as the second element.\n    >>> negative_positive([-2, -1, 0, 1, 2])\n\
    \    (2, 3)\n    >>> negative_positive([-2, -1, 0\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3yy9j0ve.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3yy9j0ve.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    long balance = 0;\n\tforeach(long op; operations)\n\t{\n\t\tbalance += op;\n\t\
    \tif(balance < 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n/*\n  Write a\
    \ function `merge` that merges two sorted arrays into one.\n  >>> merge([1, 3,\
    \ 6, 8], [2, 4, 5, 7])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n  >>> merge([1, 1, 1, 1],\
    \ [1, 1, 1, 1])\n  [1, 1, 1, 1, 1, 1, 1, 1]\n  >>> merge([1, 1, 1, 1], [2, 2,\
    \ 2, 2])\n  [1, 1, 1, 1, 2, 2, 2, 2]\n*/\nlong[] merge(long[] left, long[] right)\
    \ \n{\n\t//TODO\n\treturn null;\n}\n/*\n Write a function that takes an array\
    \ of unique integers sorted in ascending order\n and returns number of inversions\
    \ of this array.\n >>> numInversions([1, 2, 3, 4])\n 0\n >>> numInversions([1,\
    \ 3, 2, 4])\n 1\n >>> numInversions([4, 3, 2, 1])\n 6\n*/\nlong numInversions(long[]\
    \ arr) \n{\n\t//TODO\n\treturn 0;\n}\n/*\nGiven an array of integers `arr`, reverse\
    \ it.\n>>> reverse([1, 2, 3, 4])\n[4, 3, 2, 1]\n>>> reverse([])\n[]\n*/\nlong[]\
    \ reverse(long[] arr) \n{\n\tlong[] result = new long[arr.length];\n\tauto index\
    \ = arr.length - 1;\n\tforeach(long x; arr)\n\t{\n\t\tresult[index] = x;\n\t\t\
    index--;\n\t}\n\treturn result;\n}\n/*\nGiven an array of integers `arr`, return\
    \ true if it contains at least two consecutive equal elements.\n>>> hasTwoEqualAdjacent([1,\
    \ 2, 3, 4])\nfalse\n>>> hasTwoEqualAdjacent([1, 2, 3,\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1o6x0g9u.d(71): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1o6x0g9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    if (operations.length == 0)\n        return false;\n    \n    long[] new_arr\
    \ = new long[1];\n    new_arr[0] = 0;\n    foreach(num; operations)\n    {\n \
    \       new_arr ~= new_arr[$-1] + num;\n        if (new_arr[$-1] < 0)\n      \
    \      return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(c; operations)\n    {\n        sum += c;\n   \
    \     if(sum < 0)\n            return true;\n    }\n    return false;\n}\n/*\n\
    \ A function that takes a list of integers and returns a pair(a tuple) of two\n\
    \    integers in which the first number is the length of the longest sequence\
    \ of\n    consecutive integers from the input, and the second is the beginning\
    \ of that sequence\n    >>> longest_sequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\
    \    (10, 1)\n    >>> longest_sequence([1, 3, 2, 5, 4, 7, 6, 9, 8, 11])\n    (5,\
    \ 3)\n    >>> longest_sequence([1, 3, 2, 5, 4, 7, 6, 8, 9, 11])\n    (6, 2)\n\
    */\nTuple!(size_t, size_t) longest_sequence(long[] v) \n{\n    assert(v.length\
    \ > 0);\n    auto result = tuple(1, 0);\n    size_t size = 1;\n    for(size_t\
    \ i = 1; i < v.length; i++)\n    {\n        if(v[i] == v[i - 1] + 1)\n       \
    \ {\n            size++;\n            if(size > result[0])\n                result\
    \ = tuple(size, i - size + 1);\n        }\n        else\n            size = 1;\n\
    \    }\n    return result;\n}\n/*\n You're given a function that takes a list\
    \ of pairs of integers, and returns a new list of\n    pairs, but with the first\
    \ and second elements of each pair swapped.\n    >>> swap_pairs([(1, 2), (3, 4),\
    \ (5, 6)])\n    [(2, 1), (4, 3), (6, 5)]\n*/\nTuple!(size_t, size_t)[] swap_pairs(Tuple!(size_t,\
    \ size_t)[] v) \n{\n    auto w = v.dup;\n    foreach(e; w)\n        e = tuple(e[1],\
    \ e[0]);\n    return w;\nunittest\n{\n    alias candidate = below_zero;\n\n  \
    \  assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L,\
    \ -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n  \
    \  assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqlnwpbj2.d(65): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqlnwpbj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(var i; operations)\n    {\n        balance\
    \ += i;\n        if(balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}\n/*\n You're given an array of integers representing the coordinates\
    \ of the restaurants on a street.\n    Your task is to sort them in order to maximize\
    \ the number of restaurants you can visit.\n    >>> best_route([1, 3, 5, 7, 9])\n\
    \    5\n    >>> best_route([0, 9, 4, 3, 5, 9, 6, 1, 5, 4])\n    8\n    >>> best_route([-6,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6])\n    12\n*/\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxkww75u5.d(16): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkww75u5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long total = 0;\n    foreach(op; operations)\n    {\n        total += op;\n\
    \        if(total < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n\
    \    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n  \
    \  assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long? balance = null;\n    foreach(operation; operations)\n    {\n      \
    \  balance = balance.getOrElse(0L) + operation;\n        if(balance < 0)\n   \
    \         return true;\n    }\n    return false;\n}\n \n/*\n    You're given an\
    \ array of deposit and withdrawal operations on a bank account that starts with\n\
    \    zero balance. Your task is to detect if at any point the balance of account\
    \ fallls below zero, and\n    at that point function should return true. Otherwise\
    \ it should return false.\n    >>> below_zero_2([1L, 2L, 3L])\n    false\n   \
    \ >>> below_zero_2([1L, 2L, -4L, 5L])\n    true\n    >>> below_zero_2([1L, 2L,\
    \ 3L, 4L, 5L, 6L, 7L, 8L, 9L, -10L, 10L, 20L, 30L, 40L, 50L, 60L, 70L, 80L, 90L,\
    \ 100L, -110L, 110L, 120L, 130L, 140L, 150L, 160L, 170L, 180L, 190L, 200L, -210L,\
    \ 210L, 220L, 230L, 240L, 250L, 260L, 270L, 280L, 290L, 300L, -310L, 310L, 320L,\
    \ 330L, 340L, 350L, 360L, 370L, 380L, 390L, 400L, -410L, 410L, 420L, 430L, 440L,\
    \ 450L, 460L, 470L, 480L, 490L, 500L, -510L, 510L, 520L, 530L, 540L, 550L, 560L,\
    \ 570L, 580L, 590L, 600L, -610L, 610L, 620L, 630L, 640L, 650L, 660L, 670L, 680L,\
    \ 690L, 700L, -710L, 710L, 720L, 730L, 740L, 750L, 760L, 770L, 780L, 790L, 800L,\
    \ -810L, 810L, 820L, 830L, 840L, 850L, 860L, 870\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqi7up__t.d(15): Error: no identifier for declarator `long`

    /tmp/tmpqi7up__t.d(15): Error: found `?` instead of statement

    /tmp/tmpqi7up__t.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqi7up__t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long n = operations.length;\n    long prev_bal = 0;\n    long curr_bal =\
    \ 0;\n    foreach(i; 0..n) \n    {\n        curr_bal = prev_bal + operations[i];\n\
    \        if(curr_bal < 0)\n            return true;\n        prev_bal = curr_bal;\n\
    \    }\n    return false;\n}\n// tests\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    long sum = 0;\n\tforeach(op; operations)\n\t{\n\t\tsum += op;\n\t\tif(sum < 0)\n\
    \t\t\treturn true;\n\t}\n\treturn false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long[] b = [0];\n    bool t = true;\n    foreach(int i, long x; operations)\
    \ \n    {\n        b[0] += x;\n        if(b[0] < 0) \n        {\n            t\
    \ = false;\n            break;\n        }\n    }\n    return t;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8c_qzw_g.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282b5]

    ??:? void tmp8c_qzw_g.__unittest_L28_C1() [0x427dec]

    ??:? void tmp8c_qzw_g.__modtest() [0x428038]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c313]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430339]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4307e8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4302c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b17d]

    ??:? runModuleUnitTests [0x42c0e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428778]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*\n    5. Write a struct, which will represent\
    \ a point in 2D Cartesian coordinate system. Write function getDistance, which\
    \ returns a distance between two points.\n*/\nstruct Point {\n    double x;\n\
    \    double y;\n    double getDistance(ref Point other) \n    {\n        return\
    \ hypot(this.x - other.x, this.y - other.y);\n    }\n}\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    \n}\n/*\nCount that any word in the text is repeated at least n times\n \
    \   >>> count_words_repeat(\"abc def def def\", 3)\n    1\n    >>> count_words_repeat(\"\
    abc def def def\", 2)\n    1\n    >>> count_words_repeat(\"abc def def def\",\
    \ 1)\n    1\n    >>> count_words_repeat(\"aaa bbb ccc aaa\", 2)\n    2\n    >>>\
    \ count_words_repeat(\"aaa bbb ccc aaa bbb\", 2)\n    3\n    >>> count_words_repeat(\"\
    aaa bbb ccc aaa bbb\", 3)\n    2\n    >>> count_words_repeat(\"abc def def def.\
    \ ghi jkl klm klm klm klm\", 3)\n    2\n    >>> count_words_repeat(\"abc def def\
    \ def. ghi jkl klm klm klm klm\", 4)\n    1\n    >>> count_words_repeat(\"aaa\
    \ bbb ccc ddd eee fff ggg hhh\", 2)\n    0\n    >>> count_words_repeat(\"aaa\"\
    , 2)\n    1\n*/\nsize_t count_words_repeat(in string text, in size_t n) \n{\n\
    \    \n}\n/*\n    count_digits function should recursively count the number of\
    \ digits in the given number.\n    >>> count_digits(123456)\n    6\n    >>> count_digits(9)\n\
    \    1\n    >>> count_digits(0)\n    1\n    >>> count_digits(123456789012345678901234567890)\n\
    \    30\n*/\nsize_t count_digits(size_t number) \n{\n    \n}\n/*\n    prime function\
    \ should return true if the given number is prime, and false if it is not.\n \
    \   >>> prime(2)\n    true\n    >>> prime(3)\n    true\n    >>> prime(4)\n   \
    \ false\n    >>> prime(5)\n    true\n    >>> prime(6)\n    false\n    >>> prime(101)\n\
    \    true\n    >>> prime(1009)\n    true\n    >>> prime(1010)\n   \nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxs35vabt.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxs35vabt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (long i = 0L; i < operations.length; i++) \n\
    \    {\n        balance += operations[i];\n        if (balance < 0L)\n       \
    \     return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(l; operations)\n    {\n        sum += l;\n   \
    \     if(sum < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n   \
    \ alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long op=0;\n    foreach(i;operations)\n    {\n        op=op+i;\n        if(op<0)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    /*\n    You're given a sequence of parentheses, figure out if they are balanced.\n\
    \    >>> is_balanced(\"()\")\n    true\n    >>> is_balanced(\"(((())))\")\n  \
    \  true\n    >>> is_balanced(\"())(\")\n    false\n*/\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    import std.math;\n    long sum = 0;\n    foreach(op; operations) \n    {\n\
    \        sum += op;\n        if (sum < 0) \n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long operation; operations) \n    {\n   \
    \     balance += operation;\n        if (balance < 0L) \n        {\n         \
    \   return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(i; operations)\n    {\n        balance +=\
    \ i;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(long val; operations)\n    {\n        sum += val;\n\
    \        if(sum < 0)\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(i; operations)\n    {\n        balance +=\
    \ i;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\n/*\n Write a function that takes a list of ASCII strings and returns a set\
    \ of the ASCII characters that appear \n in the strings.\n >>> chars([\"erased\"\
    , \"scared\", \"tracer\"])\n  [\"e\", \"a\", \"d\", \"r\", \"s\", \"c\", \"t\"\
    ]\n  \n*/\nstring[] chars(string[] strs)\n{\n    bool[] ascii = [false; 128];\n\
    \    foreach(str; strs)\n    {\n        foreach(c; str)\n        {\n         \
    \   ascii[c] = true;\n        }\n    }\n    return filter!(c => ascii[c])(iota(128));\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy6vwiox7.d(33): Error: comma expected separating array initializers,
    not `;`

    /tmp/tmpy6vwiox7.d(33): Error: semicolon expected, not `128`

    /tmp/tmpy6vwiox7.d(33): Error: found `]` when expecting `;` following statement

    /tmp/tmpy6vwiox7.d(33): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy6vwiox7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(idx, val; operations)\n    {\n        balance\
    \ += val;\n        if(balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \     long balance = 0;\n     for (long i = 0; i < operations.length; i++)\n \
    \    {\n         balance += operations[i];\n         if (balance < 0)\n      \
    \       return true;\n     }\n     return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long transaction; operations)\n    {\n  \
    \      balance += transaction;\n        if(balance < 0L) return true;\n    }\n\
    \    return false;\n}\n/*\nYou're given a preorder traversal of a binary tree.\
    \ Your task is to reconstruct the tree.\n    >>> tree = reconstruct_preorder([1,\
    \ 2, 3, 4, 5, 6, 7])\n    >>> tree.val\n    1\n    >>> tree.left.val\n    2\n\
    \    >>> tree.right.val\n    3\n    >>> tree.left.left.val\n    4\n    >>> tree.left.right.val\n\
    \    5\n    >>> tree.right.left.val\n    6\n    >>> tree.right.right.val\n   \
    \ 7\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl889eqxn.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl889eqxn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long bal = 0;\n    foreach(op; operations)\n    {\n        bal += op;\n \
    \       if(bal < 0)\n            return true;\n    }\n    return false;\n}\n/*\n\
    \ You are given an array of pairs of a number and its square (in no particular\
    \ order).\n    Your task is to find out a pair with the given number as first\
    \ element.\n    If there is no such pair, function should return (0, 0).\n   \
    \ >>> find_pair([(3L, 9L), (5L, 25L), (2L, 4L)], 3L)\n    (3L, 9L)\n    >>> find_pair([(3L,\
    \ 9L), (5L, 25L), (2L, 4L)], 0L)\n    (0L, 0L)\n*/\nTuple!(long, long) find_pair(Tuple!(long,\
    \ long)[] pairs, long num) \n{\n    long num_squared = num * num;\n    foreach(pair;\
    \ pairs)\n    {\n        if(pair[0] == num || pair[1] == num_squared)\n      \
    \      return pair;\n    }\n    return tuple(0L, 0L);\n}\n/*\n You are given two\
    \ arrays of integer values in no particular order.\n    Your task is to find out\
    \ a pair of values (one from the first array, one from the second), such that\n\
    \    their product is maximum. Function should return this pair of values.\n \
    \   >>> find_max_product([5L, 4L, 3L, 2L, 1L], [6L, 7L, 8L, 9L, 10L])\n    (10L,\
    \ 1L)\n*/\nTuple!(long, long) find_max_product(long[] a, long[] b) \n{\n    long\
    \ max_product = 0;\n    Tuple!(long, long) max_pair = tuple(0L, 0L);\n    foreach(a_item;\
    \ a)\n    {\n        foreach(b_item; b)\n        {\n            long current_product\
    \ = a_item * b_item;\n            if(current_product > max_product)\n        \
    \    {\n               \nunittest\n{\n    alias candidate = below_zero;\n\n  \
    \  assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L,\
    \ -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n  \
    \  assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu8lxlp29.d(62): Error: found `unittest` instead of statement

    /tmp/tmpu8lxlp29.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpu8lxlp29.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpu8lxlp29.d(73): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8lxlp29.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \  int balance = 0;\n  foreach(operation; operations) \n  {\n    balance += operation;\n\
    \    if (balance < 0) \n    {\n      return true;\n    }\n  }\n  return false;\n\
    }\n/*\n    Reverse a linked list.\n    >>> string(reverse_list(typeof(null).init))\n\
    \    \"\"\n    >>> string(reverse_list(typeof([\"A\"]).init))\n    \"A\"\n   \
    \ >>> string(reverse_list(typeof([\"A\", \"B\", \"C\"]).init))\n    \"CBA\"\n\
    \    \n*/\nstring reverse_list(shared(List) n) \n{\n  shared(List) r;\n  while\
    \ (n) \n  {\n    r = typeof(r).init(n.value, r);\n    n = n.next;\n  }\n  return\
    \ string(r);\n}\n/*\n    Given a string of balanced parentheses, return an array\
    \ of\n    the number of opening brackets for each nesting level.\n    For each\
    \ level of nesting, the number of opening brackets\n    must equal the number\
    \ of closing brackets.\n    >>> count_parentheses(\"()\")\n    [1L]\n    >>> count_parentheses(\"\
    ()()\")\n    [1L, 1L]\n    >>> count_parentheses(\"()(())\")\n    [1L, 2L]\n \
    \   >>> count_parentheses(\"(())(())\")\n    [1L, 2L, 2L]\n    >>> count_parentheses(\"\
    ()(())(())\")\n    [1L, 2L, 2L, 2L]\n    >>> count_parentheses(\"()(()(()))\"\
    )\n    [1L, 2L, 3L, 3L]\n    \n*/\nlong[] count_parentheses(string s) \n{\n  int\
    \ bracket_count = 0;\n  long[] counts;\n  foreach(ch; s) \n  {\n    if (ch ==\
    \ '(') \n    {\n      if (bracket_count + 1 > counts.length) \n      {\n     \
    \   counts ~= 0;\n      }\n      counts[bracket_count]++;\n      bracket_count++;\n\
    \    }\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hxi406n.d(81): Error: found `unittest` instead of statement

    /tmp/tmp0hxi406n.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hxi406n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long bank_balance = 0L;\n    foreach(idx, elem; operations)\n    {\n    \
    \    bank_balance += elem;\n        if(bank_balance < 0L)\n        {\n       \
    \     return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(item; operations) \n    {\n        sum += item;\n\
    \        if (sum < 0) \n        {\n            return true;\n        }\n    }\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool flag = false;\n    long balance = 0;\n    foreach(op; operations)\n\
    \    {\n        balance += op;\n        if(balance < 0) \n        {\n        \
    \    flag = true;\n            break;\n        }\n    }\n    return flag;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long acc = 0;\n    foreach(element; operations) \n    {\n        acc += element;\n\
    \        if (acc < 0)\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n   \
    \ if(operations.empty) \n        return false;\n    long balance = 0;\n    for(long\
    \ op : operations) \n        balance += op;\n        if(balance < 0)\n       \
    \     return true;\n    return false;\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1po1_rak.d(14): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp1po1_rak.d(14): Error: declaration expected, not `if`

    /tmp/tmp1po1_rak.d(17): Error: declaration expected, not `for`

    /tmp/tmp1po1_rak.d(19): Error: declaration expected, not `if`

    /tmp/tmp1po1_rak.d(21): Error: declaration expected, not `return`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1po1_rak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*\nWrite a function that takes a list\
    \ of strings, and returns a single string composed of all of the\n    strings,\
    \ separated by newlines, with a trailing newline.\n    >>> multilineString([\"\
    foo\", \"bar\", \"baz\"])\n    \"foo\\nbar\\nbaz\\n\"\n*/\nstring multilineString(string[]\
    \ strings) \n{\n    string result = \"\";\n    foreach(string str; strings) \n\
    \    {\n        result ~= str ~ \"\\n\";\n    }\n    return result;\n}\n/*\nWrite\
    \ a function that takes a list of integers and returns a list of squares of those\
    \ integers.\n    >>> squareAll([1, 2, 3])\n    [1, 4, 9]\n*/\nunittest\n{\n  \
    \  alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int sum = 0;\n    foreach(x; operations)\n    {\n        sum += x;\n    \
    \    if(sum < 0)\n            return true;\n    }\n    return false;\n}\n/*\n\
    \ You're given an array of integers. It's always unsorted and has only unique\
    \ elements.\n    How quickly can you find the smallest missing integer?\n    >>>\
    \ find_smallest_missing_int([2, 0, 1])\n    3\n*/\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long total = 0;\n    foreach(op; operations)\n    {\n        total += op;\n\
    \        if(total < 0)\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    // TODO: Write your code here\n    long cur_bal = 0;\n    foreach(var op;\
    \ operations)\n    {\n        cur_bal += op;\n        if(cur_bal < 0)\n      \
    \      return true;\n    }\n    return false;\n}\n/*\n How many times an element\
    \ should be removed from an array inorder to make the array one sorted array.\n\
    \    >>> remove([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n    0\n    >>> remove([3,2,1,4,5,6,7,8,9,10,11,12,13,14,15])\n\
    \    3\n*/\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7idlr8xn.d(17): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7idlr8xn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    //bool below_zero(long[] operations) {\n    foreach(op; operations) \n  \
    \  {\n        if (op < 0L)\n            return true;\n    }\n    return false;\n\
    }\n/*\n    Given an array of positive integers and an integer k, you have to find\
    \ whether it is possible to\n    get k as the sum of some of the array elements.\n\
    \    Example:\n    >>> has_sum([0L, 1L, 2L, 3L, 4L, 5L], 11L)\n    true\n    >>>\
    \ has_sum([1L, 3L, 5L, 7L, 9L], 13L)\n    false\n*/\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7yzjra9m.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428245]

    ??:? void tmp7yzjra9m.__unittest_L32_C1() [0x427dda]

    ??:? void tmp7yzjra9m.__modtest() [0x427fc8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c22f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b0c2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430255]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430704]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b099]

    ??:? runModuleUnitTests [0x42c005]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428694]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    if (operations.empty)\n        return false;\n    long s = 0;\n    return\
    \ any!(b => (s += b) < 0)(operations);\n}\nunittest\n{\n    alias candidate =\
    \ below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqpc_hn7r.d(15): Error: no property `empty` for type `long[]`

    /tmp/tmpqpc_hn7r.d(18): Error: template instance `any!((b) => (s += b) < 0)` template
    `any` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqpc_hn7r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    auto sum = 0L;\n    auto balance = 0L;\n    auto isNegative = false;\n  \
    \  foreach(idx, val; operations)\n    {\n        sum += val;\n        if(sum <\
    \ 0L)\n        {\n            isNegative = true;\n            break;\n       \
    \ }\n    }\n    return isNegative;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    bool res;\n\tlong balance = 0;\n\t\n\t//foreach (long operation; operations) {\n\
    \tforeach(i, operation; operations)\n\t{\n\t\tbalance += operation;\n\t\tif (balance\
    \ < 0) {\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool below = false;\n    auto iter = operations.begin();\n    auto end =\
    \ operations.end();\n    long balance = 0;\n    for (; iter != end; ++iter) \n\
    \    {\n        balance += *iter;\n        if (balance < 0) \n        {\n    \
    \        below = true;\n            break;\n        }\n    }\n    return below;\n\
    }\n/*\nThis function receives a vector of longs and returns a vector with the\
    \ same elements\nfor which each element has a property: it is divisible by the\
    \ elements that are before it.\n>>> divisibles([1L, 2L, 3L, 5L, 7L])\n[1L, 2L,\
    \ 3L, 5L, 7L]\n>>> divisibles([1L, 2L, 3L, 5L, 6L])\n[1L, 2L, 3L, 5L, 6L]\n>>>\
    \ divisibles([1L, 2L, 3L, 5L, 6L, 8L])\n[1L, 2L, 3L, 5L, 6L, 8L]\n>>> divisibles([1L,\
    \ 2L, 4L, 5L, 6L, 8L])\n[1L, 2L, 4L, 5L, 6L, 8L]\n>>> divisibles([1L, 2L, 3L,\
    \ 4L, 5L, 6L, 7L, 8L])\n[1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]\n>>> divisibles([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L])\n[1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L]\n>>>\
    \ divisibles([9L, 7L, 6L, 5L, 4L, 3L, 2L, 1L])\n[9L, 7L, 6L, 5L, 4L, 3L, 2L, 1L]\n\
    >>> divisibles([1L, 2L, 3L, 4L, 5L, 6L, 8L, 9L])\n[1L, 2L, 3L, 4\nunittest\n{\n\
    \    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n  \
    \  assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa2e0g86j.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2e0g86j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n \nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    //balance of the bank account\n    long balance = 0L;\n    foreach(delta;\
    \ operations)\n    {\n        //update balance\n        balance += delta;\n  \
    \      //check if balance went below zero\n        if(balance < 0L) return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    if (operations.empty) return false;\n    int balance = 0;\n    foreach (op;\
    \ operations)\n    {\n        balance += op;\n        if (balance < 0)\n     \
    \       return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcitqcvn9.d(15): Error: no property `empty` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcitqcvn9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool belowZero = false;\n    int size = operations.length;\n    long[] startBalance\
    \ = new long[size];\n    long sum = 0;\n    for (int i = 0; i < size; i++)\n \
    \   {\n        startBalance[i] = sum;\n        sum += operations[i];\n       \
    \ if (sum < 0 && !belowZero)\n        {\n            belowZero = true;\n     \
    \   }\n    }\n    return belowZero;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7s8yw8n.d(16): Error: cannot implicitly convert expression `operations.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7s8yw8n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long amount; operations) \n    {\n      \
    \  balance += amount;\n        if (balance < 0L) \n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n/*\n You're given a vector of\
    \ integer numbers. All elements are unique and sorted.\n    The function should\
    \ return the number of elements that are strictly bigger than their previous\n\
    \    element.\n    >>> bigger_than_previous([1, 5, 2, 4, 10])\n    3\n*/\nsize_t\
    \ bigger_than_previous(int[] numbers) \n{\n    size_t counter = 0;\n    foreach(int\
    \ number; numbers) \n    {\n        if (number > numbers[$ - 1]) \n        {\n\
    \            counter++;\n        }\n    }\n    return counter;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    auto currentBalance = 0L;\n    foreach(op; operations)\n    {\n        currentBalance\
    \ += op;\n        if(currentBalance < 0) return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long runningTotal = 0;\n    foreach(operation; operations)\n    {\n     \
    \   runningTotal += operation;\n        if(runningTotal < 0)\n        {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\n \n/*\n    You're\
    \ given an array of integer numbers and a target sum. Find the amount of contiguous\
    \ sequences\n    in the array that sum up to the given target.\n    >>> sequence_amount([1L,\
    \ 2L, 1L, 3L, 2L, 1L], 4L)\n    5\n    >>> sequence_amount([1L, 2L, 1L, 3L, 2L,\
    \ 1L], 9L)\n    0\n    >>> sequence_amount([1L, -1L, 1L, -1L, 1L, -1L], 0L)\n\
    \    7\n*/\nlong sequence_amount(long[] sequence, long target) \n{\n    long runningTotal\
    \ = 0;\n    long amount = 0;\n    for(int i = 0; i < sequence.length; i++)\n \
    \   {\n        int j = i;\n        runningTotal = 0;\n        while(j < sequence.length)\n\
    \        {\n            runningTotal += sequence[j];\n            if(runningTotal\
    \ == target)\n            {\n                amount++;\n            }\n      \
    \      j++;\n        }\n    }\n    return amount;\n}\n \n/*\n    You're given\
    \ an array of numbers and a target sum. Return an array of length 2 that contains\n\
    \    the first and last indices of a contiguous subarray in the given array, that\
    \ sums up to the\n    given target. If such subarray doesn't exist, return [-1,\
    \ -1].\n    >>> subarray_indices([1L, 2L, 3L, 4L, 5L], 9L)\n    [2L, 4L]\n   \
    \ >>> subarray_indices([1L, 2L, 3L, 4L, 5L], 15L)\n    [-1L, -1L]\n    >>> subarray_indices([1L,\
    \ 2L, 1L, 3L, 2L, 1L], 4L)\n    [0L, 2L]\n    >>> subarray_indices([1L, 2L\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0knevt9.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0knevt9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations) \n    {\n        balance\
    \ += operation;\n        if (balance < 0L) return true;\n    }\n    return false;\n\
    }\n/*\nYou're given an array of birth and death years of people, and your task\
    \ is to determine the year with\n    the highest number of people alive. This\
    \ is assumed to be a closed year (i.e. everyone born in 1900\n    dies before\
    \ 1901, everyone born in 1901 dies before 1902 etc.)\n    >>> highest_population_year([[1910,\
    \ 1950], [1920, 1930], [1931, 1940]])\n    1930\n*/\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int balance = 0;\n    foreach(dep, _withdraw; operations)\n    {\n      \
    \  balance += dep;\n        if(balance < 0)\n            return true;\n    }\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0m296lro.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x428255]

    ??:? void tmp0m296lro.__unittest_L24_C1() [0x427e4d]

    ??:? void tmp0m296lro.__modtest() [0x427fd8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c23f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b0d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430265]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430714]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b0a9]

    ??:? runModuleUnitTests [0x42c015]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4286a4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long i = 0;\n    long[] d = [];\n    long[] w = [];\n    foreach(long x;\
    \ operations)\n    {\n        if(x>0)\n        {\n            d ~= x;\n      \
    \  }\n        else\n        {\n            w ~= x;\n        }\n    }\n    long\
    \ balance = 0;\n    foreach(long x; d)\n    {\n        balance += x;\n    }\n\
    \    foreach(long x; w)\n    {\n        balance += x;\n    }\n    return balance\
    \ < 0;\n}\n/*\n You're given a sorted list of numbers in increasing order, and\
    \ a target number. Your task is to find the number of times target appears in\
    \ the list.\n >>> find_num_occurences([1, 1, 2, 3, 3, 3, 4, 5, 5, 6, 6, 6, 6,\
    \ 7, 8, 8, 9, 9, 9, 10], 3)\n 3\n*/\nlong find_num_occurences(long[] sorted_list,\
    \ long target) \n{\n    long num_occurences = 0;\n    foreach(long element; sorted_list)\n\
    \    {\n        if(element == target)\n        {\n            num_occurences++;\n\
    \        }\n    }\n    return num_occurences;\n}\n/*\n>>> find_number([1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10], 10)\n9\n>>> find_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\
    \ 15)\n-1\n*/\nlong find_number(long[] sorted_list, long target) \n{\n    long\
    \ index = -1;\n    long i = 0;\n    foreach(long element; sorted_list)\n    {\n\
    \        if(element == target)\n        {\n            index = i;\n        }\n\
    \        i++;\n    }\n    return index;\n}\n/*\n >>> find_sum_equal_target([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10], 15)\n (6, 9)\n>>> find_sum_equal_target([1, 2,\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpro2w8_8f.d(77): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpro2w8_8f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool isNegative = false;\n    long sum = 0;\n    foreach(op; operations)\n\
    \    {\n        sum += op;\n        if(sum < 0)\n        {\n            isNegative\
    \ = true;\n            break;\n        }\n    }\n    return isNegative;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\n/*\n\
    \    Write a function to check if passed array is a palindrome. A palindrome is\
    \ an array that reads the\n    same backward as forward.\n    >>> is_palindrome([\"\
    a\", \"b\", \"c\", \"c\", \"b\", \"a\"])\n    true\n    >>> is_palindrome([\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n    false\n    \n*/\nunittest\n{\n \
    \   alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n   \
    \ assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (l in operations)\n    {\n        balance +=\
    \ l;\n        if (balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm8xmts8l.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmpm8xmts8l.d(22): Error: found `return` when expecting `;` following `for`
    condition

    /tmp/tmpm8xmts8l.d(22): Error: found `;` when expecting `)`

    /tmp/tmpm8xmts8l.d(23): Error: found `}` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8xmts8l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*\n Given an array of ranges, merge overlapping\
    \ ranges in-place to produce a single\n    range.\n    >>> auto r = [iota(1, 10),\
    \ iota(5, 13), iota(3, 14), iota(7, 9), iota(9, 15), iota(2, 16)];\n    >>> merge_ranges(r);\n\
    \    >>> r\n    [[1, 16]]\n    \n*/\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    for (long i = 0; i < operations.length; i++)\n    {\n\
    \        sum += operations[i];\n        if (sum < 0)\n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(op; operations)\n    {\n        sum += op;\n \
    \       if(sum < 0)\n            return true;\n    }\n    return false;\n}\n/*\n\
    \ Note: Is important to notice that above function is not generic, it only works\
    \ for integers, for\n    example, it would not work for floating point numbers,\
    \ because of their inherent inaccuracies.\n    let's fix that by using another\
    \ way of creating a module.\n*/\nmodule my_module;\nexport below_zero;\n// it's\
    \ possible to import a module's alias when using the import statement\nimport\
    \ std.math : abs;\nimport std.typecons : tuple;\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0t0bitho.d(29): Error: declaration expected, not `module`

    /tmp/tmp0t0bitho.d(30): Error: no identifier for declarator `below_zero`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0t0bitho.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(long op; operations) \n    {\n        sum += op;\n\
    \        if (sum < 0)\n            return true;\n    }\n    return false;\n}\n\
    /*\n    >>> count_subarray([1L, 0L, 1L, 1L], [1L, 1L])\n    2\n*/\nlong count_subarray(long[]\
    \ a, long[] b) \n{\n    long cnt = 0;\n    for (long i = 0; i <= a.length - b.length;\
    \ i++)\n    {\n        cnt += a[i .. i + b.length] == b;\n    }\n    return cnt;\n\
    }\n/*\n    >>> count_subarray([1L, 0L, 1L, 1L], [1L, 1L])\n    2\n*/\nlong count_subarray(long[]\
    \ a, long[] b) \n{\n    long cnt = 0;\n    for (long i = 0; i <= a.length - b.length;\
    \ i++)\n    {\n        cnt += a[i .. i + b.length] == b;\n    }\n    return cnt;\n\
    }\n/*\n    >>> count_subarray([1L, 0L, 1L, 1L], [1L, 1L])\n    2\n*/\nlong count_subarray(long[]\
    \ a, long[] b) \n{\n    long cnt = 0;\n    for (long i = 0; i <= a.length - b.length;\
    \ i++)\n    {\n        cnt += a[i .. i + b.length] == b;\n    }\n    return cnt;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(v; operations) \n    {\n        sum += v;\n  \
    \      if (sum < 0) \n        {\n            return true;\n        }\n    }\n\
    \    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long bal = 0;\n    foreach(op; operations)\n    {\n        bal += op;\n \
    \       if(bal < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n \
    \   alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n   \
    \ assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    \n}\n \n/*\n You're given a string that's composed of Latin capital letters,\
    \ non-Latin capital letters and spaces.\n    Your task is to extract the non-Latin\
    \ capital letters and put them in the same order as in the string.\n    >>> extract_non_latin(\"\
    You're given a string that's composed of Latin capital letters\")\n    \"Y'ree\
    \ giv a strin' th's composed f Lain epital etters\"\n    >>> extract_non_latin(\"\
    abcdef\")\n    \"\"\n*/\nstring extract_non_latin(string input)\n{\n    \n}\n\
    \ \n \n/*\n You're given a string and a number K. Your task is to return all the\
    \ substrings of size K, that do not \n    contain the same character twice.\n\
    \    >>> non_same_char_substrings(\"chocolate\", 2)\n    [\"ch\", \"co\", \"hc\"\
    , \"oa\", \"lh\", \"te\"]\n    >>> non_same_char_substrings(\"abacaba\", 2)\n\
    \    [\"ab\", \"ba\", \"ac\", \"ca\"]\n*/\nstring[] non_same_char_substrings(string\
    \ input, size_t K)\n{\n    \n}\n \n/*\n You're given an array of positive integers.\
    \ Your task is to find the biggest possible number that can be \n    made from\
    \ some of the elements of the array (at least two), where adjacent digits differ\
    \ by one. If such \n    number cannot be made, return 0.\n    >>> biggest_number([456,\
    \ 454, 455])\n    456455\n    >>> biggest_number([43, 55, 23, 25, 51])\n    5232551\n\
    \    >>> biggest_number([1, 2, 3, 4, 5])\n    0\n*/\nlong biggest_number(size_t[]\
    \ input)\n{\n    \n}\n \n/*\n You're given an array A of non-negative integers,\
    \ your task is to return the length of the longest zigzag \n    subsequence of\
    \ A.\n    >>> zigzag_subsequence([1, 7, 4, 9, 2, 5])\n    6\n    >>> zigzag_subsequence([1,\
    \ 17, 5, 10, 13, 15, 10,\nunittest\n{\n    alias candidate = below_zero;\n\n \
    \   assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L,\
    \ -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n  \
    \  assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq83sdkby.d(61): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq83sdkby.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long runningTotal = 0;\n    //long[] sum = new long[1000];\n    foreach(long\
    \ i; operations)\n    {\n        runningTotal += i;\n        if(runningTotal <\
    \ 0)\n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long curr_balance = 0L;\n    foreach(num; operations)\n    {\n        curr_balance\
    \ += num;\n        if(curr_balance < 0L)\n            return true;\n    }\n  \
    \  return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long current = 0;\n    foreach(var op; operations)\n    {\n        current\
    \ += op;\n        if(current < 0)\n            return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpck3hfipo.d(16): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpck3hfipo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\n/*\n *\n *\n * Given an array of operations in the format of deposit and withdrawal\
    \ operations on a bank account \n * starting with zero balance, return the minimum\
    \ balance that was reached during the course of operations.\n * If the balance\
    \ never went below zero, function should return zero.\n *\n * >>> min_balance([1L,\
    \ 2L, 3L])\n * 0L\n * >>> min_balance([1L, 2L, -4L, 5L])\n * -3L\n */\nlong min_balance(long[]\
    \ operations) \n{\n    long balance = 0L;\n    long minBal = 0L;\n    foreach(op;\
    \ operations)\n    {\n        balance += op;\n        if(balance < minBal)\n \
    \           minBal = balance;\n    }\n    return minBal;\n}\nunittest\n{\n   \
    \ alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \  int balance = 0;\n  foreach(l; operations) \n  {\n    balance += l;\n    if\
    \ (balance < 0)\n    {\n      return true;\n    }\n  }\n  return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    return std.algorithm.any!((x => x < 0))(operations);\n}\nunittest\n{\n  \
    \  alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9s79q542.d(15): Error: undefined identifier `algorithm` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9s79q542.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long current_balance = 0L;\n    foreach(idx, operation; operations)\n   \
    \ {\n        current_balance += operation;\n        if(current_balance < 0L)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    // -----------------------------------------------------------------------------------------------\n\
    /*\n    You're given a sorted (ascending) array of distinct numbers and a target\
    \ number. \n    Your task is to find two numbers in the array that sum up to the\
    \ target number.\n    >>> find_sum([1L, 2L, 3L, 4L, 5L], 7L)\n    (2L, 5L)\n \
    \   >>> find_sum([1L, 2L, 3L, 4L, 5L], 9L)\n    (4L, 5L)\n    >>> find_sum([1L,\
    \ 2L, 3L, 4L, 5L], -2L)\n    null\n    >>> find_sum([1L, 2L, 3L, 4L, 5L], 0L)\n\
    \    null\n    >>> find_sum([1L, 2L, 3L, 4L, 5L], 100L)\n    null\n*/\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long x = 0;\n    foreach(var i; operations)\n    {\n        x += i;\n   \
    \     if(x < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcmeag7s7.d(16): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcmeag7s7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\n/*\n Given a string s, return a string made of the first 2 and the last 2 chars\
    \ of the original string,\n    so 'spring' yields 'spng'. However, if the string\
    \ length is less than 2, return instead the empty\n    string.\n    >>> both_ends('spring')\n\
    \    'spng'\n    >>> both_ends('Hello')\n    'Helo'\n    >>> both_ends('a')\n\
    \    ''\n    >>> both_ends('xyz')\n    'xyyz'\n*/\nstring both_ends(string s)\
    \ \n{\n    if(s.length < 2)\n        return \"\";\n    return s[0..2] ~ s[$-2..$];\n\
    }\n/*\n Given a list of numbers, return a list where all adjacent == elements\
    \ have been reduced to a single\n    element, so [1, 2, 2, 3] returns [1, 2, 3].\
    \ You may create a new list or modify the passed in list.\n    >>> remove_adjacent([1,\
    \ 2, 2, 3])\n    [1, 2, 3]\n    >>> remove_adjacent([2, 2, 3, 3, 3])\n    [2,\
    \ 3]\n    >>> remove_adjacent([])\n    []\n*/\nauto remove_adjacent(int[] nums)\
    \ \n{\n    // TODO @21.07.2020\n    return int[0];\n}\n/*\n Given two strings,\
    \ return True if either of the strings appears at the very end of the other string,\n\
    \    ignoring upper/lower case differences (in other words, the computation should\
    \ not be 'case\n    sensitive'). Note: s.lower() returns the lowercase version\
    \ of a string.\n    >>> end_other('Hiabc', 'abc')\n    True\n    >>> end_other('AbC',\
    \ 'HiaBc')\n    True\n    >>> end_other('abc', 'abXabc')\n    True\n    >>> end_other('abc',\
    \ 'abXabc')\n    True\n    >>> end_other('abc\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf44ikud9.d(56): Error: found `[` when expecting `.` following int

    /tmp/tmpf44ikud9.d(56): Error: found `0` when expecting identifier following `int`.

    /tmp/tmpf44ikud9.d(56): Error: found `]` when expecting `;` following `return`
    statement

    /tmp/tmpf44ikud9.d(56): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpf44ikud9.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf44ikud9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(number; operations)\n    {\n        sum += number;\n\
    \        if(sum < 0)\n        {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n/*\n    You are given an array of integers. The array is\
    \ then passed to a function that adds 1 to\n    every odd integer, multiplies\
    \ every even integer by 2, and then stores the result back in the\n    same array.\
    \ \n    >>> process_array([1, 2, 3, 4, 5])\n    [3, 4, 4, 8, 6]\n*/\nlong[] process_array(long[]\
    \ array)\n{\n    foreach(i, e; array)\n    {\n        if(i % 2 == 0)\n       \
    \ {\n            array[i] = e * 2;\n        }\n        else\n        {\n     \
    \       array[i] = e + 1;\n        }\n    }\n    return array;\n}\n/*\n    You\
    \ are given an array of integers and an integer as arguments. The function should\
    \ return\n    true if any two integers in the array sum up to the integer that\
    \ was passed as an argument.\n    Otherwise, it should return false. \n    >>>\
    \ add_up([1, 2, 3, 4, 5], 6)\n    true\n    >>> add_up([1, 2, 3, 4, 5], 10)\n\
    \    false\n*/\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long total = 0;\n    for (long op in operations)\n    {\n        total +=\
    \ op;\n        if (total < 0)\n            return true;\n    }\n    return false;\n\
    }\n/*\n    Given an array of integers, your task is to rearrange its elements\
    \ in such a way that\n    the value of the product of the first and the last element\
    \ equals to the product of\n    the second and the second to last, and so on.\n\
    \    >>> arrange_value_product([1, 2, 3, 4, 5])\n    [5, 2, 4, 1, 3]\n    >>>\
    \ arrange_value_product([1, 2, 3, 4, 5, 6])\n    [1, 6, 2, 5, 3, 4]\n*/\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedx3_wsm.d(16): Error: semicolon expected, not `in`

    /tmp/tmpedx3_wsm.d(16): Error: expression expected, not `in`

    /tmp/tmpedx3_wsm.d(16): Error: found `operations` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedx3_wsm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long prev = 0;\n    foreach( op; operations) \n    {\n        prev += op;\n\
    \        if (prev < 0)\n            return true;\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long op; operations)\n    {\n        balance\
    \ += op;\n        if(balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}\n/*\n You're given an array of integers. Your task is to detect if\
    \ there are any two numbers in the array\n    whose sum is 10.\n    >>> has_10([1,\
    \ 2, 3, 4, 5])\n    false\n    >>> has_10([1, 2, 3, 4, 5, 10])\n    true\n   \
    \ >>> has_10([0, 1, 2, 3, 4, 5, 10])\n    true\n    \n*/\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    int bal = 0;\n    foreach(op; operations) {\n        bal += op;\n       \
    \ if (bal < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \  return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjlsq736x.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x4281ed]

    ??:? void tmpjlsq736x.__unittest_L17_C1() [0x427de1]

    ??:? void tmpjlsq736x.__modtest() [0x427f6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b06a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4301fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4306ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430189]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b041]

    ??:? runModuleUnitTests [0x42bfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42863c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164595
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\n/*\n Given an array of positive integers and an integer n, your task is to\
    \ split the array into a number\n    of subarrays as close to the same size as\
    \ possible, such that the sum of the elements of each\n    subarray is divisible\
    \ by n. Return a tuple of the form (size, subarrays).\n    >>> divisible_by_n([1,2,3,4,5,6,7,8,9,10],\
    \ 2)\n    (5, [([1, 2, 3, 4, 5], [6, 7, 8, 9, 10])])\n    >>> divisible_by_n([1,2,3,4,5,6,7,8,9,10],\
    \ 3)\n    (3, [([1, 2, 3, 4], [5, 6, 7], [8, 9, 10])])\n    >>> divisible_by_n([1,2,3,4,5,6,7,8,9,10],\
    \ 11)\n    (1, [([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])])\n*/\ntuple(int, long[][])\
    \ divisible_by_n(long[] values, long n)\n{\n    int size = values.length / n;\n\
    \    if(values.length % n > 0)\n        size++;\n    int current = 0;\n    long[][]\
    \ result = new long[][](n);\n    foreach(val; values)\n    {\n        if(result[current]\
    \ is null)\n            result[current] = new long[](size);\n        result[current]\
    \ ~= val;\n        current++;\n        if(current == n)\n            current =\
    \ 0;\n    }\n    return tuple(size, result);\n}\n/*\n \u0417\u0430\u0434\u0430\
    \u0447\u0430 \u0441\u0434\u0435\u043B\u0430\u0442\u044C \u043A\u043E\u043F\u0438\
    \u044E \u0441\u043F\u0438\u0441\u043A\u0430, \u043D\u043E \u0437\u0430\u043C\u0435\
    \u043D\u0438\u0442\u044C \u0432 \u043D\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy8hpvhwp.d(35): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpy8hpvhwp.d(35): Error: no identifier for declarator `tuple(int, long[][])`

    /tmp/tmpy8hpvhwp.d(35): Error: semicolon expected following function declaration

    /tmp/tmpy8hpvhwp.d(35): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpy8hpvhwp.d(36): Error: no identifier for declarator `divisible_by_n(long[]
    values, long n)`

    /tmp/tmpy8hpvhwp.d(53): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy8hpvhwp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long x = 0;\n    foreach(long y; operations)\n    {\n        x += y;\n  \
    \      if(x < 0)\n            return true;\n    }\n    return false;\n}\n/*\n\
    \ You're given two arrays, one of prices and one of quantity of items. You're\
    \ allowed to buy only\n    maximum one item in each day. Prices of the items are\
    \ given in chronological order.\n    Calculate the maximum profit that you can\
    \ make.\n    >>> maximum_profit([3L, 5L, 4L, 6L, 2L], [1L, 2L, 1L, 1L, 1L])\n\
    \    4\n*/\nlong maximum_profit(long[] prices, long[] quantity) \n{\n    long\
    \ max_profit = 0;\n    long min_price = prices[0];\n    long max_price = prices[0];\n\
    \    bool sold = false;\n    foreach(y; quantity)\n    {\n        if(y > 0)\n\
    \        {\n            foreach(x; prices)\n            {\n                if(x\
    \ < min_price)\n                    min_price = x;\n                if(x > max_price)\n\
    \                    max_price = x;\n            }\n            if(max_price >\
    \ min_price)\n            {\n                if(max_price - min_price > max_profit)\n\
    \                    max_profit = max_price - min_price;\n                min_price\
    \ = max_price;\n                max_price = 0;\n                sold = true;\n\
    \            }\n        }\n        else\n        {\n            if(sold)\n   \
    \         {\n                min_price = prices[0];\n                max_price\
    \ = prices[0];\n                sold = false;\n            }\n        }\n    }\n\
    \    return max_profit;\n}\n/*\n Given a string, return a new string where the\
    \ first and last chars have been exchanged.\n    >>> front_back(\"code\")\n  \
    \  \"eodc\"\n    >>> front_back(\"a\")\n    \"a\"\n    >>> front_back(\"ab\")\n\
    \    \"ba\"\n*/\nstring front_back(string str) \n{\n    int len = str.length;\n\
    \    if(len <= 1)\n        return\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxikm0s_3.d(83): Error: expression expected, not `unittest`

    /tmp/tmpxikm0s_3.d(84): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxikm0s_3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long total = 0;\n    foreach(op; operations) \n    {\n        total += op;\n\
    \        if (total < 0) \n        {\n            return true;\n        }\n   \
    \ }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n\
    \    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L,\
    \ -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n  \
    \  assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n  {\n\
    \    if (operations.length < 0) return false;\n    else if (operations.length\
    \ == 0) return false;\n    else if (operations.length == 1) return operations[0]\
    \ > 0 ? false : true;\n    else {\n      auto buffer = new bool[](operations.length\
    \ + 1);\n      buffer[0] = false;\n      for (int i = 1; i < operations.length\
    \ + 1; i++)\n        buffer[i] = buffer[i - 1] ? true : operations[i - 1] > 0\
    \ ? false : true;\n      return buffer[operations.length];\n    }\n  }\n/*\n Given\
    \ array of unique numbers and sum you need to find two values in array that sum\
    \ up to requested sum,\n    or return null if there is no combination that matches\
    \ required sum.\n    >>> find_sum([2L, 3L, 7L, 11L], 8L)\n    (2L, 6L)\n    >>>\
    \ find_sum([2L, 3L, 7L, 11L], 4L)\n    null\n*/\n@safe long[] find_sum(long[]\
    \ values, long sum) \n  {\n    if (values.length < 2) return null;\n    else {\n\
    \      auto buffer = new long[](values.length);\n      for (int i = 0; i < values.length;\
    \ i++)\n        buffer[i] = values[i];\n      std.algorithm.sort(buffer);\n  \
    \    for (int i = 0; i < buffer.length; i++)\n        if (std.algorithm.find(buffer,\
    \ sum - buffer[i]) != -1) return [buffer[i], sum - buffer[i]];\n      return null;\n\
    \    }\n  }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsolvbnm0.d(41): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmpsolvbnm0.d(43): Error: undefined identifier `algorithm` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsolvbnm0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    auto balance = 0L;\n    auto belowZero = false;\n    foreach(op; operations)\n\
    \    {\n        balance += op;\n        if(balance < 0)\n        {\n         \
    \   belowZero = true;\n            break;\n        }\n    }\n    return belowZero;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    long sum = 0;\n\tfor (long i = 0; i < operations.length; i++)\n\t{\n\t\tsum +=\
    \ operations[i];\n\t\tif (sum < 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\
    return false;\n}\n/*\n    A function that takes two strings of the same length,\
    \ and returns true if one of the strings is\n    a permutation of the other (meaning\
    \ that they have the same letters but rearranged).\n    >>> permutation(\"abc\"\
    , \"bca\")\n    true\n    >>> permutation(\"abc\", \"bda\")\n    false\n*/\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(index, op; operations)\n    {\n        balance\
    \ += op;\n        if(balance < 0L)\n            return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*\n You're given a list of strings. Your\
    \ task is to return a tuple of (longest string length, common\n    prefix length\
    \ of longest strings, longest string).\n    >>> longest_strings([\"abcde\", \"\
    abc\", \"ab\"])\n    (5L, 2L, \"abcde\")\n    >>> longest_strings([\"a\", \"ab\"\
    , \"abc\"])\n    (3L, 0L, \"abc\")\n    >>> longest_strings([\"x\", \"xy\", \"\
    xyz\", \"xyw\"])\n    (3L, 2L, \"xyz\")\n    >>> longest_strings([\"hello\", \"\
    hell\", \"heaven\"])\n    (5L, 4L, \"hello\")\n*/\nauto longest_strings(string[]\
    \ strings) \n{\n    auto lenAndPrefix = max(\n        strings.map!(s => tuple(s.length,\
    \ s.commonPrefixLength(strings[0]))),\n        (a, b) => a[0] > b[0] || a[0] ==\
    \ b[0] && a[1] > b[1]\n    );\n    return tuple(lenAndPrefix[0], lenAndPrefix[1],\
    \ strings[0]);\n}\n/*\n You're given a list of strings. Your task is to return\
    \ a tuple of (shortest string length, common\n    prefix length of shortest strings,\
    \ shortest string).\n    >>> shortest_strings([\"abcde\", \"abc\", \"ab\"])\n\
    \    (2L, 2L, \"ab\")\n    >>> shortest_strings([\"a\", \"ab\", \"abc\"])\n  \
    \  (1L, 0L, \"a\")\n    >>> shortest_strings([\"x\", \"xy\", \"xyz\", \"xyw\"\
    ])\n    (2L, 2L, \"xy\")\n    >>> shortest_strings([\"hello\", \"hell\", \"heaven\"\
    ])\n    (4L, 4L, \"hell\")\n*/\nauto shortest_strings(string[] strings)\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi1pz69fp.d(58): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpi1pz69fp.d(59): Error: no identifier for declarator `shortest_strings(string[]
    strings)`

    /tmp/tmpi1pz69fp.d(59): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi1pz69fp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n   \
    \ pure nothrow @safe @nogc {\n    long balance = 0L;\n    foreach (op; operations)\
    \ {\n        balance += op;\n        if (balance < 0L) {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool below_zero = false;\n    long balance = 0;\n    foreach(operation; operations)\
    \ \n    {\n        balance += operation;\n        if(balance < 0) \n        {\n\
    \            below_zero = true;\n            break;\n        }\n    }\n    return\
    \ below_zero;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool below_zero(int start, int end) pure nothrow @safe\n    {\n        if\
    \ (end < start)\n            return false;\n        else\n        {\n        \
    \    if (start == end)\n                return operations[start] < 0;\n      \
    \      else\n            {\n                int mid = (start + end) / 2;\n   \
    \             return below_zero(start, mid) || below_zero(mid + 1, end);\n   \
    \         }\n        }\n    }\n    return below_zero(0, operations.length - 1);\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5p27ushm.d(30): Error: function `tmp5p27ushm.below_zero.below_zero(int
    start, int end)` is not callable using argument types `(int, ulong)`

    /tmp/tmp5p27ushm.d(30):        cannot pass argument `operations.length - 1LU`
    of type `ulong` to parameter `int end`

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(val; operations)\n    {\n        sum += val;\n\
    \        if(sum < 0)\n            return true;\n    }\n    return false;\n}\n\
    /*\n    You're given an array of positive integers and a positive integer k. Your\
    \ task is to count the\n    number of ways that you can choose k elements from\
    \ the array so that the sum of those k\n    elements is not divisible by 3. For\
    \ example, if array is [1, 2, 3, 4, 5, 6] and k is 3, the result\n    is 7, because\
    \ you can choose from array [1, 2, 4, 5], [1, 2, 4, 6], [1, 2, 5, 6], [1, 3, 4,\
    \ 5],\n    [1, 3, 4, 6], [1, 3, 5, 6], [2, 3, 4, 5].\n    >>> ways_not_div_by_3([1L,\
    \ 2L, 3L, 4L, 5L, 6L], 3)\n    7\n*/\nlong ways_not_div_by_3(long[] array, long\
    \ k) \n{\n    long result = 0;\n    enum number_of_elements = array.length;\n\
    \    long[] elements = array;\n    foreach(i; 0 .. number_of_elements)\n    {\n\
    \        if(i == 0) \n        {\n            elements = array;\n        }\n  \
    \      else\n        {\n            elements = elements[1 .. $];\n        }\n\
    \        if(k == 1)\n        {\n            foreach(el; elements)\n          \
    \  {\n                if(el % 3 != 0)\n                    result++;\n       \
    \     }\n        }\n        else \n        {\n            foreach(el; elements)\n\
    \            {\n                if(el % 3 != 0)\n                    result +=\
    \ ways_not_div_by_3(elements, k - 1);\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\n    You're given an array of positive integers. Your task is\
    \ to find the minimum product of two elements\n    of this array.\n    >>> min_product([1L,\
    \ 2L, 3L, 4L\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2sqv19cf.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2sqv19cf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    auto result = 0L;\n    for (auto l : operations)\n    {\n        result +=\
    \ l;\n        if (result < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ua3hty8.d(16): Error: no identifier for declarator `l`

    /tmp/tmp3ua3hty8.d(16): Error: expression expected, not `:`

    /tmp/tmp3ua3hty8.d(16): Error: found `operations` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ua3hty8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    auto sum = 0L;\n    foreach(op; operations) \n    {\n        if(sum + op\
    \ < 0)\n            return true;\n        sum += op;\n    }\n    return false;\n\
    }\n \n/*\n Returns the max profit that can be obtained from buying the stock once\
    \ and selling it once,\n    assuming that you can only buy the stock on day 0\
    \ and sell it on day N (both days inclusive).\n    Assume that N is greater than\
    \ 0.\n    >>> max_profit([2L, 7L, 5L, 8L, 11L, 9L])\n    9\n    >>> max_profit([2L,\
    \ 1L, 2L, 1L, 0L, 1L, 2L])\n    2\n*/\n \nlong max_profit(long[] stock_prices)\
    \ \n{\n    long maxProfit = 0L;\n    foreach(i, price; stock_prices) \n    {\n\
    \        foreach(j, other_price; stock_prices[i..$]) \n        {\n           \
    \ maxProfit = max(maxProfit, other_price - price);\n        }\n    }\n    return\
    \ maxProfit;\n}\n \n/*\n Returns the maximum length of the longest palindromic\
    \ subsequence in the array.\n    >>> max_palindrome_subsequence([1L, 2L, 1L])\n\
    \    3\n    >>> max_palindrome_subsequence([2L, 2L, 3L, 3L, 3L])\n    5\n    >>>\
    \ max_palindrome_subsequence([0L, 0L, 1L, 0L, 0L])\n    5\n*/\nlong max_palindrome_subsequence(long[]\
    \ a) \n{\n    auto size = a.length;\n    auto i = 0;\n    auto j = size - 1;\n\
    \    auto count = 0;\n    while(i < j) \n    {\n        if(a[i] == a[j]) \n  \
    \      {\n            count += 2;\n            i++;\n            j--;\n      \
    \  }\n        else if(a[i + 1] == a[j]) \n        {\n            count += 2;\n\
    \            i += 2\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp62q_srmb.d(75): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmp62q_srmb.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp62q_srmb.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp62q_srmb.d(86): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp62q_srmb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    for (long operation; operation in operations) \n\
    \    {\n        balance += operation;\n        if (balance < 0L) \n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvze4aj1x.d(16): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmpvze4aj1x.d(24): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvze4aj1x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164594
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool f = false;\n    long balance = 0;\n    foreach(operation; operations)\n\
    \    {\n        balance += operation;\n        if(balance < 0)\n        {\n  \
    \          f = true;\n            break;\n        }\n    }\n    return f;\n}\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L) return true;\n    }\n    return false;\n}\n//Solution:\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long initial_balance = 0L;\n    foreach(i; operations)\n    {\n        initial_balance\
    \ += i;\n        if(initial_balance < 0L)\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long acc = 0;\n    bool ret = false;\n    foreach(x; operations)\n    {\n\
    \        acc += x;\n        if(acc < 0)\n        {\n            ret = true;\n\
    \            break;\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(op; operations)\n    {\n        sum += op;\n \
    \       if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(i; operations) {\n        balance += i;\n\
    \        if (balance < 0L)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    auto acc =0L;\n\tbool flag =false;\n\tforeach(op;operations)\n\t{\n\t\tacc+=op;\n\
    \t\tif(acc<0)\n\t\t{\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long currentBalance = 0L;\n    foreach(i; operations)\n    {\n        currentBalance\
    \ += i;\n        if(currentBalance < 0L)\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\n/*\n Write a function that receives a\
    \ string in one of the following formats:\n \"HH:MM\", \"HH:MM:SS\", \"HH:MM:SS.SSS\"\
    \ and converts it to the number of milliseconds passed since midnight.\n Your\
    \ function should return the number of milliseconds in the corresponding long\
    \ format.\n    \n    >>> convertToMillis(\"12:00\")\n    43200000L\n    >>> convertToMillis(\"\
    00:20:00\")\n    1200000L\n    >>> convertToMillis(\"00:01:25.234\")\n    85234L\n\
    \    \n*/\nlong convertToMillis(string t) \n{\n    auto arr = t.split(\":\");\n\
    \    long time = 0L;\n    long timeMultiplier = 0L;\n    if(arr.length == 2)\n\
    \    {\n        timeMultiplier = 60000L;\n    }\n    else if(arr.length == 3)\n\
    \    {\n        timeMultiplier = 1000L;\n    }\n    foreach(i; arr)\n    {\n \
    \       time += (to!long(i) * timeMultiplier);\n        timeMultiplier /= 60L;\n\
    \    }\n    return time;\n}\n/*\n    You're given a list of n strings containing\
    \ words in random order (but with the same length).\n    Your task is to return\
    \ a 2D array, where n strings are sorted lexicographically.\n    >>> sortByLength([\"\
    abc\", \"cd\", \"bca\"])\n    [\"abc\", \"bca\", \"cd\"]\n    >>> sortByLength([\"\
    abcd\", \"bc\", \"efg\", \"h\"])\n    [\"h\", \"bc\", \"efg\", \"abcd\"]\n*/\n\
    string[] sortByLength(string[] strs) \n{\n    string[] result = new string[strs.length];\n\
    \    int[] strsLength = new int[strs.length];\n    int i = 0;\n    foreach(s;\n\
    unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) ==\
    \ false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwsqjjwi2.d(73): Error: expression expected, not `unittest`

    /tmp/tmpwsqjjwi2.d(74): Error: found `{` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsqjjwi2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(long operation; operations)\n    {\n    \
    \    balance += operation;\n        if(balance < 0L)\n            return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\
    \n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L,\
    \ 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L,\
    \ -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(op; operations) \n    {\n        balance\
    \ += op;\n        if (balance < 0L) \n        {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\n/*\n Write a function that checks whether\
    \ a string is a palindrome. A palindrome is a string that reads\n    the same\
    \ both backward and forward.\n    >>> is_palindrome(\"abba\")\n    true\n    >>>\
    \ is_palindrome(\"abc\")\n    false\n    >>> is_palindrome(\"ab ba\")\n    true\n\
    \    \n*/\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    foreach(op; operations)\n    {\n        sum += op;\n \
    \       if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n\
    \    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L,\
    \ 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L,\
    \ 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L])\
    \ == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164593
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n \
    \       sum += operations[i];\n        if (sum < 0)\n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0L;\n    foreach(operation; operations)\n    {\n        balance\
    \ += operation;\n        if(balance < 0L)\n            return true;\n    }\n \
    \   return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164592
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    bool b = false;\n    long balance = 0;\n    for (long i = 0; i < operations.length;\
    \ i++)\n    {\n        balance += operations[i];\n        if (balance < 0)\n \
    \       {\n            b = true;\n            break;\n        }\n    }\n    return\
    \ b;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n You're given an array of\
    \ deposit and withdrawal operations on a bank account that starts with\n    zero\
    \ balance. Your task is to detect if at any point the balance of account fallls\
    \ below zero, and\n    at that point function should return true. Otherwise it\
    \ should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\t\
    long balance = 0;\n\tforeach( long op; operations) \n\t{\n\t\tbalance += op;\n\
    \t\tif (balance < 0) \n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164595
