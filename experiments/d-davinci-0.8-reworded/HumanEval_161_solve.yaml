name: HumanEval_161_solve
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYou are given a string s.\n \
  \   if s[i] is a letter, reverse its case from lower to upper or vise versa, \n\
  \    otherwise keep it as it is.\n    If the string contains no letters, reverse\
  \ the string.\n    The function should return the resulted string.\n    Examples\n\
  \    >>> solve(\"1234\")\n    \"4321\"\n    >>> solve(\"ab\")\n    \"AB\"\n    >>>\
  \ solve(\"#a@C\")\n    \"#A@c\"\n    \n*/\nstring solve(string s) \n"
tests: "unittest\n{\n    alias candidate = solve;\n\n    assert(candidate(\"AsDf\"\
  ) == \"aSdF\");\n    assert(candidate(\"1234\") == \"4321\");\n    assert(candidate(\"\
  ab\") == \"AB\");\n    assert(candidate(\"#a@C\") == \"#A@c\");\n    assert(candidate(\"\
  #AsdfW^45\") == \"#aSDFw^45\");\n    assert(candidate(\"#6@2\") == \"2@6#\");\n\
  \    assert(candidate(\"#$a^D\") == \"#$A^d\");\n    assert(candidate(\"#ccc\")\
  \ == \"#CCC\");\n}\nvoid main(){}"
completions: ["{\n    if(s.canFind(\"[a-zA-Z]\"))\n    {\n        string res;\n  \
    \      foreach(char c; s)\n        {\n            if(c.isLetter)\n           \
    \     res ~= c.toupper;\n            else\n                res ~= c.tolower;\n\
    \        }\n        return res;\n    }\n    else\n        return s.dup.reverse;\n\
    }", "{\n    auto it = s.front;\n    auto end = s.back;\n    string res = \"\"\
    ;\n    while(it != end)\n    {\n        res ~= it;\n        it = it.next;\n  \
    \  }\n    res ~= it;\n    return res;\n}\n/*\n    int size = s.length;\n    if(!size)\n\
    \        return s;\n    string res = \"\";\n    if(!std.typecons.isAlpha(s[0]))\n\
    \    {\n        for(int i = 0; i < size; i++)\n        {\n            if(std.typecons.isAlpha(s[i]))\n\
    \            {\n                res ~= std.string.tolower(s[i]);\n           \
    \ }\n            else\n            {\n                res ~= s[i];\n         \
    \   }\n        }\n    }\n    else\n    {\n        for(int i = 0; i < size; i++)\n\
    \        {\n            if(std.typecons.isAlpha(s[i]))\n            {\n      \
    \          res ~= std.string.toupper(s[i]);\n            }\n            else\n\
    \            {\n                res ~= s[i];\n            }\n        }\n    }\n\
    \    return res;\n*/", "{\n    string str;\n    if (std.algorithm.all!(isLetter)(s))\n\
    \    {\n        str = s.dup;\n        std.algorithm.retro(str);\n        return\
    \ str;\n    }\n    else \n    {\n        auto a = s.map!(a => isLetter(a) ? (a\
    \ > 'Z' ? a.toUpper : a.toLower) : a);\n        return a.toString;\n    }\n}",
  "{\n    typeof(return) r;\n    r.length = s.length;\n    for (int i = 0; i < s.length;\
    \ i++)\n    {\n        if (('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i]\
    \ <= 'Z'))\n        {\n            r[i] = s[i] ^ 0x20;\n        }\n        else\n\
    \        {\n            r[i] = s[i];\n        }\n    }\n    return r;\n}", "{\n\
    \    static if (is(typeof(s[0]) : char))\n    {\n        string s2;\n        foreach\
    \ (immutable c; s)\n        {\n            if (isLetter(c))\n                s2\
    \ ~= c.toUpper() ~ c.toLower();\n            else\n                s2 ~= c;\n\
    \        }\n        return s2.dup.idup;\n    }\n    else\n    {\n        string\
    \ s2;\n        foreach (immutable c; s)\n        {\n            if (isDigit(c))\n\
    \                s2 ~= c;\n            else\n                s2 ~= to!string(c);\n\
    \        }\n        return s2.dup.idup;\n    }\n}", "{\n    string result = \"\
    \";\n    if(s.length < 2) return s;\n    foreach(ch; s)\n    {\n        if(isalpha(ch))\
    \ result ~= \n            (isupper(ch) ? tolower(ch) : toupper(ch));\n       \
    \ else result ~= ch;\n    }\n    return result;\n}", "{\n    return replace(s,(a){\
    \ \n        if(a>='a' && a<='z') \n            return to!char(a+'A'-'a');\n  \
    \      else if(a>='A' && a<='Z') \n            return to!char(a+'a'-'A');\n  \
    \      else return a;\n    });\n}\n// import std.stdio;\n// void main()\n// {\n\
    //     writefln(\"%s\",solve(\"aBcDe\"));\n// }", "{\n\tbool isOk=false;\n\tforeach(e;s)\n\
    \t{\n\t\tif(('a'..'z').canFind(e)||('A'..'Z').canFind(e))\n\t\t{\n\t\t\tisOk=true;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\tif(isOk)\n\t{\n\t\tforeach(e;s)\n\t\t{\n\t\t\tif(('a'..'z').canFind(e))\n\
    \t\t\t{\n\t\t\t\ts=s.replace(e,to!string(toUpper(e)));\n\t\t\t}\n\t\t\telse if(('A'..'Z').canFind(e))\n\
    \t\t\t{\n\t\t\t\ts=s.replace(e,to!string(toLower(e)));\n\t\t\t}\n\t\t}\n\t}\n\t\
    else\n\t{\n\t\ts=s.dup.reverse;\n\t}\n    return s;\n}", "{\n    if (s.canFind('a')\
    \ == false && s.canFind('A') == false)\n        return reverse(s);\n    string\
    \ result = \"\";\n    foreach (c; s)\n    {\n        auto low = to!char(c);\n\
    \        auto high = to!char(c);\n        if (c == low)\n            result ~=\
    \ high;\n        else if (c == high)\n            result ~= low;\n        else\n\
    \            result ~= c;\n    }\n    return result;\n}", "{\n    string temp\
    \ = \"\";\n    bool letters = false;\n    foreach(c; s)\n    {\n        letters\
    \ = letters || isAlpha(c);\n        temp ~= (isAlpha(c) ? (c.isUpper ? c.toLower\
    \ : c.toUpper) : c);\n    }\n    return letters ? temp : temp.reverse;\n}", "{\n\
    \  string result;\n  enum {upper, lower} letter_mode;\n  foreach(ch; s)\n  {\n\
    \    if(!isLetter(ch))\n    {\n      if(result.length != 0)\n      {\n       \
    \ result = reverse(result);\n      }\n      if(ch.isUpper)\n      {\n        letter_mode\
    \ = lower;\n      }\n      else if(ch.isLower)\n      {\n        letter_mode =\
    \ upper;\n      }\n      else\n      {\n        letter_mode = nothrow;\n     \
    \ }\n      result ~= ch;\n    }\n    else\n    {\n      if(letter_mode == lower)\n\
    \      {\n        result ~= ch.toLower;\n      }\n      else if(letter_mode ==\
    \ upper)\n      {\n        result ~= ch.toUpper;\n      }\n      else\n      {\n\
    \        result ~= ch;\n      }\n    }\n  }\n  if(result.length != 0)\n  {\n \
    \   result = reverse(result);\n  }\n  return result;\n}", "{\n    auto res = s.empty\
    \ ? \"\" : s.dup;\n    auto count = 0;\n    foreach(i, c; s) {\n        if (c.isLetter)\
    \ {\n            res[i] = to!string(c)[0] ^ \" \";\n            count++;\n   \
    \     }\n    }\n    if (count == 0) res = reverse(res);\n    return res;\n}",
  "{\n\treturn s.split()\n\t\t.map!(c => !c.isLetter() ? c : c.toUpper() ^ c.toLower())\n\
    \t\t.join;\n}", "{\n   string str;\n   foreach(c; s)\n   {\n       if(c>='a' &&\
    \ c<='z')\n            str ~= toupper(c);\n       else if(c>='A' && c<='Z')\n\
    \            str ~= tolower(c);\n       else \n            str ~= c;\n   }\n \
    \  return str;\n}\n/*\nYou are given a string s.\n    The function should return\
    \ a string that contains the digits of s in the same order, but grouped by threes.\n\
    \    Examples\n    >>> solve(\"123456789\")\n    \"123 456 789\"\n    >>> solve(\"\
    123 456 789\")\n    \"123 456 789\"\n    >>> solve(\"9\")\n    \"9\"\n*/\nstring\
    \ solve(string s) \n{\n   string str;\n   int k = 0;\n   foreach(c; s)\n   {\n\
    \       if(k == 3)\n       {\n            str ~= \" \";\n            k = 0;\n\
    \       }\n       if(c>='0' && c<='9')\n       {\n            str ~= c;\n    \
    \        k++;\n       }\n   }\n   return str;\n}\n/*\nYou are given two strings\
    \ s and t.\n    The function should return true if s and t contain the same characters\
    \ but in a different order, false otherwise.\n    Examples\n    >>> solve(\"abcd\"\
    , \"bacd\")\n    true\n    >>> solve(\"bacd\", \"abcd\")\n    true\n    >>> solve(\"\
    aaab\", \"aabb\")\n    true\n    >>> solve(\"bacd\", \"abcd\")\n    true\n   \
    \ >>> solve(\"bcad\", \"abcd\")\n    false\n    >>> solve(\"abcd\", \"aaaa\")\n\
    \    false\n*/", "{\n    int len = s.length;\n    string ans = \"\";\n    for\
    \ (int i = 0; i < len; i++)\n    {\n        if (s[i] >= 'a' && s[i] <= 'z')\n\
    \        {\n            ans += (char)(s[i] - 32);\n        }\n        else if\
    \ (s[i] >= 'A' && s[i] <= 'Z')\n        {\n            ans += (char)(s[i] + 32);\n\
    \        }\n        else\n        {\n            ans += s[i];\n        }\n   \
    \ }\n    return len == 0 ? s : ans;\n}", "{\n    int len = s.length;\n    string\
    \ ltr = \"abcdefghijklmnopqrstuvwxyz\";\n    string ret;\n    foreach(i; 0 ..\
    \ len)\n    {\n        if(s[i] in ltr)\n        {\n            char ch = toUpper(s[i]);\n\
    \            ret ~= ch;\n        }\n        else\n        {\n            char\
    \ ch = toLower(s[i]);\n            ret ~= ch;\n        }\n    }\n    return ret;\n\
    }", "{\n    foreach(c; s) \n    {\n        if(isAlpha(c))\n            c = toUpper(c);\n\
    \        else\n            c = toLower(c);\n    }\n    return s;\n}\n/*\n    More\
    \ Efficient Solution\n    It is a bit faster, because it only runs over characters\
    \ \n    which are already letters (or digits), and avoids the \n    toLower and\
    \ toUpper calls.\n*/\nstring solve(string s) \n{\n    return s\n    .replace!(c\
    \ => !isAlpha(c) ? c : \n                isLower(c) ? toUpper(c) : toLower(c));\n\
    }\n/*\n    The most direct way is to use map\n*/\nstring solve(string s) \n{\n\
    \    return s.map!(c => !isAlpha(c) ? c : \n                  isLower(c) ? toUpper(c)\
    \ : toLower(c));\n}\n/*\n    For a somewhat more efficient solution, create \n\
    \    a dictionary (mapping) from characters to characters \n    to be used by\
    \ replace.\n*/\nstring solve(string s) \n{\n    immutable mapping = ['a':'A',\
    \ 'b':'B', 'c':'C', 'd':'D', 'e':'E', 'f':'F',\n                         'g':'G',\
    \ 'h':'H', 'i':'I', 'j':'J', 'k':'K', 'l':'L',\n                         'm':'M',\
    \ 'n':'N', 'o':'O', 'p':'P', 'q':'Q', 'r':'R',\n                         's':'S',\
    \ 't':'T', 'u':'U', 'v':'V', 'w':'W', 'x':'X',\n                         'y':'Y',\
    \ 'z':'Z', 'A':'a', 'B':'b', 'C':'c', 'D':'d',\n                         'E':'e',\
    \ 'F':'f', 'G':'g', 'H':'h', 'I':'i', 'J':'j',\n                         'K':'k',\
    \ 'L", "{\n    string reverse = \"\";\n    // First condition to check if there\
    \ is any letter in string\n    if(s.canFind('a') || s.canFind('A') || s.canFind('b')\
    \ || s.canFind('B') || s.canFind('c') || s.canFind('C') || s.canFind('d') || s.canFind('D')\
    \ || s.canFind('e') || s.canFind('E') || s.canFind('f') || s.canFind('F') || s.canFind('g')\
    \ || s.canFind('G') || s.canFind('h') || s.canFind('H') || s.canFind('i') || s.canFind('I')\
    \ || s.canFind('j') || s.canFind('J') || s.canFind('k') || s.canFind('K') || s.canFind('l')\
    \ || s.canFind('L') || s.canFind('m') || s.canFind('M') || s.canFind('n') || s.canFind('N')\
    \ || s.canFind('o') || s.canFind('O') || s.canFind('p') || s.canFind('P') || s.canFind('q')\
    \ || s.canFind('Q') || s.canFind('r') || s.canFind('R') || s.canFind('s') || s.canFind('S')\
    \ || s.canFind('t') || s.canFind('T') || s.canFind('u') || s.canFind('U') || s.canFind('v')\
    \ || s.canFind('V') || s.canFind('w') || s.canFind('W') || s.canFind('x') || s.canFind('X')\
    \ || s.canFind('y') || s.canFind('Y') || s.canFind('z') || s.canFind('Z')){\n\
    \        // Reverse case function\n        for(in i = 0; i < s.length; i++){\n\
    \            // if char is uppercase reverse it to lower\n            if(s[i]\
    \ == 'A' || s[i] == 'B' || s[i] == 'C' || s", "{\n    string no_letters = \"\"\
    , letters = \"\";\n    foreach(immutable char c; s)\n    {\n        static bool\
    \ isLower = false;\n        static bool isUpper = false;\n        isLower = isLower\
    \ || isLowerAlpha(c);\n        isUpper = isUpper || isUpperAlpha(c);\n       \
    \ if(isLowerAlpha(c) || isUpperAlpha(c))\n        {\n            letters ~= c;\n\
    \        }\n        else\n        {\n            no_letters ~= c;\n        }\n\
    \    }\n    if(isLower || isUpper)\n    {\n        string result = \"\";\n   \
    \     foreach(immutable char c; letters)\n        {\n            static bool isLower\
    \ = false;\n            static bool isUpper = false;\n            isLower = isLower\
    \ || isLowerAlpha(c);\n            isUpper = isUpper || isUpperAlpha(c);\n   \
    \         if(isLowerAlpha(c))\n            {\n                result ~= toUpper(c);\n\
    \            }\n            else if(isUpperAlpha(c))\n            {\n        \
    \        result ~= toLower(c);\n            }\n        }\n        return result\
    \ ~ no_letters;\n    }\n    else\n    {\n        return no_letters.dup.idup.retro;\n\
    \    }\n}", "{\n  if(!s.canFind('a') && !s.canFind('b') && !s.canFind('c') &&\
    \ !s.canFind('d') && !s.canFind('e') && !s.canFind('f') && !s.canFind('g') &&\
    \ !s.canFind('h') && !s.canFind('i') && !s.canFind('j') && !s.canFind('k') &&\
    \ !s.canFind('l') && !s.canFind('m') && !s.canFind('n') && !s.canFind('o') &&\
    \ !s.canFind('p') && !s.canFind('q') && !s.canFind('r') && !s.canFind('s') &&\
    \ !s.canFind('t') && !s.canFind('u') && !s.canFind('v') && !s.canFind('w') &&\
    \ !s.canFind('x') && !s.canFind('y') && !s.canFind('z') && !s.canFind('A') &&\
    \ !s.canFind('B') && !s.canFind('C') && !s.canFind('D') && !s.canFind('E') &&\
    \ !s.canFind('F') && !s.canFind('G') && !s.canFind('H') && !s.canFind('I') &&\
    \ !s.canFind('J') && !s.canFind('K') && !s.canFind('L') && !s.canFind('M') &&\
    \ !s.canFind('N') && !s.canFind('O') && !s.canFind('P') && !s.canFind('Q') &&\
    \ !s.canFind('R') && !s.canFind('S') && !s.canFind('T') && !s.canFind('U') &&\
    \ !s.canFind('V') && !s.canFind('W') && !s.canFind('X') && !s.canFind('Y') &&\
    \ !s.canFind('Z'))\n  {\n    return s.to!string.dup.reverse;\n  }\n  else\n  {\n\
    \    foreach(l; s)\n    {"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
