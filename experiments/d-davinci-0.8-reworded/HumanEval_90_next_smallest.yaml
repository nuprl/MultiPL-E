name: HumanEval_90_next_smallest
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given an array\
  \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
  \ element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L,\
  \ 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n\
  \    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n\
  \    \n*/\nNullable!(long) next_smallest(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
  \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
  \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n    \
  \    assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result =\
  \ candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result =\
  \ candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
  \ = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
  \ == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
  }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
  \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    if (lst.length < 2)\n        return null;\n    long[] sortedLst\
    \ = lst.sort();\n    long nextSmallest = sortedLst[0];\n    foreach (i, el; sortedLst)\n\
    \    {\n        if (el != nextSmallest)\n        {\n            nextSmallest =\
    \ el;\n            break;\n        }\n    }\n    return nextSmallest;\n}\n/*",
  "{\n    if (lst.length < 2)\n        return typeof(return).init;", "{\n    Nullable!(long)\
    \ min = min(lst);\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    return\
    \ min(lst2);\n}", "{\n    if (lst.length == 0) \n    {\n        return null;\n\
    \    }\n    Nullable!(long) ret = null;\n    for (long a; a in lst) \n    {\n\
    \        if (a > 0) \n        {\n            if (ret is null) \n            {\n\
    \                ret = a;\n            } \n            else if (a < ret) \n  \
    \          {\n                ret = a;\n            }\n        }\n    }\n    return\
    \ ret;\n}", "{\n    Nullable!(long) result = Nullable!(long).init;\n    long smallest\
    \ = long.max;\n    long secondSmallest = long.max;\n    foreach(l; lst)\n    {\n\
    \        if(l < smallest)\n        {\n            secondSmallest = smallest;\n\
    \            smallest = l;\n        }\n        else if(l < secondSmallest)\n \
    \       {\n            secondSmallest = l;\n        }\n    }\n    if(secondSmallest\
    \ == long.max)\n    {\n        return Nullable!(long).init;\n    }\n    else\n\
    \    {\n        return Nullable!(long)(secondSmallest);\n    }\n}\nstatic assert(next_smallest([1L,\
    \ 2L, 3L, 4L, 5L]) == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L])\
    \ == 2L);\nstatic assert(next_smallest([]) == Nullable!(long).init);\nstatic assert(next_smallest([1L,\
    \ 1L]) == Nullable!(long).init);", "in {\n    assert(lst.length < 9223372036854775807);\n\
    }\nout (result) {\n    assert(lst.length == 0 || result.is_some && result.get\
    \ < lst[$-1] < lst[$-2]);\n}\ndo {\n    if (lst.length < 2) return Nullable!(long).init;\n\
    \    return Nullable!(long).init(lst[1]);\n}", "{ \n    if (lst.length < 2) \n\
    \        return null;\n    long min1 = long.max;\n    long min2 = long.max;\n\
    \    for (long x; x : lst) \n    {\n        if (x < min1) \n        {\n      \
    \      min2 = min1;\n            min1 = x;\n        } \n        else if (x < min2)\
    \ \n        {\n            min2 = x;\n        }\n    }\n    if (min2 == long.max)\
    \ \n        return null;\n    return to!Nullable(min2);\n}", "{\n    Nullable!(long)\
    \ t = Nullable!(long).init;\n    long max = lst[0];\n    foreach(long x; lst)\n\
    \    {\n        if(x > max)\n        {\n            max = x;\n        }\n    }\n\
    \    long min = max;\n    foreach(long x; lst)\n    {\n        if(x < min)\n \
    \       {\n            min = x;\n        }\n    }\n    foreach(long x; lst)\n\
    \    {\n        if(x != min)\n        {\n            if(t.isNull)\n          \
    \  {\n                t = Nullable!(long).init;\n                t.init(x);\n\
    \            }\n            else\n            {\n                if(x < t.get!)\n\
    \                {\n                    t.get = x;\n                }\n      \
    \      }\n        }\n    }\n    return t;\n}", "{\n    if (lst.length == 0)\n\
    \        return null;\n    if (lst.length == 1)\n        return null;\n    long\
    \ min, min2;\n    min = min2 = lst[0];\n    foreach (i; 1..lst.length)\n    {\n\
    \        if (lst[i] < min)\n        {\n            min2 = min;\n            min\
    \ = lst[i];\n        }\n        else if (lst[i] < min2)\n        {\n         \
    \   min2 = lst[i];\n        }\n    }\n    if (min2 == min)\n        return null;\n\
    \    return min2;\n}\n/*", "{\n    // 1. Remove any duplicates from the list:\n\
    \    long[] lst_nodup = lst.dup;\n    lst_nodup.sort();\n    lst_nodup = lst_nodup.unique;\n\
    \    // 2. If the length of the list is less than 2: return null:\n    if (lst_nodup.length\
    \ < 2)\n    {\n        return Nullable!(long)(0);\n    }\n    // 3. Return the\
    \ second element in the list:\n    return Nullable!(long)(lst_nodup[1]);\n}",
  "{\n    if (lst.length < 2)\n        return Nullable!(long)().init;\n    \n    long\
    \ min = minElement(lst);\n    long next_min = min;\n    foreach (num; lst)\n \
    \   {\n        if (num == min)\n            continue;\n        else if (num <\
    \ next_min)\n            next_min = num;\n    }\n    if (next_min == min)\n  \
    \      return Nullable!(long)().init;\n    else\n        return Nullable!(long)(next_min);\n\
    }\n/*\n    You are given a string.\n    Write a function palindrome() that returns\
    \ the lexicographically largest palindrome of the string.\n    >>> palindrome(\"\
    abc\")\n    \"cbc\"\n    >>> palindrome(\"aaa\")\n    \"aaa\"\n    >>> palindrome(\"\
    abacada\")\n    \"adacada\"\n    >>> palindrome(\"cac\")\n    \"cac\"\n*/\nstring\
    \ palindrome(string s)\n{\n    if (s.length < 2)\n        return s;\n    if (s.length\
    \ == 2)\n        return s[0] > s[1] ? s : s[1..$] ~ s[0..1];\n    else\n    {\n\
    \        auto m = maxElement(s);\n        long idx = s.indexOf(m);\n        return\
    \ s[idx..$] ~ s[0..idx];\n    }\n}\n/*\n    * Write a function max_product() that\
    \ takes an array of ints and returns the largest product of any 3 ints from the\
    \ array.\n    * Return null if the given array has less than 3 elements.\n   \
    \ >>> max_product([1, 2, 3, 4, 5])\n    60\n    >>> max_product([1, 0, 2, -3,\
    \ 4, -5])\n    -15\n    >>> max_product([0, 2, -3, -1, 2, -5])\n    6\n    >>>\
    \ max_product([])\n    None\n    >>> max_product([0, 0, 0])\n    0\n*/\nNullable!(long)\
    \ max_product(long[] vals)\n", "{\n    auto r = typeof(return)();\n    if (lst.length\
    \ < 2) return r;\n    auto lowest = long.max;\n    auto next_lowest = long.max;\n\
    \    foreach (element; lst) \n    {\n        if (element < lowest) \n        {\n\
    \            next_lowest = lowest;\n            lowest = element;\n        } \n\
    \        else if (element < next_lowest) \n        {\n            next_lowest\
    \ = element;\n        }\n    }\n    return next_lowest == long.max ? r : next_lowest;\n\
    }\n/*", "{ \n    if (lst.length < 2) \n        return null; \n    // for all elements\
    \ in lst, put an index, value pair into an array \n    auto z = zip(iota(lst.length),\
    \ lst); \n    // sort the index, value pairs \n    sort!((i,j) => (i[1] < j[1]))(z);\
    \ \n    // return the second index, value pair \n    return z[1][1]; \n} \n ",
  "{ \n    long min = long.max; \n    long min2 = long.max; \n    foreach(i; lst)\n\
    \    { \n        if (i < min)\n        { \n            min2 = min; \n        \
    \    min = i; \n        }\n        else if (i < min2)\n        { \n          \
    \  min2 = i; \n        }\n    }\n    return min2 == long.max ? null : min2; \n\
    }", "{\n    Nullable!(long) result = Nullable!(long).init;\n    // extract the\
    \ min:\n    auto min = minElement(lst);\n    bool isMax = true;\n    foreach(l;\
    \ lst)\n    {\n        if(l == min)\n            continue;\n        if(isMax)\n\
    \        {\n            result = l;\n            isMax = false;\n        }\n \
    \       else\n        {\n            if(l < result)\n                result =\
    \ l;\n        }\n    }\n    return result;\n}\n/*\n    You are given an array\
    \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
    \ element of the array.\n    Return null if there is no such element.\n    >>>\
    \ next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L,\
    \ 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L,\
    \ 1L])\n    None\n    \n*/\nNullable!(long) next_smallest_sort(long[] lst) \n\
    {\n    lst.sort;\n    int count = 0;\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(i == 0)\n        {\n            if(lst[i] != lst[i+1])\n  \
    \              return lst[i+1];\n        }\n        else if(i == lst.length -\
    \ 1)\n        {\n            if(lst[i] != lst[i-1])\n                return lst[i-1];\n\
    \        }\n        else\n        {\n            if(lst[i] != lst[i-1] && lst[i]\
    \ != lst[i+1])\n                return lst[i+1];\n        }\n    }\n    return\
    \ Nullable!(long).init;\n}", "{\n    if (lst.length < 2)\n        return null;\n\
    \    else \n    {\n        //Tuple!(long, long) minmax = minmax(lst);\n      \
    \  //return minmax[1];\n        long min, max;\n        min = max = lst[0];\n\
    \        foreach (l; lst) \n        {\n            if (l < min)\n            \
    \    min = l;\n            if (l > max)\n                max = l;\n        }\n\
    \        return max;\n    }\n}\nstatic struct Rectangle\n{\n    real width;\n\
    \    real height;\n    real perimeter()\n    {\n        return 2 * (width + height);\n\
    \    }\n    real area()\n    {\n        return width * height;\n    }\n}\n// Demo ",
  "{\n    Nullable!(long) result = Nullable!(long).init;\n    if (lst.length == 0)\n\
    \    {\n        return result;\n    }\n    else\n    {\n        if (lst.length\
    \ == 1)\n        {\n            return result;\n        }\n        else\n    \
    \    {\n            long temp = lst[0];\n            long temp1 = lst[1];\n  \
    \          if (temp > temp1)\n            {\n                temp = temp1;\n \
    \               temp1 = lst[0];\n            }\n            foreach (i; 2..lst.length)\n\
    \            {\n                if (lst[i] < temp)\n                {\n      \
    \              temp1 = temp;\n                    temp = lst[i];\n           \
    \     }\n                else if (lst[i] < temp1)\n                {\n       \
    \             temp1 = lst[i];\n                }\n            }\n            if\
    \ (temp1 == temp)\n            {\n                return result;\n           \
    \ }\n            else\n            {\n                result.init(temp1);\n  \
    \              return result;\n            }\n        }\n    }\n}", "{\n    int\
    \ n = lst.length;\n    if (n < 2) return null;\n    long min1 = long.max;\n  \
    \  long min2 = long.max;\n    foreach (a; lst) \n    {\n        if (a < min1)\
    \ \n        {\n            min2 = min1;\n            min1 = a;\n        }\n  \
    \      else if (a < min2) \n        {\n            min2 = a;\n        }\n    }\n\
    \    if (min2 == long.max) return null;\n    return make!Nullable(long)(min2);\n\
    }", "{\n    // lst.sort();\n    // lst.remove(lst[0]);\n    // if (lst.length\
    \ == 0)\n    // {\n    //     return null;\n    // }\n    // return lst[0];\n\
    \    long min = long.max;\n    long second = long.max;\n    foreach (x; lst)\n\
    \    {\n        if (x < min)\n        {\n            second = min;\n         \
    \   min = x;\n        }\n        else if (x < second)\n        {\n           \
    \ second = x;\n        }\n    }\n    if (second == long.max)\n    {\n        return\
    \ null;\n    }\n    return second;\n}", "{\n    static int findIndex2ndSmallest(long[]\
    \ lst) {\n        long smallest = lst[0];\n        long next_smallest = long.max;\n\
    \        int next_smallest_idx = 0;\n        for (int i = 1; i < lst.length; i++)\
    \ {\n            if (lst[i] < smallest) {\n                next_smallest = smallest;\n\
    \                next_smallest_idx = i - 1;\n                smallest = lst[i];\n\
    \            } else if (lst[i] < next_smallest) {\n                next_smallest\
    \ = lst[i];\n                next_smallest_idx = i;\n            }\n        }\n\
    \        return next_smallest_idx;\n    }\n    return Nullable!(long)(findIndex2ndSmallest(lst),\
    \ lst[findIndex2ndSmallest(lst)]);\n}", "{\n    if (lst.length < 2)\n        return\
    \ null;\n    else\n    {\n        auto min = min(lst);\n        if (lst.length\
    \ == 2)\n        {\n            if (lst[0] == lst[1])\n                return\
    \ null;\n            else\n                return min;\n        }\n        else\n\
    \        {\n            lst.remove(min);\n            return min(lst);\n     \
    \   }\n    }\n}", "{\n    if (lst.length < 2)\n        return null;\n    long\
    \ min = min(lst);\n    lst.remove(min);\n    return min(lst);\n}", "{\n\tNullable!(long)\
    \ result = null;\n\tlong min = lst[0];\n\tforeach(i, e; lst) \n\t{\n\t\tif (e\
    \ <= min)\n\t\t{\n\t\t\tmin = e;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (result.isNull\
    \ || result.get > e)\n\t\t\t{\n\t\t\t\tresult = e;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{ \n    int min = min(lst);\n    long[] lst2 = lst[0..$-1].filter!(x\
    \ => x != min);\n    if (lst2.length == 0)\n        return null;\n    else\n \
    \       return min(lst2);\n}", "{\n    Nullable!(long) n = new Nullable!(long)();\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.data = null;\n    n.data = null;\n    n.data = null;\n\
    \    n.data = null;\n    n.", "in\n{\n    assert(allSatisfy!(e => is(typeof(e)\
    \ == long), lst));\n}\nbody\n{\n    if (lst.length < 2)\n        return None;\n\
    \    immutable max = maxElement(lst);\n    long min = max;\n    long min2 = max;\n\
    \    foreach (e; lst) \n    {\n        if (e < min) \n        {\n            min2\
    \ = min;\n            min = e;\n        } \n        else if (e < min2) \n    \
    \    {\n            min2 = e;\n        }\n    }\n    if (min2 == max)\n      \
    \  return None;\n    return min2;\n}", "{\n    auto result = new std.typecons.Nullable!(long);\n\
    \    if (lst.length < 2) \n    {\n        return result;\n    }\n    auto maxL\
    \ = lst[0];\n    auto minL = lst[0];\n    foreach (i, ref l; lst) \n    {\n  \
    \      if (l < minL) \n        {\n            minL = l;\n        }\n        if\
    \ (l > maxL) \n        {\n            maxL = l;\n        }\n    }\n    auto diffs\
    \ = lst.map!(a => abs(a - minL));\n    auto nextSmallest = *minElement(diffs);\n\
    \    if (nextSmallest == diffs[0]) \n    {\n        foreach (i, ref l; lst) \n\
    \        {\n            if (diffs[i] == nextSmallest && l != minL) \n        \
    \    {\n                result.set(l);\n                return result;\n     \
    \       }\n        }\n    }\n    result.set(minL);\n    return result;\n}", "{\n\
    \    Nullable!(long) secondSmallest = Nullable!(long).init;", "{ \n    if (lst.length\
    \ < 2) return null;\n    auto finder = new MinMaxElement(lst[0], lst[0]);\n  \
    \  foreach (i; lst[1..$])\n    {\n        if (finder.min > i) finder.min = i;\n\
    \        if (finder.max < i) finder.max = i;\n    }\n    if (finder.min == finder.max)\
    \ return null;\n    else return finder.min;\n}\n/*\n    You are given a non-empty\
    \ array of integers.\n    Write a function that returns a maximum possible sum\
    \ of elements in a contiguous subarray of this array.\n    >>> max_sum([4L, 6L,\
    \ -3L, 5L, -2L, 1L])\n    12L\n    >>> max_sum([0L, 0L, 0L, 0L, 0L, 0L])\n   \
    \ 0L\n    >>> max_sum([-3L, -1L, -2L, -3L, -2L, -1L])\n    -1L\n    >>> max_sum([-1L,\
    \ -2L, -3L, -4L, -5L, -6L])\n    -1L\n    >>> max_sum([1L, 2L, 3L, 4L, 5L, 6L])\n\
    \    21L\n    >>> max_sum([2L, -1L, 2L, -1L, 2L, -1L])\n    4L\n*/\nlong max_sum(long[]\
    \ lst)\n{\n    if (lst.length == 0) return 0;\n    auto max_sum = 0L;\n    auto\
    \ sum = 0L;\n    foreach (v; lst)\n    {\n        sum += v;\n        if (sum <\
    \ 0) sum = 0;\n        if (sum > max_sum) max_sum = sum;\n    }\n    return max_sum;\n\
    }\n/*\n    Given a non-empty array of integers, return the k most frequent elements.\n\
    \    >>> top_k_frequent([1L, 1L, 1L, 2L, 2L, 3L], 2)\n    [1L, 2", "{\n    if\
    \ (lst.length < 2)\n        return null;\n    long min, min2;\n    min = min2\
    \ = lst[0];\n    foreach (i, idx; lst) \n    {\n        if (i < min) \n      \
    \  {\n            min2 = min;\n            min = i;\n        } \n        else\
    \ if (i < min2) \n        {\n            min2 = i;\n        }\n    }\n    return\
    \ min2;\n}\n/*", "{\n     Nullable!(long) min = minElement(lst);\n     long minIndex\
    \ = min.index;\n     // delete first min element\n     lst = lst[minIndex+1..$];\n\
    \     if (lst.length > 0)\n        return minElement(lst);\n     else\n      \
    \  return null;\n}\n ", "{\n\tNullable!(long) small;\n\t\n\tif (lst.length < 2)\
    \ return null;", "{\n    if (lst.length < 2) return null;\n    long min = lst[0];\n\
    \    long sec = long.max;\n    foreach (i; lst) \n    {\n        if (i < min)\
    \ \n        {\n            sec = min;\n            min = i;\n        } \n    \
    \    else if (i < sec) \n        {\n            sec = i;\n        }\n    }\n \
    \   if (sec == long.max) \n    {\n        return null;\n    }\n    return sec;\n\
    }", "in {\n    lst.length >= 0;\n} \nout (result) \n{\n    lst.length <= 2;\n\
    \    if (lst.length == 0)\n        result == null;\n    else if (lst.length ==\
    \ 1)\n        result == null;\n    else {\n        lst.length == 2;\n        result\
    \ == (long)(min(lst));\n    }\n} \nbody {\n    typeof(result) r = null;\n    if\
    \ (lst.length > 1) {\n        long min1 = min(lst);\n        long min2 = long.max;\n\
    \        foreach (i; 0 .. lst.length) {\n            if (lst[i] != min1)\n   \
    \             min2 = min(min2, lst[i]);\n        }\n        if (min2 != long.max)\n\
    \            r = Nullable!(long)(min2);\n    }\n    return r;\n}", "in\n{\n  \
    \  assert(lst.length > 0);\n}\nbody\n{\n    long smallest = long.max;\n    long\
    \ next_smallest = long.max;\n    foreach(long val; lst)\n    {\n        if(val\
    \ < smallest)\n        {\n            next_smallest = smallest;\n            smallest\
    \ = val;\n        }\n        else if(val < next_smallest)\n        {\n       \
    \     next_smallest = val;\n        }\n    }\n    return next_smallest != long.max\
    \ ? make!Nullable(long)(next_smallest) : null;\n}", "{\n    long min1 = long.max;\n\
    \    long min2 = long.max;\n    if (lst.length < 2)\n        return null;\n  \
    \  foreach (elem; lst)\n    {\n        if (elem < min1)\n        {\n         \
    \   min2 = min1;\n            min1 = elem;\n        }\n        else if (elem <\
    \ min2)\n        {\n            min2 = elem;\n        }\n    }\n    if (min2 ==\
    \ long.max)\n        return null;\n    return min2;\n}\n/*", "{\n    enum bool\
    \ was_min = false;\n    if (lst.length < 2)\n        return null;\n    long min\
    \ = lst[0];\n    long min2 = lst[1];\n    foreach (idx, elem; lst)\n    {\n  \
    \      if (idx == 0)\n            continue;\n        if (elem < min)\n       \
    \ {\n            if (was_min)\n                min2 = min;\n            else\n\
    \                was_min = true;\n            min = elem;\n        }\n       \
    \ else if (was_min && elem < min2)\n            min2 = elem;\n    }\n    if (was_min)\n\
    \        return min2;\n    else\n        return null;\n}", "{\n    long min1 =\
    \ long.max;\n    long min2 = long.max;\n    foreach(index, elem; lst) \n    {\n\
    \        if (elem < min1) \n        {\n            min2 = min1;\n            min1\
    \ = elem;\n        } \n        else if (elem < min2) \n        {\n           \
    \ min2 = elem;\n        }\n    }\n    if (min2 == long.max)\n    {\n        return\
    \ Nullable!(long)();\n    }\n    return min2;\n}", "{\n    if (lst.length < 2)\
    \ return null;\n    long m1 = long.max;\n    long m2 = long.max;\n    foreach\
    \ (i; lst) \n    {\n        if (i < m1) \n        {\n            m2 = m1;\n  \
    \          m1 = i;\n        } \n        else if (i < m2) \n        {\n       \
    \     m2 = i;\n        }\n    }\n    return m2;\n}", "{\n    if (lst.length <\
    \ 2) \n    {\n        return Nullable!(long)();\n    }\n    auto r = tuple(lst[0],\
    \ lst[1]);\n    foreach (ref l; lst[2 .. $]) \n    {\n        r = min(r, tuple(l,\
    \ l));\n    }\n    return r[1];\n}", "{\n    if (lst.length < 2) return null;\n\
    \    auto min = lst[0];\n    auto sec = lst[1];\n    foreach (i, item; lst) \n\
    \    {\n        if (item < min) \n        {\n            sec = min;\n        \
    \    min = item;\n        } \n        else if (item < sec)\n        {\n      \
    \      sec = item;\n        }\n    }\n    return sec;\n}\n/*", "{\n    static\
    \ struct {\n        long smallest;\n        long nextSmallest;\n    } state;\n\
    \    int i = 0;\n    long candidate;\n    if (lst.length == 0)\n    {\n      \
    \  return Nullable!(long).init;\n    }\n    foreach (candidate; lst)\n    {\n\
    \        if (i == 0)\n        {\n            state.smallest = candidate;\n   \
    \         state.nextSmallest = candidate;\n        }\n        else\n        {\n\
    \            if (candidate < state.smallest)\n            {\n                state.nextSmallest\
    \ = state.smallest;\n                state.smallest = candidate;\n           \
    \ }\n            else if (candidate < state.nextSmallest)\n            {\n   \
    \             state.nextSmallest = candidate;\n            }\n        }\n    \
    \    i++;\n    }\n    if (state.smallest == state.nextSmallest)\n    {\n     \
    \   return Nullable!(long).init;\n    }\n    return Nullable!(long)(state.nextSmallest);\n\
    }", "{ \n    long[] a = lst.dup;\n    a.sort;\n    if (a.length < 2) return null;\n\
    \    if (a[0] == a[1]) return null;\n    return a[1];\n}", "{\n    if (lst.length<2)\n\
    \        return null;\n    std.algorithm.sort(lst);\n    auto ret=lst[0];\n  \
    \  for (int i=1;i<lst.length;i++) \n    {\n        if (lst[i]!=ret)\n        \
    \    return lst[i];\n    }\n    return null;\n}", "{\n    auto less = (long a,\
    \ long b) { return a < b; };\n    auto[a, b] = tuple(lst[0..$-1].map!(l => tuple(l,lst[l\
    \ + 1 .. $])).filter!(t => t[1].filter!(l => less(t[0], l)).length == 0).map!(t\
    \ => t[0]).sort(less));\n    return a == b ? null : a;\n}", "{\n    if (lst.length\
    \ < 2)\n        return null;\n    long num1 = lst[0];\n    long num2 = lst[1];\n\
    \    if (num1 > num2)\n        num1 = num2;\n    for (long n in lst[2..$]) \n\
    \    {\n        if (n < num1) \n        {\n            num2 = num1;\n        \
    \    num1 = n;\n        }\n        else if (n < num2) \n        {\n          \
    \  num2 = n;\n        }\n    }\n    if (num1 == num2)\n        return null;\n\
    \    return num2;\n}\n//     >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n//     2L\n\
    //     >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n//     2L\n//     >>> next_smallest([])\n\
    //     None\n//     >>> next_smallest([1L, 1L])\n//     None\n//     >>> next_smallest([1L,\
    \ 1L, 3L])\n//     3L\n//     >>> next_smallest([1L, 1L, 3L, 2L])\n//     2L",
  "in \n{\n    assert(lst.length == 0 || lst.length == 1 || lst.length > 1);\n}\n\
    body \n{\n    return lst.length == 0 ? Nullable!(long).init :\n        lst.length\
    \ == 1 ? Nullable!(long).init :\n            (lst[0] > lst[1] ? lst[1] : lst[0])\
    \ \n            == \n            (lst[0] < lst[1] ? lst[1] : lst[0]) ? Nullable!(long).init\
    \ : \n                (lst[0] > lst[1] ? lst[1] : lst[0]) == lst[0] ? lst[1] :\
    \ lst[0];\n}\n/*\n    You are given an array of integers and a target integer,\
    \ let's call it target.\n    Write a function product_of_three_elements_summing_to_target()\
    \ that returns\n    the product of three elements from the given array that sum\
    \ to target.\n    Return null if there is no such element.\n    >>> product_of_three_elements_summing_to_target([1L,\
    \ 2L, 3L, 4L, 5L], 5L)\n    6L\n    >>> product_of_three_elements_summing_to_target([1L,\
    \ 2L, 3L, 4L, 5L], 1L)\n    null\n    >>> product_of_three_elements_summing_to_target([1L,\
    \ 2L, 3L, 4L, 5L], -5L)\n    null\n*/\nNullable!(long) product_of_three_elements_summing_to_target(long[]\
    \ lst, long target) \nin \n{\n    assert(lst.length == 0 || lst.length == 1 ||\
    \ lst.length > 1);\n}\nbody \n{\n    return lst.length == 0 ? Nullable!(long).init\
    \ :\n        lst.length == 1 ? Nullable!(long).init :\n            lst.length\
    \ == 2 ? Nullable!(long).init :\n                lst.length == 3 ? (", "{\n  \
    \  if (lst.length < 2) \n    {\n        return null;\n    }\n    auto min1 = min(lst);\n\
    \    auto min2 = long.max;\n    foreach (i; lst) \n    {\n        if (i != min1)\
    \ \n        {\n            min2 = min(min2, i);\n        }\n    }\n    return\
    \ (min2 != long.max) ? min2 : null;\n}", "{\n    Nullable!(long) result = null;\n\
    \    if (lst.length > 1) \n    {\n        lst.sort();\n        result = lst[1];\n\
    \    }\n    return result;\n}", "{\n    if (lst.length < 2) return null;\n   \
    \ auto min_of_three = function (long a, long b, long c) { return min(min(a, b),\
    \ c); };\n    long min = lst[0], next_min = lst[1];\n    if (next_min < min) swap(min,\
    \ next_min);\n    foreach (i, e; lst[2 .. $]) \n    {\n        next_min = min_of_three(min,\
    \ next_min, e);\n        if (next_min == e) min = min_of_three(min, lst[i], e);\n\
    \    }\n    return next_min;\n}", "{\n    if (lst.length < 2)\n        return\
    \ null;\n    long min1 = lst[0];\n    long min2 = lst[1];\n    if (min1 > min2)\n\
    \    {\n        long tmp = min1;\n        min1 = min2;\n        min2 = tmp;\n\
    \    }\n    foreach (const i; lst[2..$])\n    {\n        if (i < min1)\n     \
    \   {\n            min2 = min1;\n            min1 = i;\n        }\n        else\
    \ if (i < min2)\n        {\n            min2 = i;\n        }\n    }\n    return\
    \ min2;\n}", "in {\n    assert(lst.length >= 0);\n}\nout (result) \n{\n    if\
    \ (result is null) {\n        assert(lst.length < 2);\n    } else {\n        assert(result\
    \ >= 2);\n        assert(result < min(lst[$]));\n    }\n}\nbody {\n    if (lst.length\
    \ < 2) return null;\n    long lowest, secondLowest;\n    long[] sorted = lst.dup.sort();\n\
    \    // 1 0 == 1\n    // 1 2 == 1\n    // 1 1 == 0\n    if (sorted[0] == sorted[1])\
    \ return null;\n    return sorted[1];\n}", "    if (isInputRange!(typeof(lst)))\
    \ {\n    /*\n        If you don't know what Nullable is, take a look at std.typecons.Nullable:\n\
    \        http://dlang.org/phobos/std_typecons.html#.Nullable\n    */\n    Nullable!(long)\
    \ result;\n    import std.algorithm.iteration : min, count;\n    if (lst.length\
    \ > 1 && lst.count(lst.min) == 1) {\n        result = lst.min;\n    }\n    return\
    \ result;\n}\n/*\n    You are given an array of strings in random order.\n   \
    \ Write a function sort_by_length() that sorts the array by length.\n    >>> sort_by_length([\"\
    c\", \"bb\", \"aaa\"])\n    [\"c\", \"bb\", \"aaa\"]\n    >>> sort_by_length([\"\
    ccc\", \"bb\", \"a\", \"iiii\"])\n    [\"a\", \"bb\", \"ccc\", \"iiii\"]\n   \
    \ >>> sort_by_length([\"\", \"bb\", \"aa\", \"iiii\"])\n    [\"\", \"aa\", \"\
    bb\", \"iiii\"]\n    >>> sort_by_length([\"ccc\", \"b\", \"a\", \"iiii\"])\n \
    \   [\"b\", \"a\", \"ccc\", \"iiii\"]\n    >>> sort_by_length([\"\", \"b\", \"\
    aa\", \"iiii\"])\n    [\"\", \"b\", \"aa\", \"iiii\"]\n*/", "{\n    auto l = lst.dup;\n\
    \    l.sort;\n    l.reserve(l.length);\n    if (l.length < 2)\n        return\
    \ null;\n    long prev = l[0];\n    long next = l[1];\n    foreach (i, elem; l[2..$])\
    \ \n    {\n        prev = next;\n        next = elem;\n        if (prev != next)\n\
    \            return prev;\n    }\n    return null;\n}", "{\n    auto key = lst[0];\n\
    \    auto value = typeof(return) (null);\n    foreach(immutable i, immutable item;\
    \ lst) \n    {\n        if (item > key) \n        {\n            if (value.isNull)\
    \ \n            {\n                value = item;\n            } \n           \
    \ else \n            {\n                value = min(value, item);\n          \
    \  }\n        }\n    }\n    return value;\n}", "    in \n    {\n        assert(lst.length\
    \ > 0);\n    }\n    body \n    {\n        Nullable!(long) result = null;\n   \
    \     foreach (num1; lst) \n        {\n            bool found = false;\n     \
    \       foreach (num2; lst) \n            {\n                if (num1 != num2\
    \ && num1 > num2) \n                {\n                    found = true;\n   \
    \                 break;\n                }\n            }\n            if (!found)\
    \ \n            {\n                result = to!Nullable(num1);\n             \
    \   break;\n            }\n        }\n        return result;\n    }", "{\n   \
    \ /* \n        first of all, sort the array\n        to be able to find the smallest\n\
    \        and second smallest\n    */\n    sort(lst);\n    /*\n        using std.algorithm.find()\
    \ here\n        find the first occurrence in the range\n        which is not equal\
    \ to the first element.\n        (that is the smallest value)\n    */\n    return\
    \ find(lst, 1, (elem) => elem != lst[0]);\n}", "{\n    if (lst.length <= 1) return\
    \ null;\n    return lst[1..$].min!(a => a).idup;\n}", "{\n    long min_lst = lst[0];\n\
    \    long min_2nd = long.max;\n    foreach(i; lst) \n    {\n        if(i > min_lst\
    \ && i < min_2nd)\n        {\n            min_2nd = i;\n        }\n        if(i\
    \ < min_lst)\n        {\n            min_2nd = min_lst;\n            min_lst =\
    \ i;\n        }\n    }\n    if(min_2nd == long.max)\n    {\n        return null;\n\
    \    }\n    return min_2nd;\n}", "{\n    long min1 = long.max;\n    long min2\
    \ = long.max;\n    foreach(num; lst)\n    {\n        if(num < min1)\n        {\n\
    \            min2 = min1;\n            min1 = num;\n        }\n        else if(num\
    \ < min2)\n        {\n            min2 = num;\n        }\n    }\n    if(min2 ==\
    \ long.max) return null;\n    return to!(Nullable!(long))min2;\n}", "{\n    if\
    \ (lst.length < 2)\n        return Nullable!(long)();\n    long smallest = lst[0];\n\
    \    Nullable!(long) next_smallest = Nullable!(long)();\n    foreach (long l;\
    \ lst) \n    {\n        if (l < smallest) \n        {\n            next_smallest\
    \ = Nullable!(long)(smallest);\n            smallest = l;\n        } \n      \
    \  else if (l > smallest && \n            (next_smallest is null || l < next_smallest.get!(Nullable!(long)())))\
    \ \n        {\n            next_smallest = Nullable!(long)(l);\n        }\n  \
    \  }\n    return next_smallest;\n}", "{\n    if (lst.length < 2) return Nullable!(long)();\n\
    \    long min = lst[0];\n    long min2 = -1;\n    foreach (l; lst) \n    {\n \
    \       if (l < min) \n        {\n            min2 = min;\n            min = l;\n\
    \        }\n        else if (l > min && (min2 == -1 || l < min2)) \n        {\n\
    \            min2 = l;\n        }\n    }\n    if (min2 == -1) return Nullable!(long)();\n\
    \    return Nullable!(long)(min2);\n}", "{ \n    if (lst.length < 2) \n      \
    \  return null; \n    else \n    { \n        long[] temp = lst[0..$-1]; \n   \
    \     sort(temp); \n        return temp[1]; \n    } \n}\n ", "{\n    if (lst.length<2)\n\
    \        return null;\n    auto min_=reduce!(min)(lst);\n    remove(lst,min_);\n\
    \    auto min2_=reduce!(min)(lst);\n    if (min2_==min_)\n        return null;\n\
    \    return min2_;\n}", "{\n    Nullable!(long) next_smallest = null;\n    long\
    \ smallest = lst[0];\n    foreach(l; lst) \n    {\n        if(l < smallest) \n\
    \        {\n            next_smallest = smallest;\n            smallest = l;\n\
    \        }\n        else if(l > smallest && (l < next_smallest || !next_smallest.isValid))\
    \ \n        {\n            next_smallest = l;\n        }\n    }\n    return next_smallest;\n\
    }", "in\n{\n    assert(!lst.empty);\n}\nbody\n{\n    if (lst.length == 1)\n  \
    \      return null;\n    else\n    {\n        long min = lst[0];\n        long\
    \ min2 = lst[1];\n        int i = 1;\n        while (i < lst.length)\n       \
    \ {\n            if (lst[i] < min)\n            {\n                min2 = min;\n\
    \                min = lst[i];\n            }\n            else if (lst[i] < min2)\n\
    \                min2 = lst[i];\n            i += 1;\n        }\n        if (min2\
    \ == min)\n            return null;\n        else\n            return make!Nullable(long)(min2);\n\
    \    }\n}", "{\n    Nullable!(long) result = Nullable!(long).init;\n    long?\
    \ min = null;\n    long? min2 = null;\n    if (lst.length == 0)\n    {\n     \
    \   return null;\n    }\n    else\n    {\n        foreach (elem; lst)\n      \
    \  {\n            if (min is null)\n            {\n                min = elem;\n\
    \            }\n            else if (elem < min)\n            {\n            \
    \    min2 = min;\n                min = elem;\n            }\n            else\
    \ if (min2 is null || elem < min2)\n            {\n                min2 = elem;\n\
    \            }\n        }\n        if (min2 !is null)\n        {\n           \
    \ result = min2;\n        }\n    }\n    return result;\n}", "{\n    /*", "{\n\
    \    if (lst.length <= 1)\n        return null;\n    lst.sort();\n    if (lst[0]\
    \ == lst[1])\n        return null;\n    return lst[1];\n}\nstatic assert(next_smallest([1L,\
    \ 2L, 3L, 4L, 5L]) == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L])\
    \ == 2L);\nstatic assert(next_smallest([]) == null);\nstatic assert(next_smallest([1L,\
    \ 1L]) == null);", "{\n    if (lst.length < 2)\n        return null;\n    auto\
    \ result = null;\n    int i = 0;\n    int low = min(lst[0], lst[1]);\n    int\
    \ high = max(lst[0], lst[1]);\n    if (lst.length > 2)\n    {\n        for (i\
    \ = 2; i < lst.length; i++)\n        {\n            if (lst[i] < low)\n      \
    \      {\n                high = low;\n                low = lst[i];\n       \
    \     }\n            else if (lst[i] < high)\n            {\n                high\
    \ = lst[i];\n            }\n        }\n    }\n    if (low != high)\n        result\
    \ = to!(Nullable!(long)) high;\n    return result;\n}", "{\n    // You are allowed\
    \ to use the standard library\n    auto result = std.algorithm.sorting.minElement(lst);\n\
    \    if (result.front.isSome) \n    {\n        if (result.back.isSome)\n     \
    \   {\n            auto element = result.front.get;\n            auto index =\
    \ result.back.get;\n            if (index < lst.length - 1)\n            {\n \
    \               auto next_index = index + 1;\n                lst.remove(index);\n\
    \                auto min_result = std.algorithm.sorting.minElement(lst);\n  \
    \              if (min_result.front.isSome)\n                {\n             \
    \       return typeof(element).init(min_result.front.get);\n                }\n\
    \            }\n        }\n    }\n    return Nullable!(long).init;\n}\n/*\n  \
    \  Return all the values of the group\n    >>> group_by([1L, 2L, 3L], [0L, 0L,\
    \ 1L])\n    [[1L, 2L], [3L]]\n*/\nlong[][] group_by(long[] values, long[] groups)\n\
    {\n    assert(values.length == groups.length);\n    auto group_set = std.algorithm.sorting.uniq(groups);\n\
    \    long[][] result;\n    result.length = group_set.length;\n    foreach (group;\
    \ group_set)\n    {\n        long[] lst;\n        foreach (index, value; values)\n\
    \        {\n            if (group == groups[index])\n            {\n         \
    \       lst ~= value;\n            }\n        }\n        result[group] = lst;\n\
    \    }\n    return result;\n}\n/*\n    >>> split_by([1L, 2L, 3L, 4L, 5L], 1L)\n\
    \    [[1L], [2L, 3L, 4L, 5L]]\n    >>> split_by([1L, 2L, 3L, 4L, 5L], 2L)\n  \
    \  [[1L, 2L], [3L, 4L, 5L]]\n    >>> split_by([1L, 2L, 3L, 4L", "    if (lst.length\
    \ > 1)\n{\n    long smallest, next_smallest;\n    if (lst[0] < lst[1])\n    {\n\
    \        smallest = lst[0];\n        next_smallest = lst[1];\n    }\n    else\n\
    \    {\n        smallest = lst[1];\n        next_smallest = lst[0];\n    }\n \
    \   foreach (el; lst[2..$])\n    {\n        if (el < smallest)\n        {\n  \
    \          next_smallest = smallest;\n            smallest = el;\n        }\n\
    \        else if (el < next_smallest)\n        {\n            next_smallest =\
    \ el;\n        }\n    }\n    if (smallest == next_smallest)\n    {\n        return\
    \ null;\n    }\n    else\n    {\n        return next_smallest;\n    }\n}\nelse\n\
    {\n    return null;\n}", "in\n{\n    assert(lst.length >= 0);\n}\nbody\n{\n  \
    \  if (lst.length == 0) return typeof(null).init;\n    if (lst.length == 1) return\
    \ typeof(null).init;\n    long smallest = lst[0];\n    long second_smallest =\
    \ lst[1];\n    foreach (i, el; lst)\n    {\n        if (el < smallest)\n     \
    \   {\n            second_smallest = smallest;\n            smallest = el;\n \
    \       }\n        else if (el < second_smallest)\n        {\n            second_smallest\
    \ = el;\n        }\n    }\n    if (smallest == second_smallest) return typeof(null).init;\n\
    \    return second_smallest;\n}\n/*", "{\n    if (lst.length < 2)\n        return\
    \ null;\n    long smallest = lst[0];\n    long smallest2 = long.max;\n    foreach\
    \ (i; lst)\n    {\n        if (i < smallest)\n        {\n            smallest2\
    \ = smallest;\n            smallest = i;\n        }\n        else if (i < smallest2)\n\
    \        {\n            smallest2 = i;\n        }\n    }\n    if (smallest2 ==\
    \ long.max)\n        return null;\n    return typeof(smallest2).init;\n}", "{\n\
    \    // See notes in next_largest()\n    Nullable!(long)[] lst2 = lst.map!(x =>\
    \ Nullable!(long)(x));\n    Nullable!(long) out = lst2[0];\n    for (long i =\
    \ 1; i < lst2.length; i++) \n    {\n        if (lst2[i] > out) \n        {\n \
    \           out = lst2[i];\n        }\n    }\n    return out;\n}\n/*", "{\n  \
    \  long smallest = lst[0];\n    Nullable!(long) second_smallest = null;\n    foreach(i;\
    \ 1..lst.length) \n    {\n        if (lst[i] < smallest) \n        {\n       \
    \     second_smallest = min(second_smallest, smallest);\n            smallest\
    \ = lst[i];\n        } \n        else \n        {\n            second_smallest\
    \ = min(second_smallest, lst[i]);\n        }\n    }\n    return second_smallest;\n\
    }", "{\n    if (lst.length == 0 || lst.length == 1)\n        return Nullable!(long)();\n\
    \    long min = lst[0];\n    long min2 = lst[1];\n    for (long i = 1; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n        {\n            min2 = min;\n\
    \            min = lst[i];\n        }\n        else if (lst[i] < min2)\n     \
    \   {\n            min2 = lst[i];\n        }\n    }\n    if (min == min2)\n  \
    \      return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\n/*", "{\n\
    \    if (lst.length <= 1)\n        return null;\n    else if (lst.length == 2)\n\
    \        return lst[0] != lst[1] ? lst[1] : null;\n    long min_value = lst[0];\n\
    \    long min_value_2 = long.max;\n    foreach (long item; lst)\n    {\n     \
    \   if (item < min_value)\n        {\n            min_value_2 = min_value;\n \
    \           min_value = item;\n        }\n        else if (item < min_value_2)\n\
    \            min_value_2 = item;\n    }\n    return min_value_2 == long.max ?\
    \ null : min_value_2;\n}\n/*", "{\n    auto res = new Nullable!(long)(Nullable!(long).init);\n\
    \    if (lst.length < 2) return res;\n    long smallest = lst[0];\n    long second_smallest\
    \ = lst[1];\n    foreach (i, x; lst)\n    {\n        if (x < smallest)\n     \
    \   {\n            second_smallest = smallest;\n            smallest = x;\n  \
    \      }\n        else if (x < second_smallest)\n        {\n            second_smallest\
    \ = x;\n        }\n    }\n    if (second_smallest == smallest) return res;\n \
    \   res.release = second_smallest;\n    return res;\n}", "{\n    long[] l = lst.dup;\n\
    \    l.sort;\n    l.unique;\n    if (l.length == 0 || l.length == 1)\n       \
    \ return null;\n    else\n        return l[1];\n}", "{\n    /*\n        1. Find\
    \ the smallest element\n        2. Find the second smallest element\n    */\n\
    \    // You can do this in one pass of the array.\n    if (lst.length == 0)\n\
    \        return null;\n    if (lst.length == 1)\n        return null;\n    if\
    \ (lst.length == 2)\n    {\n        if (lst[0] == lst[1])\n            return\
    \ null;\n        else\n            return max(lst[0], lst[1]);\n    }\n    //\
    \ lst.length >= 3\n    long smallest = min(lst[0], lst[1]);\n    if (lst[0] ==\
    \ lst[1])\n        return lst[2];\n    if (lst[0] < lst[1])\n        return lst[0];\n\
    \    else\n        return lst[1];\n    Nullable!(long) the_second_smallest;\n\
    \    foreach (i, n; lst)\n    {\n        if (n == smallest)\n            continue;\n\
    \        if (the_second_smallest.isNull)\n        {\n            the_second_smallest\
    \ = n;\n            continue;\n        }\n        if (n < the_second_smallest)\n\
    \            the_second_smallest = n;\n    }\n    return the_second_smallest;\n\
    }", "{ \n    if (lst.length < 2) \n        return null;\n    long min = lst[0];\n\
    \    long next_min = lst[1];\n    bool sorted = lst[0] < lst[1];\n    foreach\
    \ (i, el; lst) \n    {\n        if (el < min) \n        {\n            next_min\
    \ = min;\n            min = el;\n        }\n        else if (el > min && el <\
    \ next_min) \n        {\n            next_min = el;\n        }\n        else if\
    \ (el == min) \n        {\n            sorted = false;\n        }\n    }\n   \
    \ if (sorted)\n        return null;\n    return next_min;\n}", "{ \n    //return\
    \ null; \n    \n    long smallest;\n    long next_smallest;\n    int i;\n    \n\
    \    if (lst.length == 0)\n    {\n        return null;\n    }\n    \n    if (lst.length\
    \ == 1)\n    {\n        return null;\n    }\n    \n    if (lst.length == 2)\n\
    \    {\n        if (lst[0] == lst[1])\n        {\n            return null;\n \
    \       }\n        else\n        {\n            if (lst[0] < lst[1])\n       \
    \     {\n                return lst[1];\n            }\n            else\n   \
    \         {\n                return lst[0];\n            }\n        }\n    }\n\
    \    \n    // now iterate through, keeping\n    // track of the smallest and next\
    \ smallest\n    smallest = lst[0];\n    next_smallest = lst[1];\n    \n    if\
    \ (smallest > next_smallest)\n    {\n        smallest = lst[1];\n        next_smallest\
    \ = lst[0];\n    }\n    \n    for (i = 2; i < lst.length; i++)\n    {\n      \
    \  if (lst[i] < smallest)\n        {\n            next_smallest = smallest;\n\
    \            smallest = lst[i];\n        }\n        else if (lst[i] < next_smallest)\n\
    \        {\n            next_smallest = lst[i];\n        }\n    }\n    \n    return\
    \ next_smallest;\n}", "{\n    if (lst.length < 2)\n        return Nullable!(long)();\n\
    \    auto min = min_element(lst);\n    if (min == lst.length - 1)\n        return\
    \ Nullable!(long)();\n    auto next = min + 1;\n    while (next < lst.length &&\
    \ lst[next] == lst[min])\n        next++;\n    if (next == lst.length)\n     \
    \   return Nullable!(long)();\n    auto nxtmin = min(lst[next], lst[min]);\n \
    \   for (auto i = next + 1; i < lst.length; i++)\n        if (lst[i] < nxtmin\
    \ && lst[i] != lst[min])\n            nxtmin = lst[i];\n    return nxtmin;\n}",
  "{\n    if (lst.length < 2)\n        return null;\n    long min1, min2;\n    min1\
    \ = min2 = long.max;\n    foreach (n; lst)\n    {\n        if (n < min1)\n   \
    \     {\n            min2 = min1;\n            min1 = n;\n        }\n        else\
    \ if (n < min2)\n        {\n            min2 = n;\n        }\n    }\n    if (min2\
    \ == long.max)\n        return null;\n    return make!Nullable(long)(min2);\n\
    }\n// Change the above code to return 1st, 2nd, 3rd, ... smallest element, \n\
    // or None if there is no such element.\n// Example:\n// next_smallest([1L, 2L,\
    \ 3L, 4L, 5L], 2)\n// 2L\n// next_smallest([1L, 2L, 3L, 4L, 5L], 3)\n// 3L\n//\
    \ next_smallest([1L, 2L, 3L, 4L, 5L], 10)\n// None\nNullable!(long) next_smallest(long[]\
    \ lst, int index) \n{\n    if (lst.length < index)\n        return null;\n   \
    \ auto data = lst.dup;\n    data.sort;\n    return make!Nullable(long)(data[index\
    \ - 1]);\n}\n/*\n    You are given a matrix as a flat list of integers.\n    Write\
    \ a function get_col() that returns a list of integers representing a column.\n\
    \    >>> get_col([1L, 2L, 3L, 4L, 5L, 6L], 2, 3)\n    [2L, 5L]\n    >>> get_col([1L,\
    \ 2L, 3L, 4L, 5L, 6L], 1, 2)\n    [1L, 3L]\n    >>> get_col([1L, 2L, 3L, 4L, 5L,\
    \ 6L], 1, 2, True)\n    [1L, 3L, 0L]\n    >>> get_col([1L, 2L, 3L, 4L, 5L, 6L],",
  "{\n    int[] arr;\n    if (lst.length < 2)\n        return null;\n    arr = [lst[0],lst[1]];\n\
    \    for (int i = 2; i < lst.length; i++) \n    {\n        if (lst[i] > arr[0])\
    \ \n        {\n            if (lst[i] < arr[1])\n                arr[1] = lst[i];\n\
    \        }\n        else \n        {\n            if (lst[i] < arr[0]) \n    \
    \        {\n                arr[1] = arr[0];\n                arr[0] = lst[i];\n\
    \            }\n        }\n    }\n    if (arr[0] == arr[1])\n        return null;\n\
    \    return arr[1];\n}", "{\n    long min = -1L;\n    long min2 = -1L;\n    foreach(l;\
    \ lst)\n    {\n        if(l < min || min == -1L)\n        {\n            min2\
    \ = min;\n            min = l;\n        }\n        else if(l < min2 || min2 ==\
    \ -1L)\n        {\n            min2 = l;\n        }\n    }\n    if(min2 == -1L)\n\
    \    {\n        return null;\n    }\n    return min2;\n}\n/*", "{\n    if (lst.length\
    \ < 2) \n    {\n        return null;\n    }\n    long min1 = long.max;\n    long\
    \ min2 = long.max;\n    foreach (item; lst) \n    {\n        if (item < min1)\
    \ \n        {\n            min2 = min1;\n            min1 = item;\n        }\n\
    \        else if (item != min1 && item < min2) \n        {\n            min2 =\
    \ item;\n        }\n    }\n    if (min2 == long.max) \n    {\n        return null;\n\
    \    }\n    return min2;\n}\nstatic assert(next_smallest([1L, 2L, 3L, 4L, 5L])\
    \ == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L]) == 2L);\nstatic assert(next_smallest([])\
    \ == null);\nstatic assert(next_smallest([1L, 1L]) == null);\n/*", "{\n    if\
    \ (lst.length < 2)\n        return null;\n    import std.algorithm.iteration :\
    \ min, minElement;\n    import std.algorithm.sorting : sort;\n    import std.algorithm.searching\
    \ : count;\n    return lst.sort.minElement!(a => a > lst.sort.min).front;\n}",
  "{\n    if (lst.length <= 1) return null;", "{\n    Nullable!(long) res;\n    if\
    \ (lst.length < 2)\n        return res;\n    const long max_int = cast(long)std.numeric.numeric_limits.max;\n\
    \    long num_max = max_int;\n    long num_max2 = max_int;\n    for (long i =\
    \ 0; i < lst.length; i++)\n    {\n        long num = lst[i];\n        if (num\
    \ < num_max)\n        {\n            num_max2 = num_max;\n            num_max\
    \ = num;\n        }\n        else if (num > num_max && num < num_max2)\n     \
    \   {\n            num_max2 = num;\n        }\n    }\n    if (num_max2 == max_int)\n\
    \        return res;\n    res = makeNullable(num_max2);\n    return res;\n}",
  "{\n    long min = lst[0];\n    foreach(value; lst)\n    {\n        if(value < min)\
    \ min = value;\n    }\n    long result = long.max;\n    foreach(value; lst)\n\
    \    {\n        if(value > min && value < result) result = value;\n    }\n   \
    \ if(result == long.max) return Nullable!(long)();\n    return Nullable!(long)(result);\n\
    }\n/*", "{\n    if (lst.length == 0)\n        return null;\n    else if (lst.length\
    \ == 1)\n        return null;\n    else\n    {\n        long min = lst[0];\n \
    \       long next = lst[1];\n        for (int i = 1; i < lst.length; i++)\n  \
    \      {\n            if (lst[i] < min)\n            {\n                next =\
    \ min;\n                min = lst[i];\n            }\n            else if (lst[i]\
    \ < next && lst[i] != min)\n                next = lst[i];\n        }\n      \
    \  if (next == min)\n            return null;\n        else\n            return\
    \ next;\n    }\n}", "{\n    if (lst.length == 0)\n        return null;\n    if\
    \ (lst.length == 1)\n        return null;\n    if (lst.length == 2)\n    {\n \
    \       if (lst[0] == lst[1])\n            return null;\n        return lst[1];\n\
    \    }\n    long smallest = lst[0];\n    long secondSmallest = lst[1];\n    foreach\
    \ (long l; lst)\n    {\n        if (l > smallest)\n        {\n            if (l\
    \ < secondSmallest)\n            {\n                secondSmallest = l;\n    \
    \        }\n        }\n        else if (l < smallest)\n        {\n           \
    \ secondSmallest = smallest;\n            smallest = l;\n        }\n    }\n  \
    \  if (smallest == secondSmallest)\n        return null;\n    return secondSmallest;\n\
    }\n/*", "{\n\tstatic struct Tmp \n\t{\n\t\tlong first;\n\t\tlong second;\n\t}\n\
    \t\n\tTmp tmp;\n\tforeach(i; lst)\n\t{\n\t\tif(i < tmp.first)\n\t\t{\n\t\t\ttmp.second\
    \ = tmp.first;\n\t\t\ttmp.first = i;\n\t\t}\n\t\telse if(i < tmp.second)\n\t\t\
    {\n\t\t\ttmp.second = i;\n\t\t}\n\t}\n\treturn tmp.second;\n}\n/*", "{ \n    //\
    \ TODO\n    return null;\n}", "{\n    if (lst.length < 2) \n    {\n        return\
    \ null;\n    }", "{\n    Nullable!(long) min = null;\n    if (lst.length == 0)\
    \ return null;\n    foreach (el; lst) \n    {\n        if (min is null || el <\
    \ min.get) \n        {\n            min = el;\n        }\n    }\n    long minVal\
    \ = min.get;\n    min = null;\n    foreach (el; lst) \n    {\n        if (el ==\
    \ minVal) continue;\n        if (min is null || el < min.get) \n        {\n  \
    \          min = el;\n        }\n    }\n    return min;\n}", "{\n    if (lst.length\
    \ < 2)\n        return null;\n    long min = lst[0];\n    long second = lst[1];\n\
    \    if (min > second) \n    {\n        min = second;\n        second = lst[0];\n\
    \    }\n    foreach (n; lst[2..$]) \n    {\n        if (n < min) \n        {\n\
    \            second = min;\n            min = n;\n        } \n        else if\
    \ (n < second) \n        {\n            second = n;\n        }\n    }\n    return\
    \ second;\n}", "{\n    //static assert(isInputRange!(long[]));\n    static assert(!isForwardRange!(long[]));\n\
    \    static assert(!isInputRange!(long[]));\n    static assert(isInfinite!(long[]));\n\
    \    static assert(!isBidirectionalRange!(long[]));\n    static assert(!isRandomAccessRange!(long[]));\n\
    \    static assert(isRandomAccessRange!(int[]));\n    static assert(!isBidirectionalRange!(int[]));\n\
    \    static assert(!isInfinite!(int[]));\n    static assert(isInputRange!(int[]));\n\
    \    static assert(!isForwardRange!(int[]));\n    static assert(!isInputRange!(ulong[]));\n\
    \    static assert(!isForwardRange!(ulong[]));\n    static assert(!isInfinite!(ulong[]));\n\
    \    static assert(!isBidirectionalRange!(ulong[]));\n    static assert(isRandomAccessRange!(ulong[]));\n\
    \    static assert(!isInputRange!(byte[]));\n    static assert(!isForwardRange!(byte[]));\n\
    \    static assert(!isInfinite!(byte[]));\n    static assert(!isBidirectionalRange!(byte[]));\n\
    \    static assert(isRandomAccessRange!(byte[]));\n    static assert(!isRandomAccessRange!(long[]));\n\
    \    static assert(!isBidirectionalRange!(char[]));\n    static assert(!isInfinite!(char[]));\n\
    \    static assert(isInputRange!(char[]));\n    static assert(!isForwardRange!(char[]));\n\
    \    static assert(!isInputRange!(ushort[]));\n    static assert(!isForwardRange!(ushort[]));\n\
    \    static assert(!isInfinite!(ushort[]));\n    static assert(!isBidirectionalRange!(ushort[]));\n\
    \    static assert(isRandomAccessRange!(ushort[]));\n    static assert(!isRandomAccessRange!(char[]));\n\
    \   ", "{\n    if (lst.length < 2) return null;\n    auto min = lst[0];\n    auto\
    \ min_idx = 0;\n    foreach (idx, val; lst)\n    {\n        if (val < min)\n \
    \       {\n            min = val;\n            min_idx = idx;\n        }\n   \
    \ }\n    long[] lst_without_min = lst[min_idx .. $];\n    lst_without_min ~= lst[0\
    \ .. min_idx];\n    min = lst_without_min[0];\n    foreach (idx, val; lst_without_min)\n\
    \    {\n        if (val < min)\n        {\n            min = val;\n        }\n\
    \    }\n    return min;\n}", "{\n    Nullable!(long) second_smallest;\n    long\
    \ smallest = lst[0];\n    foreach(l; lst)\n    {\n        if(l < smallest)\n \
    \       {\n            second_smallest = smallest;\n            smallest = l;\n\
    \        }\n        else if (l > smallest && (second_smallest is null || l < second_smallest))\n\
    \        {\n            second_smallest = l;\n        }\n    }\n    return second_smallest;\n\
    }", "{\n    Nullable!(long) result = null;\n    if (lst.length <= 2) \n    {\n\
    \        if (lst.length == 2 && lst[0] == lst[1]) \n        {\n            result\
    \ = null;\n        }\n        else \n        {\n            result = to!(Nullable!(long))(lst[1]);\n\
    \        }\n    }\n    else \n    {\n        long[] ls = lst.dup;\n        ls.sort;\n\
    \        foreach (i, val; ls) \n        {\n            if (i < ls.length - 1)\
    \ \n            {\n                if (ls[i] != ls[i + 1]) \n                {\n\
    \                    result = to!(Nullable!(long))(ls[i + 1]);\n             \
    \       break;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nstatic assert(next_smallest([1L, 2L, 3L, 4L, 5L]) == 2L);\nstatic\
    \ assert(next_smallest([5L, 1L, 4L, 3L, 2L]) == 2L);\nstatic assert(next_smallest([])\
    \ == null);\nstatic assert(next_smallest([1L, 1L]) == null);\n/*\n    You are\
    \ given an array of integers.\n    Return true if the array is empty or it contains\
    \ at least one element that appears at least twice.\n    Return false otherwise.\n\
    \    >>> has_duplicates([1L, 2L, 3L, 4L, 5L])\n    false\n    >>> has_duplicates([1L,\
    \ 2L, 3L, 4L, 5L, 1L])\n    true\n    >>> has_duplicates([1L, 1L, 1L, 1L, 1L])\n\
    \    true\n    >>> has_duplicates([])\n    false\n*/", "{\n    long min, min2;\n\
    \    min = min2 = long.max;\n    foreach(long n; lst)\n    {\n        if (n <\
    \ min)\n        {\n            min2 = min;\n            min = n;\n        }\n\
    \        else if (n < min2)\n        {\n            min2 = n;\n        }\n   \
    \ }\n    return min2;\n}", "{\n    if (lst.length <= 1) \n    {\n        return\
    \ null;\n    }\n    long min = lst[0];\n    long second = min;\n    foreach (i;\
    \ lst) \n    {\n        if (i > min) \n        {\n            second = i;\n  \
    \          break;\n        }\n        else if (i < min) \n        {\n        \
    \    second = min;\n            min = i;\n        }\n    }\n    foreach (i; lst)\
    \ \n    {\n        if (i > min && i < second) \n        {\n            second\
    \ = i;\n        }\n    }\n    if (second == min) \n    {\n        return null;\n\
    \    }\n    return second;\n}", "{\n    if (lst.length == 0) \n    {\n       \
    \ return null;\n    } \n    else if (lst.length == 1) \n    {\n        return\
    \ null;\n    }\n    long min1 = long.max;\n    long min2 = long.max;\n    foreach\
    \ (l; lst) \n    {\n        if (l < min1) \n        {\n            min2 = min1;\n\
    \            min1 = l;\n        } \n        else if (l < min2) \n        {\n \
    \           min2 = l;\n        }\n    }\n    if (min2 == long.max) \n    {\n \
    \       return null;\n    }\n    return min2;\n}", "{\n    Nullable!(long) min,\
    \ min2 = Nullable!(long).init;\n    foreach(el; lst)\n    {\n        if(min.isNull\
    \ || min2.isNull)\n        {\n            if(min.isNull)\n            {\n    \
    \            min = el;\n            } else\n            {\n                min2\
    \ = el;\n            }\n        } else\n        {\n            if(el < min)\n\
    \            {\n                min2 = min;\n                min = el;\n     \
    \       } else if(el < min2)\n            {\n                min2 = el;\n    \
    \        }\n        }\n    }\n    return min2;\n}", "{\n    // type of the array\n\
    \    immutable lstLen = lst.length;\n    if (lstLen == 0) \n    {\n        return\
    \ null;\n    }\n    else if (lstLen == 1) \n    {\n        return null;\n    }\n\
    \    //  Initialize first and second smallest \n    int first = std.algorithm.min(lst);\n\
    \    int second = std.algorithm.max(lst);", "{\n    long min, next_min;\n    auto\
    \ len = lst.length;\n    if (len < 2) return null;\n    if (lst[0] < lst[1]) {\n\
    \        min = lst[0];\n        next_min = lst[1];\n    } else {\n        min\
    \ = lst[1];\n        next_min = lst[0];\n    }\n    if (len == 2) {\n        if\
    \ (min == next_min) return null;\n        return next_min;\n    }\n    for (int\
    \ i = 2; i < len; i++) {\n        if (lst[i] < min) {\n            next_min =\
    \ min;\n            min = lst[i];\n        } else if (lst[i] == min) {\n     \
    \       next_min = min;\n        } else if (lst[i] < next_min) {\n           \
    \ next_min = lst[i];\n        }\n    }\n    if (min == next_min) return null;\n\
    \    return next_min;\n}", "{\n    if (lst.length < 2) \n    {\n        return\
    \ Nullable!(long).init;\n    }\n    auto a = lst[0];\n    auto b = lst[1];\n \
    \   a = min(a, b);\n    b = max(a, b);\n    for (int i = 2; i < lst.length; i++)\
    \ \n    {\n        auto c = lst[i];\n        if (c < a) \n        {\n        \
    \    b = a;\n            a = c;\n        } \n        else if (c < b) \n      \
    \  {\n            b = c;\n        }\n    }\n    if (a == b) \n    {\n        return\
    \ Nullable!(long).init;\n    }\n    return Nullable!(long)(b);\n}", "{\n    if\
    \ (lst.length <= 1)\n        return Nullable!(long).init;\n    long smallest =\
    \ lst[0];\n    long next_smallest = lst[1];\n    for (size_t i = 1; i < lst.length;\
    \ i++) \n    {\n        if (lst[i] < smallest) \n        {\n            next_smallest\
    \ = smallest;\n            smallest = lst[i];\n        } \n        else if (lst[i]\
    \ < next_smallest) \n        {\n            next_smallest = lst[i];\n        }\n\
    \    }\n    if (smallest == next_smallest)\n        return Nullable!(long).init;\n\
    \    return Nullable!(long)(next_smallest);\n}", "    in {\n        assert(lst.length\
    \ > 0);\n    }\n    out (result) {\n        if (result.isSome) {\n           \
    \ assert(result.get > 0);\n        }\n    }\n{\n    long min;\n    long next;\n\
    \    foreach (idx, x; lst) {\n        if (idx == 0) {\n            min = x;\n\
    \            next = lst[1];\n        } else if (x < min) {\n            next =\
    \ min;\n            min = x;\n        } else if (x < next) {\n            next\
    \ = x;\n        }\n    }\n    if (min == next) {\n        return null;\n    }\
    \ else {\n        return next;\n    }\n}\n/*", "{\n    return null;\n}", "{ \n\
    \    if (lst.length < 2) \n        return null;\n    else if (lst.length == 2)\
    \ \n        return (lst[0] == lst[1]) ? null : lst[1];\n    else \n    {\n   \
    \     long min = minElement(lst);\n        long second_min = maxElement(lst);\n\
    \        foreach (element; lst) \n        {\n            if (element != min &&\
    \ element < second_min) \n                second_min = element;\n        }\n \
    \       return (second_min == maxElement(lst)) ? null : second_min;\n    }\n}",
  "{\n    enum size_t size = lst.length;\n    if (size == 0u) \n    {\n        return\
    \ Nullable!(long)();\n    }\n    else if (size == 1u) \n    {\n        return\
    \ Nullable!(long)();\n    }\n    else \n    {\n        long minValue = lst[0];\n\
    \        long secondSmallest = long.max;\n        for (size_t i = 1; i < size;\
    \ i++) \n        {\n            if (lst[i] < minValue) \n            {\n     \
    \           secondSmallest = minValue;\n                minValue = lst[i];\n \
    \           }\n            else if (lst[i] < secondSmallest && lst[i] != minValue)\
    \ \n            {\n                secondSmallest = lst[i];\n            }\n \
    \       }\n        if (secondSmallest == long.max) \n        {\n            return\
    \ Nullable!(long)();\n        }\n        else \n        {\n            return\
    \ Nullable!(long)(secondSmallest);\n        }\n    }\n}\n/*", "{\n    if (lst.length\
    \ < 2) return null;\n    long smallest = lst[0];\n    long next_smallest = lst[1];\n\
    \    foreach (item; lst) \n    {\n        if (item < smallest) \n        {\n \
    \           next_smallest = smallest;\n            smallest = item;\n        }\
    \ \n        else if (item < next_smallest) \n        {\n            next_smallest\
    \ = item;\n        }\n    }\n    if (smallest == next_smallest) return null;\n\
    \    return next_smallest;\n}", "{ \n    alias OrderedType = Ordered!(long);\n\
    \    auto min2 = new OrderedType(0);\n    bool set = false;\n    foreach(num;\
    \ lst) \n    {\n        if (num == lst[0]) \n        {\n            continue;\n\
    \        }\n        if (set == false) \n        {\n            min2 = new OrderedType(num);\n\
    \            set = true;\n        }\n        else if (num < min2) \n        {\n\
    \            min2 = num;\n        }\n    }\n    if (set == false) \n    {\n  \
    \      return null;\n    }\n    return to!(Nullable!(long))(min2);\n}\n/*\n  \
    \  Given a list of integers, write a function cnt_odd(lst) that returns the number\
    \ of odd integers in the list.\n    >>> cnt_odd([1L, 2L, 3L, 4L, 5L])\n    3L\n\
    \    >>> cnt_odd([2L, 4L, 6L, 8L])\n    0L\n    >>> cnt_odd([])\n    0L\n    >>>\
    \ cnt_odd([1L, 1L, 1L])\n    3L\n*/\nlong cnt_odd(long[] lst) \n{\n    long cnt\
    \ = 0;\n    foreach(num; lst) \n    {\n        if (num % 2 == 1) \n        {\n\
    \            cnt++;\n        }\n    }\n    return cnt;\n}\n/*\n    Given a list\
    \ of integers, write a function palindrome(lst) that returns True if the list\
    \ is a palindrome and False otherwise.\n    >>> palindrome([1L, 2L, 3L, 2L, 1L])\n\
    \    true\n    >>> palindrome([1L, 2L, 3L, 4L, 1L])\n    false\n    >>> palindrome([])\n\
    \    true\n    >>> palindrome([1L, 1L])\n    true\n*/", "{\n    /* \n    1. Find\
    \ the min element in the array.\n    2. Find the next min element in the array.",
  "{\n    auto tp = tuple!(long)(lst);\n    if (tp.length == 0)\n        return Nullable!(long)();\n\
    \    else\n    {\n        auto fst = tp[0];\n        auto snd = tp[0];\n     \
    \   foreach (cur; tp)\n        {\n            if (cur < fst)\n            {\n\
    \                snd = fst;\n                fst = cur;\n            }\n     \
    \       else if (cur < snd)\n                snd = cur;\n        }\n        if\
    \ (fst == snd)\n            return Nullable!(long)();\n        else\n        \
    \    return Nullable!(long)(snd);\n    }\n}\n/*\n    You are given a base-10 positive\
    \ integer.\n    Write a function generate_denominations() that returns the list\
    \ of all coins that sum up to the given number.\n    You have coins [1, 5, 10,\
    \ 25, 50] available.\n    >>> generate_denominations(10)\n    [10]\n    >>> generate_denominations(1)\n\
    \    [1]\n    >>> generate_denominations(5)\n    [5]\n    >>> generate_denominations(12)\n\
    \    [10, 1, 1]\n    >>> generate_denominations(123)\n    [50, 50, 25, 1, 1, 1,\
    \ 1]\n    >>> generate_denominations(2)\n    None\n*/\nNullable!(long[]) generate_denominations(long\
    \ x)\n{\n    static long[] coi = [1, 5, 10, 25, 50];\n    if (x == 0)\n      \
    \  return Nullable!(long[])([]);\n    else\n    {\n        foreach (d; coi)\n\
    \        {\n            if (x >= d)\n            {\n                auto t = generate_denominations(x\
    \ - d);\n                if (t.isValid)\n                {\n                 \
    \   return Nullable!(long[])([d] ~ t.get);\n                }\n            }\n\
    \        }\n        return Nullable!(long[])();\n    }\n}\n/*\n    You are given\
    \ a list of strings.\n    Write a function", "in\n{\n    assert(lst.length >=\
    \ 0);\n}\nbody\n{\n    if (lst.length == 0)\n    {\n        return null;\n   \
    \ }\n    else if (lst.length == 1)\n    {\n        return null;\n    }\n    else\n\
    \    {\n        long least = lst[0];\n        long sec = long.max;\n        foreach\
    \ (long item; lst)\n        {\n            if (item < least)\n            {\n\
    \                sec = least;\n                least = item;\n            }\n\
    \            else if (item < sec)\n            {\n                sec = item;\n\
    \            }\n        }\n        if (sec == long.max)\n        {\n         \
    \   return null;\n        }\n        else\n        {\n            return sec;\n\
    \        }\n    }\n}\n*/", "{\n    if (lst.length == 0)\n        return null;\n\
    \    if (lst.length == 1)\n        return null;\n    long small = lst[0];\n  \
    \  long next_small = lst[1];\n    foreach (element; lst)\n    {\n        if (element\
    \ < small)\n        {\n            next_small = small;\n            small = element;\n\
    \        }\n        else if (element < next_small)\n        {\n            next_small\
    \ = element;\n        }\n    }\n    if (small == next_small)\n        return null;\n\
    \    return next_small;\n}", "{\n    if (lst.length <= 1)\n        return null;\n\
    \    long smallest = lst[0];\n    long min2 = long.max;\n    foreach (i; lst)\
    \ \n    {\n        if (i < smallest) \n        {\n            min2 = min(smallest,\
    \ min2);\n            smallest = i;\n        } \n        else \n        {\n  \
    \          min2 = min(i, min2);\n        }\n    }\n    if (min2 == long.max)\n\
    \        return null;\n    return min2;\n}\n// Solution from http://codereview.stackexchange.com/questions/85914/second-smallest-number-in-list\n\
    Nullable!(long) next_smallest2(long[] array) \n{\n    if (array.length < 2) \n\
    \    {\n        return null;\n    }\n    long min1 = long.max;\n    long min2\
    \ = long.max;\n    foreach (item; array) \n    {\n        if (item < min1) \n\
    \        {\n            min2 = min1;\n            min1 = item;\n        } \n \
    \       else if (item < min2) \n        {\n            min2 = item;\n        }\n\
    \    }\n    if (min2 == long.max) \n    {\n        return null;\n    }\n    return\
    \ min2;\n}", "{\n    Nullable!(long) res = Nullable!(long).init;\n    if (lst.length\
    \ > 1)\n    {\n        long min = lst[0];\n        long second_min = lst[1];\n\
    \        res = second_min;\n        foreach (long l; lst)\n        {\n       \
    \     if (l < min)\n            {\n                res = min;\n              \
    \  min = l;\n            }\n            else if (l < second_min)\n           \
    \ {\n                res = l;\n            }\n        }\n    }\n    return res;\n\
    }\n/*", "{\n    auto res = Nullable!(long)();\n    if (lst.length == 0) return\
    \ res;\n    else if (lst.length == 1) return res;\n    else \n    {\n        auto\
    \ temp_list = lst[];\n        sort(temp_list);\n        auto unique_list = temp_list.dup;\n\
    \        unique_list.length = unique(unique_list);\n        if (unique_list.length\
    \ == 1) return res;\n        else return unique_list[1];\n    }\n}\n// TESTS\n\
    unittest \n{\n    auto test_list1 = [1L, 2L, 3L, 4L, 5L];\n    assert(next_smallest(test_list1)\
    \ == 2L);\n    auto test_list2 = [5L, 1L, 4L, 3L, 2L];\n    assert(next_smallest(test_list2)\
    \ == 2L);\n    auto test_list3 = [];\n    assert(next_smallest(test_list3) is\
    \ null);\n    auto test_list4 = [1L, 1L];\n    assert(next_smallest(test_list4)\
    \ is null);\n}", "{\n    if (lst.length < 2) return null;\n    else if (lst.length\
    \ == 2) \n    {\n        return (lst[0] != lst[1]) ? to!long(min(lst[0], lst[1]))\
    \ : null;\n    }\n    else \n    {\n        long min = max(lst);\n        long\
    \ m = min;\n        foreach (x; lst) \n        {\n            if (x < min) \n\
    \            {\n                m = min;\n                min = x;\n         \
    \   }\n            else if (x < m && x != min) \n            {\n             \
    \   m = x;\n            }\n        }\n        return (m == min) ? null : m;\n\
    \    }\n}", "{\n    if (lst.length < 2) \n    {\n        return null;\n    }\n\
    \    else\n    {\n        auto minimum = lst[0];\n        auto second_minimum\
    \ = minimum;\n        foreach (i, elem; lst) \n        {\n            if (elem\
    \ < minimum) \n            {\n                second_minimum = minimum;\n    \
    \            minimum = elem;\n            }\n            else if (elem < second_minimum)\
    \ \n            {\n                second_minimum = elem;\n            }\n   \
    \     }\n        if (second_minimum == minimum) \n        {\n            return\
    \ null;\n        }\n        else\n        {\n            return second_minimum;\n\
    \        }\n    }\n}", "{\n    long min1 = long.max;\n    long min2 = long.max;\n\
    \    foreach(long n; lst)\n    {\n        if(n < min1)\n        {\n          \
    \  min2 = min1;\n            min1 = n;\n        }\n        else if(n < min2)\n\
    \        {\n            min2 = n;\n        }\n    }\n    if(min2 == long.max)\
    \ return Nullable!(long)();\n    return Nullable!(long)(min2);\n}\n/*", "{\n \
    \   if (lst.length <= 1) return null;\n    long min1 = max(lst);\n    long min2\
    \ = max(lst);\n    foreach (l; lst) \n    {\n        if (l < min1) \n        {\n\
    \            min2 = min1;\n            min1 = l;\n        } \n        else if\
    \ (l < min2) \n        {\n            min2 = l;\n        }\n    }\n    if (min1\
    \ == min2) return null;\n    return min2;\n}", "{\n    return lst.minElement!\"\
    a < b\"(1);\n}", "{\n    if (lst.length < 2)\n        return null;\n    long smallest\
    \ = 0L;\n    long nextSmallest = 0L;\n    auto first = true;\n    foreach (i,\
    \ current; lst)\n    {\n        if (first)\n        {\n            smallest =\
    \ current;\n            nextSmallest = current;\n            first = false;\n\
    \        }\n        else if (current < smallest)\n        {\n            nextSmallest\
    \ = smallest;\n            smallest = current;\n        }\n        else if (current\
    \ < nextSmallest)\n        {\n            nextSmallest = current;\n        }\n\
    \    }\n    if (smallest == nextSmallest)\n        return null;\n    return nextSmallest;\n\
    }", "{ \n    if (lst.length == 0) \n        return typeof(return).init;\n    long\
    \ min = lst[0];\n    long second_min = lst[0];\n    foreach (elem; lst)\n    {\n\
    \        if (elem < min)\n        {\n            second_min = min;\n         \
    \   min = elem;\n        }\n        else if (elem < second_min)\n        {\n \
    \           second_min = elem;\n        }\n    }\n    if (second_min == min)\n\
    \        return typeof(return).init;\n    return second_min;\n}\n/*", "{\n   \
    \ if (lst.length < 2)\n        return null;\n    long n_smallest = long.max;\n\
    \    long n2_smallest = long.max;\n    foreach (elem; lst) \n    {\n        if\
    \ (elem < n_smallest) \n        {\n            n2_smallest = n_smallest;\n   \
    \         n_smallest = elem;\n        } \n        else if (elem < n2_smallest)\
    \ \n        {\n            n2_smallest = elem;\n        }\n    }\n    if (n2_smallest\
    \ != long.max)\n        return n2_smallest;\n    return null;\n}\n/*", "{\n  \
    \  if (lst.length < 2)\n        return null;\n    long min = lst[0];\n    long\
    \ nmin = lst[1];\n    foreach (i, x; lst)\n    {\n        if (x < min)\n     \
    \   {\n            nmin = min;\n            min = x;\n        }\n        else\
    \ if (x < nmin)\n        {\n            nmin = x;\n        }\n    }\n    if (min\
    \ == nmin)\n        return null;\n    return nmin;\n}", "{\n    if (lst.length\
    \ < 2) return typeof(null).init;\n    // quick-and-dirty solution\n    lst.sort();\n\
    \    return lst[1];\n}\nstatic assert(next_smallest([1L, 2L, 3L, 4L, 5L]) == 2L);\n\
    static assert(next_smallest([5L, 1L, 4L, 3L, 2L]) == 2L);\nstatic assert(next_smallest([])\
    \ == typeof(null).init);\nstatic assert(next_smallest([1L, 1L]) == typeof(null).init);",
  "{\n    if (lst.length < 2)\n        return null;\n    else \n    {\n        long\
    \ min = lst[0];\n        long next_min = lst[1];\n        for (long i = 1; i <\
    \ lst.length; i++) \n        {\n            if (lst[i] < min) \n            {\n\
    \                next_min = min;\n                min = lst[i];\n            }\n\
    \            else if (lst[i] < next_min) \n            {\n                next_min\
    \ = lst[i];\n            }\n        }\n        if (min != next_min)\n        \
    \    return next_min;\n        else\n            return null;\n    }\n}", "{\n\
    \    if (lst.length <= 1)\n        return Nullable!(long).init;\n    else\n  \
    \  {\n        auto s = lst[0];\n        auto n = lst[1];\n        foreach (i;\
    \ 2..lst.length)\n        {\n            if (lst[i] < s)\n            {\n    \
    \            n = s;\n                s = lst[i];\n            }\n            else\
    \ if (lst[i] < n)\n                n = lst[i];\n        }\n        return n;\n\
    \    }\n}", "{\n    auto nums = lst[0 .. $];\n    if (nums.length == 0) return\
    \ null;\n    if (nums.length == 1) return null;\n    auto sorted = nums.sort;\n\
    \    return sorted[1];\n}", "{\n    if (lst.length<2) return null;\n    auto sorted=lst.dup.sort;\n\
    \    for (auto i=1; i<sorted.length; i++)\n    {\n        if (sorted[i]!=sorted[i-1])\
    \ return sorted[i];\n    }\n    return null;\n}\n/*", "{\n    size_t len = lst.length;\n\
    \    if (len == 0) return null;\n    if (len == 1) return null;\n    long[] lst_copy\
    \ = lst[1..$];\n    std.algorithm.sort(lst_copy);\n    lst_copy.removeDuplicates();\n\
    \    if (lst_copy.length == 1) return null;\n    else return lst_copy[1];\n}",
  "{\n    if (lst.length == 0 || lst.length == 1)\n        return null;\n    long\
    \ min = lst[0];\n    long sec = lst[1];\n    if (min > sec)\n    {\n        min\
    \ = lst[1];\n        sec = lst[0];\n    }\n    foreach (x; lst[2..$])\n    {\n\
    \        if (x < min)\n        {\n            sec = min;\n            min = x;\n\
    \        }\n        else if (x < sec)\n        {\n            sec = x;\n     \
    \   }\n    }\n    return sec;\n}", "{\n    long min, nmin;\n    min = lst[0];\n\
    \    nmin = long.max;\n    foreach(i; lst)\n    {\n        if(min > i)\n     \
    \   {\n            nmin = min;\n            min = i;\n        }\n        else\
    \ if(nmin > i && i != min)\n        {\n            nmin = i;\n        }\n    }\n\
    \    if(nmin == long.max)\n    {\n        return null;\n    }\n    return nmin;\n\
    }", "{\n    alias Nullable!(long) T;\n    long min = lst[0], second = lst[0];\n\
    \    foreach(l; lst) \n    {\n        if(l < min) \n        {\n            second\
    \ = min;\n            min = l;\n        } \n        else if(l < second) \n   \
    \     {\n            second = l;\n        }\n    }\n    return second != min ?\
    \ T(second) : T.init;\n}\n/*", "{\n    if (lst.length == 0) \n    {\n        return\
    \ null;\n    }\n    long min2 = long.max;\n    long min1 = long.max;\n    foreach\
    \ (elem; lst) \n    {\n        if (elem < min1) \n        {\n            min2\
    \ = min1;\n            min1 = elem;\n        } \n        else if (elem < min2)\
    \ \n        {\n            min2 = elem;\n        }\n    }\n    if (min2 == long.max)\
    \ \n    {\n        return null;\n    }\n    return min2;\n}\n/*", "in {\n    assert(lst.length\
    \ >= 0);\n}\nout (result) {\n    foreach (t; lst)\n        invariant(t <= result);\n\
    }\nbody {\n    if (lst.length == 0) {\n        return Nullable!(long).init;\n\
    \    }\n    auto it = lst.front;\n    auto cur = *it;\n    auto next = *(it +\
    \ 1);\n    auto cur_idx = 0;\n    auto next_idx = 1;\n    foreach (idx, t; lst)\n\
    \        in {\n            if (idx != 0) {\n                assert(t >= lst[idx\
    \ - 1]);\n            }\n        }\n        out (cur, next, cur_idx, next_idx)\
    \ {\n            invariant(lst[cur_idx] == cur);\n            invariant(lst[next_idx]\
    \ == next);\n            invariant(next == cur);\n            invariant(next >=\
    \ lst[idx]);\n        }\n        body {\n            if (t != cur) {\n       \
    \         if (t < cur) {\n                    next = cur;\n                  \
    \  next_idx = cur_idx;\n                    cur = t;\n                    cur_idx\
    \ = idx;\n                } else {\n                    next = t;\n          \
    \          next_idx = idx;\n                }\n            }\n        }\n    if\
    \ (next == cur) {\n        return Nullable!(long).init;\n    }\n    return next;\n\
    }\n/*\n    Write a function permutations() that returns all permutations of a\
    \ list.\n    >>> permutations([1L, 2L, 3L])\n    [[1L, 2L, 3L], [1L, 3L, 2L],\
    \ [2L, 1L, 3L], [2L, 3L, 1L], [3L, 1L, 2L], [3L, 2L, 1L]]\n    >>> permutations([1L])\n\
    \    [[1L]]\n    >>> permutations([])\n    [[]]\n*/\nlong[][] permutations(long[]\
    \ lst) \nin {\n    assert(lst.length >= 0);", "{\n    if (lst.length < 2) return\
    \ null;\n    long min1 = min(lst);\n    long[] lst_wo_min = lst.filter!(x => x\
    \ != min1);\n    return min(lst_wo_min);\n}", "{\n    \n}", "{\n    // https://stackoverflow.com/questions/29002695/is-it-possible-to-get-the-2nd-lowest-element-using-min-from-d\n\
    \    if (lst.length < 2)\n        return Nullable!(long).init;\n    immutable\
    \ m = min(lst);\n    immutable i = lst.indexOf(m);\n    if (i == lst.length -\
    \ 1)\n        lst.length -= 1;\n    else if (i == 0)\n        lst.removeFront();\n\
    \    else\n        lst = lst[0..i] ~ lst[i+1..$];\n    return min(lst);\n}\n/*\n\
    \    Write a function that returns the sum of multiples of 3 and 5 below n.\n\
    \    >>> mult_sum(10)\n    23\n    >>> mult_sum(20)\n    78\n*/\nsize_t mult_sum(in\
    \ size_t n) \n{\n    return iota(n)\n    .filter!(i => i % 3 == 0 || i % 5 ==\
    \ 0)\n    .sum;\n}\n/*\n    Write a function that takes a string and calculates\
    \ the sum of all individual digits.\n    >>> digit_sum(\"12345\")\n    15\n  \
    \  >>> digit_sum(\"\")\n    0\n    >>> digit_sum(\"abcde\")\n    0\n*/\nsize_t\
    \ digit_sum(in string str) \n{\n    return str.canFind('0')\n        ? str.replace(\"\
    0\", \"\").retro()\n            .map!(a => to!size_t(str[a]))\n            .sum\n\
    \        : 0;\n}\n/*\n    Write a function that creates a list of tuples representing\
    \ all possible combinations of elements from the two lists.\n    >>> combinations([1,\
    \ 2, 3], [4, 5, 6])\n    [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3,\
    \ 4), (3, 5), (3, 6)]\n    >>> combinations([1, 2, 3], [])\n    []\n    >>> combinations([],\
    \ [4, 5,", "{ \n    size_t i;\n    long min = long.max;\n    long min2 = long.max;\n\
    \    for (i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n    \
    \    {\n            min2 = min;\n            min = lst[i];\n        }\n      \
    \  else if (lst[i] < min2)\n        {\n            min2 = lst[i];\n        }\n\
    \    }\n    if (min2 == long.max)\n    {\n        return null;\n    }\n    else\n\
    \    {\n        return min2;\n    }\n}", "{\n    if (lst.length < 2)\n       \
    \ return null;\n    return min(lst[1 .. $]);\n}\nstatic assert(next_smallest([1L,\
    \ 2L, 3L, 4L, 5L]) == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L])\
    \ == 2L);\nstatic assert(next_smallest([]) == null);\nstatic assert(next_smallest([1L,\
    \ 1L]) == null);", "{\n\tlong min1, min2;\n\tif (lst.length == 0) return null;\n\
    \tmin1 = min2 = lst[0];\n\tforeach (n; lst) \n\t{\n\t\tif (n < min1) \n\t\t{\n\
    \t\t\tmin2 = min1;\n\t\t\tmin1 = n;\n\t\t}\n\t\telse if (n < min2) \n\t\t{\n\t\
    \t\tmin2 = n;\n\t\t}\n\t}\n\tif (min1 == min2) return null;\n\treturn min2;\n\
    }\nstatic assert(next_smallest([1L, 2L, 3L, 4L, 5L]) == 2L);\nstatic assert(next_smallest([5L,\
    \ 1L, 4L, 3L, 2L]) == 2L);\nstatic assert(next_smallest([]) == null);\nstatic\
    \ assert(next_smallest([1L, 1L]) == null);", "{\n    if (lst.length < 2) \n  \
    \  {\n        return Nullable!(long)();\n    }\n    else\n    {\n        auto\
    \ n = lst[0];\n        auto m = lst[1];\n        for (auto i = 2; i < lst.length;\
    \ i++)\n        {\n            if (lst[i] < m)\n            {\n              \
    \  if (lst[i] < n)\n                {\n                    m = n;\n          \
    \          n = lst[i];\n                }\n                else\n            \
    \    {\n                    m = lst[i];\n                }\n            }\n  \
    \      }\n        if (n == m)\n        {\n            return Nullable!(long)();\n\
    \        }\n        else\n        {\n            return Nullable!(long)(m);\n\
    \        }\n    }\n}\n/*", "{ \n    long min1 = long.max; \n    long min2 = long.max;\
    \ \n    foreach (idx, num; lst) { \n        if (num < min1) { \n            min2\
    \ = min1; \n            min1 = num; \n        } else if (num < min2 && num !=\
    \ min1) { \n            min2 = num; \n        } \n    } \n    if (min2 == long.max)\
    \ { \n        return Nullable!(long)(); \n    } \n    return Nullable!(long)(min2);\
    \ \n} \n/*\n    >>> next_smallest([1L, 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L,\
    \ 1L, 4L, 3L, 2L])\n    2L\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1L,\
    \ 1L])\n    None\n*/", "{\n    if (lst.length == 0)\n        return null;\n  \
    \  if (lst.length == 1)\n        return null;\n    long smallest_so_far = lst[0];\n\
    \    Nullable!(long) second_smallest_so_far = null;\n    foreach (immutable num;\
    \ lst) \n    {\n        if (num < smallest_so_far) \n        {\n            second_smallest_so_far\
    \ = smallest_so_far;\n            smallest_so_far = num;\n        }\n        else\
    \ if ((num < second_smallest_so_far) || (second_smallest_so_far == null)) \n \
    \       {\n            second_smallest_so_far = num;\n        }\n    }\n    return\
    \ second_smallest_so_far;\n}\nstatic assert(next_smallest([1L, 2L, 3L, 4L, 5L])\
    \ == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L]) == 2L);\nstatic assert(next_smallest([])\
    \ == null);\nstatic assert(next_smallest([1L, 1L]) == null);", "{\n    if (lst.length\
    \ < 2)\n        return typeof(null);\n    long smallest = lst[0];\n    Nullable!(long)\
    \ nsmallest = typeof(null);\n    foreach (idx, elem; lst) \n    {\n        if\
    \ (elem < smallest) \n        {\n            nsmallest = smallest;\n         \
    \   smallest = elem;\n        }\n        else if (elem > smallest && nsmallest\
    \ is null || nsmallest > elem) \n        {\n            nsmallest = elem;\n  \
    \      }\n    }\n    return nsmallest;\n}", "{\n    long min = (lst.length > 0)\
    \ ? lst[0] : 0;\n    long sec = 0;\n    foreach(l; lst) \n    {\n        if (l\
    \ < min) \n        {\n            sec = min;\n            min = l;\n        }\
    \ \n        else if (l > min && l < sec) \n        {\n            sec = l;\n \
    \       }\n    }\n    return (sec != 0) ? makeNullable(sec) : null;\n}", "{\n\
    \    return lst.length > 1 ? lst[1] : null;\n}", "{\n    //*** your code goes\
    \ here ***\n    return null;\n}", "{ \n    if (lst.length < 2) \n        return\
    \ null;\n    long min_val = long.max;\n    long min_val2 = long.max;\n    foreach\
    \ (val; lst) \n    {\n        if (val < min_val) \n        {\n            min_val2\
    \ = min_val;\n            min_val = val;\n        } \n        else if (val < min_val2)\
    \ \n        {\n            min_val2 = val;\n        }\n    }\n    if (min_val2\
    \ == long.max) \n        return null;\n    return min_val2;\n}\nstatic assert(next_smallest([1L,\
    \ 2L, 3L, 4L, 5L]) == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L])\
    \ == 2L);\nstatic assert(next_smallest([]) == null);\nstatic assert(next_smallest([1L,\
    \ 1L]) == null);\n/*", "{ \n    Nullable!(long) result = Nullable!(long).init;\n\
    \    if (lst.length == 0)\n        return result;\n    if (lst.length == 1)\n\
    \        return result;\n    auto min = lst[0];\n    auto sec = lst[1];\n    foreach\
    \ (item; lst)\n    {\n        if (item == min)\n            continue;\n      \
    \  if (item < min)\n        {\n            sec = min;\n            min = item;\n\
    \        }\n        else if (item < sec)\n            sec = item;\n    }\n   \
    \ if (sec == min)\n        return result;\n    result.value = sec;\n    return\
    \ result;\n}", "{\n    if (lst.length < 2)\n        return null;\n    else\n \
    \   {\n        long first = lst[0];\n        long second = long.max;\n       \
    \ foreach (curr; lst)\n        {\n            if (curr < first)\n            {\n\
    \                second = first;\n                first = curr;\n            }\n\
    \            else if (curr < second && curr != first)\n                second\
    \ = curr;\n        }\n        if (second == long.max)\n            return null;\n\
    \        else\n            return second;\n    }\n}", "{\n    Nullable!(long)\
    \ res = Nullable!(long).init;\n    if (lst.length <= 1) return res;\n    auto\
    \ min = minElement(lst);\n    lst -= min;\n    if (lst.length > 0)\n    {\n  \
    \      auto smin = minElement(lst);\n        return smin;\n    }\n    return res;\n\
    }\n/*\n    # Write a function to calculate the divisors of a number.\n    >>>\
    \ divisors(10)\n    [1, 2, 5, 10]\n    >>> divisors(11)\n    [1, 11]\n    >>>\
    \ divisors(12)\n    [1, 2, 3, 4, 6, 12]\n*/\nlong[] divisors(long n)\n{\n    long[]\
    \ res = [];\n    foreach(i; 2..n/2)\n    {\n        if (n % i == 0) res ~= i;\n\
    \    }\n    return res;\n}", "{\n    long[] new_lst = lst.dup;\n    new_lst.sort;\n\
    \    Nullable!(long) ret = Nullable!(long)(null);\n    if (new_lst.length >= 2)\n\
    \    {\n        if (new_lst[0] != new_lst[1])\n        {\n            ret = new_lst[1];\n\
    \        }\n    }\n    return ret;\n}\n//\nstatic assert(next_smallest([1L, 2L,\
    \ 3L, 4L, 5L]) == 2L);\nstatic assert(next_smallest([5L, 1L, 4L, 3L, 2L]) == 2L);\n\
    static assert(next_smallest([]) == null);\nstatic assert(next_smallest([1L, 1L])\
    \ == null);\n \n/*", "{\n    version(none) \n    {\n        import std.algorithm;\n\
    \        import std.functional;\n        import std.conv;\n        import std.range;\n\
    \        auto n = nth(lst.sort().unique.dropOne,1);\n        return n ? to!long(n)\
    \ : null;\n    }\n    import std.traits;\n    import std.array;\n    import std.range;\n\
    \    import std.conv;\n    import std.functional;\n    alias pred = less;\n  \
    \  auto t = ElementType!(lst);\n    t max = t.init;\n    t max2 = t.init;\n  \
    \  static foreach(i; lst) \n    {\n        if(pred(i, max)) \n        {\n    \
    \        max2 = max;\n            max = i;\n        }\n        else if(pred(i,\
    \ max2)) \n        {\n            max2 = i;\n        }\n    }\n    return pred(max2,\
    \ max) ? to!long(max2) : null;\n}", "{\n    if (lst.length < 2) return null;\n\
    \    auto min_1 = lst[0];\n    auto min_2 = lst[1];\n    if (min_1 > min_2) swap(min_1,\
    \ min_2);\n    foreach (i, v; lst[2..$])\n    {\n        if (v < min_1)\n    \
    \    {\n            min_2 = min_1;\n            min_1 = v;\n        }\n      \
    \  else if (v < min_2)\n        {\n            min_2 = v;\n        }\n    }\n\
    \    return min_2;\n}", "{\n    Nullable!(long) result = std.typecons.nullable;\n\
    \    foreach(l; lst) \n    {\n        if (result.isNull) \n        {\n       \
    \     result = l;\n        } \n        else if (l < result) \n        {\n    \
    \        if (result.get != l) \n            {\n                return result;\n\
    \            }\n        } \n        else \n        {\n            result = l;\n\
    \        }\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n    \
    \    return null;\n    else if (lst.length == 1)\n        return null;\n    else\
    \ if (lst.length == 2)\n    {\n        if (lst[0] != lst[1])\n            return\
    \ min(lst[0], lst[1]);\n        else\n            return null;\n    }\n    else\n\
    \    {\n        auto sorted = lst.sort.array;\n        foreach (i, element; sorted)\n\
    \        {\n            if (i < sorted.length - 1)\n            {\n          \
    \      if (element != sorted[i + 1])\n                    return sorted[i + 1];\n\
    \            }\n        }\n        return null;\n    }\n}", "{ \n    if (lst.length\
    \ < 2) \n        return null;\n    auto [_, smallest] = lst[0];\n    auto [_,\
    \ second_smallest] = lst[1];\n    foreach (i, el; lst) \n    {\n        if (i\
    \ < 2) \n            continue;\n        if (el < smallest) \n        {\n     \
    \       second_smallest = smallest;\n            smallest = el;\n        }\n \
    \       else if (el < second_smallest) \n        {\n            second_smallest\
    \ = el;\n        }\n    }\n    return second_smallest;\n}\n \nconst long test_arr1\
    \ = [1L, 2L, 3L, 4L, 5L];\nconst long test_arr2 = [5L, 1L, 4L, 3L, 2L];\nconst\
    \ long test_arr3 = [];\nconst long test_arr4 = [1L, 1L];\nstatic assert(next_smallest(test_arr1)\
    \ == 2L);\nstatic assert(next_smallest(test_arr2) == 2L);\nstatic assert(next_smallest(test_arr3)\
    \ == null);\nstatic assert(next_smallest(test_arr4) == null);\n \n/*", "{\n  \
    \  size_t[] idx = null;\n    size_t[] nidx = null;\n    nidx ~= 0L;\n    size_t\
    \ len = lst.length;\n    bool found = false;\n    if (len < 2) return null;\n\
    \    for (size_t i = 1; i < len; i++) \n    {\n        if (lst[i] < lst[nidx[0]])\
    \ \n        {\n            if (idx !is null) \n            {\n               \
    \ nidx ~= idx[0];\n            }\n            nidx[0] = i;\n            found\
    \ = true;\n        }\n        else if (lst[i] < lst[nidx[$ - 1]]) \n        {\n\
    \            nidx ~= i;\n            found = true;\n        }\n        else if\
    \ (found) \n        {\n            break;\n        }\n        idx ~= i;\n    }\n\
    \    if (found) \n    {\n        if (idx !is null) \n        {\n            std.algorithm.sort(idx);\n\
    \            foreach (idx; e; e++) \n            {\n                if (nidx.indexOf(e)\
    \ is size_t.max) \n                {\n                    return e;\n        \
    \        }\n            }\n        }\n        return nidx[$ - 1];\n    }\n   \
    \ return null;\n}", "{\n    if (lst.length < 2) return null;\n    long min = lst[0];\n\
    \    long next_min = lst[1];\n    foreach (el; lst) \n    {\n        if (el <\
    \ min) \n        {\n            next_min = min;\n            min = el;\n     \
    \   } \n        else if (el < next_min) \n        {\n            next_min = el;\n\
    \        }\n    }\n    return (min == next_min) ? null : next_min;\n}\n//\nNullable!(long)\
    \ next_smallest(long[] lst) \n{\n    if (lst.length < 2) return null;\n    sort(lst);\n\
    \    return (lst[0] == lst[1]) ? null : lst[1];\n}\n//\nNullable!(long) next_smallest(long[]\
    \ lst) \n{\n    if (lst.length < 2) return null;\n    long min = lst[0];\n   \
    \ long next_min = lst[1];\n    foreach (el; lst) \n    {\n        if (el < min)\
    \ \n        {\n            next_min = min;\n            min = el;\n        } \n\
    \        else if (el < next_min) \n        {\n            next_min = el;\n   \
    \     }\n    }\n    return (min == next_min) ? null : next_min;\n}\n//\nNullable!(long)\
    \ next_smallest(long[] lst) \n{\n    if (lst.length < 2) return null;\n    sort(lst);\n\
    \    return (lst[0] == lst[1]) ? null : lst[1];\n}\n//\nNullable!(long) next_smallest(long[]\
    \ lst) \n{\n    if (lst.length < 2) return null;\n    long min = lst[0];\n   \
    \ long next_min = lst[1];\n    foreach (el; lst) \n    {\n        if (el < min)\
    \ \n        {\n            next_min = min;\n            min =", "{\n\tlong min,\
    \ min2;\n\tNullable!(long) min2 = null;\n\t\n\tmin = lst[0];\n\tforeach(i; lst)\n\
    \t{\n\t\tif(i < min)\n\t\t{\n\t\t\tmin2 = min;\n\t\t\tmin = i;\n\t\t}\n\t\telse\
    \ if (i != min && (i < min2 || min2 is null))\n\t\t{\n\t\t\tmin2 = i;\n\t\t}\n\
    \t}\n\treturn min2;\n}", "in {\n    assert( lst.length <= 2 );\n}\nout (Nullable!(long)\
    \ result)\n{\n    typeof(lst[0]) min = lst[0];\n    typeof(lst[0]) min_2 = lst[0];\n\
    \    typeof(lst[0]) tmp = lst[0];\n    int index = 0;\n    foreach(immutable item;\
    \ lst)\n    {\n        if(item < min)\n        {\n            tmp = min;\n   \
    \         min = item;\n        }\n        else if(item < tmp)\n        {\n   \
    \         tmp = item;\n        }\n    }\n    result = to!Nullable(tmp);\n}", "{\n\
    \    Nullable!(long) smallest = long.min;\n    Nullable!(long) secondSmallest\
    \ = long.min;\n    foreach(i; lst) \n    {\n        if(i < smallest) \n      \
    \  {\n            secondSmallest = smallest;\n            smallest = i;\n    \
    \    }\n        else if(i < secondSmallest) \n        {\n            secondSmallest\
    \ = i;\n        }\n    }\n    return secondSmallest;\n}", "{\n    if (lst.length\
    \ < 2) \n    {\n        return null;\n    }\n    else \n    {\n        lst.sort();\n\
    \        return lst[1];\n    }\n}", "{\n    int size = lst.length;\n    if (size\
    \ < 2) \n    {\n        return null;\n    }\n    else \n    {\n        long min1\
    \ = min(lst);\n        long min2 = long.max;\n        foreach (i; lst) \n    \
    \    {\n            if (i != min1 && i < min2) \n            {\n             \
    \   min2 = i;\n            }\n        }\n        if (min2 == long.max) \n    \
    \    {\n            return null;\n        }\n        else \n        {\n      \
    \      return min2;\n        }\n    }\n}", "{ \n    // TODO\n    // Use std.algorithm.minElement\n\
    \    return typeof(return).init;\n}", "{ \n    return lst.length < 2 ? Nullable!(long).init\
    \ : \n        lst.filter!(a => a != lst[0]).min; \n}\n \n/*\n    The QInt type\
    \ represents 4 long integers that hold 4*32 = 128 bits\n    each QInt has a sign.\n\
    \    You are given a range of operations on QInt.\n    Write operators for the\
    \ following operations:\n    addition, subtraction, multiplication, division\n\
    \    You should take in account the sign.\n    >>> auto q1 = QInt(1, 2, 3, 4);\n\
    \    >>> auto q2 = QInt(1, 2, 3, 4);\n    >>> q1 + q2\n    QInt(2, 4, 6, 8)\n\
    \    >>> q1 - q2\n    QInt(0, 0, 0, 0)\n    >>> q1 * q2\n    QInt(1, 4, 9, 16)\n\
    \    >>> q1 / q2\n    QInt(1, 1, 1, 1)\n    >>> auto q3 = QInt(-1, -2, -3, -4);\n\
    \    >>> q1 + q3\n    QInt(0, 0, 0, 0)\n    >>> q1 - q3\n    QInt(2, 4, 6, 8)\n\
    \    >>> q1 * q3\n    QInt(-1, -4, -9, -16)\n    >>> q1 / q3\n    QInt(-1, -1,\
    \ -1, -1)\n*/\nstruct QInt\n{\n    long a, b, c, d;\n    this(long a, long b,\
    \ long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c\
    \ = c;\n        this.d = d;\n    }\n    QInt opBinary(string op : \"+\")(QInt\
    \ rhs)\n    {\n        return new QInt(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d);\n\
    \    }\n    QInt opBinary(string op : \"-\")(QInt rhs)\n    {\n        return\
    \ new QInt(a -", "{\n    // version 0: using std.datetime.StopWatch to check time\
    \ elapsed\n    StopWatch sw = StopWatch(ClockType.Monotonic);\n    sw.start();\n\
    \    // lst.length == 0\n    if (lst.length == 0) \n    {\n        return null;\n\
    \    }\n    // lst.length == 1\n    if (lst.length == 1) \n    {\n        return\
    \ null;\n    }\n    // lst.length == 2\n    if (lst.length == 2) \n    {\n   \
    \     if (lst[0] == lst[1]) \n        {\n            return null;\n        }\n\
    \        return lst[1];\n    }\n    // lst.length > 2\n    long smallest = lst[0];\n\
    \    long next_smallest = lst[1];\n    for (long i = 2; i < lst.length; i++) \n\
    \    {\n        if (lst[i] < smallest) \n        {\n            if (smallest <\
    \ next_smallest) \n            {\n                next_smallest = smallest;\n\
    \            }\n            smallest = lst[i];\n        }\n        else if (lst[i]\
    \ < next_smallest) \n        {\n            next_smallest = lst[i];\n        }\n\
    \    }\n    if (smallest < next_smallest) \n    {\n        return next_smallest;\n\
    \    }\n    sw.stop();\n    writeln(\"runtime: \", sw.peek().msecs);\n    return\
    \ null;\n}", "{\n    if (lst.length < 2) return null;\n    long first = lst[0];\n\
    \    long second = long.max;\n    foreach (i; lst) \n    {\n        if (i < first)\n\
    \        {\n            second = first;\n            first = i;\n        }\n \
    \       else if (i > first && i < second) \n        {\n            second = i;\n\
    \        }\n    }\n    if (second == long.max) return null;\n    return second;\n\
    }\n/*", "in {\n\tassert(lst.length <= 5000);\n}\nbody {\n    Nullable!(long) res\
    \ = typeof(return)();\n    enum lst_size = lst.length;\n    if (lst_size == 0)\
    \ {\n        return res;\n    }\n    if (lst_size == 1) {\n        return res;\n\
    \    }\n    long min = min(lst);\n    long min2 = min;\n    foreach (elt; lst)\
    \ {\n        if (elt != min) {\n            if (elt < min2) {\n              \
    \  min2 = elt;\n            }\n        }\n    }\n    if (min2 == min) {\n    \
    \    return res;\n    }\n    res = Nullable!(long)(min2);\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return null;\n    if (lst.length == 1)\n \
    \       return null;\n    long smallest = lst[0];\n    long second_smallest =\
    \ long.max;\n    foreach (idx, elem; lst) \n    {\n        if (idx > 0) \n   \
    \     {\n            if (elem < smallest) \n            {\n                second_smallest\
    \ = smallest;\n                smallest = elem;\n            }\n            else\
    \ if (elem < second_smallest) \n            {\n                second_smallest\
    \ = elem;\n            }\n        }\n    }\n    if (second_smallest == long.max)\n\
    \        return null;\n    return second_smallest;\n}\n ", "{\n    if (lst.length\
    \ < 2) \n    {\n        return null;\n    }\n    long fst = max_long;\n    long\
    \ snd = max_long;\n    foreach (x; lst) \n    {\n        if (x < fst) \n     \
    \   {\n            snd = fst;\n            fst = x;\n        }\n        else if\
    \ (x < snd) \n        {\n            snd = x;\n        }\n    }\n    if (snd ==\
    \ max_long) \n    {\n        return null;\n    }\n    return make_nullable!(long)(snd);\n\
    }", "{\n    if (lst.length < 2) return null;\n    long min1 = min(lst[0], lst[1]);\n\
    \    long min2 = max(lst[0], lst[1]);\n    for (size_t i = 2; i < lst.length;\
    \ i++) \n    {\n        if (lst[i] < min1) \n        {\n            min2 = min1;\n\
    \            min1 = lst[i];\n        } \n        else if (lst[i] < min2) \n  \
    \      {\n            min2 = lst[i];\n        }\n    }\n    return min2;\n}",
  "{\n    const n = lst.length;\n    if (n < 2)\n        return Nullable!(long).init;\n\
    \    Nullable!(long) min = Nullable!(long).init;\n    Nullable!(long) min2 = Nullable!(long).init;\n\
    \    foreach (i, l; lst)\n    {\n        if (min.isNull)\n        {\n        \
    \    min = l;\n        }\n        else if (l < min)\n        {\n            min2\
    \ = min;\n            min = l;\n        }\n        else if (min2.isNull)\n   \
    \     {\n            min2 = l;\n        }\n        else if (l < min2)\n      \
    \  {\n            min2 = l;\n        }\n    }\n    return min2;\n}", "{\n    auto\
    \ x = long.min;\n    auto y = long.min;\n    for (long i in lst) \n    {\n   \
    \     if (i == x) \n        {\n            continue;\n        }\n        if (i\
    \ < x) \n        {\n            y = x;\n            x = i;\n        }\n      \
    \  else if (i < y) \n        {\n            y = i;\n        }\n    }\n    return\
    \ y == long.min ? null : typeof(null).init;\n}\n/*", "in\n{\n    assert(lst.length\
    \ > 0);\n}\nbody\n{\n    auto n = lst.length;\n    if (n < 2) return null;\n \
    \   return lst[indexOf(lst, min(lst[1..$]))];\n}\n// TEST", "{\n    static struct\
    \ Result\n    {\n        long min_val;\n        long min_2nd_val;\n    }\n   \
    \ static Result make(long l)\n    {\n        return Result(l, l);\n    }\n   \
    \ static Result update(long l, ref Result r)\n    {\n        if (l == r.min_val)\n\
    \            return r;\n        else if (l < r.min_val)\n        {\n         \
    \   r.min_2nd_val = r.min_val;\n            r.min_val = l;\n            return\
    \ r;\n        }\n        else if (l < r.min_2nd_val)\n        {\n            r.min_2nd_val\
    \ = l;\n            return r;\n        }\n        else\n            return r;\n\
    \    }\n    static Nullable!(long) toNullable(ref Result r)\n    {\n        if\
    \ (r.min_val != r.min_2nd_val)\n            return some(r.min_2nd_val);\n    \
    \    else\n            return null;\n    }\n    auto r = reduce!(update)(map!(make)(lst));\n\
    \    return toNullable(r);\n}", "{\n    if (lst.length <= 1)\n        return null;\n\
    \    auto min1 = min(lst);\n    lst.remove(min1);\n    auto min2 = min(lst);\n\
    \    return min2;\n}", "{ \n    if (lst.length <= 1) \n        return typeof(return).init;\n\
    \    long min, max;\n    size_t minIndex, maxIndex;\n    foreach (i, v; lst) \n\
    \    {\n        if (i == 0) \n        {\n            min = v;\n            max\
    \ = v;\n            minIndex = i;\n            maxIndex = i;\n        }\n    \
    \    else \n        {\n            if (v < min) \n            {\n            \
    \    min = v;\n                minIndex = i;\n            }\n            if (v\
    \ > max) \n            {\n                max = v;\n                maxIndex =\
    \ i;\n            }\n        }\n    }\n    long secondMin = max;\n    long secondMinIndex\
    \ = maxIndex;\n    foreach (i, v; lst) \n    {\n        if (i != minIndex && i\
    \ != maxIndex) \n        {\n            if (v < secondMin) \n            {\n \
    \               secondMin = v;\n                secondMinIndex = i;\n        \
    \    }\n        }\n    }\n    if (secondMin == max) \n        return typeof(return).init;\n\
    \    return secondMin;\n}", "{\n    return lst.sort.length < 2 ? null : lst.sort[1];\n\
    }", "in {\n    assert(lst.length >= 0);\n}\nout (Nullable!(long) result)\n{\n\
    \    if (lst.length == 0)\n        result = null;\n    else if (lst.length ==\
    \ 1)\n        result = null;\n    else if (lst.length == 2)\n    {\n        if\
    \ (lst[0] == lst[1])\n            result = null;\n        else if (lst[0] < lst[1])\n\
    \            result = lst[0];\n        else\n            result = lst[1];\n  \
    \  }\n    else \n    {\n        long min = lst[0];\n        long second = lst[1];\n\
    \        if (min > second)\n        {\n            second = min;\n           \
    \ min = lst[1];\n        }\n        foreach (i; 1..lst.length)\n        {\n  \
    \          if (lst[i] < min)\n            {\n                second = min;\n \
    \               min = lst[i];\n            }\n            else if (lst[i] < second\
    \ && lst[i] != min)\n            {\n                second = lst[i];\n       \
    \     }\n        }\n        if (second == min)\n            result = null;\n \
    \       else\n            result = second;\n    }\n}\npure nothrow @safe @nogc\
    \ unittest \n{\n    assert(next_smallest([1L, 2L, 3L, 4L, 5L]) == 2L);\n    assert(next_smallest([5L,\
    \ 1L, 4L, 3L, 2L]) == 2L);\n    assert(next_smallest([]) == null);\n    assert(next_smallest([1L,\
    \ 1L]) == null);\n}", "{\n    if (lst.length < 2)\n        return Nullable!(long)();\n\
    \    \n    long smallest = lst[0];\n    long second_smallest = null;\n    foreach\
    \ (item; lst)\n    {\n        if (item < smallest)\n        {\n            second_smallest\
    \ = smallest;\n            smallest = item;\n        }\n        else if (item\
    \ < second_smallest || second_smallest == null)\n        {\n            second_smallest\
    \ = item;\n        }\n    }\n    return Nullable!(long)(second_smallest);\n}\n\
    /*", "{\n    if (lst.length == 0) \n    {\n        return null;\n    }\n    auto\
    \ lstSet = lst.sort.unique;\n    if (lstSet.length < 2) \n    {\n        return\
    \ null;\n    }\n    return lstSet[1];\n}", "{\n    long min1 = long.max;\n   \
    \ long min2 = long.max;\n    foreach(x; lst) \n    {\n        if (x < min1) \n\
    \        {\n            min2 = min1;\n            min1 = x;\n        }\n     \
    \   else if (x < min2) \n        {\n            min2 = x;\n        }\n    }\n\
    \    return min2 < long.max ? min2 : null;\n}", "{\n    if (lst.length <= 1)\n\
    \        return Nullable!(long).init;\n    auto min1 = min(lst[0], lst[1]);\n\
    \    auto min2 = max(lst[0], lst[1]);\n    foreach (cur; lst[2..$]) \n    {\n\
    \        if (cur < min1) \n        {\n            min2 = min1;\n            min1\
    \ = cur;\n        }\n        else if (cur < min2) \n        {\n            min2\
    \ = cur;\n        }\n    }\n    return Nullable!(long)(min2);\n}", "{\n    if\
    \ (lst.length <= 1) return null;\n    long smallest = lst[0];\n    long next =\
    \ long.max;\n    foreach (index, elem; lst)\n    {\n        if (index == 0) continue;\n\
    \        else if (elem < smallest)\n        {\n            next = smallest;\n\
    \            smallest = elem;\n        }\n        else if (elem < next)\n    \
    \    {\n            next = elem;\n        }\n    }\n    if (next == long.max)\n\
    \    {\n        return null;\n    }\n    return next;\n}", "{ \n    struct minmax\n\
    \    {\n        long min, max;\n    }\n    if (lst.length == 0)\n        return\
    \ null;\n    if (lst.length == 1)\n        return null;\n    minmax val = minmax(lst[0],\
    \ lst[0]);\n    for (int i = 1; i < lst.length; i++)\n    {\n        val.min =\
    \ min(val.min, lst[i]);\n        val.max = max(val.max, lst[i]);\n    }\n    if\
    \ (val.min == val.max)\n        return null;\n    long[] lst2 = new long[lst.length];\n\
    \    int j = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i]\
    \ > val.min)\n        {\n            lst2[j] = lst[i];\n            j++;\n   \
    \     }\n    }\n    lst2 = lst2[0..j];\n    auto result = lst2[0];\n    for (int\
    \ i = 1; i < lst2.length; i++)\n    {\n        result = min(result, lst2[i]);\n\
    \    }\n    return result;\n}", "{\n    if (lst.length < 2)\n        return Nullable!(long)();\n\
    \    else\n    {\n        auto min = lst[0];\n        foreach (i, lst)\n     \
    \   {\n            if (lst[i] < min)\n                min = lst[i];\n        }\n\
    \        foreach (i, lst)\n        {\n            if (lst[i] != min)\n       \
    \         return Nullable!(long)(lst[i]);\n        }\n        return Nullable!(long)();\n\
    \    }\n}\n/*", "{\n    static Nullable!(long) nl;\n    if (lst.length <= 2) \n\
    \    {\n        nl = null;\n        return nl;\n    }\n    long[] temp = lst.dup;\n\
    \    temp.sort();\n    if (temp[0] == temp[1]) \n    {\n        for (int i = 1;\
    \ i < temp.length; i++) \n        {\n            if (temp[i] != temp[i-1]) \n\
    \            {\n                nl = temp[i];\n                return nl;\n  \
    \          }\n        }\n    }\n    nl = temp[1];\n    return nl;\n}", "{\n  \
    \  if (lst.length < 2)\n        return null;\n    else\n    {\n        auto sm\
    \ = lst[0];\n        auto nsm = lst[1];\n        if (sm > nsm)\n        {\n  \
    \          sm = nsm;\n            nsm = lst[0];\n        }\n        for (int i\
    \ = 2; i < lst.length; i++)\n        {\n            if (lst[i] < sm)\n       \
    \     {\n                nsm = sm;\n                sm = lst[i];\n           \
    \ }\n            else if (lst[i] < nsm)\n                nsm = lst[i];\n     \
    \   }\n        return nsm;\n    }\n}", "{\n    long min1 = long.max;\n    long\
    \ min2 = long.max;\n    foreach(val; lst)\n    {\n        if(val < min1)\n   \
    \     {\n            min2 = min1;\n            min1 = val;\n        }\n      \
    \  else if(val < min2)\n        {\n            min2 = val;\n        }\n    }\n\
    \    if(min2 == long.max)\n    {\n        return Nullable!(long)();\n    }\n \
    \   else\n    {\n        return Nullable!(long)(min2);\n    }\n}\n/*"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
