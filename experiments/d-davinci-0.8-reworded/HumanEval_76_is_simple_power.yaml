name: HumanEval_76_is_simple_power
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
  \ that returns true if a number x is a simple\n    power of n and false in other\
  \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>> is_simple_power(1L,\
  \ 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n    >>> is_simple_power(8L,\
  \ 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n    false\n    >>> is_simple_power(3L,\
  \ 1L)\n    false\n    >>> is_simple_power(5L, 3L)\n    false\n    \n*/\nbool is_simple_power(long\
  \ x, long n) \n"
tests: "unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
  \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
  \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
  \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
  \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
  \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
completions: ["{\n    if (n == 1L)\n        return x == 1L;\n    if (x == 0L)\n  \
    \      return false;\n    if (x == 1L)\n        return true;\n    if (n == 0L)\n\
    \        return x == 0L;\n    if (n == 2L)\n        return true;\n    if (n %\
    \ 2 == 0L)\n        return false;\n    for (long i = 3L; i <= n; i += 2L)\n  \
    \  {\n        if (x % i == 0L)\n            return false;\n    }\n    return (x\
    \ % n == 0L) && is_simple_power(x / n, n);\n}", "{\n    if (x < 1)\n        return\
    \ false;\n    if (n == 1)\n        return x == 1;\n    if (n == 0)\n        return\
    \ x == 0;\n    if (x == 1)\n        return true;\n    if (n == 1)\n        return\
    \ false;\n    long exponent = 1;\n    long temp = n;\n    while (temp * n <= x)\n\
    \    {\n        temp *= n;\n        exponent++;\n    }\n    return temp == x;\n\
    }\n/*\n Your task is to write a function that returns true if a number x is a\
    \ power of n and false in other cases.\n    x is a power of n if n**i=x, where\
    \ i is a natural number\n    For example:\n    >>> is_power(1L, 4L)\n    true\n\
    \    >>> is_power(2L, 2L)\n    true\n    >>> is_power(8L, 2L)\n    true\n    >>>\
    \ is_power(3L, 2L)\n    false\n    >>> is_power(3L, 1L)\n    false\n    >>> is_power(5L,\
    \ 3L)\n    false\n*/", "{\n    if(x==1) return true;\n    if(n==1) return false;\n\
    \    if(x==n) return true;\n    return is_simple_power(x, cast(long)log(cast(real)x)/log(cast(real)n));\n\
    }", "{\n    bool res;\n    long result=0;\n    if( x==1L || x==n )\n    {\n  \
    \      res=true;\n    }\n    else\n    {\n        result=log2(x)/log2(n);\n  \
    \      res= ( n**result == x) ? true : false;\n    }\n    return res;\n}\n \n\
    \ \n/*\n    https://www.daniweb.com/programming/software-development/threads/252679/c-program-to-check-whether-a-number-is-a-power-of-another\n\
    \    http://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int\n\
    \    http://stackoverflow.com/questions/10030783/fast-and-elegant-integer-power-function-in-c-c\n\
    */\n \n \nlong power(long n,long p)\n{\n    long res;\n    res=pow(n,p);\n   \
    \ return res;\n}", "{\n    const double xt = x;\n    const double nt = n;\n  \
    \  const double num = log(xt) / log(nt);\n    const uint numi = num;\n    const\
    \ double numt = numi;\n    return numt == num;\n}\nstatic assert(is_simple_power(1L,\
    \ 4L));\nstatic assert(is_simple_power(2L, 2L));\nstatic assert(is_simple_power(8L,\
    \ 2L));\nstatic assert(!is_simple_power(3L, 2L));\nstatic assert(!is_simple_power(3L,\
    \ 1L));\nstatic assert(!is_simple_power(5L, 3L));\n/*\nfrom std.typecons:\n  \
    \  auto tup(T1)(T1 x1) { return tuple(x1); }\n    auto tup(T1, T2)(T1 x1, T2 x2)\
    \ { return tuple(x1, x2); }\n    auto tup(T1, T2, T3)(T1 x1, T2 x2, T3 x3) { return\
    \ tuple(x1, x2, x3); }\n    auto tup(T1, T2, T3, T4)(T1 x1, T2 x2, T3 x3, T4 x4)\
    \ { return tuple(x1, x2, x3, x4); }\n    auto tup(T1, T2, T3, T4, T5)(T1 x1, T2\
    \ x2, T3 x3, T4 x4, T5 x5) { return tuple(x1, x2, x3, x4, x5); }\n    auto tup(T1,\
    \ T2, T3, T4, T5, T6)(T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6) { return tuple(x1,\
    \ x2, x3, x4, x5, x6); }\n    auto tup(T1, T2, T3, T4, T5, T6, T7)(T1 x1, T2 x2,\
    \ T3 x3, T", "{\n    immutable long num = x;\n    immutable long pow = n;\n  \
    \  return x != 0 && n != 0 && num != 1 ? x != 1 && n != 1 && pow != 1 ? num %\
    \ n == 0 ? x % n == 0 ? log(num) / log(n) % 1 == 0 ? true : false : false : false\
    \ : false : false;\n}", "{\n    return x > 0 && (x==1 || (n != 1 && x % n == 0\
    \ && is_simple_power(x/n, n)));\n}", "{\n    return x==1?true:is_simple_power(x,n,\
    \ 1);\n}", "{\n\t \n\treturn false;\n}", "{\n    if(x == 1)\n        return true;\n\
    \    else if(x == 0 || n == 0)\n        return false;\n    else if(n == 1)\n \
    \       return false;\n    else\n    {\n        bool res = false;\n        double\
    \ result = 1;\n        for(long i = 0; i <= x; i++)\n        {\n            result\
    \ = pow(n, i);\n            if(result == x)\n            {\n                res\
    \ = true;\n                break;\n            }\n        }\n        return res;\n\
    \    }\n}", "{\n    if(n==0L)return x==1L;\n    if(n==1L)return x==1L;\n    while(true)\n\
    \    {\n        auto r = x % n;\n        if(r == 0L)\n        {\n            x\
    \ = x / n;\n            if(x == 1L)\n                return true;\n        }\n\
    \        else\n            return false;\n    }\n}", "{\n\treturn x == (long)pow(n,(int)log(x)/(int)log(n));\n\
    }", "{\n    immutable int_ = (int)log(x) / log(n);\n    return pow(n, int_) ==\
    \ x;\n}", "{\n\tdouble result = log(x)/log(n);\n\tif(result == int(result)){\n\
    \t\treturn true;\n\t}\n\treturn false;\n}", "{\n    if ( x == 1 || x == n)\n \
    \   {\n        return true;\n    }\n    else if (x < n)\n    {\n        return\
    \ false;\n    }\n    else\n    {\n        bool retVal = false;\n        bool loopFlag\
    \ = true;\n        int i = 2;\n        while (loopFlag)\n        {\n         \
    \   if ( (n ** i) == x)\n            {\n                retVal = true;\n     \
    \           loopFlag = false;\n            }\n            else if ( (n ** i) >\
    \ x)\n            {\n                loopFlag = false;\n            }\n      \
    \      else\n            {\n                i++;\n            }\n        }\n \
    \       return retVal;\n    }\n}", "{\n    enum x = x;\n    enum n = n;\n    if(n\
    \ == 1 && x == 1)\n        return true;\n    if(n > x)\n        return false;\n\
    \    long left = n;\n    long right = x;\n    while(left < right)\n    {\n   \
    \     left *= n;\n        if(left == right)\n            return true;\n    }\n\
    \    return false;\n}\n/*\nYou have a lot of apples (1.5 kg) and you want to distribute\
    \ them among a number of your colleagues.\n    The only condition is that the\
    \ colleague with the smallest number of apples is at least three times less than\
    \ the colleague with the largest number of apples.\n    Your task is to find such\
    \ a number of colleagues. If there is no such number return 0.\n    >>> distribute_apples(1.5)\n\
    \    2\n    >>> distribute_apples(9)\n    3\n    >>> distribute_apples(6)\n  \
    \  3\n    >>> distribute_apples(0)\n    0\n    >>> distribute_apples(2)\n    0\n\
    \    >>> distribute_apples(11)\n    5\n    >>> distribute_apples(24)\n    10\n\
    \    >>> distribute_apples(80)\n    28\n    >>> distribute_apples(103)\n    31\n\
    \    >>> distribute_apples(30)\n    10\n    >>> distribute_apples(102)\n    31\n\
    \    >>> distribute_apples(9.5)\n    3\n    >>> distribute_apples(24.5)\n    10\n\
    */", "{\n    long nn = long.abs(n);\n    long xx = long.abs(x);\n    if (nn ==\
    \ 0)\n        return xx == 1;\n    if (xx < 1)\n        return false;\n    long\
    \ i = 1;\n    long pow = nn;\n    long last_pow = pow;\n    while (pow <= xx)\n\
    \    {\n        if (pow == xx)\n            return true;\n        last_pow = pow;\n\
    \        pow *= nn;\n    }\n    return false;\n}", "{\n  //x=n**i\n  //i=log(x)/log(n)\n\
    \  static long double log_n=log(n);\n  long double log_x=log(x);\n  long double\
    \ i=log_x/log_n;\n  if (i==(long long)i && i>0)\n    return true;\n  return false;\n\
    }", "{\n    return n == 1 || x == n || (x > 1 && x % n == 0 && is_simple_power(x\
    \ / n, n));\n}", "{\n    int p = 1;\n    long r = 1;\n    while (r < x)\n    {\n\
    \        p++;\n        r = power(n, p);\n    }\n    return (r == x) ? true : false;\n\
    }", "{\n    if(x==1)\n        return true;\n    else if(x==n)\n        return\
    \ true;\n    else if(n==1)\n        return false;\n    else if(n==0)\n       \
    \ return false;\n    else if(x%n != 0)\n        return false;\n    else\n    \
    \    return is_simple_power(x/n, n);\n}", "{\n\tfloat exponent = log(x)/log(n);\n\
    \tif(long(exponent) == exponent)\n\t\treturn true;\n\treturn false;\n}\n/*\nYour\
    \ task is to write a function that returns true if a number x is a multiple\n\
    \    of n and false in other cases.\n    x is a multiple of n if n % x = 0\n \
    \   For example:\n    >>> is_multiple(1L, 1L)\n    true\n    >>> is_multiple(4L,\
    \ 2L)\n    true\n    >>> is_multiple(4L, 3L)\n    false\n    >>> is_multiple(4L,\
    \ 4L)\n    true\n    >>> is_multiple(0L, 1L)\n    true\n    >>> is_multiple(0L,\
    \ 0L)\n    true\n*/", "{\n    return pow(n, cast(double)log(x) / log(n)) == x;\n\
    }", "{\n    if (x <= 0 || n <= 0)\n        return false;\n    \n    long sq =\
    \ n;\n    while (sq < x)\n        sq *= n;\n    \n    return sq == x;\n}", "{\n\
    \    if(n == 1L && x != 1L) return false;\n    //if(n == 1L && x == 1L) return\
    \ true;\n    auto res = long(log(x) / log(n));\n    auto res2 = pow(n, res);\n\
    \    if(res2 == x) return true;\n    return false;\n}", "{\n    long num = 0;\n\
    \    foreach(immutable digit; x.to!string)\n    {\n        num *= 10;\n      \
    \  num += digit - '0';\n    }\n    return num % n == 0;\n}", "{\n    static if\
    \ (is(typeof(x) == long))\n    {\n        static if (n == 0L)\n        {\n   \
    \         return false;\n        }\n        static if (n == 1L)\n        {\n \
    \           return x == 1L;\n        }\n        static if (n > 1L)\n        {\n\
    \            if (x == 0L)\n            {\n                return true;\n     \
    \       }\n            double l = log(cast(double)x) / log(cast(double)n);\n \
    \           static if (is(l is integral))\n            {\n                if (cast(long)l\
    \ == 0L)\n                {\n                    return false;\n             \
    \   }\n                if (cast(long)l == 1L)\n                {\n           \
    \         return true;\n                }\n                long p = 1L;\n    \
    \            long i = 2L;\n                while (i <= cast(long)l)\n        \
    \        {\n                    p *= n;\n                    if (p == x)\n   \
    \                 {\n                        return true;\n                  \
    \  }\n                    ++i;\n                }\n                return false;\n\
    \            }\n            else\n            {\n                return false;\n\
    \            }\n        }\n        else\n        {\n            return false;\n\
    \        }\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n   \
    \ return n == 1 && x == 1 || n != 1 && x == n ^^ int(log(x) / log(n));\n}", "{\n\
    \    if(n == 0) \n        return true;\n    while(x % n == 0) \n        x /= n;\n\
    \    return x == 1;\n}", "{\n    if (n == 1)\n        return false;\n    long\
    \ n1 = 1;\n    long n2 = n;\n    long n3 = n * n;\n    if (x < n1)\n        return\
    \ false;\n    if (x == n1)\n        return true;\n    while (x >= n3)\n    {\n\
    \        n1 = n2;\n        n2 = n3;\n        n3 *= n;\n    }\n    if (x >= n2\
    \ && x < n3)\n        return true;\n    return false;\n}", "{\n    return x ==\
    \ 1L && n == 1L ? true : (x == n && n == 1L ? true : (x == n*n ? true : (x==n*n*n\
    \ ? true : (x==n*n*n*n ? true : (x==n*n*n*n*n ? true : (x==n*n*n*n*n*n ? true\
    \ : (x==n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n\
    \ ? true : (x==n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n ? true :\
    \ (x==n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n ? true :\
    \ (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n ?\
    \ true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n ? true : (x==n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ ? true : (x==n*n*n*n*n*n*", "{\n    return ((x == 1L) || ( n == 1L)) ? true\
    \ : (x % n == 0) ? is_simple_power(x / n, n) : false;\n}", "{\n    long x = cast(long)log(x);\n\
    \    long y = cast(long)log(n);\n    return x % y == 0;\n}", "{\n    // Do your\
    \ magic here\n    return std.math.isPowerOf(x, n);\n}", "{\n    if (x==1) return\
    \ true;\n    if (n==1) return false;\n    if (n==x) return true;\n    if (n==0)\
    \ return false;\n    int i = 1;\n    while (n**i < x) \n    {\n        i++;\n\
    \    }\n    return n**i == x;\n}", "{\n    enum bool retVal = false;\n    ulong\
    \ temp = 0;\n    if (x == 1) return true;\n    if (x > 0 && n > 0)\n    {\n  \
    \      for (ulong i = 2; i < x; i++)\n        {\n            temp = i;\n     \
    \       for (ulong j = 1; j < n; j++)\n            {\n                temp *=\
    \ i;\n                if (temp == x) return true;\n            }\n        }\n\
    \    }\n    return retVal;\n}", "{\n  int y = x;\n  long z = 0;\n  long a = y;\n\
    \  int i = 1;\n  for(int i=1; i<=y; i++)\n  {\n    a = a * n;\n    if(a==x)\n\
    \    {\n      return true;\n    }\n  }\n  return false;\n}", "{\n    if(x < 0\
    \ || n < 0) return false;\n    if(n == 0) return true;\n    for(int i = 1; i <\
    \ 16; i++)\n    {\n        if(pow(n, i) == x)\n            return true;\n    }\n\
    \    return false;\n}", "{\n    return x == n**cast(int)log(n,x);\n}", "{\n  \
    \  if (x <= 0 || n <= 0) return false;\n    if (x == 1) return true;\n    long\
    \ xx = x;\n    while (xx % n == 0)\n    {\n        xx /= n;\n        if (xx ==\
    \ 1) return true;\n    }\n    return false;\n}", "{\n    while(x%n==0)\n     \
    \   x/=n;\n    return x==1L;\n}", "{\n    long pow = Math.pow(x,1.0);\n    long\
    \ p = x;\n    if(p == n)\n    {\n        return true;\n    }\n    else \n    {\n\
    \        return false;\n    }\n}", "{\n    if (x==1 && n==1) return true;\n  \
    \  while (true)\n    {\n        x /= n;\n        if (x==1) return true;\n    \
    \    if (x<1) return false;\n    }\n}\n/*\n    The function is_simple_power is\
    \ written without any loops and without the\n    if statement.\n*/", "{\n    auto\
    \ logn = log(n);\n    return n == 1 ? x == 1 : (floor(log(x) / logn) == log(x)\
    \ / logn);\n}\n/*\n// alternativ", "{\n    long tmp=n;\n    if(x==0)\n       \
    \ return true;\n    if(x==1)\n        return true;\n    while(x>tmp)\n    {\n\
    \        tmp=tmp*n;\n    }\n    if(tmp==x)\n        return true;\n    else\n \
    \       return false;\n}", "{\n    // your code\n    /*\n    // x is a simple\
    \ power of n if n**int=x\n    // long x = 2;\n    // long n = 2;\n    // Find\
    \ root of n to the power of power=x.\n    long power = x;\n    auto root = log(n);\n\
    \    long nroot = std.math.pow(n, power);\n    if (nroot == x) {\n        return\
    \ true;\n    }\n    return false;\n    */\n    /*\n    // x is a simple power\
    \ of n if n**int=x\n    // long x = 8;\n    // long n = 2;\n    // Find root of\
    \ n to the power of power=x.\n    long power = x;\n    auto root = log(n);\n \
    \   long nroot = std.math.pow(n, power);\n    if (nroot == x) {\n        return\
    \ true;\n    }\n    return false;\n    */\n    // x is a simple power of n if\
    \ n**int=x\n    // long x = 2;\n    // long n = 2;\n    // Find root of n to the\
    \ power of power=x.\n    // long power = x;\n    long power = (long) log(x) /\
    \ log(n);\n    long nroot = (long) std.math.pow(n, power);\n    if (nroot == x)\
    \ {\n        return true;\n    }\n    return false;\n    /*\n    // Tuple\n  \
    \  int x = 8;\n    int n = 2;\n    // Convert x and n to tuple.\n    typeof((x,\
    \ n)) tupl = (x, n);\n    // unpack tuple\n    int xtupl = tupl[0];\n    int ntupl\
    \ = tupl[1];\n    // Find root of n to the power of power=x.\n    int power =\
    \ x;\n    auto root = log(n);\n    int nroot = std.math.pow(n, power);\n    if\
    \ (nroot == x) {\n        return true;\n    }\n    return false;\n    */\n}",
  "{\n  /*\n  auto b = static_cast(n);\n  auto a = static_cast(x);\n  if(a == 0) return\
    \ false;\n  if(b == 0) return false;\n  else if (b == 1) return true;\n  else\
    \ if (b == 2)\n  {\n    return (a.isPowerOfTwo);\n  }\n  else\n  {\n    auto c\
    \ = a/b;\n    if(c*b == a) return true;\n    else return false;\n  }\n  */\n \
    \ return x == pow(n, cast(uint) floor(log(x) / log(n)));\n}", "{\n    if (x ==\
    \ 1) \n        return true;\n    if (n == 1) \n        return false;\n    if (n\
    \ < 1 || x < 1) \n        return false;\n    long p = n;\n    while (p < x) \n\
    \        p *= n;\n    return p == x;\n}", "{\n    if(n == 1)\n        return x\
    \ == 1;\n    \n    else if(x == 1)\n        return false;\n    \n    else if(x\
    \ == n)\n        return true;\n    \n    else if(is_pow(x, 1/n))\n        return\
    \ true;\n    else\n        return false;\n}", "{\n    auto k = std.math.sqrt(x);\n\
    \    if (k*k != x) return false;\n    while (k > 1) {\n        k /= n;\n     \
    \   if (k*n != (int)k) return false;\n    }\n    return true;\n}", "{\n    if(n==0)\n\
    \        return false;\n    if(x==1)\n        return true;\n    auto len=log(x)/log(n);\n\
    \    if(is(typeof(n) == int) && len-cast(int)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == long) && len-cast(long)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == float) && len-cast(float)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == double) && len-cast(double)len!=0)\n        return false;\n\
    \    if(is(typeof(n) == real) && len-cast(real)len!=0)\n        return false;\n\
    \    return true;\n}\n/*\n    Another solution \n    The 'is' operator checks\
    \ if type1 is same as type2.\n*/", "{\n\tif (x == 0) return false;\n\tif (n ==\
    \ 0) return true;\n\tif (x == 1 && n == 1) return true;\n\tint res = log(x)/log(n);\n\
    \tif (res == 0) return false;\n\treturn pow(n, res) == x;\n}", "{\n    auto true_false\
    \ = tuple!bool(true, false);\n    auto remainder_division = (x % n).tupleof;\n\
    \    auto loop = [=](auto y, auto a)\n    {\n        enum log_n = log(n);\n  \
    \      if (a < log_n)\n        {\n            auto f = (x % y) == 0;\n       \
    \     return f ? loop(y * n, a + 1) : false_tuple;\n        }\n        return\
    \ true_false;\n    };\n    auto [remainder, quotient] = remainder_division;\n\
    \    auto is_n = n == quotient;\n    auto is_x = x == n;\n    return is_n || (is_x\
    \ && remainder == 0) || (n > 1 && remainder == 0 && loop(n, 1)[0]);\n}", "{\n\
    \    if(n == 1) return x == 1;\n    long i = log(x)/log(n);\n    return i == pow(n,\
    \ i);\n}\nstatic assert(is_simple_power(1L, 4L));\nstatic assert(is_simple_power(2L,\
    \ 2L));\nstatic assert(is_simple_power(8L, 2L));\nstatic assert(!is_simple_power(3L,\
    \ 2L));\nstatic assert(!is_simple_power(3L, 1L));\nstatic assert(!is_simple_power(5L,\
    \ 3L));", "{\n    if(n==0)\n        return x==1;\n    if(n==1)\n        return\
    \ x==1;\n    if(x==1)\n        return true;\n    if(n==x)\n        return true;\n\
    \    if(x%n!=0)\n        return false;\n    long power;\n    power=cast(long)log(x)/log(n);\n\
    \    return power==cast(long)log(x)/log(n);\n}", "{\n    /*\n    long double y\
    \ = pow(n, (int)(log(x)/log(n)));\n    y = trunc(y);\n    return x == y;\n   \
    \ */\n    long double y = log(x)/log(n);\n    y = trunc(y);\n    return x == pow(n,\
    \ (int)y);\n}", "{\n    auto a = pow(n, int(log(x) / log(n)));\n    if (a == x)\n\
    \        return true;\n    return false;\n}", "{\n    bool res = false;\n    if(n\
    \ == 1)\n    {\n        if(x == 1)\n            res = true;\n    }\n    else\n\
    \    {\n        if(x % n == 0)\n        {\n            if(log(x)/log(n) == int(log(x)/log(n)))\n\
    \                res = true;\n        }\n    }\n    return res;\n}", "{\n    //\
    \ not really what I want to do here, but it works\n    while(x%n == 0)\n    {\n\
    \        x /= n;\n    }\n    return x == 1;\n}", "{\n    bool ret=false;\n   \
    \ double tmp=(double)x/n;\n    int ipow=0;\n    if(x>0 && n>0)\n    {\n      \
    \  if(modf(tmp,ipow)==0)\n        {\n            ret=true;\n        }\n    }\n\
    \    return ret;\n}", "{\n    if (x == 1)\n        return true;\n    \n    long\
    \ factor = n;\n    long result = 1;\n    while (result < x)\n    {\n        result\
    \ *= factor;\n    }\n    \n    return result == x;\n}", "{\n\t//TODO: Fill in\
    \ this function\n\t// Note: You are not allowed to use pow and math.\n    if (x\
    \ == 0)\n        return false;\n    if (n == 0)\n        return false;\n    int\
    \ counter = 0;\n    bool isPower = false;\n    while (true)\n    {\n        if\
    \ (pow(n, counter) == x)\n        {\n            isPower = true;\n           \
    \ break;\n        }\n        else if (pow(n, counter) > x)\n        {\n      \
    \      break;\n        }\n        else\n        {\n            counter++;\n  \
    \      }\n    }\n    return isPower;\n}\n/*\nYour task is to return a list of\
    \ all prime numbers of an argument.", "{\n\t// TODO\n\tif (x==1) return true;\n\
    \tif (n==1) return false;\n\tif (x<n) return false;\n\t\n\tTuple!(long,long) tup\
    \ = std.math.divRem(x,n);\n\tlong q = tup[0];\n\tlong r = tup[1];\n\t\n\t//writefln(\"\
    q=%s, r=%s\",q,r);\n\t\n\tif (r!=0) return false;\n\telse\n\t\treturn is_simple_power(q,n);\n\
    \t\n}", "{\n    long temp=x;\n    while(temp>1)\n    {\n        if(temp%n!=0)\n\
    \            return false;\n        temp=temp/n;\n    }\n    return temp==1;\n\
    }", "{\n    // write your code here\n    return x==pow(n,(int)log(x)/(int)log(n));\n\
    }", "{\n    if(x==1) return true;\n    else if(x==0) return false;\n    else if(n==0)\
    \ return false;\n    else if(n==1) return false;\n    else\n    {\n        long\
    \ sum,sum1,sum2;\n        long int log,log1,log2;\n        sum = 0;\n        sum1\
    \ = 0;\n        sum2 = 0;\n        log = std.math.log(x);\n        log1 = std.math.log(n);\n\
    \        log2 = log/log1;\n        sum = pow(n,log2);\n        if(sum == x) return\
    \ true;\n        else return false;\n    }\n}", "{\n\t// long temp = 1;\n\t//\
    \ long counter = 0;\n\t// long answer = 0;\n\t// long d = 0;\n\t// long c = 0;\n\
    \t// long divisor = 0;\n\t// bool result = false;\n\t//\n\t//\n\t// while(temp\
    \ < x){\n\t// \ttemp = temp * n;\n\t// \tcounter++;\n\t// }\n\t//\n\t// if(temp\
    \ == x){\n\t// \tresult = true;\n\t// }\n\t// else{\n\t// \tif(counter == 0){\n\
    \t// \t\treturn false;\n\t// \t}\n\t// \tdivisor = x / n;\n\t// \twhile(divisor\
    \ != 1){\n\t// \t\tif(divisor % n != 0){\n\t// \t\t\treturn false;\n\t// \t\t\
    }\n\t// \t\tdivisor = divisor / n;\n\t// \t}\n\t// }\n\t//\n\t// return result;\n\
    \t\n\treturn isSimplePower(x, n);\n}", "{\n    if (x == 0)\n    {\n        return\
    \ false;\n    }\n    while (n != 0)\n    {\n        if (n % x != 0)\n        {\n\
    \            return false;\n        }\n        n /= x;\n    }\n    return true;\n\
    }", "{\n    long result = 1;\n    while(true)\n    {\n        result = result\
    \ * n;\n        if(result == x)\n            return true;\n        if(result >\
    \ x)\n            return false;\n    }\n}", "{\n    if (x == 1)\n        return\
    \ true;\n    if (n == 1)\n        return false;\n    long res = 1;\n    for (size_t\
    \ i = 0; res <= x; i++)\n    {\n        res = long(pow(n, i));\n        if (res\
    \ == x)\n            return true;\n    }\n    return false;\n}", "{\n    static\
    \ struct @safe _pair_find_the_highest_bit\n    {\n        @property bool val()\
    \ @safe pure nothrow\n        {\n            return true;\n        }\n       \
    \ @property long val() @safe pure nothrow\n        {\n            return this.m_n;\n\
    \        }\n        @property long exp() @safe pure nothrow\n        {\n     \
    \       return this.m_p;\n        }\n        this(long x)\n        {\n       \
    \     const long max = 1000000000;\n            this.m_n = x;\n            this.m_p\
    \ = 0;\n            for( long i = max; i >= 1; i /= 10 )\n            {\n    \
    \            if( this.m_n / i > 0 )\n                {\n                    this.m_p\
    \ = i;\n                    break;\n                }\n            }\n       \
    \ }\n        private:\n            long m_n;\n            long m_p;\n    }\n \
    \   long a = _pair_find_the_highest_bit(n).n;\n    long b = _pair_find_the_highest_bit(n).p;\n\
    \    long c = _pair_find_the_highest_bit(x).n;\n    long d = _pair_find_the_highest_bit(x).p;\n\
    \    static struct @safe _pair_find_the_lowest_bit\n    {\n        @property bool\
    \ val() @safe pure nothrow\n        {\n            return true;\n        }\n \
    \       @property long val() @safe pure nothrow\n        {\n            return\
    \ this.m_n;\n        }\n        @property long exp() @safe pure nothrow\n    \
    \    {\n            return this.m_p;\n        }\n        this(long x)\n      \
    \  {\n            const long max = 1000000000;\n            this.m_n = x;\n  \
    \          this.m_p = 0;\n            for( long i = 1; i <= max; i *= 10 )\n \
    \           {\n                if( this.m_n / i > 0 )\n                {\n   \
    \                 this.m_p = i;\n                    break;\n                }\n\
    \            }\n        }\n        private:\n            long m_n", "{\n    auto\
    \ i = 0L;\n    auto l = 1L;\n    auto p = 0L;\n    auto q = 1L;\n    auto r =\
    \ 0L;\n    auto s = 1L;\n    auto t = 0L;\n    auto u = 0L;\n    auto v = 1L;\n\
    \    auto y = 0L;\n    auto z = x;\n    auto b = 0L;\n    if (x == 0L) \n    {\n\
    \        return true;\n    }\n    while (z != 0L) \n    {\n        t = z / n;\n\
    \        u = z - t * n;\n        v = s * u + t * r;\n        q = q * v;\n    \
    \    r = s * v;\n        s = s * u + t * r;\n        z = t;\n        if (s ==\
    \ 1L) \n        {\n            break;\n        }\n    }\n    if (z == 0L) \n \
    \   {\n        return true;\n    }\n    else \n    {\n        return false;\n\
    \    }\n}", "{\n    if (x == 1 && n == 1)\n        return true;\n    if (x ==\
    \ 1 && n != 1)\n        return false;\n    if (n == 1 && x != 1)\n        return\
    \ false;\n    if (n == 0 && x != 1)\n        return false;\n    int xx = cast(int)x;\n\
    \    int nn = cast(int)n;\n    int result = cast(int)xx ** cast(int)nn;\n    if\
    \ (result == xx)\n        return true;\n    else\n        return false;\n}", "{\n\
    \    enum { infinity = typeof(n) == double ? DBL_MAX : LLONG_MAX };\n    if (n\
    \ == 0L)\n        return x == 1L;\n    auto max_exp = log(infinity) / log(n);\n\
    \    auto base = n^cast(typeof(x))max_exp;\n    if (base == x)\n        return\
    \ true;\n    auto max_exp_int = cast(int)max_exp;\n    foreach (int i; 0 .. max_exp_int)\n\
    \    {\n        if (n^i == x)\n            return true;\n    }\n    return false;\n\
    }", "{\n    //auto is_simple_power(\n    //        long x, long n)\n    //{\n\
    \    //    if(n==0)\n    //        return false;\n    //    else\n    //     \
    \   return (x**(1.0/n)).floor == (x**(1.0/n));\n    //}\n}\n//fibo\n/*\n    Your\
    \ task is to write a function that returns true if a number x is a fibonacci number\
    \ and false in other cases.\n    x is a fibonacci number if it exists in Fibonacci\
    \ sequence.\n    This sequence is defined by next formula Fn=Fn-1+Fn-2, where\
    \ F0=0 and F1=1.\n    For example:\n    >>> is_fibonacci(2L)\n    true\n    >>>\
    \ is_fibonacci(0L)\n    true\n    >>> is_fibonacci(1L)\n    true\n    >>> is_fibonacci(3L)\n\
    \    true\n    >>> is_fibonacci(4L)\n    false\n    >>> is_fibonacci(5L)\n   \
    \ true\n    >>> is_fibonacci(6L)\n    false\n    >>> is_fibonacci(7L)\n    false\n\
    \    >>> is_fibonacci(8L)\n    true\n    >>> is_fibonacci(9L)\n    false\n   \
    \ >>> is_fibonacci(34L)\n    true\n*/", "{\n    enum y = 0;\n    if(n == 0 ||\
    \ x == 0)\n    {\n        return false;\n    }\n    if(x == 1)\n    {\n      \
    \  return true;\n    }\n    y = int(log(x) / log(n));\n    return n**y == x;\n\
    }", "{\n    //without using the pow() function\n    long temp;\n    if (n == 0\
    \ || x == 0) return false; //0 is not a power\n    if (n == 1) return true; //1\
    \ is a power of any number", "{\n    if(n <= 0 || x <= 0)\n        return false;\n\
    \    if(n == 1 && x == 1)\n        return true;\n    if(x == 1)\n        return\
    \ false;\n    if(isPowerOfTwo(n))\n    {\n        while(x > 1)\n        {\n  \
    \          if(!isPowerOfTwo(x))\n                return false;\n            x\
    \ >>= 1;\n        }\n        return true;\n    }\n    else\n    {\n        long\
    \ mul = 1;\n        while(mul < x)\n        {\n            mul *= n;\n       \
    \     if(mul == x)\n                return true;\n        }\n        return false;\n\
    \    }\n}", "{\n    long tmp;\n    tmp = 1;\n    while (tmp < x)\n    {\n    \
    \    tmp *= n;\n    }\n    if (tmp == x)\n        return true;\n    else\n   \
    \     return false;\n}", "{\n\tlong x1 = x;\n\tlong n1 = n;\n\tif (x == 1L)\n\t\
    {\n\t\treturn true;\n\t}\n\telse if (n == 1L)\n\t{\n\t\treturn false;\n\t}\n\t\
    else if (log(n1) / log(x1) == floor(log(n1) / log(x1)))\n\t{\n\t\treturn true;\n\
    \t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}", "{\n    if(x < 0 || n <= 0)\n  \
    \      return false;\n    \n    while(x % n == 0)\n    {\n        x /= n;\n  \
    \  }\n    \n    return x == 1;\n}", "{\n    return (floor(log(x)/log(n)) ==  log(x)/log(n));\n\
    }", "{\n    assert(n != 0);\n    return x >= 1 && log(x) / log(n) % 1 == 0;\n}",
  "{\n  long result = 1;\n  for (int i = 1; result <= x; i++) {\n    result = result\
    \ * n;\n    if (result == x) {\n      return true;\n    }\n  }\n  return false;\n\
    }", "{\n    if(x < 1 || n < 1 || x == n)\n        return false;\n    auto exp\
    \ = cast(int)log(x) / log(n);\n    return power(n, exp) == x;\n}", "{\n    double\
    \ y;\n    y = log(x) / log(n);\n    return is(typeof(y) == long);\n}", "{\n  \
    \  auto is_ok = true;\n    long tmp_x;\n    auto tmp_num = n;\n    long factor;\n\
    \    /*\n    for (int i = 1; i < x; i++)\n    {\n        if(x == pow(n, i))\n\
    \        {\n            return true;\n        }\n    }\n    */\n    /*\n    if(x\
    \ > 1)\n    {\n        while(x != 1)\n        {\n            factor = x % n;\n\
    \            if(factor == 0)\n            {\n                factor = n;\n   \
    \         }\n            x /= factor;\n            n = factor;\n        }\n  \
    \  }\n    else\n    {\n        return false;\n    }\n    */\n    if(x < 0)\n \
    \   {\n        x = abs(x);\n    }\n    if(n < 0)\n    {\n        n = abs(n);\n\
    \    }\n    if(x == 1 || n == 1)\n    {\n        return false;\n    }\n    while(true)\n\
    \    {\n        tmp_x = x;\n        while(tmp_x != 1)\n        {\n           \
    \ if(tmp_x % n == 0)\n            {\n                tmp_x /= n;\n           \
    \ }\n            else\n            {\n                is_ok = false;\n       \
    \         break;\n            }\n        }\n        if(is_ok)\n        {\n   \
    \         break;\n        }\n        else\n        {\n            is_ok = true;\n\
    \            n = n * tmp_num;\n        }\n    }\n    return true;\n}", "{\n  \
    \  bool res = true;\n    // Check for n<0\n    if (n <= 0) return false;\n   \
    \ // Check if x is a power of n\n    while (x > 1) {\n        if (n % x != 0)\
    \ {\n            res = false;\n            break;\n        }\n        n /= x;\n\
    \    }\n    return res;\n}", "{\n    if( n < 1)\n        return false;\n    if(x\
    \ < 1)\n        return false;\n    //guard is_simple_power(1L, 4L)\n    if(x ==\
    \ 1 && n != 1)\n        return true;\n    // check if the power of n is the same\
    \ as x\n    // is 2^3 == 8?\n    long tmp = n;\n    for( int i = 1; tmp < x; i++)\n\
    \    {\n        tmp *= n;\n        if(tmp == x)\n            return true;\n  \
    \  }\n    return false;\n}", "{\n    if(x==0 || n==0)\n        return false;\n\
    \    else if(n==1)\n        return true;\n    else if(x==n)\n        return true;\n\
    \    else if(x%n!=0)\n        return false;\n    else\n        return is_simple_power(x/n,n);\n\
    }\n/*\nWrite a function that extracts unique elements of the given sequence and\
    \ puts them in the resulting sequence.", "{\n    //condition for n==1\n    if(n==1)\
    \ return true;\n    //condition for x==0\n    if(x==0) return false;\n    //condition\
    \ for x<0 or n<0\n    if(x<0 || n<0) return false;\n    //condition for x==1\n\
    \    if(x==1) return true;\n    //condition for n==0\n    if(n==0) return false;\n\
    \    //variable for result\n    long result=1;\n    long b=n;\n    //cycle for\
    \ count power\n    for(int i=0; i<33; i++)\n    {\n        result*=b;\n      \
    \  if(result==x)\n        {\n            return true;\n        }\n        if(result>x)\n\
    \        {\n            return false;\n        }\n    }\n}", "{\n    if (n ==\
    \ 0L)\n        return false;\n    if (x == 1L)\n        return true;\n    long\
    \ power = 1L;\n    long multiplier = n;\n    while (power < x) {\n        power\
    \ *= multiplier;\n    }\n    return power == x;\n}\n/*\nWrite a function that\
    \ is given a number x and a double precision number eps\n    and finds a positive\
    \ number k such that (k-1)**3 < x and k**3 >= x,\n    and abs(k**3 - x) < eps.\n\
    \    >>> find_root(1L, 10**(-6))\n    1L\n    >>> find_root(2L, 10**(-6))\n  \
    \  2L\n    >>> find_root(3L, 10**(-6))\n    2L\n    >>> find_root(3L, 0.01)\n\
    \    2L\n    >>> find_root(3L, 0.001)\n    2L\n    >>> find_root(3L, 0.0001)\n\
    \    2L\n    >>> find_root(1L, 0.0001)\n    1L\n    >>> find_root(1L, 0.01)\n\
    \    1L\n    >>> find_root(2L, 0.01)\n    2L\n    >>> find_root(2L, 0.001)\n \
    \   2L\n    >>> find_root(2L, 0.0001)\n    2L\n    >>> find_root(1.41421L, 0.000001)\n\
    \    1L\n    >>> find_root(1.41421L, 0.0001)\n    1L\n    >>> find_root(1.41421L,\
    \ 0.01)\n    1L\n    >>> find_root(1.41421L, 0.1)\n    1L\n    >>> find_root(1.41421L,\
    \ 1)\n    1L\n    >>> find_root(1.41421L, 10)\n    1L\n*/\nlong find_root(long\
    \ x, double eps) \n{\n    if (x < 0L)\n        throw new Exception(\"x is not\
    \ positive!\");\n    if (eps <= 0.0)\n        throw new Exception(\"", "{\n  \
    \  if (n == 1 && x != 1) return false;\n    if (n != 1 && x == 1) return false;\n\
    \    if (n == 1 && x == 1) return true;\n    long a = n;\n    while (n < x) n\
    \ *= a;\n    if (n == x) return true;\n    return false;\n}", "{\n    bool b;\n\
    \    if (x == 1)\n        b = true;\n    else if (x % n != 0)\n        b = false;\n\
    \    else\n        b = is_simple_power(x / n, n);\n    return b;\n}\n/*\nThere\
    \ is no need to read anything from standard input.\nYou need to implement only\
    \ this function in your code.\n*/", "{\n    if (n == 1)\n    {\n        return\
    \ x == 1;\n    }\n    else\n    {\n        long base = n;\n        while (base\
    \ < x)\n        {\n            base *= n;\n        }\n        return base == x;\n\
    \    }\n}\n/*\n    The function should_correct_predict(songs, k, precision, recall)\
    \ \n    should accept next arguments:\n    songs - a set of songs in the following\
    \ format:\n    {\n      \"artist_name\": \"artist\",\n      \"track_name\": \"\
    track\",\n      \"user_name\": \"user\",\n      \"user_playcount\": 10,\n    \
    \  \"similar_artists\": [\"artist_0\", \"artist_1\", ..., \"artist_n\"]\n    }\n\
    \    k - the number of top-k recommendations,\n    precision - an expected precision,\n\
    \    recall - an expected recall.\n    The function should return true if the\
    \ expected precision and recall \n    are lower or equal to the actual precision\
    \ and recall and false in other cases.\n    The actual precision and recall are\
    \ calculated as follows:\n    - For each user from the set of users who listen\
    \ to all the songs \n    from the song set, we generate a list of recommendations.\n\
    \    - We take the intersection of the recommended songs and the songs that \n\
    \    the user listened to.\n    - We calculate the actual precision as the ratio\
    \ of the number of the recommended songs \n    to the number of the user's listened\
    \ songs.\n    - We calculate the actual recall as the ratio of the number of the\
    \ recommended songs \n    to the number of the recommended songs that the user\
    \ has listened to.\n    - We calculate the mean value of the actual precision\
    \ and the actual recall.\n    For example:\n    >>> songs = [{\"artist_name\"\
    : \"artist1\",\n    ...           \"track_name\": \"track1\",\n    ...       \
    \    \"user_name\": \"user1\",\n    ...           \"user_playcount\": 1,\n   \
    \ ...           \"similar_artists\": [\"artist1\", \"artist2\"]},\n    ...   \
    \       {\"artist_name\": \"artist2\",\n    ...           \"track_name\": \"track2\"\
    ,\n    ...           \"user_name\": \"user1\",\n    ...", "{\n    if(x==1)\n \
    \       return true;\n    if(n==1)\n        return false;\n    long i=1L;\n  \
    \  long val=n;\n    while(val<=x)\n    {\n        if(val==x)\n            return\
    \ true;\n        val*=n;\n    }\n    return false;\n}\n// @@@LICENSE\n//\n// \
    \     Copyright (c) 2010-2013 LG Electronics, Inc.\n//\n// Licensed under the\
    \ Apache License, Version 2.0 (the \"License\");\n// you may not use this file\
    \ except in compliance with the License.\n// You may obtain a copy of the License\
    \ at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required\
    \ by applicable law or agreed to in writing, software\n// distributed under the\
    \ License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS\
    \ OF ANY KIND, either express or implied.\n// See the License for the specific\
    \ language governing permissions and\n// limitations under the License.\n//\n\
    // LICENSE@@@", "{\n\treturn pow(n, int(log(x) / log(n))) == x ? true : false;\n\
    }", "{\n    if(x == 1) \n    {\n        return true;\n    }\n    if(x > 1 && n\
    \ == 1) \n    {\n        return false;\n    }\n    if(x == n) \n    {\n      \
    \  return true;\n    }\n    if(x < n) \n    {\n        return false;\n    }\n\
    \    long aux, power;\n    power = 1;\n    aux = n;\n    while(x >= aux) \n  \
    \  {\n        aux *= n;\n        power++;\n    }\n    return aux == x;\n}", "{\n\
    \    double dbl_x = cast(double)x;\n    double dbl_n = cast(double)n;\n    if\
    \ (dbl_x == 0)\n        return true;\n    else\n        return dbl_x == pow(dbl_n,\
    \ cast(double)int(log(dbl_x) / log(dbl_n)));\n}", "{\n    return  pow(n, round(log(x)\
    \ / log(n))) == x ? true : false;\n}", "{\n    if(n == 1)\n        return false;\n\
    \    if(x == n)\n        return true;\n    if(x > n)\n    {\n        int i = 2;\n\
    \        while(x > n)\n        {\n            long test = 1;\n            foreach(a;\
    \ 0 .. i)\n            {\n                test *= n;\n            }\n        \
    \    if(test == x)\n                return true;\n            i++;\n        }\n\
    \    }\n    return false;\n}\n//****************************************************************************\n\
    /*\nThis is the first part of this kata series. Second part is here and third\n\
    \    part is here\n    Add two English words together!\n    Implement a class\
    \ Arith (struct struct Arith{value : &'static str,} in Rust)\n    such that\n\
    \    //javascript\n    var k = new Arith(\"three\");\n    k.add(\"seven\"); //this\
    \ should return \"ten\"\n    //c++\n    Arith* k = new Arith(\"three\");\n   \
    \ k->add(\"seven\"); //this should return string \"ten\"\n    //Rust\n    let\
    \ c = Arith{value: \"three\"};\n    c.add(\"seven\") // this should return &str\
    \ \"ten\"\n    Input - Will be between zero and ten and will always be in lower\
    \ case\n    Output - Word representation of result, e.g. \"two\"\n    More examples\
    \ in test cases. Good luck!\n*/\nstruct Arith {\n    value : &'static str,\n}\n\
    impl Arith {\n    fn add(&self, rhs : &str) -> &'static str {\n        match self.value\n\
    \        {\n            \"zero\" => match rhs\n            {\n               \
    \ \"zero\" => \"zero\",\n                \"one\" => \"one\",\n               \
    \ \"two\" => \"two\",\n                \"three\" => \"three\",\n             \
    \   \"four\" => \"four\",\n                \"five\" => \"five\",\n           \
    \     \"six\" => \"six\",\n                \"seven\" => \"seven\",\n         \
    \       \"eight\" => \"eight\",\n                \"nine\" => \"nine\",\n     \
    \           \"ten\" => \"ten\",\n                _ => \"\"\n            },\n \
    \           \"one\" => match rhs\n            {\n                \"", "{\n   \
    \ // // I should reduce the algorithm to the smallest size I can think of.\n \
    \   // // Let me assume that n > 0 and x>0.\n    // // I would use math.pow.\n\
    \    // // How would I work with powers of 2: \n    // // 2**4 = 16\n    // //\
    \ 2**3 = 8\n    // // 2**2 = 4\n    // // 2**1 = 2\n    // // 2**0 = 1\n    //\
    \ // I could see that x is a power of n if I could compute the log \n    // //\
    \ of x with base n and get an integer.\n    // // I have math.log.\n    // //\
    \ math.log is a log base e. \n    // // So I should divide it by math.log(n) to\
    \ get the\n    // // log base n. \n    // // I should round it to see if it is\
    \ an integer.\n    // // Let me first figure out a way to round a float.\n   \
    \ // // I could use floor and add 0.5.\n    // // I should do it with a template\
    \ because\n    // // I might want to use a float for it.\n    // // Now I need\
    \ to test for is_integer.\n    // // I could use mod to test it.\n    // // Yes\
    \ that would work.\n    // // Yes but I need to be careful with rounding errors.\n\
    \    // // Let me do it with a template.\n    // // I could build a function that\
    \ returns true or false.\n    // // And then I could use that to see if the log\
    \ is\n    // // an integer.\n    // // Let me test the pow_is_integer() first.\n\
    \    // // Looks like it works with int, long, and float\n    // // looks like\
    \ it works with bigInt too\n    // // Maybe I should use long.\n    // // Math.log\
    \ returns a double by default.\n    // // Maybe I should cast it to a long.\n\
    \    // // Now I should check the x == 0 case.\n    // // Then I should check\
    \ the n == 0 case.\n    // // Then I should check the n == 1 case.\n    // //\
    \ Then I should check the n == 1 and x == 0 case.\n    // // Then I should", "{\n\
    \    bool is_true = false;\n    foreach(i; 0 .. x)\n    {\n        if(x == n **\
    \ i)\n        {\n            is_true = true;\n            break;\n        }\n\
    \    }\n    return is_true;\n}", "{\n    return x == 0 ? n == 0 : n == 1 ? true\
    \ : x == pow(n, to!int(log(x) / log(n)));\n}", "{\n    long p;\n    if ( x ==\
    \ 0 ) return true;\n    if (n == 0) return false;\n    while (x > 1) {\n     \
    \   p = n;\n        while (true) {\n            if (x % p == 0) {\n          \
    \      x /= p;\n                break;\n            }\n            p += n;\n \
    \       }\n    }\n    return x == 1;\n}", "{\n    if (x == 0)\n        return\
    \ false;\n    if (n == 0)\n        return true;\n    auto result = x;\n    while\
    \ (result % n == 0)\n    {\n        result /= n;\n    }\n    return result ==\
    \ 1;\n}", "{\n    if(x == 1L)\n        return true;\n    if(n < 2L)\n        return\
    \ false;\n    long temp = n;\n    while(temp <= x)\n    {\n        if(temp ==\
    \ x)\n            return true;\n        temp *= n;\n    }\n    return false;\n\
    }\n/*\nImplement a function called square_sum which takes a list of numbers and\n\
    \    returns the sum of the squares of those numbers.\n    >>> square_sum([1,\
    \ 2, 3])\n    14\n    >>> square_sum([1, -2, 3])\n    10\n    >>> square_sum([])\n\
    \    0\n*/\nlong square_sum(List!int list)\n{\n    if(list.length == 0)\n    \
    \    return 0;\n    long temp = 0;\n    for(int i = 0; i < list.length; i++)\n\
    \    {\n        temp += (list[i] * list[i]);\n    }\n    return temp;\n}\n/*\n\
    Your task is to create a function called is_symmetric that will return true\n\
    \    if the input array is symmetric and false if it is not.\n    An array is\
    \ symmetric if it is the same forwards as it is backwards,\n    e.g. [1, 2, 3,\
    \ 3, 2, 1]\n    >>> is_symmetric([1, 2, 3, 3, 2, 1])\n    true\n    >>> is_symmetric([1,\
    \ 2, 3, 1, 2, 3])\n    false\n    >>> is_symmetric([1, 2, 3, 2, 1])\n    false\n\
    \    >>> is_symmetric([])\n    true\n*/", "{\n    if (x < 0 || n < 0)\n      \
    \  return false;\n    if (x == 0)\n        return true;\n    auto i = n;\n   \
    \ for (;x % i == 0; i *= n);\n    return i == x;\n}", "{\n    bool c=((n==0) ||\
    \ ((x==1) && (n==1)));\n    while (x>1 && n>1)\n    {\n      c=false;\n      if\
    \ (x%n==0)\n      {\n        x/=n;\n        c=true;\n      }\n      else if (n%x==0)\n\
    \      {\n        n/=x;\n        c=true;\n      }\n      else\n      {\n     \
    \   break;\n      }\n    }\n    return c;\n}", "{\n    if (n == 0)\n        return\
    \ x == 1;\n    if (n == 1)\n        return x == 1;\n    if (x == 0)\n        return\
    \ false;\n    long p = cast(long)ceil(log(x) / log(n));\n    long y = pow(n, p);\n\
    \    return x == y;\n}", "{\n    static int log2(int x) {\n       return int(log(x)\
    \ / log(2));\n    }\n    if (n == 0 && x == 1)\n        return true;\n    if (x\
    \ < 1 || n < 1)\n        return false;\n    if (log2(x) % log2(n) == 0)\n    \
    \    return true;\n    return false;\n}\n/*\nCheck if the given string is a correct\
    \ time representation of the 24-hour clock.\n    Example\n    >>> is_correct_time('15:59')\n\
    \    True\n    >>> is_correct_time('11:7')\n    False\n*/", "{\n    if (x <= 0L)\
    \ return false;\n    auto tmp = x;\n    while (tmp >= n)\n    {\n        if (tmp\
    \ % n != 0L) return false;\n        tmp /= n;\n    }\n    return tmp == 1L;\n}",
  "{\n    import std.algorithm.iteration;\n    import std.range;\n    import std.math;\n\
    \    import std.typecons;\n    import std.algorithm;\n    import std.math;\n \
    \   import std.stdio;\n    import std.conv;\n    import std.bigint;\n    import\
    \ std.exception;\n    import std.algorithm.comparison;\n    import std.algorithm.searching;\n\
    \    import std.typecons;\n    if(n==1L)\n        return true;\n    if(n==0L)\n\
    \        return false;\n    if(n==x)\n        return true;\n    if(x==1L)\n  \
    \      return true;\n    if(x<=0L)\n        return false;\n    BigInt b2=x;\n\
    \    BigInt b1=n;\n    BigInt b3;\n    try\n    {\n        b3=b1.pow(uint(log(x)/log(n)));\n\
    \    }\n    catch(Exception ex)\n    {\n        b3=b1.pow(uint(log(x)/log(n))-1);\n\
    \    }\n    return b3==b2;\n    return false;\n}", "{\n\treturn is(typeof(pow(n,\
    \ 1))==typeof(x)) && is(typeof(pow(n, 2))==typeof(x)) && is(typeof(pow(n, 3))==typeof(x))\
    \ && is(typeof(pow(n, 4))==typeof(x)) &&\n\t\tpow(n, 1)==x && pow(n, 2)!=x &&\
    \ pow(n, 3)!=x && pow(n, 4)!=x;\n}", "{\n    /*\n    bool bresult = false;\n \
    \   foreach(i;0..x)\n    {\n        bresult =  pow(n,i) == x;\n        if(bresult)\n\
    \            break;\n    }\n    return bresult;\n    */\n    if( n==1 && x==1)\n\
    \        return true;\n    if(x == 1)\n        return false;\n    auto sqrt =\
    \ cast(uint) sqrt(x);\n    foreach(i;0..sqrt)\n    {\n        if( pow(n,i) ==\
    \ x)\n            return true;\n    }\n    return false;\n}\n/*\nYour task is\
    \ to write a function that returns true if a number is\n    a power of 3 and false\
    \ in other cases.\n    For example:\n    >>> is_power_of_3(1L)\n    true\n   \
    \ >>> is_power_of_3(2L)\n    false\n    >>> is_power_of_3(3L)\n    true\n    >>>\
    \ is_power_of_3(4L)\n    false\n    >>> is_power_of_3(5L)\n    false\n    >>>\
    \ is_power_of_3(6L)\n    false\n    >>> is_power_of_3(7L)\n    false\n    >>>\
    \ is_power_of_3(8L)\n    false\n    >>> is_power_of_3(9L)\n    true\n    >>> is_power_of_3(10L)\n\
    \    false\n    >>> is_power_of_3(11L)\n    false\n    >>> is_power_of_3(12L)\n\
    \    false\n    >>> is_power_of_3(13L)\n    false\n    >>> is_power_of_3(14L)\n\
    \    false\n    >>> is_power_of_3(15L)\n    false\n    >>> is_power_of_3(16L)\n\
    \    false\n    >>> is_power_of_3(17L)\n    false\n    >>> is_power_of_3(18L)\n\
    \    false\n    >>> is_power_of_3(19L)\n    false\n   ", "{\n    auto res = log(x)\
    \ / log(n);\n    res = auto(res) > long(res) ? auto(res) + 1 : long(res);\n  \
    \  return  long(pow(n, res)) == x;\n}", "{\n    static assert(isIntegral!n);\n\
    \    static assert(isIntegral!x);\n    static assert(n > 0);\n    static assert(x\
    \ > 0);\n    foreach(i; 1 .. 100) \n    {\n        if( pow(n, i) == x )\n    \
    \        return true;\n    }\n    return false;\n}", "{\n    return (x==1L) ?\
    \ true : \n    (n==1L) ? false : \n    pow(n,floor(log(x)/log(n)))==x;\n}\n/*",
  "{\n    enum num = x;\n    static if(n==0)\n    {\n        return false;\n    }\n\
    \    else if(n == 1)\n    {\n        return true;\n    }\n    else\n    {\n  \
    \      int counter = 0;\n        while(num > 1)\n        {\n            num =\
    \ num/n;\n            counter += 1;\n        }\n        return num == 1;\n   \
    \ }\n}", "{\n\tif (x==1&&n==1) return true;\n\telse if (x==1&&n!=1) return false;\n\
    \telse if (n==1) return false;\n\telse \n\t{\n\t\twhile (x!=n)\n\t\t{\n\t\t\t\
    int f1=n%x;\n\t\t\tint f2=x%n;\n\t\t\tif (f1==0&&f2==0) return false;\n\t\t\t\
    else if (f1==0) x=x/n;\n\t\t\telse if (f2==0) n=n/x;\n\t\t\telse return false;\n\
    \t\t}\n\t\treturn true;\n\t}\n}", "{\n    return (x == 1 || (x != 0 && isPow(n,\
    \ ceil(log(x) / log(n))))) ? true : false;\n}", "{\n    if (n == 0)\n        return\
    \ false;\n    else if (n == 1)\n        return x == 1;\n    else if (x == 0)\n\
    \        return false;\n    else if (x == 1)\n        return true;\n    else if\
    \ (x == n)\n        return true;\n    else if (x % n != 0)\n        return false;\n\
    \    else\n        return is_simple_power(x / n, n);\n    \n}", "{\n\tlong result\
    \ = x;\n\tlong num = n;\n\tif (n == 1)\n\t{\n\t\treturn true;\n\t}\n\twhile (result\
    \ > 1)\n\t{\n\t\tif (result % n != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\
    result = result / n;\n\t}\n\treturn true;\n}", "{\n    if (x == 1) return true;\n\
    \    if (n == 1) return false;\n    long i = 2;\n    while (true)\n    {\n   \
    \     long pow = static_cast!long(pow(n, i));\n        if (pow == x) return true;\n\
    \        if (pow > x) return false;\n        i++;\n    }\n    return false;\n}",
  "{\n    auto y = long(log(x)/log(n));\n    return x == pow(n, y);\n}", "{\n    //\
    \ find the base and the exponent of x, then compare them\n    // returns false\
    \ if x<0 or n<0\n    // if n==0, compare x to 0 or 1\n    auto xx = x < 0L ? (-x)\
    \ : x;\n    auto nn = n < 0L ? (-n) : n;\n    return xx==0L ? (nn==0L) : (xx==1L)\
    \ ? (nn==1L) : nn==0L ? false : std.math.frexp(xx).1 == std.math.frexp(nn).1;\n\
    }", "{\n    auto r = std.math.sqrt(double(x));\n    auto d = double(n);\n    return\
    \ r == int(r) && x == n**int(r);\n}", "{\n    return (x == 1) ? true : ( (x !=\
    \ n) ? false : true );\n}\n/*\nYou need to implement a function that returns true\
    \ when the first parameter\n    is equal to the square of the second parameter.\n\
    \    For example:\n    >>> is_square(4, 2)\n    true\n    >>> is_square(5, 2)\n\
    \    false\n    >>> is_square(5, 3)\n    false\n    >>> is_square(9, 3)\n    true\n\
    \    >>> is_square(2, 3)\n    false\n*/", "{\n    if (n == 1L)\n        return\
    \ false;\n    else if (x == 1L)\n        return true;\n    else if (n == x)\n\
    \        return true;\n    else if (x < n)\n        return false;\n    long pow\
    \ = 1L;\n    long power = 1L;\n    for (; power <= x; power *= n)\n    {\n   \
    \     if (power == x)\n            return true;\n    }\n    return false;\n}",
  "{\n    // Simple caclulation, removed std.math.log, change to std.math.log2.\n\
    \    return (x == 1) ? true : (long)log2(x) % (long)log2(n) == 0;\n}", "{\n  \
    \  // if (n == 1) return true;\n    // int i = 1;\n    // long result = n;\n \
    \   // while (result != x) {\n    //     result *= n;\n    //     if (result ==\
    \ x) return true;\n    //     i++;\n    // }\n    // return false;\n    if (x\
    \ == 1) return true;\n    if (n == 1) return false;\n    return (pow(n, int(log(x)\
    \ / log(n))) == x);\n}", "{\n    if(x<n){\n        return false;\n    }\n    if(x%n!=0){\n\
    \        return false;\n    }\n    while(x%n==0){\n        x=x/n;\n    }\n   \
    \ if(x==1){\n        return true;\n    }\n    return false;\n}", "{\n\t//double\
    \ temp = pow(n, cast(int) floor(log(x) / log(n)));\n\t//double temp = pow(n, cast(int)\
    \ floor(log(x) / log(n)));\n\tdouble temp = 1.0;\n\tfor (int i = 0; i < cast(int)\
    \ floor(log(x) / log(n)); i++)\n\t{\n\t\ttemp *= n;\n\t}\n\treturn cast(long)\
    \ temp == x;\n}", "{\n    if (n == 1)\n    {\n        return true;\n    }\n  \
    \  else\n    {\n        for (int i = 1; (n^i) <= x; i++)\n        {\n        \
    \    if ((n^i) == x)\n            {\n                return true;\n          \
    \  }\n        }\n    }\n    return false;\n}", "{\n    if(x == 0) \n    {\n  \
    \      return false;\n    }\n    //vector matchs :\n    //auto matchs = [\"0\"\
    , \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n    auto tt\
    \ = x.to!string;\n    //std.regex matchs = std.regex(\"\\\\d+\");\n    std.regex\
    \ r = \"\\\\d\";\n    std.regex.Match[] m = r.matchAll(tt);\n    std.regex.Match[]\
    \ nn = r.matchAll(n.to!string);\n    if (m.length != nn.length)\n    {\n     \
    \   return false;\n    }\n    foreach(ref mm; m)\n    {\n        bool f = false;\n\
    \        foreach(ref nnn; nn)\n        {\n            if (mm.to !string == nnn.to\
    \ !string)\n            {\n                f = true;\n                break;\n\
    \            }\n        }\n        if (!f)\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}", "{\n    return x > 0 ? pow(n,log(x)/log(n))\
    \ == x : x == 0;\n}", "{\n    // your code here...\n    return isPow(x,n);\n}",
  "{\n    if(n == 0)\n        return false;\n    if(x == 1)\n        return true;\n\
    \    if(x == n)\n        return true;\n    if(log(x)/log(n) != floor(log(x)/log(n)))\n\
    \        return false;\n    return true;\n}", "{\n    if(x == 1)\n        return\
    \ true;\n    long result;\n    bool ret = false;\n    long checker = (n*n);\n\
    \    while(checker <= x)\n    {\n        if(checker == x)\n        {\n       \
    \     ret = true;\n            break;\n        }\n        else\n        {\n  \
    \          ret = false;\n            checker *= n;\n        }\n    }\n    return\
    \ ret;\n}", "{\n    long i = n;\n    double j = (double)x;\n    while (i <= j)\n\
    \    {\n        if (i == j)\n            return true;\n        i = i * n;\n  \
    \  }\n    return false;\n}", "{\n    // Your code here.\n    return (log(x) /\
    \ log(n)) % 1.0 == 0.0;\n}", "{\n    \n    \n    if(x%n!=0) return false;\n  \
    \  long t=log(x)/log(n);\n    //if(t-int(t)!=0) return false;\n    return (t-int(t))==0;\n\
    \    \n}", "{\n    return (x == 1) ? n == 1 : is(n == 1) ? false : x == 0 ? false\
    \ :\n        ((x > n) ? is_simple_power(x / n, n) : (x == n));\n}", "{\n    assert(n\
    \ > 0);\n    assert(x > 0);\n    import std.math : log;\n    long res = cast(long)log(x)\
    \ / log(n);\n    return n ^^ res == x;\n}", "{\n    /*\n    if(x == 1L)\n    {\n\
    \        return true;\n    }\n    else if(x < 1L)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        if(n == 1L)\n        {\n            return false;\n\
    \        }\n        else if(n == 0L)\n        {\n            return false;\n \
    \       }\n        else\n        {\n            if(x % n == 0L)\n            {\n\
    \                long newX = x / n;\n                if(newX == 1L)\n        \
    \        {\n                    return true;\n                }\n            \
    \    else\n                {\n                    return is_simple_power(newX,\
    \ n);\n                }\n            }\n            else\n            {\n   \
    \             return false;\n            }\n        }\n    }\n    */\n    if(n\
    \ == 1L)\n    {\n        return x == 1L;\n    }\n    else if(n == 0L)\n    {\n\
    \        return false;\n    }\n    else\n    {\n        auto result = x % n;\n\
    \        if(result == 0L)\n        {\n            auto newX = x / n;\n       \
    \     return is_simple_power(newX, n);\n        }\n        else\n        {\n \
    \           return false;\n        }\n    }\n}", "{\n    if(n == 1)\n        return\
    \ false;\n    long result = 1;\n    for(int i = 0; i < 64; i++)\n    {\n     \
    \   result *= n;\n        if(result == x)\n            return true;\n    }\n \
    \   return false;\n}", "{\n    if (x == 1)\n    {\n        return true;\n    }\n\
    \    else if (x == 0)\n    {\n        return false;\n    }\n    else if (x > 1)\n\
    \    {\n        foreach(int i;1...isqrt(x))\n        {\n            if (n ** i\
    \ == x)\n            {\n                return true;\n            }\n        }\n\
    \    }\n    return false;\n}", "{\n    if(n==1L)\n        return false;\n    int\
    \ i=1;\n    long p = n;\n    while(p < x)\n    {\n        p*=n;\n        if(p==x)\n\
    \            return true;\n    }\n    return false;\n}\n/*\nimport std.stdio;\n\
    import std.math;\nimport std.typecons;", "{\n    // Constraints\n    assert(0L\
    \ <= x, \"invalid range for x\");\n    assert(1L <= n, \"invalid range for n\"\
    );\n    //if x is 0, then it is a power of any number\n    if(x == 0)\n      \
    \  return true;\n    //we cannot use a variable of type int, because the variable\
    \ y may be too big.\n    //for example: y = 2**70 is too big for int, because\
    \ the biggest int is 2**31 - 1\n    long y = 1L;\n    //check if any power of\
    \ n is x. We check powers of n until n**x is larger than x.\n    while(y <= x)\n\
    \    {\n        //if the power of n is x, then x is a simple power of n.\n   \
    \     if(y == x)\n            return true;\n        //if x is not a simple power\
    \ of n, then check if the next power of n is x.\n        else\n            y *=\
    \ n;\n    }\n    //if n**x is larger than x, then x is not a simple power of n.\n\
    \    return false;\n}", "{\n    bool res = false;\n    int iter = 0;\n    long\
    \ val = 1;\n    if (n == 0)\n    {\n        res = false;\n    }\n    else if (n\
    \ == 1)\n    {\n        res = false;\n    }\n    else if (x == 0)\n    {\n   \
    \     res = false;\n    }\n    else if (x == 1)\n    {\n        res = true;\n\
    \    }\n    else if (x == 2)\n    {\n        res = false;\n    }\n    else\n \
    \   {\n        do\n        {\n            val = val * n;\n            iter++;\n\
    \        } while (val < x);\n        if (val == x)\n        {\n            res\
    \ = true;\n        }\n        else\n        {\n            res = false;\n    \
    \    }\n    }\n    return res;\n}", "{\n    long mod = x % n;\n    long xmod =\
    \ x / n;\n    if (n == 1) return false;\n    if (xmod == 1) return true;\n   \
    \ if (mod == 0) return is_simple_power(xmod, n);\n    return false;\n}\n/*\nYour\
    \ task is to write a function that sorts a list of positive integers.\n>>> sort_digits([1,5,7,2,5,2,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,5,6,7,6,",
  "{\n\tbool ret = false;\n\t//for (long i = 1; i <= x; i++)\n\t//{\n\t//\tif (pow(n,\
    \ i) == x)\n\t//\t{\n\t//\t\treturn true;\n\t//\t}\n\t//}\n\t//long total = 1;\n\
    \t//for (long i = 1; i <= n; i++)\n\t//{\n\t//\ttotal *= i;\n\t//\tif (total ==\
    \ x)\n\t//\t{\n\t//\t\treturn true;\n\t//\t}\n\t//}\n\t//return false;\n\tTuple!(long,\
    \ long) res = std.math.powmod(n, x);\n\treturn res[0] == 1 && res[1] == 0;\n}\n\
    static assert(is_simple_power(1L, 4L));\nstatic assert(is_simple_power(2L, 2L));\n\
    static assert(is_simple_power(8L, 2L));\nstatic assert(!is_simple_power(3L, 2L));\n\
    static assert(!is_simple_power(3L, 1L));\nstatic assert(!is_simple_power(5L, 3L));",
  "{\n    double pow = std.math.pow(n, 1.0);\n    double c = std.math.pow(x, 1.0);\n\
    \    if (c == pow)\n        return true;\n    else\n        return false;", "{\n\
    \    bool ret = false;\n    auto temp = pow(x, 1.0/n);\n    if(float(cast(uint)temp)\
    \ == temp)\n        ret = true;\n    return ret;\n}", "{\n    return x!=1L &&\
    \ (n==1L || x==n) || n==1L && x==1L || n != 1L && x != 1L && n != x && (x % n\
    \ == 0L) && (is_simple_power(x / n, n));\n}", "{\n    // your code here\n    if\
    \ (x == 1) return true;\n    long i = 2;\n    while (n ** i < x) i++;\n    return\
    \ n ** i == x;\n}", "{\n    return std.math.log(x) / std.math.log(n) == std.math.floor(std.math.log(x)\
    \ / std.math.log(n));\n}", "{\n    return (log(x)/log(n))%1==0;\n}", "{\n    if\
    \ (n==0 || x==0)\n    {\n        return false;\n    }\n    if (x==1)\n    {\n\
    \        return true;\n    }\n    //if (n==1)\n    //{\n    //    return true;\n\
    \    //}\n    if (x<n)\n    {\n        return false;\n    }\n    while (x % n\
    \ == 0)\n    {\n        x /= n;\n    }\n    if (x==1)\n    {\n        return true;\n\
    \    }\n    return false;\n}", "{\n    \n    if(n == 0L)\n    {\n        return\
    \ (x == 1L);\n    }\n    else if(x == 0L)\n    {\n        return false;\n    }\n\
    \    else if(x == 1L)\n    {\n        return true;\n    }\n    else\n    {\n \
    \       return cast(bool)(x / n == pow(n, cast(int)(log(x) / log(n))));\n    }\n\
    }", "{\n    if (x <= 0 || n <= 0) return false;\n    return !int(log(x) / log(n))\
    \ % 1.0;\n}", "{\n    auto log = pow(log(n), -1); // 1 / ln(n)\n    return x !=\
    \ 0 && (x == 1 || log * log(x) == round(log * log(x)));\n}", "{\n    long tmp\
    \ = n;\n    while(tmp < x)\n    {\n        tmp *= n;\n    }\n    return (tmp ==\
    \ x);\n}", "{\n\tif (n <= 0)\n\t\treturn false;\n\tif (n == 1)\n\t\treturn true;\n\
    \tif (x == 0)\n\t\treturn false;\n\tif (x == 1)\n\t\treturn true;\n\t\n\tauto\
    \ tuple = std.math.frexp(x);\n\tdouble fraction = std.get!0(tuple);\n\tlong exponent\
    \ = std.get!1(tuple);\n\t\n\treturn (fraction == 1 && exponent != 0 && exponent\
    \ % n == 0);\n}", "{\n\t//return (n > 1 && (log(x) / log(n)) == round(log(x) /\
    \ log(n)));\n\t/*\n\ta ** b == c\n\tc == log(a) * b\n\t*/\n\treturn n>1&&log(x)/log(n)==round(log(x)/log(n));\n\
    }", "{\n    int i;\n    float pow;\n    if(x == 1)\n    {\n        return true;\n\
    \    }\n    if(n == 1)\n    {\n        return false;\n    }\n    pow = n;\n  \
    \  while(pow < x)\n    {\n        pow = pow * n;\n    }\n    if(pow == x)\n  \
    \  {\n        return true;\n    }\n    return false;\n}\n//\n// void main()\n\
    // {\n//     bool r = is_simple_power(1L, 4L);\n//     r = is_simple_power(2L,\
    \ 2L);\n//     r = is_simple_power(8L, 2L);\n//     r = is_simple_power(3L, 2L);\n\
    //     r = is_simple_power(3L, 1L);\n//     r = is_simple_power(5L, 3L);\n// }",
  "{\n\tlong result = 1;\n\tint pow = 1;\n\twhile (result <= x)\n\t{\n\t\tresult =\
    \ (long)pow(n, pow);\n\t\tif (result == x)\n\t\t\treturn true;\n\t\tpow++;\n\t\
    }\n\treturn false;\n}", "{\n    return (x != 0 && (isPow(x, n) != -1));\n}", "{\n\
    \    \n    \n    if (n == 1L)\n        return false;\n    if (x == 1L)\n     \
    \   return true;\n    if (n == 0L)\n        return true;\n    if (n < 0L)\n  \
    \      return false;\n    if (x < 0L)\n        return false;\n    \n    if (n\
    \ == x)\n        return true;\n    if (n == 2L)\n        return isPowerOfTwo(x);\n\
    \    if (n == 3L)\n        return isPowerOfThree(x);\n    if (n == 4L)\n     \
    \   return isPowerOfFour(x);\n    if (n == 5L)\n        return isPowerOfFive(x);\n\
    \    if (n == 6L)\n        return isPowerOfSix(x);\n    if (n == 7L)\n       \
    \ return isPowerOfSeven(x);\n    if (n == 8L)\n        return isPowerOfEight(x);\n\
    \    if (n == 9L)\n        return isPowerOfNine(x);\n    if (n == 10L)\n     \
    \   return isPowerOfTen(x);\n    \n    return false;\n}", "{\n    auto res = x/n;\n\
    \    if (res*n == x)\n    {\n        if (isPow(res, n))\n            return true;\n\
    \    }\n    return false;\n}", "{\n    if(x == 1 && n != 0)\n        return true;\n\
    \    \n    if(n == 0 && x != 1)\n        return false;\n        \n    if(n ==\
    \ 0 && x == 1)\n        return true;\n    \n    long k = 1;\n    while(k * n <=\
    \ x)\n    {\n        if(k * n == x)\n            return true;\n        k++;\n\
    \    }\n    return false;\n}", "{\n    if(n<0 or x<0) return false;\n    if(n==0)\
    \ return false;\n    if(n==1) return true;\n    long int xc = cast(long) log(x);\n\
    \    long int yc = cast(long) log(n);\n    return (xc/yc==xc/yc.to!double);\n}",
  "{\n    if (n == 0) return false;\n    if (x == 1) return true;\n    if (x % n ==\
    \ 0)\n    {\n        long temp = x / n;\n        //math.sqrt(n)\n        if (std.typecons.is(temp,\
    \ long) || temp == 1) return true;\n        else return false;\n    }\n    else\
    \ return false;\n}", "{\n    // can we take the root?\n    static assert(isIntegral!(int),\
    \ \"int is not an integral type!\");\n    static assert(is(typeof(pow(1,1))==long),\
    \ \"pow() returns another type!\");\n    if (n == 0) return false;\n    if (x\
    \ == 1) return true;\n    int y = log(x) / log(n);\n    return pow(n, y) == x;\n\
    }\n//void main() {}", "{\n    if (x <= 0 || n <= 0)\n        return false;\n \
    \   else if (x == 1)\n        return true;\n    else if (n == 1)\n        return\
    \ false;\n    while (x % n == 0)\n    {\n        x /= n;\n        if (x == 1)\n\
    \            return true;\n    }\n    return false;\n}", "{\n    return isPow(n,\
    \ x);\n}\n ", "{\n    if (x == 0) return false;\n    if (n == 0) return true;\n\
    \    long pow = 1;\n    int i = 0;\n    do {\n        i++;\n        pow *= n;\n\
    \    } while (pow < x);\n    return pow == x;\n}", "{\n    if (x==1)\n       \
    \ return true;\n    if (n == 1)\n        return false;\n    while(true)\n    {\n\
    \        if (x%n == 0)\n        {\n            if (x/n == n)\n               \
    \ return true;\n            x = x/n;\n        }\n        else\n            return\
    \ false;\n    }\n}\n ", "{\n\tif(x == 1)\n\t\treturn true;\n\tif(n == 1)\n\t\t\
    return false;\n\twhile(true)\n\t{\n\t\tif(x % n != 0)\n\t\t\treturn false;\n\t\
    \tx /= n;\n\t\tif(x == 1)\n\t\t\treturn true;\n\t}\n}", "{\n    if (n == 0L)\n\
    \        return false;\n    long is_power = std.math.pow(n, std.math.log(x)/std.math.log(n));\n\
    \    return is_power == x;\n}", "{\n    //return(x & (x - 1)) == 0;\n    return(x%n\
    \ == 0 && log2(x/n) == int(log2(x/n)));\n}", "{\n    auto result = false;\n  \
    \  if (n == 1L)\n    {\n        if (x == 1L)\n        {\n            result =\
    \ true;\n        }\n    }\n    else if (n > 1L)\n    {\n        double power =\
    \ std.math.log(x)/std.math.log(n);\n        if (power == (long)power)\n      \
    \  {\n            result = true;\n        }\n    }\n    return result;\n}\n/*\n\
    You should implement a function that takes a string as an argument and\n    calculates\
    \ the length of the longest substring which consists of only\n    distinct characters.\n\
    \    >>> \"aa\"\n    1\n    >>> \"aaa\"\n    1\n    >>> \"abcabcbb\"\n    3\n\
    \    >>> \"abcabcabcd\"\n    4\n    >>> \"bbbbb\"\n    1\n    >>> \"pwwkew\"\n\
    \    3\n    >>> \"c\"\n    1\n    >>> \"dvdf\"\n    3\n*/\nsize_t length_of_longest_substring(string\
    \ str) \n{\n    auto maxLen = 0;\n    auto curLen = 0;\n    auto pos = 0;\n  \
    \  for (size_t i = 0; i < str.length; i++)\n    {\n        auto found = false;\n\
    \        for (size_t j = pos; j < i; j++)\n        {\n            if (str[i] ==\
    \ str[j])\n            {\n                found = true;\n                pos =\
    \ j + 1;\n                break;\n            }\n        }\n        if (!found)\n\
    \        {\n            curLen++;\n        }\n        else\n        {\n      \
    \      if (curLen > maxLen)\n            {\n                maxLen = curLen;\n\
    \            }\n            curLen = i - pos + 1;\n        }\n    }\n    if (curLen\
    \ > maxLen)\n    {\n        maxLen = curLen;\n    }\n    return maxLen;\n}\n/*\n\
    Given a positive integer n, find the number of integers in the range 1..n\n  \
    \  (inclusive) which have exactly 4 divisors.\n    Note: the function should return\
    \ 0 for the edge case n = 1 (", "{\n\treturn(!(1L % n) && !(x % pow(n, int(log(x)\
    \ / log(n)))));\n}", "{\n    return n>0 && n <= x && x%n==0 ? is_simple_power(x/n,\
    \ n) : x==1;\n}", "{\n    auto p = pow(n, cast(double)log(x) / log(n));\n    return\
    \ p - cast(long)p == 0;\n}", "{\n    if (x == 0) \n        return false;\n   \
    \ if (n == 0) \n        return false;\n    if (x == 1) \n        return true;\n\
    \    if (n == 1) \n        return false;\n    if (x == n) \n        return true;\n\
    \    if (x < n) \n        return false;\n    bool result = false;\n    int count\
    \ = 0;\n    //printf(\"x=%ld, n=%ld\\n\", x, n);\n    for (; n < x; n += n) \n\
    \    {\n        ++count;\n        //printf(\"n=%ld\\n\", n);\n        if (n ==\
    \ x) \n        {\n            result = true;\n            break;\n        }\n\
    \    }\n    //printf(\"count = %d\\n\", count);\n    return result;\n}", "{\n\
    \    if (x == 0 && n != 0) return false;\n    if (x == 0 && n == 0) return true;\n\
    \    if (n == 0) return false;\n    if (x == 1) return true;\n    if (n == 1)\
    \ return false;\n    if (n == x) return true;\n    long result = n;\n    for (;\
    \ result <= x;)\n    {\n        if (result == x) return true;\n        result\
    \ *= n;\n    }\n    return false;\n}", "{\n    return x == 0 ? false : x == 1\
    \ ? true : x % n == 0 ? is_simple_power(x / n, n) : false;\n}", "{\n    return\
    \ (x == 1) ? n == 1 : (x > 1) ? (((long)(log(x) / log(n))) == (log(x) / log(n)))\
    \ ? pow(n, log(x) / log(n)) == x : false : false;\n}", "{\n    //check if x is\
    \ a simple power of n\n    if(n == 1)\n        return false;\n    float res =\
    \ log(x) / log(n);\n    return(res == cast(long)res);\n}", "{\n    if(x == 0)\
    \ return false;\n    if(n == 0) return false;\n    if(x == 1) return true;\n \
    \   if(n == 1) return true;\n    int counter = 0;\n    while(n <= x)\n    {\n\
    \        n *= n;\n        counter++;\n    }\n    return counter == 1;\n}", "{\n\
    \    if(n==1) return false;\n    if(x==1) return true;\n    int temp = 0;\n  \
    \  while(x>1)\n    {\n        if(x%n==0)\n        {\n            x=x/n;\n    \
    \        temp++;\n        }\n        else\n        {\n            return false;\n\
    \        }\n    }\n    if(temp==1) return true;\n    else return false;\n}", "{\n\
    \    if(x == 1) return true;\n    while(x > 1)\n    {\n        if(x % n != 0)\n\
    \            return false;\n        x /= n;\n    }\n    return true;\n}", "{\n\
    \    return x == long.pow(n, cast(int)std.math.log(x) / std.math.log(n));\n}",
  "{\n    if(x == 1L && n == 1L)\n        return true;\n    else if(x == 1L)\n   \
    \     return false;\n    else if(n == 1L)\n        return false;\n    auto power\
    \ = (long)log(x) / log(n);\n    return pow(n, power) == x;\n}", "{\n    if(n ==\
    \ 1 && x == n)\n        return true;\n    if(x < n)\n        return false;\n \
    \   int m = cast(int)log(x)/log(n);\n    if(pow(n, m) == x)\n        return true;\n\
    \    return false;\n}", "{\n    return !(x < 1 || n < 1) && x == n ** cast(int)\
    \ cast(log)(x) / cast(log)(n);\n}", "{\n    double x_ = x;\n    double n_ = n;\n\
    \    return cast(double)round(log(x_) / log(n_)) == log(x_) / log(n_);\n}", "{\n\
    \    double nn = n;\n    double xx = x;\n    double r = log(xx) / log(nn);\n \
    \   if (r != cast(long)r) return false;\n    return r == cast(long)r;\n}", "{\n\
    \tint t = 1;\n\tif (x == 1)\n\t\treturn true;\n\telse\n\t{\n\t\twhile (x != n)\n\
    \t\t{\n\t\t\tn *= n;\n\t\t\tif (n > x)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn\
    \ true;\n\t}\n\t\t\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
