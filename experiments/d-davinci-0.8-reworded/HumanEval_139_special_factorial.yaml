name: HumanEval_139_special_factorial
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nThe Brazilian factorial is defined\
  \ as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n\
  \ > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function\
  \ will receive an integer as input and should return the special\n    factorial\
  \ of this integer.\n    \n*/\nlong special_factorial(long n) \n"
tests: "unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
  \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
  \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
completions: ["{\n    long x = 1;\n    long nn = n;\n    while(nn > 0)\n    {\n  \
    \      x *= std.math.factorial(nn);\n        nn--;\n    }\n    return x;\n}",
  "{\n\ttypeof(factorial!int)()(x) = 0;\n\tif(n<=1)return n*1;\n\treturn n*special_factorial(n-1);\n\
    }", "{\n\tif (n < 0) {\n\t\treturn -1;\n\t}\n\tif (n == 0) {\n\t\treturn 1;\n\t\
    }\n\treturn n * special_factorial(n - 1);\n}\n/*\n    Count the number of times\
    \ that the element elem appears in the given list.\n    >>> count_elem(1, [1,\
    \ 2, 1, 1, 1, 2, 3, 1, 1, 4, 1, 5, 6, 1])\n    8\n    >>> count_elem(2, [1, 2,\
    \ 1, 1, 1, 2, 3, 1, 1, 4, 1, 5, 6, 1])\n    2\n    >>> count_elem(9, [1, 2, 1,\
    \ 1, 1, 2, 3, 1, 1, 4, 1, 5, 6, 1])\n    0\n*/\nlong count_elem(long elem, long[]\
    \ list)\n{\n\tlong n = 0;\n\tforeach (long i; list) {\n\t\tif (i == elem) {\n\t\
    \t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n/*\n    A \"Fibonacci word\" is a word over\
    \ the alphabet {0, 1} defined as follows:\n    - The empty word is a Fibonacci\
    \ word.\n    - If a word has last letter 0, then the word obtained by removing\
    \ the last\n    letter is a Fibonacci word.\n    - If a word has last letter 1,\
    \ then the word obtained by removing the last\n    letter and then the last letter\
    \ of the obtained word is a Fibonacci word.", "{\n\treturn n <= 0 ? 1 : n * special_factorial(n\
    \ - 1);\n}", "{\n    return factorial(n) * factorial(n - 1) * factorial(n - 2);\n\
    }", "{\n    int res = n;\n    n--;\n    while(n>0)\n    {\n        res *= n;\n\
    \        n--;\n    }\n    return res;\n}", "{\n    import std.stdio : writeln;\n\
    \    return reduce!((a, b) => a * b)(iota(n));\n}\n ", "{\n    long brazilian_factorial\
    \ = 1L;\n    long factorial = 1L;\n    if (n == 0)\n        return 1L;\n    else\n\
    \    {\n        for (int i = 1; i <= n; i++)\n        {\n            factorial\
    \ *= i;\n            brazilian_factorial *= factorial;\n        }\n        return\
    \ brazilian_factorial;\n    }\n}", "{\n    long res = 1;\n    foreach(i; 1..n)\
    \ {\n        res *= factorial(i);\n    }\n    return res;\n}", "{\n    long result\
    \ = 1;\n    for (int i = 0; i < n; i++)\n    {\n        result *= factorial(n\
    \ - i);\n    }\n    return result;\n}", "{\n    return n == 0 ? 1 : n * special_factorial(n\
    \ - 1);\n}", "{\n  if (n <= 1) return 1;", "{\n    int i = 0;\n    long result\
    \ = 1;\n    while (i < n) {\n        result *= i+1;\n        i++;\n    }\n   \
    \ return result;\n}", "{\n\treturn n==0 ? 1 : n * special_factorial(n-1);\n}",
  "{\n\tlong result = 1;\n\tforeach(i; 1 .. n)\n\t{\n\t\tresult *= math.factorial(i);\n\
    \t}\n\treturn result;\n}\n \n/*\nGiven a string and an integer, find the nth index\
    \ of the end where a given substring is located.", "{\n    import std.math : lgamma;\n\
    \    assert(n > 0);\n    auto result = 1.0;\n    for (long i = 1; i <= n; i++)\n\
    \    {\n        result *= lgamma(i+1);\n    }\n    return result;\n}", "{\n  \
    \  static assert(n > 0);", "{\n    long result = 1;\n    foreach(i;2..n)\n   \
    \ {\n        result *= i;\n    }\n    return result;\n}", "{\n    static if (is(typeof(mixin(\"\
    factorial\"))))\n    {\n        return factorial(n) * factorial(n - 1) * factorial(n\
    \ - 2);\n    }\n    else\n    {\n        return n.factorial * (n - 1).factorial\
    \ * (n - 2).factorial;\n    }\n}", "{\n\tlong ret = 1;\n\tforeach(i; 2..n+1)\n\
    \t{\n\t\tret *= i;\n\t}\n\treturn ret;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
