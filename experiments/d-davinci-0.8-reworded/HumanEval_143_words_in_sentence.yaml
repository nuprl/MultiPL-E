name: HumanEval_143_words_in_sentence
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a string\
  \ representing a sentence,\n    the sentence contains some words separated by a\
  \ space,\n    and you have to return a string that contains the words from the original\
  \ sentence,\n    whose lengths are prime numbers,\n    the order of the words in\
  \ the new string should be the same as the original one.\n\n    Example 1:\n   \
  \ >>> words_in_sentence(\"This is a test\")\n    \"is\"\n\n    Example 2:\n    >>>\
  \ words_in_sentence(\"lets go for swimming\")\n    \"go for\"\n    \n    Constraints:\n\
  \        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n\
  \    \n*/\nstring words_in_sentence(string sentence) \n"
tests: "unittest\n{\n    alias candidate = words_in_sentence;\n\n    assert(candidate(\"\
  This is a test\") == \"is\");\n    assert(candidate(\"lets go for swimming\") ==\
  \ \"go for\");\n    assert(candidate(\"there is no place available here\") == \"\
  there is no place\");\n    assert(candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\
  );\n    assert(candidate(\"go for it\") == \"go for it\");\n    assert(candidate(\"\
  here\") == \"\");\n    assert(candidate(\"here is\") == \"is\");\n}\nvoid main(){}"
completions: ["{\n    static auto is_prime = [](int x) \n    {\n        if (x <= 1)\
    \ return false;\n        for (int i = 2; i * i <= x; ++i) \n        {\n      \
    \      if (x % i == 0) return false;\n        }\n        return true;\n    };\n\
    \    string result;\n    foreach (index, word; split(sentence, \" \")) \n    {\n\
    \        if (is_prime(word.length)) \n        {\n            if (result.length)\
    \ result ~= \" \";\n            result ~= word;\n        }\n    }\n    return\
    \ result;\n}\n// @end:  \n/*\n    tests:\n*/\nstatic assert(words_in_sentence(\"\
    This is a test\") == \"is\");\nstatic assert(words_in_sentence(\"lets go for swimming\"\
    ) == \"go for\");\nstatic assert(words_in_sentence(\"Hello from ankara\") == \"\
    from\");\nstatic assert(words_in_sentence(\"Oh, this is a huge test\") == \"Oh,\
    \ is\");\nstatic assert(words_in_sentence(\"what is a prime number\") == \"what\
    \ is a\");\n// @exclude", "{\n    // Calculate Primes\n    int max_length = 0;\n\
    \    foreach(token; sentence.split)\n    {\n        max_length = max(max_length,\
    \ token.length);\n    }\n    enum isPrime = true;\n    int[] primes = new int[];\n\
    \    for(int i = 2; i <= max_length; i++)\n    {\n        isPrime = true;\n  \
    \      foreach(n; primes)\n        {\n            if(i % n == 0)\n           \
    \ {\n                isPrime = false;\n                break;\n            }\n\
    \        }\n        if(isPrime)\n        {\n            primes ~= i;\n       \
    \ }\n    }\n    // Select Primes\n    string[] tokens = sentence.split;\n    string\
    \ result = \"\";\n    foreach(token; tokens)\n    {\n        foreach(prime; primes)\n\
    \        {\n            if(token.length == prime)\n            {\n           \
    \     result ~= token ~ \" \";\n                break;\n            }\n      \
    \  }\n    }\n    return result.trimRight;\n}", "{\n    static auto is_prime =\
    \ typeof(is_prime)([](int x) {\n        for (int i = 2; i <= (int)sqrt(x); i++)\n\
    \            if (x % i == 0)\n                return false;\n        return true;\n\
    \    });\n    auto words = to!string[](split(sentence, \" \"));\n    return join(join(words.filter!(w\
    \ => w.length.is_prime)), \" \");\n}", "{\n    // NOTE: isPrime uses lazy iterators,\
    \ which are not supported\n    // by the hackerrank Python interpreter.\n    //\
    \ static if (__ctfe)\n    static assert (false);\n    auto words = split(sentence,\
    \ \" \");\n    auto isPrime = (int n) => \n    {\n        if (n <= 1)\n      \
    \      return false;\n        if (n % 2 == 0)\n            return n == 2;\n  \
    \      foreach (i; 3 .. ceil(sqrt(n)))\n            if (n % i == 0)\n        \
    \        return false;\n        return true;\n    };\n    string res = \"\";\n\
    \    foreach (word; words)\n    {\n        if (isPrime(word.length))\n       \
    \     res ~= \" \" ~ word;\n    }\n    return res[1 .. $];\n}", "{\n    string\
    \ ret;\n    foreach(w; split(sentence, \" \"))\n    {\n        // if the length\
    \ of the word is a prime, add it to the return string\n        if(isPrime(w.length))\n\
    \            ret ~= w ~ \" \";\n    }\n    // remove the last space character\n\
    \    return ret[0..$-1];\n}", "{\n    string[] words = split(sentence, \" \");\n\
    \    string prime_words = \"\";\n    foreach(word; words)\n    {\n        if(std.math.isPrime(word.length))\n\
    \        {\n            prime_words ~= word ~ \" \";\n        }\n    }\n    return\
    \ chomp(prime_words);\n}", "{\n    static const bool is_prime[] = { false, false,\
    \ true, true, false, true, false, true, false, false, false, true, false, true,\
    \ false, false, false, true, false, true, false, false, false, true, false, false,\
    \ false, false, false, true, false, true, false, false, false, false, false, false,\
    \ true, false, true, false, false, false, false, false, false, false, false, false,\
    \ true, false, true, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, true, false, true, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, true, false, true, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, true, false, true, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, true, false, true, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, true, false, true, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, true, false, true, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, true,\
    \ false, true, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, true, false, true, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false", "{\n    import std.string;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.conv;\n    import std.typecons;\n    import\
    \ std.array;\n    import std.math;\n    import std.traits;\n    auto splittedSentence\
    \ = to!(string[])(split(sentence));\n    auto str = \"\";\n    foreach(word; splittedSentence)\n\
    \    {\n        if(word.length % 2 != 0 && word.length > 1)\n        {\n     \
    \       str ~= word;\n            str ~= \" \";\n        }\n    }\n    return\
    \ str.stripRight;\n}", "{\n    int[] prime_numbers = [2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n \
    \   enum is_prime = int[string]{};\n    foreach(i; prime_numbers) is_prime[to!string(i)]\
    \ = i;\n    auto words = sentence.split();\n    string[] result;\n    foreach(word;\
    \ words) {\n        if(is_prime.find(to!string(word.length)))\n            result\
    \ ~= word;\n    }\n    return result.join(\" \");\n}", "{\n    string[] words\
    \ = split(sentence, \" \");\n    string result = \"\";\n    foreach(string word;\
    \ words)\n    {\n        if(isPrime(strlen(word)))\n        {\n            result\
    \ ~= (result.length == 0 ? \"\" : \" \") ~ word;\n        }\n    }\n    return\
    \ result;\n}", "{\n    auto w = split(sentence, \" \");\n    string ret;\n   \
    \ foreach(i, word; w)\n    {\n        if(isPrime(i.length))\n        {\n     \
    \       ret ~= i;\n            ret ~= \" \";\n        }\n    }\n    ret = ret[0..$-1];\n\
    \    return ret;\n}", "{\n    // if the sentence is empty there is nothing to\
    \ do...\n    if (sentence.empty)\n        return \"\";\n    \n    // copy the\
    \ sentence so we can modify it...\n    string prime_words = sentence;\n    \n\
    \    // we will be modifying the string so it is easiest\n    // to work with\
    \ it as an array...\n    char[] word_array = prime_words.dup;\n    \n    // we\
    \ need to keep track of the index of the first\n    // character of the current\
    \ word, and the index\n    // of the first character of the next word...\n   \
    \ int current_word_begin = 0;\n    int next_word_begin = 0;\n    \n    // we need\
    \ to keep track of the length of the current\n    // word...\n    int word_length\
    \ = 0;\n    \n    // keep track of the number of characters we have\n    // removed\
    \ from the sentence...\n    int num_chars_removed = 0;\n    \n    // we will loop\
    \ through the characters in the sentence\n    // until we reach the end of the\
    \ array...\n    while (current_word_begin < word_array.length)\n    {\n      \
    \  // determine the number of characters in the\n        // current word...\n\
    \        word_length = next_word_begin - current_word_begin;\n        \n     \
    \   // if the word length is prime, then skip over\n        // it and continue\
    \ on to the next word...\n        if (isPrime(word_length))\n        {\n     \
    \       current_word_begin = next_word_begin;\n            next_word_begin = current_word_begin\
    \ + 1;\n            continue;\n        }\n        \n        // otherwise, if the\
    \ word length is not prime,\n        // then we need to remove the current word\
    \ from\n        // the sentence...\n        else\n        {\n            // to\
    \ do this, we need to shift all of the\n            // characters to the right\
    \ of the current\n            // word to the left by word_length...\n        \
    \    int i = current_word_begin;\n            while (i < word_array.length - word_length)\n\
    \            {\n                word_array[i] = word_array[i + word_length];\n\
    \                i++;\n            }\n            \n", "{\n    /*\n        s.split('\
    \ ') returns a string[]\n        a.filter!(prime) returns a string[]\n       \
    \ a.join(' ') returns a string\n    */\n    return sentence.split(' ').filter!(prime).join('\
    \ ');\n}", "{\n    string[] words = split(sentence, \" \");\n    string res =\
    \ \"\";\n    int cnt = 0;\n    for (int i = 0; i < words.length; i++) {\n    \
    \    int word_len = words[i].length;\n        if (word_len <= 2) {\n         \
    \   if (word_len == 2) {\n                if (words[i][0] == words[i][1]) {\n\
    \                    continue;\n                }\n            }\n           \
    \ res += words[i];\n            cnt++;\n        } else {\n            bool flag\
    \ = true;\n            for (int j = 2; j <= sqrt(word_len); j++) {\n         \
    \       if (word_len % j == 0) {\n                    flag = false;\n        \
    \            break;\n                }\n            }\n            if (flag) {\n\
    \                res += words[i];\n                cnt++;\n            }\n   \
    \     }\n        if (cnt < words.length) {\n            res += \" \";\n      \
    \  }\n    }\n    return res;\n}", "{\n    string[] words = split(sentence, \"\
    \ \");\n    string answer = \"\";\n    for (int i = 0; i < words.length; i++)\
    \ {\n        if (isPrime(words[i].length)) {\n            answer = answer ~ \"\
    \ \" ~ words[i];\n        }\n    }\n    return answer.trim;\n}", "{\n    string[]\
    \ words = split(sentence, \" \");\n    string res = \"\";\n    foreach(word; words)\n\
    \    {\n        if(isPrime(word.length))\n        {\n            res ~= word ~\
    \ \" \";\n        }\n    }\n    res = res.trimRight();\n    return res;\n}", "{\n\
    \    import std.algorithm : filter, map;\n    import std.range : chunk;\n    import\
    \ std.stdio : writeln;\n    import std.string : to!int;\n    import std.conv :\
    \ to;\n    //return sentence.split(\" \").filter!(a => isPrime(a.to!int())).join(\"\
    \ \");\n    auto words = sentence.split(\" \");\n    auto primes = words.map!(w\
    \ => w.to!int()).filter!(isPrime);\n    writeln(words);\n    writeln(primes);\n\
    \    return words.zip(primes).filter!(a => a[1]).map!(a => a[0]).join(\" \");\n\
    }", "{\n    string ret = \"\";\n    foreach(auto s; split(sentence, \" \")) \n\
    \    {\n        if(allPrimes(s))\n            ret ~= s ~ \" \";\n    }\n    return\
    \ ret.trimRight();\n}\nunittest \n{\n    import std.algorithm;\n    import std.array;\n\
    \    import std.algorithm;\n    import std.typecons;\n    import std.range;\n\
    \    import std.conv;\n    import std.stdio;\n    writeln(typeof(words_in_sentence(\"\
    This is a test\")));\n    assert(words_in_sentence(\"This is a test\") == \"is\"\
    );\n    assert(words_in_sentence(\"lets go for swimming\") == \"go for\");\n \
    \   assert(words_in_sentence(\"This is a list: a, b, c, d, e, f, g.\") == \"is\
    \ a c e g\");\n    writeln(typeof(words_in_sentence(\"This is a list: a, b, c,\
    \ d, e, f, g.\")));\n    writeln(words_in_sentence(\"This is a list: a, b, c,\
    \ d, e, f, g.\"));\n    writeln(words_in_sentence(\"This is a list: a, b, c, d,\
    \ e, f, g.\").length);\n    writeln(words_in_sentence(\"This is a list: a, b,\
    \ c, d, e, f, g.\").zip(\"isac eg\").fold!((a, b) => a ~ \" \" ~ b)());\n    assert(words_in_sentence(\"\
    This is a list: a, b, c, d, e, f, g.\").zip(\"isac eg\").fold!((a, b) => a ~ \"\
    \ \" ~ b)() == \"is a c e g\");\n    assert(words_in_sentence(\"This is a list:\
    \ a, b, c, d, e, f, g.\").zip(\"isac eg\").fold!((a, b) => a ~ \" \" ~ b)() ==\
    \ \"is a c e g\");\n    assert(words_in_sentence(\"", "{\n    int[] primes = [2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, 101];\n    string words = sentence.split(\" \");\n    string\
    \ solution = \"\";\n    foreach(word; words)\n    {\n        foreach(prime; primes)\n\
    \        {\n            if(word.length == prime)\n            {\n            \
    \    solution ~= word ~ \" \";\n            }\n        }\n    }\n    return solution.trimRight();\n\
    }", "{\n    // TODO - Add your solution here.\n    string[] words = split(sentence,\
    \ \" \");\n    string result = \"\";\n    foreach(inout word; words)\n    {\n\
    \        if(isPrime(word.length)) result ~= word ~ \" \";\n    }\n    return result.trimRight();\n\
    }", "{\n    string[] result;\n    string[] words = split(sentence, \" \");\n \
    \   foreach(int i, string word; words) {\n        if(isPrime(strlen(word))) {\n\
    \            result ~= word;\n        }\n    }\n    return join(result, \" \"\
    );\n}", "{\n    auto prime_words = new string[];\n    foreach(word; split(sentence,\
    \ \" \"))\n    {\n        if(isPrime(word.length))\n        {\n            prime_words\
    \ ~= word;\n        }\n    }\n    return join(prime_words, \" \");\n}\n \n//isPrime\
    \ test\nenum isPrime(size_t n)\n{\n    enum true_false = n <= 1 ? false : n ==\
    \ 2 ? true : isPrime!(n, cast(size_t) sqrt(n));\n}", "{\n    import std.math :\
    \ isPrime;\n    import std.algorithm : filter;\n    import std.conv : to;\n  \
    \  import std.typecons : tuple;\n    return sentence.split(\" \")\n        .filter!(word\
    \ => word.length.isPrime)\n        .map!(word => to!string(word))\n        .join(\"\
    \ \");\n}", "{\n    bool is_prime(size_t v) {\n        if (v < 2) return false;\n\
    \        for (auto i = size_t(2); i < v; ++i) {\n            if (v % i == 0) return\
    \ false;\n        }\n        return true;\n    }\n    auto words = sentence.split(\"\
    \ \");\n    return words.filter!(w => is_prime(w.length)).join(\" \");\n}", "{\n\
    \    string[] words = split(sentence);\n    // filter words that contains prime\
    \ number of characters\n    auto prime_words = words.filter!(word => isPrime(word.length));\n\
    \    // join the words and return the string\n    return join(prime_words, \"\
    \ \");\n}\n/*\n    Test\n*/", "{\n    auto words = sentence.split(\" \");\n  \
    \  string result;\n    foreach(word; words) {\n        if(isPrime(word.length))\
    \ {\n            result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight;\n\
    }\n/*\n    1. Split the sentence into words\n    2. Iterate the words\n    3.\
    \ If the word length is prime, add the word to the result string\n    4. Strip\
    \ right the result string and return it\n*/", "{\n\tstring result = \"\";\n\t\
    string[] words = sentence.split();\n\tforeach(word; words)\n\t{\n\t\tif( isPrime(word.length)\
    \ )\n\t\t{\n\t\t\tresult ~= \" \" ~ word;\n\t\t}\n\t}\n\treturn result.stripLeft();\n\
    }", "{\n  string[] words = split(sentence, \" \");\n  string result = \"\";\n\
    \  foreach(word; words) {\n    if(isPrime(word.length)) {\n      result ~= word\
    \ ~ \" \";\n    }\n  }\n  return result.stripRight();\n}", "{\n    bool is_prime(int\
    \ n) \n    {\n        return n > 1 && all!(i => n % i != 0)(2 .. (n - 1));\n \
    \   }\n    auto [n, words] = split(sentence);\n    string result;\n    for (auto\
    \ w; w = n.front; n.popFront()) \n    {\n        if (is_prime(w.length)) \n  \
    \      {\n            result ~= w ~ ' ';\n        }\n    }\n    return result.idup;\n\
    }", "{\n    auto words = split(sentence, ' ');\n    auto result = \"\";\n    foreach(w;\
    \ words)\n    {\n        auto len = w.length;\n        if(len > 1)\n        {\n\
    \            for(auto i = 2; i < len; i++)\n            {\n                if(len\
    \ % i == 0)\n                {\n                    goto outer;\n            \
    \    }\n            }\n            result ~= \" \" ~ w;\n        }\n        outer:\
    \ continue;\n    }\n    return result.trimLeft();\n}", "{\n\tstring[] words =\
    \ split(sentence, \" \");\n\tauto has_prime_length = [](string word) {\n\t\tsize_t\
    \ length = word.length;\n\t\tfor (size_t factor = 2; factor < length / 2; factor++)\n\
    \t\t\tif (length % factor == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t};\n\
    \treturn join(filter!has_prime_length(words), \" \");\n}", "{\n    enum is_prime\
    \ = size_t is_prime_f = 1;\n    for (size_t i = 2; i * i <= is_prime_f; ++i)\n\
    \        if (is_prime_f % i == 0)\n            return 0;\n    return 1;\n}", "{\n\
    \    int[] primes = [\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,\
    \ 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\
    \ 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\
    \ 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\
    \ 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\
    \ 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\
    \ 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,\
    \ 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,\
    \ 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\
    \ 941, 947, 953, 967, 971, 977, 983, 991, 997\n    ];\n    string result = \"\"\
    ;\n    foreach(int wordLen; primes) {\n        foreach(string word; split(sentence,\
    \ \" \")) {\n            if(word.length == wordLen)\n                result ~=\
    \ word ~ \" \";\n        }\n    }\n    return result;\n}", "{\n    string[] words\
    \ = std.split(sentence, ' ');\n    string new_sentence = \"\";\n    foreach(word;\
    \ words)\n    {\n        if(is_prime(word.length))\n        {\n            new_sentence\
    \ ~= word ~= \" \";\n        }\n    }\n    return new_sentence.idup;\n}", "{\n\
    \    static immutable primes = tuple(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n    string result = \"\
    \";\n    foreach(word; sentence.split)\n    {\n        if(word.length in primes)\n\
    \        {\n            result ~= word;\n            result ~= \" \";\n      \
    \  }\n    }\n    return result.trimRight;\n}", "{\n    import std.algorithm;\n\
    \    import std.range;\n    import std.array;\n    auto isPrime = (int n) {\n\
    \        if (n <= 1) return false;\n        if (n == 2) return true;\n       \
    \ if (n % 2 == 0) return false;\n        foreach (i; 2 .. n / 2 + 1)\n       \
    \     if (n % i == 0)\n                return false;\n        return true;\n \
    \   };\n    string[] words = split(sentence);\n    return join(map!(a => a.idup)(filter!(a\
    \ => isPrime(a.length))(words)));\n}", "{\n    import std.array : array;\n   \
    \ import std.typecons : tuple;\n    import std.algorithm : filter, map;\n    import\
    \ std.range : iota;\n    import std.numeric : isPrime;\n    import std.conv :\
    \ to;\n    /*\n        Returns the words in the sentence whose length are prime\
    \ numbers\n    */\n    auto is_prime_word(string word) => isPrime(word.length);\n\
    \    /*\n        Helper function that splits the sentence into words\n    */\n\
    \    auto split_into_words(string s)\n    {\n        return s.split(\" \").array;\n\
    \    }\n    /*\n        Helper function that concatenates strings with a space\
    \ in between\n    */\n    auto concat_words(string[] words)\n    {\n        return\
    \ to!string(words.map!(word => word ~ \" \").join);\n    }\n    return concat_words(split_into_words(sentence).filter!is_prime_word);\n\
    }", "{\n    string result = \"\";\n    bool first_word = true;\n    size_t space_index\
    \ = sentence.find(' ');\n    if (space_index == string::npos) \n    {\n      \
    \  // sentence has only one word\n        if (is_prime(sentence.length())) \n\
    \        {\n            return sentence;\n        }\n        else \n        {\n\
    \            return \"\";\n        }\n    }\n    else \n    {\n        while (space_index\
    \ != string::npos) \n        {\n            string word = sentence.substr(0, space_index);\n\
    \            sentence = sentence.substr(space_index + 1);\n            space_index\
    \ = sentence.find(' ');\n            if (is_prime(word.length())) \n         \
    \   {\n                if (first_word) \n                {\n                 \
    \   result += word;\n                    first_word = false;\n               \
    \ }\n                else \n                {\n                    result += \"\
    \ \" + word;\n                }\n            }\n        }\n        if (is_prime(sentence.length()))\
    \ \n        {\n            if (first_word) \n            {\n                result\
    \ += sentence;\n            }\n            else \n            {\n            \
    \    result += \" \" + sentence;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    size_t len = sentence.length;\n    size_t pos = 0;\n  \
    \  string list_words[100];\n    size_t index = 0;\n    while (pos < len)\n   \
    \ {\n        size_t space = 0;\n        while (pos + space < len && sentence[pos\
    \ + space] != ' ')\n        {\n            space++;\n        }\n        list_words[index]\
    \ = sentence[pos .. pos + space];\n        index++;\n        pos += space + 1;\n\
    \    }\n    string result;\n    bool first = true;\n    for (size_t i = 0; i <\
    \ index; i++)\n    {\n        size_t len = list_words[i].length;\n        bool\
    \ is_prime = true;\n        for (size_t d = 2; d <= len / 2; d++)\n        {\n\
    \            if (len % d == 0)\n            {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (is_prime)\n   \
    \     {\n            if (!first)\n            {\n                result ~= \"\
    \ \";\n            }\n            result ~= list_words[i];\n            first\
    \ = false;\n        }\n    }\n    return result;\n}", "{\n    immutable primes\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    immutable sentence_items = sentence.split();\n   \
    \ immutable is_item_in_primes = primes.length <= sentence_items.length\n     \
    \                                   ? sentence_items.zip(primes).map!(a => a[0].length\
    \ == a[1])\n                                        : sentence_items.map!(a =>\
    \ primes.canFind(a.length));\n    string result = \"\";\n    foreach(i, is_prime;\
    \ is_item_in_primes)\n    {\n        if(is_prime)\n        {\n            result\
    \ ~= sentence_items[i] ~ \" \";\n        }\n    }\n    return result.strip();\n\
    }", "{\n    int[] words_indexes = [ 0 ];\n    for (int i = 0; i < sentence.length;\
    \ i++)\n    {\n        if (sentence[i] == ' ')\n        {\n            words_indexes\
    \ ~= i;\n        }\n    }\n    words_indexes ~= sentence.length;\n    string words_prime_length;\n\
    \    for (int i = 0; i < words_indexes.length - 1; i++)\n    {\n        string\
    \ word = sentence[words_indexes[i]..words_indexes[i + 1]];\n        int word_length\
    \ = word.length;\n        bool is_prime = true;\n        for (int i = 2; i < word_length;\
    \ i++)\n        {\n            if (word_length % i == 0)\n            {\n    \
    \            is_prime = false;\n                break;\n            }\n      \
    \  }\n        if (is_prime)\n        {\n            words_prime_length ~= \" \"\
    \ ~ word;\n        }\n    }\n    return words_prime_length.trim;\n}", "{\n   \
    \ struct word_count\n    {\n        bool is_prime = false;\n        uint count\
    \ = 0;\n    };\n    auto words = sentence.split;\n    auto word_counts = words.assocArray!(x\
    \ => x, word_count)();\n    foreach(word; word_counts.keys)\n    {\n        auto\
    \ count = word.length;\n        for(uint d = 2; d <= cast(uint)sqrt(count); d++)\n\
    \        {\n            if(count % d == 0)\n            {\n                word_counts[word].is_prime\
    \ = false;\n                break;\n            }\n            else\n        \
    \    {\n                word_counts[word].is_prime = true;\n            }\n  \
    \      }\n    }\n    string result = \"\";\n    foreach(word; words)\n    {\n\
    \        if(word_counts[word].is_prime)\n        {\n            result ~= word\
    \ ~ \" \";\n        }\n    }\n    return result;\n}", "{\n    static string[]\
    \ words = split(sentence, \" \");\n    static string[] primes = map!(word => \n\
    \            isPrime(word.length) ? word : \"\", words);\n    return join(primes,\
    \ \" \");\n}", "{\n    // 1. split the sentence into an array of words\n    auto\
    \ words = split(sentence, \" \");\n    /*\n    for (int i = 0; i < words.length;\
    \ i++)\n    {\n        writefln(\"%s\", words[i]);\n    }\n    */\n    string\
    \ result = \"\";\n    // 2. loop through the array to check if each word is a\
    \ prime number\n    foreach (w; words)\n    {\n        //writefln(\"%s\", w);\n\
    \        // 3. if word is a prime number, append it to the result string\n   \
    \     if (isPrime(w.length))\n        {\n            result ~= w ~ \" \";\n  \
    \      }\n    }\n    return strip(result);\n}", "{\n    import std.conv;\n   \
    \ import std.range;\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.math;\n    auto parts = sentence.split;\n    string result = \"\";\n   \
    \ for (auto word; parts) {\n        if (word.length.isPrime) {\n            result\
    \ ~= word ~ \" \";\n        }\n    }\n    return result.trimRight;\n}", "{\n \
    \   enum primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    string res = \"\";\n    foreach(immutable\
    \ word; sentence.split())\n    {\n        if(primes.canFind(word.length))\n  \
    \      {\n            res ~= word ~ \" \";\n        }\n    }\n    return res.stripRight;\n\
    }", "{\n    import std.algorithm : find, filter;\n    import std.range : all;\n\
    \    import std.conv : to;\n    import std.array : array;\n    import std.math\
    \ : isPrime;\n    import std.range : cycle;\n    import std.range : take;\n  \
    \  import std.range : iota;\n    import std.string : splitter;\n    import std.stdio\
    \ : writeln;\n    return sentence.splitter.split(\" \").filter!(word => word.length.isPrime).array.join(\"\
    \ \");\n}", "{\n    string[] words = split(sentence, \" \");\n    string result\
    \ = \"\";\n    foreach(string word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            result ~= word ~ \" \";\n        }\n    }\n    return\
    \ result.stripRight;\n}", "{\n    string[] arr = split(sentence);\n    auto result\
    \ = appender!string();\n    foreach(i, word; arr)\n    {\n        auto len = word.length;\n\
    \        bool flag = true;\n        for(int j = 2; j <= len / 2; j++)\n      \
    \  {\n            if(len % j == 0)\n            {\n                flag = false;\n\
    \                break;\n            }\n        }\n        if(flag)\n        {\n\
    \            result.put(word);\n        }\n    }\n    return result.data;\n}",
  "{\n    auto is_prime = [](ulong x) {\n        if (x < 2) return false;\n      \
    \  if (x == 2) return true;\n        foreach (i; 2 .. cast(ulong) sqrt(x) + 1)\
    \ {\n            if (x % i == 0) return false;\n        }\n        return true;\n\
    \    };\n    string[] words = split(sentence);\n    string[] result;\n    foreach\
    \ (word; words) {\n        if (is_prime(word.length)) result ~= word;\n    }\n\
    \    return join(result, \" \");\n}\n/*\n    Testing;\n*/\nunittest {\n    assert(words_in_sentence(\"\
    This is a test\") == \"is\");\n    assert(words_in_sentence(\"lets go for swimming\"\
    ) == \"go for\");\n}", "{\n    import std.algorithm;\n    import std.range;\n\
    \    import std.array;\n    import std.stdio;\n    immutable arr = sentence.split(\"\
    \ \");\n    immutable ret = arr.filter!(a => isPrime(a.length)).join(\" \");\n\
    \    return ret;\n}\npragma(inline, true);", "{\n    string new_sentence = \"\"\
    ;\n    foreach(word; split(sentence))\n    {\n        if(word.length >= 1 && word.length\
    \ <= 100)\n        {\n            int index = 0;\n            bool isPrime = true;\n\
    \            for(int i = 2; i <= word.length/2; i++)\n            {\n        \
    \        if(word.length % i == 0)\n                {\n                    isPrime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if(isPrime == true)\n            {\n                new_sentence ~=\
    \ word ~ \" \";\n            }\n        }\n    }\n    return strip(new_sentence);\n\
    }", "{\n    immutable std.range.primerange prime_range = 0..500;\n    immutable\
    \ std.range.booleanrange boolean_range = 0..500;\n    immutable std.range.charsrange\
    \ chars_range = 0..500;\n    immutable std.range.integersrange integers_range\
    \ = 0..500;\n    immutable std.range.bytessrange bytess_range = 0..500;\n    immutable\
    \ std.range.doublesrange doubles_range = 0..500;\n    immutable std.range.floatsrange\
    \ floats_range = 0..500;\n    immutable std.range.exponentsrange exponents_range\
    \ = 0..500;\n    immutable std.range.longsrange longs_range = 0..500;\n    immutable\
    \ std.range.shortrange short_range = 0..500;\n    immutable std.range.realsrange\
    \ reals_range = 0..500;\n    immutable std.range.uintegersrange uintegers_range\
    \ = 0..500;\n    immutable std.range.ulongsrange ulongs_range = 0..500;\n    immutable\
    \ std.range.ushortrange ushort_range = 0..500;\n    immutable std.range.stringsrange\
    \ strings_range = 0..500;\n    immutable std.range.rangesrange ranges_range =\
    \ 0..500;\n    immutable std.range.boolrangesrange boolranges_range = 0..500;\n\
    \    immutable std.range.charsrangesrange charsranges_range = 0..500;\n    immutable\
    \ std.range.integersrangesrange integersranges_range = 0..500;\n    immutable\
    \ std.range.bytessrangesrange bytessranges_range = 0..500;\n    immutable std.range.doublesrangesrange\
    \ doublesranges_range = 0..500;\n    immutable std.range.floatsrangesrange floatsranges_range\
    \ = 0..500;\n    immutable std.range.exponentsrangesrange exponentsranges_range\
    \ = 0..500;\n    immutable std.range.longsrangesrange longsranges_range = 0..500;\n\
    \    immutable std.range.shortrangesrange shortranges_range = 0..500;\n    immutable\
    \ std.range.realsr", "{\n    string[] words = split(sentence, \" \");\n    bool[]\
    \ is_prime = is_prime_numbers(10000);\n    string answer = \"\";\n    foreach(word;\
    \ words)\n    {\n        if(is_prime[word.length])\n        {\n            answer\
    \ ~= word ~ \" \";\n        }\n    }\n    return answer.trimRight();\n}", "{\n\
    \    enum b = false;\n    enum w = true;\n    auto word = split(sentence, \" \"\
    );\n    string res = \"\";\n    foreach(w; word)\n    {\n        auto s = unaryFun!(isPrime)(w.length);\n\
    \        if(s)\n        {\n            res ~= w ~ \" \";\n        }\n    }\n \
    \   return res;\n}", "{\n    int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n    string\
    \ res = \"\";\n    int i = 0;\n    while (i < sentence.length)\n    {\n      \
    \  string word = \"\";\n        while (i < sentence.length && sentence[i] != '\
    \ ')\n        {\n            word ~= sentence[i];\n            i++;\n        }\n\
    \        i++;\n        if (find(primes.dup, word.length))\n        {\n       \
    \     res ~= word ~ \" \";\n        }\n    }\n    return res[0..$-1];\n}", "{\n\
    \    auto words = appender;\n    auto is_prime = isPrime;\n    foreach(word; sentence.split())\n\
    \    {\n        if(is_prime(word.length))\n        {\n            words.put(word\
    \ ~ \" \");\n        }\n    }\n    return words.data.idup;\n}", "{\n    static\
    \ immutable is_prime = (int x) {\n        if (x <= 3)\n            return x >\
    \ 1;\n        if (x % 2 == 0 || x % 3 == 0)\n            return false;\n     \
    \   for (int i = 5; i * i <= x; i += 6)\n            if (x % i == 0 || x % (i\
    \ + 2) == 0)\n                return false;\n        return true;\n    };\n  \
    \  string result = \"\";\n    foreach (word; split(sentence))\n        if (is_prime(word.length))\n\
    \            result ~= \" \" ~ word;\n    return result.popFront();\n}", "{\n\
    \    int[] prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    string[] words = split(sentence,\
    \ \" \");\n    string s;\n    foreach(w; words)\n    {\n        if(find(prime_numbers,\
    \ strlen(w)))\n        {\n            s ~= w ~ \" \";\n        }\n    }\n    return\
    \ s.trimRight();\n}", "{\n    string[] words = tokenize(sentence);\n    string\
    \ sentence;\n    foreach(word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            sentence ~= \" \" ~ word;\n        }\n    }\n    return\
    \ sentence.trim();\n}", "{\n    immutable is_prime = (size_t value) => \n    {\n\
    \        if (value < 2) return false;\n        for (size_t i = 2; i <= sqrt(value);\
    \ i++)\n            if (value % i == 0) return false;\n        return true;\n\
    \    };\n    \n    import std.algorithm : filter, map, joiner;\n    import std.range.primitives\
    \ : copy;\n    import std.conv : to;\n    import std.string : splitter;\n    \n\
    \    return sentence.splitter.map!(to!string).filter!is_prime.joiner(\" \");\n\
    }", "{\n    import std.array;\n    auto parts = sentence.split(\" \");\n    enum\
    \ isPrime = true;\n    parts = parts.filter!(a => {\n        foreach(i; 2..(a.length/2\
    \ + 1))\n        {\n            if(a.length % i == 0)\n            {\n       \
    \         isPrime = false;\n                break;\n            }\n        }\n\
    \        if(isPrime)\n            return a;\n        isPrime = true;\n    });\n\
    \    return parts.join(\" \");\n}", "{\n    enum len = find(sentence, ' ');\n\
    \    immutable res = sentence[0..len];\n    immutable len_word = res.length;\n\
    \    immutable is_prime = len_word > 1 && all!((val){return len_word % val !=\
    \ 0;})(iota(2,len_word));\n    return is_prime ? res : \"\";\n}", "{\n    // The\
    \ original sentence contains only letters, so split on spaces.\n    immutable(char)[]\
    \ words = splitter(sentence, ' ');\n    immutable(char)[] res;\n    foreach(immutable(char)[]\
    \ word; words)\n    {\n        if(isPrime(word.length))\n        {\n         \
    \   res ~= word;\n        }\n    }\n    return res.join(\" \");\n}\n/*\n    Here's\
    \ a function that determines if an integer is prime.", "{\n    auto words = sentence.split;\n\
    \    auto result = words.filter!isPrime;\n    return result.join(\" \");\n}",
  "{\n    string[] arr = split(sentence);\n    string result = \"\";\n    foreach(string\
    \ word; arr)\n    {\n        uint len = word.length;\n        if(isPrime(len))\n\
    \        {\n            result ~= \" \" ~ word;\n        }\n    }\n    return\
    \ result[1..];\n}\n/*", "{\n    auto words = split(sentence);\n    //@assert(not\
    \ words.empty);\n    auto max_word_length = words.map!(a => a.length).max;\n \
    \   //@assert(max_word_length > 0);\n    return words.filter!(a => isPrime(a.length)).join(\"\
    \ \");\n}", "{\n    // Split the sentence by spaces\n    auto words = split(sentence,\
    \ \" \");\n    // We accumulate the words with prime lengths into a string.\n\
    \    string result;\n    foreach(word; words)\n    {\n        // Only add words\
    \ with prime lengths to result.\n        if(isPrime(word.length))\n        {\n\
    \            result ~= word ~ \" \";\n        }\n    }\n    // If there were no\
    \ words with prime lengths, return \"\".\n    if(result.length == 0)\n    {\n\
    \        return \"\";\n    }\n    else\n    {\n        // Otherwise, remove the\
    \ trailing space and return result.\n        return result[0..$-1];\n    }\n}\n\
    /*\n    This function determines if n is prime or not.\n    It is based on the\
    \ sieve of Eratosthenes.\n    >>> https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    */", "{\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.conv;\n    import std.string;\n    import std.range;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import", "{\n    enum primes = [2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    string\
    \ result = \"\";\n    int len = 0;\n    foreach(word; split(sentence, \" \"))\n\
    \    {\n        len = word.length;\n        if (primes.count > 0 && len == primes[0])\n\
    \        {\n            result ~= word ~ \" \";\n        }\n    }\n    return\
    \ result.stripRight;\n}", "{\n    auto words = split(sentence, \" \");\n    auto\
    \ is_prime = (int n) {\n        if (n < 2) return false;\n        for (int i =\
    \ 2; i < sqrt(n); i++)\n            if (n % i == 0) return false;\n        return\
    \ true;\n    };\n    auto result = words.filter!(is_prime).join(\" \");\n    return\
    \ result;\n}", "{\n  string[] words = split(sentence, \" \");\n  string filteredWords\
    \ = \"\";\n  foreach(word; words)\n  {\n    if(isPrime(word.length))\n    {\n\
    \      filteredWords ~= word ~ \" \";\n    }\n  }\n  return strip(filteredWords);\n\
    }", "{\n    auto words = split(sentence, \" \");\n    string result;\n    foreach(word;\
    \ words)\n    {\n        if(isPrime(word.length))\n        {\n            result\
    \ ~= \" \" ~ word;\n        }\n    }\n    return result.length > 0 ? result[1..]\
    \ : \"\";\n}", "{\n    import std.stdio;\n    import std.conv;\n    import std.array;\n\
    \    import std.typecons;\n    import std.string;\n    import std.algorithm;\n\
    \    auto words = sentence.split(\" \");\n    auto result = words.filter!(word\
    \ => isPrime(word.length));\n    return result.map!(word => word ~ \" \").joiner.join;\n\
    }", "{\n    immutable is_prime = prime[0..100];\n    string[] words = split(sentence);\n\
    \    return join(filter!(w => is_prime[w.length])(words));\n}\n/*\n    This is\
    \ a list of words with the same length\n    >>> list_words_same_length(\"Test\
    \ test2 longest_word test_test test_test_test\")\n    [[\"Test\", \"test2\"],\
    \ [\"longest_word\"], [\"test_test\", \"test_test_test\"]]\n*/\nalias length_words\
    \ = string[];\nalias words_by_length = length_words[];\nimmutable words_by_length\
    \ list_words_same_length(string sentence) \n{\n    string[] words = split(sentence);\n\
    \    length_words[] list_words;\n    int i = 0;\n    foreach(word; words)\n  \
    \  {\n        if(list_words.length <= word.length)\n        {\n            list_words\
    \ ~= repeat(length_words.init, word.length - list_words.length + 1);\n       \
    \ }\n        list_words[word.length] ~= word;\n    }\n    return filter!(a =>\
    \ a.length > 0)(list_words);\n}\n/*\n    Given a number, list all the factors\
    \ of that number\n    >>> list_factors(60)\n    [1, 2, 3, 4, 5, 6, 10, 12, 15,\
    \ 20, 30, 60]\n*/", "{\n    import std.string : split;\n    import std.range :\
    \ filter;\n    import std.math : isPrime;\n    string[] words = sentence.split(\"\
    \ \");\n    return words.filter!isPrime.join(\" \");\n}", "{\n    auto words =\
    \ split(sentence, ' ');\n    auto primes = filter!(x => isPrime(x))(map!(w =>\
    \ w.length)(words));\n    return join(filter!(x => primes.canFind(x.length))(words),\
    \ \" \");\n}", "{\n    immutable prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    string[] s\
    \ = sentence.split();\n    string ans = \"\";\n    foreach(p; s)\n    {\n    \
    \    foreach(q; prime)\n        {\n            if(p.length == q)\n           \
    \ {\n                ans ~= p;\n                ans ~= \" \";\n            }\n\
    \        }\n    }\n    return ans.strip();\n}", "{\n    string[] words = sentence.split(\"\
    \ \");\n    string[] prime_words;\n    foreach(string word; words)\n    {\n  \
    \      if(isPrime(word.length))\n        {\n            prime_words ~= word;\n\
    \        }\n    }\n    return prime_words.join(\" \");\n}", "{\n    import std.algorithm\
    \ : filter, map;\n    import std.array : array;\n    import std.math : isPrime;\n\
    \    import std.typecons : tuple;\n    import std.range : takeWhile;\n    import\
    \ std.string : strip;\n    \n    sentence = sentence.strip();\n    auto all_words\
    \ = sentence.split(\" \");\n    auto word_lens = all_words.map!(w => w.length).array;\n\
    \    auto is_prime = word_lens.filter!(w => isPrime(w));\n    auto word_index\
    \ = word_lens.takeWhile!(w => w == is_prime[0]).length;\n    return all_words[word_index\
    \ .. all_words.length].array.join(\" \");\n}", "{\n    import std.conv;\n    import\
    \ std.string;\n    import std.array;\n    import std.algorithm;\n    import std.range;\n\
    \    bool isPrime(size_t n)\n    {\n        if (n < 2)\n            return false;\n\
    \        if (n == 2)\n            return true;\n        else if (n % 2 == 0)\n\
    \            return false;\n        else\n        {\n            for (size_t i\
    \ = 3; i <= ceil(sqrt(n)); i++)\n            {\n                if (n % i == 0)\n\
    \                    return false;\n            }\n            return true;\n\
    \        }\n    }\n    return join(map!(a => a[1])(filter!(a => isPrime(a[1].length))(zip(iota(0),split(sentence,\
    \ \" \")))));\n}", "{\n    // Get words from sentence\n    auto words = split(sentence,\
    \ \" \");\n    // Initialize empty string to store words of prime length\n   \
    \ string prime_words = \"\";\n    // If a word length is prime, then prime_words\
    \ += current word\n    foreach(word; words) {\n        if(word.length.isPrime)\
    \ {\n            prime_words ~= word ~ \" \";\n        }\n    }\n    // Remove\
    \ last space\n    prime_words = prime_words[0..prime_words.length-1];\n    return\
    \ prime_words;\n}", "{\n    bool is_prime(int n)\n    {\n        if (n <= 1) return\
    \ false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n\
    \        foreach (i; 3..n)\n        {\n            if (n % i == 0)\n         \
    \       return false;\n        }\n        return true;\n    }\n    string[] tokens\
    \ = split(sentence, \" \");\n    string result = \"\";\n    foreach (token; tokens)\n\
    \    {\n        if (is_prime(token.length))\n            result ~= token ~ \"\
    \ \";\n    }\n    return result.trimRight();\n}", "{\n\tauto words = split(sentence,\
    \ \" \");\n\tauto result = \"\";\n\tauto size = words.length;\n\tfor (int i =\
    \ 0; i < size; i++) {\n\t\tauto word = words[i];\n\t\tif (isPrime(word.length))\n\
    \t\t\tresult ~= word ~ \" \";\n\t}\n\treturn result.trimRight();\n}", "{\n   \
    \ string[] words = sentence.split(\" \");\n    immutable uint[] prime_lengths\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    bool is_prime = false;\n    string new_sentence =\
    \ \"\";\n    foreach(w; words)\n    {\n        is_prime = false;\n        foreach(prime;\
    \ prime_lengths)\n        {\n            if(w.length == prime)\n            {\n\
    \                is_prime = true;\n                break;\n            }\n   \
    \     }\n        if(is_prime)\n        {\n            new_sentence ~= w ~ \" \"\
    ;\n        }\n    }\n    return new_sentence.strip();\n}", "{\n    immutable is_prime\
    \ = isPrime;\n    immutable split_to_words = split;\n    auto primes = filter!(is_prime)(map!(length)(split_to_words(sentence)));\n\
    \    return \"\".join(map!((a, b) => a ~ \" \" ~ b)(split_to_words(sentence))(primes));\n\
    }", "{\n    string[] words = sentence.split();\n    string result = \"\";\n  \
    \  foreach(string word; words)\n    {\n        if(!isPrimeNumber(word.length))\n\
    \            continue;\n        result ~= word ~ \" \";\n    }\n    return result.trimRight();\n\
    }", "{\n    string[] words = split(sentence, \" \");\n    string result = \"\"\
    ;\n    foreach(w; words)\n    {\n        int word_length = w.length;\n       \
    \ int flag = 1;\n        if(word_length > 1)\n        {\n            for(int i\
    \ = 2; i <= word_length / 2; ++i)\n            {\n                if(word_length\
    \ % i == 0)\n                {\n                    flag = 0;\n              \
    \      break;\n                }\n            }\n        }\n        if(flag ==\
    \ 1)\n        {\n            result ~= w ~ \" \";\n        }\n    }\n    return\
    \ strip(result);\n}", "{\n    auto prime_word = [] (string word) {\n        auto\
    \ word_len = word.length;\n        auto i = 2;\n        while (i < word_len)\n\
    \        {\n            if (word_len % i == 0)\n                return false;\n\
    \            i++;\n        }\n        return true;\n    };\n    auto sentence_words\
    \ = sentence.split;\n    string[] prime_words;\n    foreach (word; sentence_words)\n\
    \    {\n        if (prime_word(word))\n            prime_words ~= word;\n    }\n\
    \    return prime_words.join(\" \");\n}", "{\n    if(!sentence.length) return\
    \ sentence;\n    string[] words = sentence.split(\" \");\n    auto is_prime =\
    \ [](int n) -> bool {\n        if(n < 2) return false;\n        if(n == 2) return\
    \ true;\n        for(int i = 2; i <= cast(int)sqrt(n); i++) if(n % i == 0) return\
    \ false;\n        return true;\n    };\n    return appender!string.joiner(\" \"\
    ).apply(words.filter!(is_prime).retro);\n}", "{\n    // init\n    string[] words\
    \ = split(sentence);\n    string[] new_words;\n    string result;\n    // check\
    \ every word\n    foreach(var word; words)\n    {\n        if(isPrime(length(word)))\n\
    \        {\n            new_words ~= word;\n        }\n    }\n    // make new\
    \ sentence\n    foreach(var word; new_words)\n    {\n        result ~= word ~\
    \ ' ';\n    }\n    // return\n    return chomp(result);\n}\n// check if num is\
    \ prime", "{\n    string[] words = split(sentence);\n    string result = \"\"\
    ;\n    foreach(word; words)\n    {\n        if(isPrime(word.length))\n       \
    \ {\n            result ~= word ~ \" \";\n        }\n    }\n    return strip(result);\n\
    }", "{\n    static import std.algorithm : filter, joiner;\n    static import std.array\
    \ : splitter;\n    static import std.math : isPrime;\n    static import std.range\
    \ : iota;\n    // first split the string by space\n    // the output of splitter\
    \ is a lazy range,\n    // so we have to force it to materialize into an array\n\
    \    auto words = sentence.splitter!((x) => x == ' ').array;\n    auto result\
    \ = iota(0, words.length)\n        .filter!(i => isPrime(words[i].length))\n \
    \       .map!(i => words[i])\n        .joiner(\" \");\n    return result;\n}",
  "{\n    bool is_prime(size_t n)\n    {\n        if (n <= 1) return false;\n    \
    \    else if (n <= 3) return true;\n        else if (n % 2 == 0 || n % 3 == 0)\
    \ return false;", "{\n    string[string] dictionary;\n    string word;\n    string\
    \ tmp;\n    foreach(i; 0 .. sentence.length)\n    {\n        if(sentence[i] ==\
    \ ' ')\n        {\n            tmp = i.to!string();\n            //writefln(\"\
    %s\\n\", tmp);\n            dictionary[word] = tmp;\n            word = \"\";\n\
    \        }\n        else\n        {\n            word ~= sentence[i];\n      \
    \  }\n    }\n    dictionary[word] = sentence.length.to!string();\n    /*\n   \
    \ foreach(i; dictionary)\n    {\n        writefln(\"%s %s\\n\", i.key, i.value);\n\
    \    }\n    */\n    string final_sentence;\n    ulong num;\n    bool isPrime;\n\
    \    foreach(i; dictionary)\n    {\n        num = i.value.to!ulong();\n      \
    \  isPrime = true;\n        foreach(j; 2 .. num)\n        {\n            if(num\
    \ % j == 0)\n            {\n                isPrime = false;\n               \
    \ break;\n            }\n        }\n        if(isPrime)\n        {\n         \
    \   final_sentence ~= i.key ~ \" \";\n        }\n    }\n    return final_sentence.stripRight;\n\
    }", "{\n    auto is_prime = [](int n) \n    {\n        if (n <= 1) \n        \
    \    return false;\n        for (int i = 2; i <= sqrt(n); i++) \n            if\
    \ (n % i == 0) \n                return false;\n        return true;\n    };\n\
    \    auto words = sentence.split(\" \");\n    auto res = \"\";\n    foreach (idx,\
    \ word; words) \n    {\n        if (is_prime(word.length)) \n            res ~=\
    \ word ~ \" \";\n    }\n    res = res.stripRight;\n    return res;\n}", "{\n \
    \   import std.algorithm;\n    import std.array;\n    import std.range;\n    import\
    \ std.stdio;\n    import std.string;\n    import std.typecons;\n    import std.math;\n\
    \    auto words = split(sentence);\n    return join(words.filter!(w => w.length.isPrime));\n\
    }", "{\n    // `words` is an array of `std.array.array`s\n    auto words = sentence.split(\"\
    \ \");\n    // `clean_words` is an array of the words whose lengths are prime\
    \ numbers.\n    auto clean_words = words.map!(\n    w => w.length.isPrime()? w\
    \ : \"\");\n    // `words_sentence` is a string.\n    auto words_sentence = clean_words.join(\"\
    \ \");\n    return words_sentence;\n}", "{\n    import std.algorithm;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.array;\n    import std.range;\n\
    \    import std.typecons;\n    import std.conv;\n    import std.math;\n    import\
    \ std.bigint;\n    import std.array;\n    import std.range;\n    import std.typecons;\n\
    \    import std.conv;\n    import std.math;\n    import std.bigint;\n    auto\
    \ is_prime = false;\n    string result = \"\";\n    auto sentence_splitted = sentence.split(\"\
    \ \");\n    foreach(word; sentence_splitted)\n    {\n        is_prime = word.length\
    \ > 2 && word.length < 100 && !word.any!(a => word.length % a == 0 && a != 1 &&\
    \ a != word.length);\n        result ~= (is_prime && word.length > 2) ? word +\
    \ \" \" : \"\";\n    }\n    return result.trimRight();\n}", "{\n    immutable\
    \ primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97];\n    auto words = split(sentence, \" \");\n   \
    \ string prime_words = \"\";\n    for (uint i = 0; i < words.length; i++) {\n\
    \        if (words[i].length in primes) {\n            prime_words ~= words[i]\
    \ ~ \" \";\n        }\n    }\n    return prime_words;\n}", "{\n    auto words\
    \ = split(sentence);\n    string result;\n    foreach(word; words) {\n       \
    \ if(isPrime(word.length)) {\n            result ~= word ~= \" \";\n        }\n\
    \    }\n    return strip(result);\n}", "{\n\tstring[] words = sentence.split(\"\
    \ \");\n\tstring result = \"\";\n\tforeach(word; words)\n\t{\n\t\tint count =\
    \ 0;\n\t\tfor(int i = 1; i <= word.length; i++)\n\t\t{\n\t\t\tif(word.length %\
    \ i == 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count == 2)\n\t\t\
    {\n\t\t\tresult = result ~ word ~ \" \";\n\t\t}\n\t}\n\treturn result.stripRight;\n\
    }", "{\n    string result;\n    string[] words = split(sentence, \" \");\n   \
    \ foreach(word; words)\n    {\n        if(isPrime(word.length))\n        {\n \
    \           result ~= word ~ \" \";\n        }\n    }\n    return result;\n}",
  "{\n    auto words = split(sentence, \" \");\n    auto primes = [](long n) {\n \
    \       enum bool is_prime = true;\n        foreach (i; 2 .. trunc(sqrt(n)) +\
    \ 1) {\n            if (n % i == 0) {\n                is_prime = false;\n   \
    \             break;\n            }\n        }\n        return is_prime;\n   \
    \ };\n    string result = \"\";\n    foreach (word; words) {\n        if (primes(word.length))\
    \ {\n            result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight;\n\
    }", "{\n    import std.algorithm : filter, map;\n    import std.array : array;\n\
    \    import std.math : isPrime;\n    import std.range : take;\n    import std.string\
    \ : split;\n    import std.typecons : tuple;\n    \n    immutable string[] words\
    \ = sentence.split(\" \");\n    return words\n            .filter!(w => w.length.isPrime())\n\
    \            .join(\" \");\n}", "{\n    // TODO: complete this function\n    return\
    \ \"\";\n}\nstatic assert(words_in_sentence(\"This is a test\") == \"is\");\n\
    static assert(words_in_sentence(\"lets go for swimming\") == \"go for\");\n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", "{\n    string[] words\
    \ = split(sentence);\n    string[] result;\n    foreach(word; words)\n    {\n\
    \        if(isPrime(word.length))\n        {\n            result ~= word;\n  \
    \      }\n    }\n    return result.join(\" \");\n}", "{\n    // Store all words\
    \ in the sentence\n    auto words = split(sentence, \" \");\n    // Store the\
    \ resulting string that contains only words with prime length\n    string result\
    \ = \"\";\n    // For each word in words\n    foreach(index, word; words) {\n\
    \        // If the length of the word is prime\n        if(isPrime(word.length))\n\
    \            // Add it to the result\n            result ~= word ~ \" \";\n  \
    \  }\n    // Return the result without the trailing space\n    return chomp(result);\n\
    }", "{\n    string[] words = split(sentence);\n    string[] prime_words;\n   \
    \ string output;\n    bool is_prime = true;\n    foreach(word; words)\n    {\n\
    \        is_prime = true;\n        if(word.length() == 1)\n        {\n       \
    \     is_prime = false;\n        }\n        else\n        {\n            foreach(i;\
    \ 2..word.length())\n            {\n                if(word.length() % i == 0)\n\
    \                {\n                    is_prime = false;\n                  \
    \  break;\n                }\n            }\n        }\n        if(is_prime)\n\
    \        {\n            prime_words ~= word;\n        }\n    }\n    foreach(word;\
    \ prime_words)\n    {\n        output ~= word ~ \" \";\n    }\n    output = output.length()\
    \ == 0 ? \"\" : output[0..$-1];\n    return output;\n}", "{\n    string[] words\
    \ = split(sentence);\n    string result = \"\";\n    foreach(string word; words)\n\
    \    {\n        auto length = to!int(word.length);\n        if(isPrime(length))\n\
    \        {\n            result ~= word ~ \" \";\n        }\n    }\n    return\
    \ result.stripRight;\n}", "{\n    return sentence.split()\n        .filter!(i\
    \ => isPrime(i.length))\n        .joiner(\" \");\n}", "{\n    import std.algorithm;\n\
    \    import std.range;\n    import std.typecons;\n    import std.math;\n    string[]\
    \ words = sentence.split;\n    string[] result = words.filter!(w => w.length.isPrime()).join(\"\
    ,\");\n    return result;\n}", "{\n    import std.algorithm : filter, map;\n \
    \   import std.array : array;\n    import std.range : chain, iota;\n    import\
    \ std.conv : to;\n    import std.math : isPrime;\n    import std.typecons : tuple;\n\
    \    import std.stdio : writeln;\n    \n    auto words = sentence.split();\n \
    \   auto filtered = words.filter!(word =>\n    {\n        size_t length = word.length;\n\
    \        return length != 0 && length != 1 && isPrime(length);\n    });\n    return\
    \ filtered.join(\" \");\n}", "{\n    auto words = split(sentence, ' ');\n    return\
    \ join(filter!((w) { return w.length.isPrime(); })(words), ' ');\n}", "{\n   \
    \ alias const_array = immutable(string[]);\n    auto is_prime = (int i) {\n  \
    \      if (i <= 1) return false;\n        if (i == 2) return true;\n        for\
    \ (int j = 2; j < i; j++)\n            if (i % j == 0) return false;\n       \
    \ return true;\n    };\n    auto to_words = (string str) {\n        const_array\
    \ result;\n        foreach (word; str.split(\" \")) {\n            if (is_prime(word.length))\n\
    \                result ~= word;\n        }\n        return result;\n    };\n\
    \    return to_words(sentence).join(\" \");\n}", "{\n    string [] arr = sentence.split(\"\
    \ \");\n    string result = \"\";\n    foreach(i; 0 .. arr.length)\n    {\n  \
    \      if(isPrime(arr[i].length))\n        {\n            result ~= arr[i] ~ \"\
    \ \";\n        }\n    }\n    return result.trim();\n}", "{\n    auto nums = filter!(x\
    \ => isPrime(x.length))(sentence.split);\n    return joiner(nums, \" \");\n}",
  "{\n    auto primes = [](int n) \n    {\n        int[] result;\n        for (int\
    \ i = 2; i <= n; i++) \n        {\n            bool is_prime = true;\n       \
    \     for (int j = 2; j < i; j++) \n            {\n                if (i % j ==\
    \ 0) \n                {\n                    is_prime = false;\n            \
    \        break;\n                }\n            }\n            if (is_prime) \n\
    \            {\n                result ~= i;\n            }\n        }\n     \
    \   return result;\n    }\n    auto words = sentence.split(\" \");\n    int[]\
    \ prime_len = primes(20);\n    string res = \"\";\n    foreach (word; words) \n\
    \    {\n        if (prime_len.canFind(word.length)) \n        {\n            res\
    \ ~= word ~ \" \";\n        }\n    }\n    return res.trimRight();\n}", "{\n  \
    \  int i = 0;\n    string result = \"\";\n    string temp = \"\";\n    auto words\
    \ = new string[sentence.length];\n    for (size_t j = 0; j < sentence.length;\
    \ j++)\n    {\n        words[j] = \"\";\n    }\n    foreach (c; sentence)\n  \
    \  {\n        if (c == ' ')\n        {\n            i++;\n        }\n        else\n\
    \        {\n            words[i] ~= c;\n        }\n    }\n    i++;\n    for (int\
    \ j = 0; j < i; j++)\n    {\n        temp = words[j];\n        int n = temp.length;\n\
    \        bool flag = true;\n        for (int k = 2; k <= n / 2; k++)\n       \
    \ {\n            if (n % k == 0)\n            {\n                flag = false;\n\
    \                break;\n            }\n        }\n        if (flag)\n       \
    \ {\n            result ~= temp ~ \" \";\n        }\n    }\n    return result;\n\
    }", "{\n    struct is_prime\n    {\n        bool opCall(int i)\n        {\n  \
    \          if (i <= 1)\n                return false;\n            for (int j\
    \ = 2; j <= sqrt(i); j++)\n                if (i % j == 0)\n                 \
    \   return false;\n            return true;\n        }\n    } is_prime;\n    \n\
    \    auto data = map!(a => a.idup, sentence.split);\n    string result;\n    foreach\
    \ (word; data)\n    {\n        if (is_prime(word.length))\n            result\
    \ ~= word ~ \" \";\n    }\n    return result.stripRight;\n}", "{\n    auto words\
    \ = split(sentence);\n    return join(filter!(w => isPrime(w.length))(words));\n\
    }", "{\n    string[] words = split(sentence, \" \");\n    string result = \"\"\
    ;\n    foreach(word; words)\n    {\n        if(isPrime(word.length))\n       \
    \ {\n            if(result.length != 0)\n                result ~= \" \";\n  \
    \          result ~= word;\n        }\n    }\n    return result;\n}", "{\n   \
    \ string[] splitSentence = split(sentence, \" \");\n    string result = \"\";\n\
    \    foreach(i, word; splitSentence)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            result ~= word ~ \" \";\n        }\n    }\n    return\
    \ result;\n}", "{\n    bool[] is_prime = new bool[sentence.length + 1];\n    is_prime[0]\
    \ = false;\n    is_prime[1] = false;\n    is_prime[2] = true;\n    for (int i\
    \ = 3; i < is_prime.length; i++)\n    {\n        if (i % 2 == 0)\n        {\n\
    \            is_prime[i] = false;\n        }\n        else\n        {\n      \
    \      bool is = true;\n            for (int j = 3; j < i / 2; j++)\n        \
    \    {\n                if (i % j == 0)\n                {\n                 \
    \   is = false;\n                    break;\n                }\n            }\n\
    \            is_prime[i] = is;\n        }\n    }\n    string result = \"\";\n\
    \    foreach (word; sentence.split(\" \"))\n    {\n        if (is_prime[word.length])\n\
    \        {\n            result ~= word ~ \" \";\n        }\n    }\n    return\
    \ result.rstrip();\n}", "{\n    auto words = split(sentence, \" \");\n    bool[]\
    \ is_prime = new bool[words.length];\n    foreach (word; words)\n    {\n     \
    \   is_prime[] = word.length.isPrime;\n    }\n    string result = filter!((word,\
    \ b) => b)(words, is_prime).join(\" \");\n    return result;\n}", "{\n    string\
    \ sentenceList[] = sentence.split(\" \");\n    string result = \"\";\n    foreach(i,\
    \ e; sentenceList)\n    {\n        if(isPrime(e.length))\n        {\n        \
    \    result ~= e ~ \" \";\n        }\n    }\n    return result.strip();\n}\n \n\
    /*\n    This function taken from https://stackoverflow.com/questions/12472573/how-to-test-if-a-number-is-prime-or-not-in-d\n\
    */", "{\n    // convert sentence to array of words\n    auto words = sentence.split;\n\
    \    // create a new string\n    string output;\n    // loop through each word\n\
    \    foreach(word; words)\n    {\n        // check if the length of the word is\
    \ a prime number\n        if(isPrime(word.length))\n        {\n            //\
    \ if it is, add it to the new string\n            output ~= word ~ \" \";\n  \
    \      }\n    }\n    // return new string\n    return output.idup;\n}", "{\n \
    \   import std.string : split;\n    auto words = sentence.split(\" \");\n    auto\
    \ new_sentence = \"\";\n    foreach(word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            new_sentence ~= word ~ \" \";\n        }\n    }\n    return\
    \ new_sentence;\n}", "{\n    string[] words = split(sentence);\n    string[] result;\n\
    \    foreach(word; words) {\n        if(isPrime(word.length)) {\n            result\
    \ ~= word;\n        }\n    }\n    return join(result, \" \");\n}\n ", "{\n   \
    \ import std.algorithm : filter, map;\n    auto words = sentence.split(\" \");\n\
    \    auto is_prime = (int n) => n > 1 && !([2 .. n - 1].filter!(j => n % j ==\
    \ 0).length);\n    auto primes = words.filter!(word => is_prime(word.length));\n\
    \    return primes.map!(a => a ~ \" \").joiner;\n}", "{\n    // set of primes\n\
    \    int[] primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 ];\n    string result = \"\";\n\
    \    // split\n    auto words = sentence.split;\n    foreach( word; words )\n\
    \    {\n        if( primes.count( word.length ) != 0 )\n        {\n          \
    \  result ~= \" \" ~ word;\n        }\n    }\n    // remove first space\n    return\
    \ result[1..$];\n}", "{\n    int[] words = split(sentence);\n    string output\
    \ = \"\";\n    foreach( int i; words )\n    {\n        int len = i.length;\n \
    \       if( isPrime(len) )\n        {\n            output ~= i ~= \" \";\n   \
    \     }\n    }\n    return output;\n}", "{\n\tstring[] words = sentence.split(\"\
    \ \");\n\tstring result = \"\";\n\tfor (int i = 0; i < words.length; i++)\n\t\
    {\n\t\tint count = 0;\n\t\tint length = words[i].length;\n\t\tfor (int j = 1;\
    \ j <= length; j++)\n\t\t{\n\t\t\tif (length % j == 0)\n\t\t\t{\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t\tif (count == 2)\n\t\t{\n\t\t\tresult += words[i] + \" \";\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    string[] words = split(sentence, \"\
    \ \");\n    string result = \"\";\n    for (int i = 0; i < words.length; i++)\n\
    \    {\n        if (isPrime(words[i].length))\n        {\n            result ~=\
    \ \" \" ~ words[i];\n        }\n    }\n    return result.trim;\n}", "{\n    string\
    \ result;\n    auto words = split(sentence, \" \");\n    foreach(word; words)\n\
    \    {\n        if(isPrime(word.length))\n        {\n            result ~= word\
    \ ~ \" \";\n        }\n    }\n    return result.stripRight();\n}", "{\n    /*\n\
    \        1. split the sentence by space and store it in a sequence\n        2.\
    \ if the length of the word is prime number,\n            then store the word\
    \ in a string\n        3. return the final string\n    */\n    int n = sentence.length;\n\
    \    string finalString = \"\";\n    string[] splitted = sentence.split(\" \"\
    );\n    foreach(it; splitted)\n    {\n        if(isPrime(it.length))\n       \
    \ {\n            finalString ~= it;\n            finalString ~= \" \";\n     \
    \   }\n    }\n    return finalString.idup;\n}", "{\n    auto is_prime = [](auto\
    \ n) -> bool {\n        if (n < 2)\n            return false;\n        for (auto\
    \ i = 2; i < n; ++i)\n            if (n % i == 0)\n                return false;\n\
    \        return true;\n    };\n    auto count_words = [](auto c) -> size_t {\n\
    \        size_t res = 0;\n        while (c) {\n            ++res;\n          \
    \  c = c & (c - 1);\n        }\n        return res;\n    };\n    auto sentence_prime_sum\
    \ = [&](auto sentence) -> size_t {\n        size_t res = 0;\n        for (size_t\
    \ i = 0; i < sentence.length(); ++i)\n            res += count_words(sentence[i]);\n\
    \        return res;\n    };\n    size_t pos = 0;\n    size_t prime_sum = 0;\n\
    \    size_t prime_start = 0;\n    size_t prime_end = 0;\n    size_t start = 0;\n\
    \    size_t end = 0;\n    for (size_t i = 0; i < sentence.length(); ++i) {\n \
    \       if (sentence[i] == ' ') {\n            if (pos - start == 1) {\n     \
    \           prime_sum += count_words(sentence[i - 1]);\n                prime_end\
    \ = i - 1;\n            }\n            if (is_prime(pos - start)) {\n        \
    \        if (prime_sum < pos - start) {\n                    prime_sum = pos -\
    \ start;\n                    prime_start = start;\n                    prime_end\
    \ = i - 1;\n                }\n            }\n            start = i + 1;\n   \
    \     }\n        ++pos;\n    }\n    if (pos - start == 1) {\n        prime_sum\
    \ += count_words(sentence[pos - 1]);\n        prime_end = pos - 1;\n    }\n  \
    \  if (is_prime(pos - start)) {\n        if (prime_sum < pos - start) {\n    \
    \        prime_sum = pos - start;\n            prime_start = start;\n        \
    \    prime_end = pos - 1;\n        }\n", "{\n    string[] words = split(sentence);\n\
    \    string[] primes;\n    foreach(string word; words)\n    {\n        if(isPrime(word.length))\n\
    \            primes ~= word;\n    }\n    return join(primes, \" \");\n}", "{\n\
    \    int[] primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n    string[] words = sentence.split(\"\
    \ \");\n    string[] result;\n    foreach(word; words)\n    {\n        bool isPrime\
    \ = false;\n        foreach(prime; primes)\n        {\n            if(word.length\
    \ == prime)\n            {\n                isPrime = true;\n                break;\n\
    \            }\n        }\n        if(isPrime)\n        {\n            result\
    \ ~= word;\n        }\n    }\n    return result.join(\" \");\n}", "{\n    bool\
    \ is_prime(int n) \n    {\n        for (int i = 2; i < n; i++)\n            if\
    \ (n % i == 0)\n                return false;\n        return true;\n    }\n \
    \   string[] words = std.string.split(sentence, \" \");\n    string res = \"\"\
    ;\n    foreach (w; words) \n    {\n        if (is_prime(w.length))\n         \
    \   res ~= w ~ \" \";\n    }\n    return res[0..$-1];\n}", "{\n    import std.conv\
    \ : to;\n    import std.range : map, filter, joiner;\n    import std.algorithm\
    \ : only;\n    import std.math : isPrime;\n    return sentence.split(\" \")\n\
    \                   .filter!(w => w.length.isPrime)\n                   .joiner(\"\
    \ \")\n                   .only;\n}\n ", "{\n    string result;\n    for (auto\
    \ word : sentence.split())\n    {\n        static int[] primes = generatePrimes!(ushort)();\n\
    \        static bool[] isPrime = primes.map!(p => true).array;\n        if (isPrime[word.length])\n\
    \            result ~= (result.length == 0 ? \"\" : \" \") ~ word;\n    }\n  \
    \  return result;\n}", "{\n    // TODO: remove this stub and implement the function\n\
    \    return \"\";\n}", "{\n\tauto words = split(sentence, \" \");\n\t\n\tstring\
    \ result;\n\t\n\tforeach(word; words)\n\t{\n\t\tint number = to!int(word);\n\t\
    \tif(isPrime(number)) result ~= word ~ \" \";\n\t}\n\t\n\treturn result.idup;\n\
    }", "{\n    import std.algorithm;\n    import std.range;\n    import std.conv;\n\
    \    import std.stdio;\n    //import std.math;\n    string[] words = sentence.split;",
  "{\n    immutable PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    string[] words = split(sentence);\n\
    \    string res = \"\";\n    foreach(word; words)\n    {\n        if(word.length.canFind(PRIMES))\n\
    \        {\n            res ~= word ~ \" \";\n        }\n    }\n    return res.trim();\n\
    }", "{\n    import std.array;\n    import std.string;\n    import std.math;\n\
    \    import std.typecons;\n    import std.conv;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.functional;\n    import std.stdio;\n    import\
    \ std.algorithm;\n    import std.conv;\n    // \u041F\u043E\u043B\u0443\u0447\u0430\
    \u0435\u043C \u0438\u0437 \u0441\u0442\u0440\u043E\u043A\u0438 \u043C\u0430\u0441\
    \u0441\u0438\u0432 \u0441\u043B\u043E\u0432\n    auto arr_str = split(sentence,\
    \ \" \");\n    // \u041F\u043E\u043B\u0443\u0447\u0430\u0435\u043C \u0438\u0437\
    \ \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u0441\u043B\u043E\u0432 \u043C\u0430\
    \u0441\u0441\u0438\u0432 \u0434\u043B\u0438\u043D \u0441\u043B\u043E\u0432\n \
    \   auto arr_len = arr_str.map!(w=>w.length).array;\n    // \u0414\u0435\u043B\
    \u0430\u0435\u043C \u043C\u0430\u0441\u0441\u0438\u0432 \u043F\u0440\u043E\u0441\
    \u0442\u044B\u0445 \u0447\u0438\u0441\u0435\u043B\n    auto pms = iota(2, 10000).filter!(isPrime).array;\n\
    \    // \u0412\u044B\u0431\u0438\u0440\u0430\u0435\u043C \u0438\u0437 \u043C\u0430\
    \u0441\u0441\u0438\u0432\u0430 \u0434\u043B\u0438\u043D \u0441\u043B\u043E\u0432\
    \ \u0442\u0435, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0435\u0441\u0442\u044C\
    \ \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\u0435 \u043F\u0440\u043E\u0441\u0442\
    \u044B\u0445 \u0447\u0438\u0441\u0435\u043B\n    auto ids = arr_len.filter!(a=>pms.canFind(a)).array;\n\
    \    // \u0412\u044B\u0431\u0438\u0440\u0430\u0435\u043C \u0438\u0437 \u043C\u0430\
    \u0441\u0441\u0438\u0432\u0430 \u0441\u043B\u043E\u0432 \u0442\u0435, \u043A\u043E\
    \u0442\u043E\u0440\u044B\u0435 \u0435\u0441\u0442\u044C \u0432 \u043C\u0430\u0441\
    \u0441\u0438\u0432\u0435 \u0438\u043D\u0434\u0435\u043A\u0441\u043E\u0432\n  \
    \  auto arr_res = arr_str.filter!(a=>ids.canFind(a.length)).array;\n    // \u0412\
    \u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u0441\u0442\u0440\u043E\
    \u043A\u0443 \u0438\u0437 \u043C\u0430\u0441\u0441\u0438\u0432\u0430\n    return\
    \ arr_res.joiner(\" \");\n}", "{\n    immutable primes = [2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    string[] words = split(sentence, \" \");\n    string res = \"\";\n    for\
    \ (size_t i = 0; i < words.length; i++) {\n        if (primes.contains(words[i].length))\
    \ {\n            res ~= \" \" ~ words[i];\n        }\n    }\n    return res[1..$];\n\
    }", "{\n    // List of Prime Numbers less than 100\n    List!(uint) prime_numbers\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    string[] words = split(sentence, \" \");\n    string\
    \ res = \"\";\n    foreach(word; words)\n    {\n        if(prime_numbers.canFind(word.length))\n\
    \        {\n            if(res.length == 0)\n                res ~= word;\n  \
    \          else\n                res ~= \" \" ~ word;\n        }\n    }\n    return\
    \ res;\n}", "{\n    string[] words = split(sentence, \" \");\n    string result\
    \ = \"\";\n    foreach(i, word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            result ~= \" \" ~ word;\n        }\n    }\n    return\
    \ result[1..$];\n}", "{\n    immutable primes = [2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    immutable\
    \ words = split(sentence, \" \");\n    auto new_sentence = words.filter!(x =>\
    \ primes.canFind(x.length));\n    return join(new_sentence, \" \");\n}", "{\n\
    \    auto words = split(sentence);\n    string result;\n    foreach(word; words)\n\
    \    {\n        if(isPrime(word.length))\n        {\n            result ~= \"\
    \ \" ~ word;\n        }\n    }\n    return result.trim();\n}", "{\n    auto words\
    \ = split(sentence, \" \");\n    auto w2 = filter!((w) => isPrime(w.length)).joiner(\"\
    \ \").join(words);\n    return w2;\n}", "{\n    string[] words = split(sentence,\
    \ \" \");\n    string[] result = \"\";\n    foreach(string word; words)\n    {\n\
    \        if(isPrime(word.length))\n        {\n            result ~= word;\n  \
    \      }\n    }\n    return join(result, \" \");\n}", "{\n    // We split the\
    \ string sentence into words\n    import std.conv : to;\n    auto words = sentence.split(\"\
    \ \");\n    // We iterate through the list of words\n    string result;\n    foreach(index,\
    \ word; words)\n    {\n        // We get the number of letter in each word\n \
    \       auto word_len = word.length;\n        // We check if the number of letters\
    \ is a prime number\n        bool prime = true;\n        if(word_len == 1)\n \
    \       {\n            prime = false;\n        }\n        else if(word_len ==\
    \ 2)\n        {\n            prime = true;\n        }\n        else\n        {\n\
    \            foreach(number; 2..word_len-1)\n            {\n                if(word_len\
    \ % number == 0)\n                {\n                    prime = false;\n    \
    \                break;\n                }\n            }\n        }\n       \
    \ // If yes we add it to the result string\n        if(prime)\n        {\n   \
    \         result ~= word ~ \" \";\n        }\n    }\n    // We return the result\
    \ string\n    return result;\n}", "{\n    string result;\n    string[] words =\
    \ split(sentence, \" \");\n    foreach(word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            result ~= word ~ \" \";\n        }\n    }\n    if(result.length\
    \ > 0)\n    {\n        result = result[0..$-1];\n    }\n    return result;\n}",
  "{\n    auto words = sentence.split(\" \");\n    string result;\n    foreach(auto\
    \ word; words)\n    {\n        if(isPrime(word.length))\n        {\n         \
    \   result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight();\n\
    }", "{\n    auto words = sentence.split(\" \");\n    auto result = words.filter!(a\
    \ => (a.length isPrime));\n    return result.join(\" \");\n}", "{\n    static\
    \ bool[] is_prime = { false, false, true, true, false, true, false, true, false,\
    \ false, false, true, false, true, false, false, false, true, false, true, false,\
    \ false, false, true, false, false, false, false, false, true, false, true, false,\
    \ false, false, false, false, false, true, false, true, false, false, false, false,\
    \ false, false, false, false, false, true, false, true, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, true, false, true, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, true, false, true, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, true, false, true, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, true, false, true, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, true, false, true, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, true, false, true, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ true, false, true, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false,", "{\n\
    \    string[] words = split(sentence, \" \");\n    string result = \"\";\n   \
    \ foreach(word; words)\n    {\n        if(word.length.isPrime)\n        {\n  \
    \          result ~= word ~ \" \";\n        }\n    }\n    return result.trim;\n\
    }", "{\n    import std.algorithm : map, filter, joiner;\n    import std.math :\
    \ isPrime;\n    import std.typecons : Tuple;\n    import std.range : take;\n \
    \   import std.array : array;\n    import std.ascii : isAlpha;\n    import std.conv\
    \ : to;\n    import std.regex : split;\n    import std.range : join;\n    import\
    \ std.iterator : filter;\n    auto words = sentence.split(\" \");\n    auto word_pairs\
    \ = words.map!(word => Tuple!(int,string)(word.length, word));\n    auto word_pairs_prime\
    \ = word_pairs.filter!(pair => isPrime(pair[0]));\n    return word_pairs_prime.map!(pair\
    \ => pair[1]).joiner(\" \").array.take(20).join(\" \");\n}", "{\n    immutable\
    \ words = split(sentence);\n    immutable primes = [2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    immutable\
    \ is_prime = unaryFun!(\"isPrimeNumber\")(words);\n    immutable select_prime\
    \ = words.byKey(is_prime);\n    return select_prime.join(\" \");\n}", "{\n   \
    \ import std.algorithm : filter, map;\n    import std.range : splitter;\n    import\
    \ std.conv : to;\n    import std.typecons : Tuple;\n    import std.typecons :\
    \ isPrime;\n    // import std.algorithm : sort;\n    auto words = sentence.splitter(\"\
    \ \");\n    string result;\n    foreach(word; words.filter!(x => x.length.isPrime()).map!(x\
    \ => Tuple!(size_t, string)(x.length, x))) {\n        // result ~= word[1] ~ \"\
    \ \";\n        // result.sort();\n        result ~= word[1] ~ \" \";\n    }\n\
    \    return result;\n}", "{\n    import std.math, std.algorithm, std.array, std.range,\
    \ std.string;\n    string[] words = sentence.split;\n    int[] lengths = words.map!(w\
    \ => w.length).array;\n    lengths.retain!(l => isPrime(l));\n    return lengths.map!(l\
    \ => words[l]).join(\" \");\n}\nunittest\n{\n    assert(words_in_sentence(\"This\
    \ is a test\") == \"is\");\n    assert(words_in_sentence(\"lets go for swimming\"\
    ) == \"go for\");\n}\n \n \n \n/*", "{\n    string[] words = split(sentence);\n\
    \    string new_sentence = \"\";\n    foreach(word; words)\n    {\n        if(is_prime(word.length))\n\
    \        {\n            new_sentence ~= word ~ \" \";\n        }\n    }\n    return\
    \ new_sentence;\n}", "{\n    string[] words = split(sentence, \" \");\n    string[]\
    \ result;\n    foreach(word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            result ~= word;\n        }\n    }\n    return result.length\
    \ ? join(result, \" \") : null;\n}", "{\n    string[] words = split(sentence,\
    \ \" \");\n    string[] primes = filter!((in word) { return word.length.isPrime;\
    \ })(words);\n    return join(primes, \" \");\n}", "{\n    string[] words = split(sentence,\
    \ \" \");\n    string res = \"\";\n    foreach(elem; words) {\n        if(isPrime(elem.length))\
    \ {\n            res ~= elem ~ \" \";\n        }\n    }\n    return res.stripRight;\n\
    }", "{\n    string new_str;\n    auto w = split(sentence, \" \");\n    int l;\n\
    \    // iterate over words\n    foreach(w_elem; w)\n    {\n        l = w_elem.length;\n\
    \        bool isPrime = true;\n        // iterate over numbers\n        foreach(n;\
    \ 2..l)\n        {\n            if(l % n == 0)\n            {\n              \
    \  isPrime = false;\n                break;\n            }\n        }\n      \
    \  if(isPrime)\n        {\n            new_str ~= \" \" ~ w_elem;\n        }\n\
    \    }\n    return new_str.strip;\n}\n/*\n    Title: Maximum number of non-overlapping\
    \ segments", "{\n    int[] sentences = split(sentence, \" \");\n    string prime_words;\n\
    \    foreach(sentence; sentences)\n    {\n        if(isPrime(sentence.length))\n\
    \        {\n            writeln(sentence);\n            prime_words ~= sentence\
    \ ~ \" \";\n        }\n    }\n    return prime_words.stripRight();\n}", "{\n \
    \   string result = \"\";\n    string[] words = split(sentence, \" \");\n    foreach(word;\
    \ words)\n    {\n        if(isPrime(word.length))\n        {\n            if(result.length\
    \ == 0)\n                result = word;\n            else\n                result\
    \ ~= \" \" ~ word;\n        }\n    }\n    return result;\n}", "{\n    auto words\
    \ = split(sentence);\n    string result;\n    foreach( word; words )\n    {\n\
    \        if(isPrime(word.length))\n        {\n            result ~= word ~ \"\
    \ \";\n        }\n    }\n    return result;\n}", "{\n    import std.conv : to;\n\
    \    import std.algorithm : filter, map;\n    import std.math : isPrime;\n   \
    \ import std.typecons : tuple;\n    import std.range : zip;\n    auto words =\
    \ sentence.split(\" \");\n    auto wordLengths = words.map!(w => w.length);\n\
    \    auto isNotPrime = wordLengths.filter!(l => !isPrime(l));\n    auto primeLengths\
    \ = wordLengths.filter!(l => isPrime(l));\n    auto indices = isNotPrime.map!(l\
    \ => wordLengths.indexOf(l));\n    return words.zip(wordLengths).filter!(t =>\
    \ !isNotPrime.canFind(t[1])).map!(t => t[0]).joiner(\" \");\n}", "{\n    bool[]\
    \ is_prime = false;\n    is_prime[2] = true;\n    is_prime[3] = true;\n    is_prime[5]\
    \ = true;\n    is_prime[7] = true;\n    is_prime[11] = true;\n    is_prime[13]\
    \ = true;\n    is_prime[17] = true;\n    is_prime[19] = true;\n    is_prime[23]\
    \ = true;\n    is_prime[29] = true;\n    is_prime[31] = true;\n    is_prime[37]\
    \ = true;\n    is_prime[41] = true;\n    is_prime[43] = true;\n    is_prime[47]\
    \ = true;\n    is_prime[53] = true;\n    is_prime[59] = true;\n    is_prime[61]\
    \ = true;\n    is_prime[67] = true;\n    is_prime[71] = true;\n    is_prime[73]\
    \ = true;\n    is_prime[79] = true;\n    is_prime[83] = true;\n    is_prime[89]\
    \ = true;\n    is_prime[97] = true;\n    is_prime[101] = true;\n    is_prime[103]\
    \ = true;\n    is_prime[107] = true;\n    is_prime[109] = true;\n    is_prime[113]\
    \ = true;\n    is_prime[127] = true;\n    is_prime[131] = true;\n    is_prime[137]\
    \ = true;\n    is_prime[139] = true;\n    is_prime[149] = true;\n    is_prime[151]\
    \ = true;\n    is_prime[157] = true;\n    is_prime[163] = true;\n    is_prime[167]\
    \ = true;\n    is_prime[173] = true;\n    is_prime[179] = true;\n    is_prime[181]\
    \ = true;\n    is_prime[191] = true;\n    is_prime[193] = true;\n    is_prime[197]\
    \ = true;\n    is_prime", "{\n    string[] words = split(sentence, \" \");\n \
    \   string prime = \"\";\n    foreach(word; words)\n    {\n        word = word.strip;\n\
    \        if(isPrime(word.length))\n        {\n            prime ~= \" \" ~ word;\n\
    \        }\n    }\n    return prime.strip;\n}", "{\n    // Check if empty\n  \
    \  if (sentence.empty)\n        return \"\";\n    \n    // Split words\n    auto\
    \ words = split(sentence, \" \");\n    \n    // Build result using isPrime\n \
    \   string result;\n    for (size_t i = 0; i < words.length; i++)\n    {\n   \
    \     auto word = words[i];\n        if (isPrime(word.length))\n        {\n  \
    \          result ~= word;\n            if (i < words.length - 1)\n          \
    \      result ~= \" \";\n        }\n    }\n    \n    return result;\n}\n```",
  "{\n    string [] words = split(sentence, \" \");\n    string result = \"\";\n \
    \   foreach(i, word; words)\n    {\n        if(isPrime(word.length))\n       \
    \ {\n            result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight();\n\
    }", "{\n  /* Your code goes here */\n  /*\n  enum is_prime(int i) = i < 2 ? false\
    \ : !iota(2, i).any!(i % _ == 0);\n  */\n  string[] result = new string[0];\n\
    \  string[] words = split(sentence, \" \");\n  foreach(word; words)\n  {\n   \
    \ if(is_prime(word.length))\n    {\n      result ~= word;\n    }\n  }\n  return\
    \ join(result, \" \");\n}", "{\n    const int limit = 10000;\n    immutable is_prime\
    \ = new bool[limit];\n    immutable is_prime[] = [false, false] ~ [true, true].repeat;\n\
    \    foreach (i; 2 .. limit)\n    {\n        if (is_prime[i])\n        {\n   \
    \         foreach (j; i * i .. limit by i)\n            {\n                is_prime[j]\
    \ = false;\n            }\n        }\n    }\n    string words[];\n    foreach\
    \ (word; sentence.split(\" \"))\n    {\n        if (is_prime[word.length])\n \
    \       {\n            words ~= word;\n        }\n    }\n    return words.join(\"\
    \ \");\n}", "{\n    // write your solution here...\n    string words[];\n    split(sentence,\
    \ \" \", words);\n    string res = \"\";\n    foreach(a; words)\n    {\n     \
    \   if(isPrime(a.length))\n        {\n            res ~= a ~ \" \";\n        }\n\
    \    }\n    res = res.trimRight();\n    return res;\n}", "{\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.math;\n    import\
    \ std.range;\n    import std.typecons;\n    import std.typecons : tuple;\n   \
    \ import std.range : chunkBy;\n    import std.algorithm : filter;\n    import\
    \ std.array : array;\n    import std.math : isPrime;\n    import std.string :\
    \ splitter;\n    import std.string : to;\n    import std.functional : bind;\n\
    \    import std.stdio : writefln;\n    import std.algorithm : map;\n    import\
    \ std.array : array;\n    import std.string : join;\n    import std.conv : to;\n\
    \    import std.range : filter;\n    import std.algorithm : map;\n    import std.algorithm\
    \ : filter;\n    import std.algorithm : map;\n    import std.algorithm : filter;\n\
    \    import std.algorithm : joiner;\n    import std.range : filter;\n    import\
    \ std.array : array;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.algorithm : joiner;\n    import std.string : join;\n\
    \    import std.algorithm : map;\n    import std.range : filter;\n    import std.typecons\
    \ : tuple;\n    import std.algorithm : joiner;\n    import std.algorithm : joiner;\n\
    \    import std.algorithm : map;\n    import std.range : filter;\n    import std.algorithm\
    \ : joiner;\n    import std.algorithm : map;\n    import std.range : filter;\n\
    \    import std.algorithm : joiner;\n    import std.algorithm : map;\n    import\
    \ std.range : filter;\n    import std.algorithm : joiner;\n    import std.algorithm\
    \ : map;\n    import std.range : filter;\n    import std.algorithm : joiner;\n\
    \    import std.algorithm : map;\n    import std.range : filter;\n    import std.algorithm\
    \ : joiner;\n    import std.algorithm : map;\n    import std.range : filter;\n\
    \   ", "{\n    string res;\n    string[] words = sentence.split(\" \");\n    foreach(string\
    \ word; words)\n    {\n        if(isPrime(word.length))\n        {\n         \
    \   res ~= word ~ \" \";\n        }\n    }\n    return res.idup.strip;\n}", "{\n\
    \    if(sentence.length <= 1)\n        return \"\";\n    import std.algorithm;\n\
    \    import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.math;\n    auto words = sentence.split(\" \");\n    auto new_words = words.filter!(word\
    \ => word.length.isPrime).array;\n    return new_words.join(\" \");\n}", "{\n\
    \    // 1. create an immutable string array \n    immutable(string) strings =\
    \ split(sentence, \" \");\n    // 2. create an empty string \n    string res =\
    \ \"\";\n    // 3. iterate over the strings\n    foreach(s; strings) \n    {\n\
    \        // 4. append prime length words to the empty string\n        if(isPrime(s.length))\
    \ \n        {\n            res ~= s ~ \" \";\n        }\n    }\n    // 5. trim\
    \ the empty space at the end of the result string\n    return trim(res);\n}",
  "{\n  auto res = \"\";\n  auto words = split(sentence, \" \");\n  foreach(word;\
    \ words)\n  {\n    if(isPrime(word.length))\n      res ~= word ~ \" \";\n  }\n\
    \  return res.stripRight;\n}", "{\n    string result;\n    string[] words = split(sentence);\n\
    \    foreach(immutable word; words)\n    {\n        if(word.length.isPrime)\n\
    \        {\n            if(result.length > 0)\n                result ~= \" \"\
    ;\n            result ~= word;\n        }\n    }\n    return result;\n}", "{\n\
    \    // std.array.join doesn't allow empty separator.\n    static struct Empty\
    \ {} empty;\n    static auto separator = typeof(empty).init;\n    \n    import\
    \ std.algorithm : filter, map;\n    import std.array : join;\n    import std.math\
    \ : isPrime;\n    import std.range : until;\n    import std.string : split;\n\
    \    \n    string[] words = sentence.split(\" \");\n    auto is_prime = (int w)\
    \ => w.isPrime;\n    return words.map!(a => a.length).filter!is_prime\n      \
    \  .map!(a => words[a]).join(separator);\n}", "{\n    // Creates an array of primes\
    \ between 0 and 100 inclusive\n    int[] primes = generatePrimes();\n    string[]\
    \ words = sentence.split(\" \");\n    string result = \"\";\n    foreach(string\
    \ word; words)\n    {\n        if(word.length in primes)\n        {\n        \
    \    result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight;\n\
    }", "{\n    bool[] all_primes = new bool[(uint)sentence.length + 1];\n    all_primes[0]\
    \ = false;\n    all_primes[1] = false;\n    foreach (i; 2..sentence.length) {\n\
    \        all_primes[i] = true;\n    }\n    foreach (i; 2..isqrt(sentence.length))\
    \ {\n        foreach (j; i..sentence.length) {\n            if (j % i == 0) {\n\
    \                all_primes[j] = false;\n            }\n        }\n    }\n   \
    \ string[] words = sentence.split(\" \");\n    string output;\n    foreach (word;\
    \ words) {\n        if (all_primes[word.length]) {\n            output ~= word\
    \ ~ \" \";\n        }\n    }\n    return output;\n}", "{\n    // Write your code\
    \ here\n    enum is_prime = (int n) \n    {\n        for (int i = 2; i < n; i++)\n\
    \            if (n % i == 0)\n                return false;\n        return true;\n\
    \    };\n    return join(filter!(is_prime)(map!(a => a.length)(split(sentence,\
    \ \" \"))), \" \");\n}", "{\n    string[] words = split(sentence);\n    string\
    \ res = \"\";\n    foreach(i, word; words)\n    {\n        if(isPrime(word.length))\n\
    \        {\n            res ~= word ~ \" \";\n        }\n    }\n    return trim(res);\n\
    }", "{\n    string[] words = sentence.split(\" \");\n    string result = \"\"\
    ;\n    bool[] is_prime = new bool[100];\n    is_prime[] = true;\n    is_prime[0]\
    \ = false;\n    is_prime[1] = false;\n    for (int i = 2; i < 100; i++)\n    {\n\
    \        for (int j = 2; j < (i / 2); j++)\n        {\n            if (i % j ==\
    \ 0)\n            {\n                is_prime[i] = false;\n                break;\n\
    \            }\n        }\n    }\n    foreach (word; words)\n    {\n        if\
    \ (is_prime[word.length])\n        {\n            result ~= word ~ \" \";\n  \
    \      }\n    }\n    return result.trim();\n}", "{\n    string[] words = split(sentence,\
    \ \" \");\n    int[] lengths = map!(x => x.length)(words);\n    bool[] is_prime\
    \ = map!(x => isPrime(x))(lengths);\n    return join(map!(x => x[0])(filter!(x\
    \ => x[1])(zip(words, is_prime))));\n}", "{\n    auto words = split(sentence);\n\
    \    auto result = filter!(s => isPrime(s.length))(words);\n    return join(result,\
    \ \" \");\n}", "{\n    bool is_prime(size_t n)\n    {\n        if (n < 2) return\
    \ false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n\
    \        for (size_t i = 3; i <= sqrt(n); i += 2)\n        {\n            if (n\
    \ % i == 0)\n                return false;\n        }\n        return true;\n\
    \    }\n    string results;\n    string temp;\n    foreach (c; sentence)\n   \
    \ {\n        if (c == ' ')\n        {\n            if (is_prime(temp.length))\n\
    \            {\n                results ~= temp ~ ' ';\n            }\n      \
    \      temp = \"\";\n        }\n        else\n        {\n            temp ~= c;\n\
    \        }\n    }\n    if (is_prime(temp.length))\n    {\n        results ~= temp;\n\
    \    }\n    return results;\n}", "{\n    import std.conv : to;\n    import std.array\
    \ : join, array;\n    import std.string : split;\n    import std.range : isPrime;\n\
    \    import std.algorithm : filter;\n    string[] words = sentence.split(\" \"\
    );\n    bool[] candidates = words.map!(word => word.length.isPrime).array;\n \
    \   return candidates.filter!(candidate => candidate).join(\" \");\n}", "{\n \
    \   string[] words = split(sentence, \" \");\n    string[] prime_words;\n    foreach(word;\
    \ words)\n    {\n        if(isPrime(word.length))\n        {\n            prime_words\
    \ ~= word;\n        }\n    }\n    return join(prime_words, \" \");\n}", "{\n \
    \   import std.array;\n    import std.range;\n    import std.conv;\n    auto words\
    \ = sentence.split(\" \");\n    string new_sentence = \"\";\n    bool isPrime(int\
    \ n)\n    {\n        if (n <= 1)\n            return false;\n        if (n <=\
    \ 3)\n            return true;\n        if (n % 2 == 0 || n % 3 == 0)\n      \
    \      return false;\n        for (int i = 5; i * i <= n; i = i + 6)\n       \
    \     if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n   \
    \     return true;\n    }\n    foreach(i, word; words)\n    {\n        if (isPrime(word.length))\n\
    \        {\n            new_sentence = new_sentence ~ \" \" ~ word;\n        }\n\
    \    }\n    return new_sentence.trim;\n}", "{\n    import std.algorithm;\n   \
    \ import std.range;\n    import std.string;\n    import std.conv;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.traits;\n    import std.typetuple;\n\
    \    static bool isPrime(int n) \n    {\n        if (n <= 1)\n            return\
    \ false;\n        for (int i = 2; i <= n / 2; i++)\n            if (n % i == 0)\n\
    \                return false;\n        return true;\n    }\n    string[] words\
    \ = sentence.split(\" \");\n    words.retain!(w => isPrime(w.length));\n    return\
    \ words.join(\" \");\n}", "{\n    string result = \"\";\n    string[] words =\
    \ split(sentence, \" \");\n    foreach(string word; words) {\n        if(isPrime(word.length))\
    \ {\n            result ~= word ~ \" \";\n        }\n    }\n    return result.stripRight;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
