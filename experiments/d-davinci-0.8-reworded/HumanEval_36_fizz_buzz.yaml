name: HumanEval_36_fizz_buzz
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn the number of times the\
  \ digit 7 appears in integers less than n which are divisible by 11 or 13.\n   \
  \ >>> fizz_buzz(50L)\n    0L\n    >>> fizz_buzz(78L)\n    2L\n    >>> fizz_buzz(79L)\n\
  \    3L\n    \n*/\nlong fizz_buzz(long n) \n"
tests: "unittest\n{\n    alias candidate = fizz_buzz;\n\n    assert(candidate(50L)\
  \ == 0L);\n    assert(candidate(78L) == 2L);\n    assert(candidate(79L) == 3L);\n\
  \    assert(candidate(100L) == 3L);\n    assert(candidate(200L) == 6L);\n    assert(candidate(4000L)\
  \ == 192L);\n    assert(candidate(10000L) == 639L);\n    assert(candidate(100000L)\
  \ == 8026L);\n}\nvoid main(){}"
completions: ["{\n    long count = 0;\n    for (long i = 0; i < n; i++) \n    {\n\
    \        string s = i.to!string;\n        if (i % 11 == 0 || i % 13 == 0) \n \
    \       {\n            if (s.canFind(\"7\")) \n            {\n               \
    \ count++;\n            }\n        }\n    }\n    return count;\n}\n/*\nWrite an\
    \ \"if\" statement that returns the same value as the following ternary:", "{\n\
    \tlong fizz_buzz_count = 0;\n\tforeach(i; 0 .. n) \n\t{\n\t\tif(i % 11 == 0 ||\
    \ i % 13 == 0) \n\t\t{\n\t\t\tauto digit_array = i.to!string().to!immutable(ubyte)[];\n\
    \t\t\tfizz_buzz_count += digit_array.count!(x => x == 53);\n\t\t}\n\t}\n\treturn\
    \ fizz_buzz_count;\n}", "{\n    long count = 0;\n    for (auto i = 0; i < n; i++)\
    \ \n    {\n        if (i % 11 == 0 || i % 13 == 0) \n        {\n            auto\
    \ digit = i;\n            while (digit > 0) \n            {\n                if\
    \ (digit % 10 == 7) \n                {\n                    count++;\n      \
    \          }\n                digit /= 10;\n            }\n        }\n    }\n\
    \    return count;\n}\n/*\nReturn the kth fibonacci number in the fibonacci sequence.\n\
    \    >>> fibonacci(7)\n    13L\n    >>> fibonacci(8)\n    21L\n    >>> fibonacci(9)\n\
    \    34L\n*/\nlong fibonacci(long k) \n{\n    return k < 2 ? k : fibonacci(k -\
    \ 1) + fibonacci(k - 2);\n}", "{\n    long a = 0;\n    foreach (i; iota(n))\n\
    \    {\n        auto x = to!string(i);\n        foreach (j; iota(x.length))\n\
    \        {\n            if (x[j] == '7')\n            {\n                a++;\n\
    \            }\n        }\n    }\n    return a;\n}\n/*\nReturn the length of the\
    \ longest run of consecutive numbers in the integer n.\n    >>> longest_run(1234)\n\
    \    1\n    >>> longest_run(12334)\n    2\n    >>> longest_run(23456)\n    2\n\
    \    >>> longest_run(33333)\n    5\n*/\nlong longest_run(long n) \n{\n    auto\
    \ a = to!string(n);\n    long x = 0;\n    long y = 0;\n    for (size_t i = 0;\
    \ i < a.length; i++)\n    {\n        if (i == 0)\n        {\n            y++;\n\
    \        }\n        else if (a[i] == a[i - 1])\n        {\n            y++;\n\
    \        }\n        else\n        {\n            if (y > x)\n            {\n \
    \               x = y;\n            }\n            y = 1;\n        }\n    }\n\
    \    if (y > x)\n    {\n        x = y;\n    }\n    return x;\n}\n/*\nReturn the\
    \ integer n without its last digit.\n    >>> without_last(123)\n    12\n    >>>\
    \ without_last(42)\n    4\n    >>> without_last(2013)\n    201\n*/\nlong without_last(long\
    \ n) \n{\n    auto x = to!string(n);\n    x = x[0..$ - 1];\n    return to!long(x);\n\
    }\n/*\nReturn the integer n reversed.\n    >>> reverse(123)\n    321\n    >>>\
    \ reverse(897)\n    798\n    >>> reverse(987654321)\n    123456789\n*/\nlong reverse(long\
    \ n) \n{\n    auto x = to!string(n);\n    x = x[$ - 1..0];\n    return to!long(",
  "{\n    long result = 0L;\n    for (long i = 0L; i < n; i++) \n    {\n        long\
    \ j = i;\n        while (j > 0L) \n        {\n            if (j % 10L == 7L) \n\
    \            {\n                result++;\n            }\n            j /= 10L;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 or 13.\n    >>>\
    \ fizz_buzz(50L)\n    0L\n    >>> fizz_buzz(78L)\n    2L\n    >>> fizz_buzz(79L)\n\
    \    3L\n    \n*/\nlong fizz_buzz(long n) \n{\n    long result = 0L;\n    for\
    \ (long i = 0L; i < n; i++) \n    {\n        if (i % 11L == 0L || i % 13L == 0L)\
    \ \n        {\n            long j = i;\n            while (j > 0L) \n        \
    \    {\n                if (j % 10L == 7L) \n                {\n             \
    \       result++;\n                }\n                j /= 10L;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 or 13.\n    >>>\
    \ fizz_buzz(50L)\n    0L\n    >>> fizz_buzz(78L)\n    2L\n    >>> fizz_buzz(79L)\n\
    \    3L\n    \n*/\nlong fizz_buzz(long n) \n{\n    long result = 0L;\n    for\
    \ (long i = 0L; i < n; i++) \n    {\n        if (i % 11L == 0L || i % 13L == 0L)\
    \ \n        {\n            foreach (j; std.range(i, 0L, -1L)) \n            {\n\
    \                if (j % 10L == 7L) \n                {\n                    result++;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \tlong ret = 0;\n\tlong i = 0;\n\tfor (; i < n; i++)\n\t{\n\t\tlong a = i;\n\t\
    \twhile (a != 0)\n\t\t{\n\t\t\tif (a % 10 == 7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\
    \t}\n\t\t\ta /= 10;\n\t\t}\n\t}\n\treturn ret;\n}\n/*\nReturn a list of the numbers\
    \ in the Fibonacci sequence below n.\n    >>> fib(10L)\n    [0L, 1L, 1L, 2L, 3L,\
    \ 5L, 8L]\n    >>> fib(100L)\n    [0L, 1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L,\
    \ 55L, 89L]\n    >>> fib(0L)\n    []\n    >>> fib(1L)\n    [0L]\n*/\nList fib(long\
    \ n)\n{\n\tList ret = new List;\n\tlong a = 0;\n\tlong b = 1;\n\tlong tmp = 0;\n\
    \tif (n <= 0)\n\t{\n\t\treturn ret;\n\t}\n\tret.append(a);\n\tif (n == 1)\n\t\
    {\n\t\treturn ret;\n\t}\n\tret.append(b);\n\tlong i = 2;\n\tfor (; i < n; i++)\n\
    \t{\n\t\ttmp = a + b;\n\t\ta = b;\n\t\tb = tmp;\n\t\tret.append(tmp);\n\t}\n\t\
    return ret;\n}\n/*\nReturn a list of Fibonacci numbers less than n which are divisible\
    \ by 3.\n    >>> fib_mod(10L)\n    [3L, 6L]\n    >>> fib_mod(100L)\n    [3L, 6L,\
    \ 21L, 33L, 66L]\n    >>> fib_mod(0L)\n    []\n    >>> fib_mod(1L)\n    []\n*/\n\
    List fib_mod(long n)\n{\n\tList ret = new List;\n\tlong a = 0;\n\tlong b = 1",
  "{\n    static immutable int[] divisors = [11, 13];\n    int result = 0;\n    foreach\
    \ (i; divisors)\n    {\n        result += 7.count_in_range(0, n/i);\n    }\n \
    \   return result;\n}", "{\n    long res = 0;\n    long init = 11;\n    long eleven\
    \ = 11;\n    long thirteen = 13;\n    if (n < 11)\n        return 0;\n    for\
    \ (long i = init; i < n; i++)\n    {\n        if (i % eleven == 0)\n        {\n\
    \            res += i.digits().filter!((x) => x == 7).length;\n        }\n   \
    \     else if (i % thirteen == 0)\n        {\n            res += i.digits().filter!((x)\
    \ => x == 7).length;\n        }\n    }\n    return res;\n}\n/*\nA machine learning\
    \ classifier that can't make mistakes classifies a list of integers into two categories.\n\
    Your goal is to train it by telling it the correct answer for each integer.\n\
    The classifier works as follows:\nGiven a list of integers, it will choose the\
    \ last integer in the list and compare it to the rest.\nIt will then move it to\
    \ either the top of the list if it's smaller than the number it's being compared\
    \ to,\nor leave it where it is if it's larger than the number it's being compared\
    \ to.\nIt will then do the same for each of the remaining numbers in the list\
    \ (i.e. it will compare each number\nto the last number in the list and move it\
    \ to the top if it's smaller).\nOnce the list is sorted, the classifier will classify\
    \ the list as category A if the last number is even,\nand category B if the last\
    \ number is odd.\nReturn the number of elements that are in the wrong category.\n\
    \    >>> classify([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    4\n    >>> classify([10,\
    \ 9, 8, 7, 6, 5, 4, 3, 2, 1])\n    4\n    >>> classify([1, 3, 5, 7, 9, 2, 4, 6,\
    \ 8, 10])\n    0\n    \n*/\nsize_t classify(in int[] nums) \n{\n    size_t res\
    \ = 0;\n    if (nums.length < 2)\n        return 0;\n    if (nums[$ - 1] % 2 ==\
    \ 0)\n    {\n        for (size_t i =", "{\n    long counter = 0;\n    foreach(i;\
    \ 0 .. n)\n    {\n        //string s = format(\"%d\", i);\n        if(i % 11 ==\
    \ 0 || i % 13 == 0)\n        {\n            int num = i;\n            while(num\
    \ > 0)\n            {\n                if(num % 10 == 7)\n                {\n\
    \                    counter++;\n                }\n                num /= 10;\n\
    \            }\n        }\n    }\n    return counter;\n}", "{\n\tlong count =\
    \ 0;\n\t\n\tforeach(i; 0..n) \n\t{\n\t\tif(i % 11 == 0 || i % 13 == 0) \n\t\t\
    {\n\t\t\tauto str = to!string(i);\n\t\t\tforeach(j; 0..str.length) \n\t\t\t{\n\
    \t\t\t\tif(str[j] == '7') \n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\nReturn the number of permutations of a string\
    \ in which no letter is followed by the same letter.\n    >>> permutations(\"\
    TAK\")\n    4L\n    >>> permutations(\"TKTA\")\n    5L\n*/\nlong permutations(string\
    \ str) \n{\n\tlong count = 0;\n\tauto perms = permutations(str.dup);\n\tforeach(i;\
    \ perms) \n\t{\n\t\tint j = 1;\n\t\twhile(i[j] != '\\0') \n\t\t{\n\t\t\tif(i[j]\
    \ == i[j-1]) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif(i[j]\
    \ == '\\0') \n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\nReturn\
    \ the sum of the all integers from 1 to n factorial, inclusive.\n    >>> factorial(3L)\n\
    \    8L\n    >>> factorial(5L)\n    153L\n*/\nlong factorial(long n) \n{\n\tlong\
    \ sum = 0;\n\tforeach(i; 1..n) \n\t{\n\t\tlong f = 1;\n\t\tforeach(j; 1..i) \n\
    \t\t{\n\t\t\tf *= j;\n\t\t}\n\t\tsum += f;\n\t}\n\treturn sum;\n}\n/*\nReturn\
    \ the sum of the digits of a string.\n    >>> digit_sum(\"1234\")\n    10L\n \
    \   >>> digit", "{\n  long count = 0;\n  long i = 11;\n  long i1 = 13;\n  long\
    \ a = n - 1;\n  long b = n / 11;\n  long c = n / 13;\n  for (i = 11; i < n; i\
    \ = i + 11) \n  {\n    if (i % 11 == 0)\n    {\n      count = count + 1;\n   \
    \ }\n  }\n  for (i1 = 13; i1 < n; i1 = i1 + 13) \n  {\n    if (i1 % 13 == 0)\n\
    \    {\n      count = count + 1;\n    }\n  }\n  return count;\n}\nlong start_time;\n\
    long stop_time;\nlong run_time(long test_num) \n{\n  long i = 0;\n  start_time\
    \ = now();\n  for (i = 0; i < test_num; i = i + 1) \n  {\n    fizz_buzz(i);\n\
    \  }\n  stop_time = now();\n  return stop_time - start_time;\n}", "{\n\timmutable\
    \ int a = 11;\n\timmutable int b = 13;\n\timmutable long fizz = (n-1) / a;\n\t\
    immutable long buzz = (n-1) / b;\n\timmutable long fizzbuzz = (n-1) / (a*b);\n\
    \t\n\treturn (n-1)/10 - fizz - buzz + fizzbuzz;\n}", "{\n\tlong ret=0;\n\tlong\
    \ count =n-1;\n\twhile(count>0)\n\t{\n\t\tif(count%11==0 || count%13==0)\n\t\t\
    {\n\t\t\tif(count%10==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\telse if(count%100==7)\n\
    \t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\telse if(count%1000==7)\n\t\t\t{\n\t\t\t\
    \tret++;\n\t\t\t}\n\t\t\telse if(count%10000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\
    \t}\n\t\t\telse if(count%100000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\t\
    else if(count%1000000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\telse if(count%10000000==7)\n\
    \t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\telse if(count%100000000==7)\n\t\t\t{\n\
    \t\t\t\tret++;\n\t\t\t}\n\t\t\telse if(count%1000000000==7)\n\t\t\t{\n\t\t\t\t\
    ret++;\n\t\t\t}\n\t\t\telse if(count%10000000000==7)\n\t\t\t{\n\t\t\t\tret++;\n\
    \t\t\t}\n\t\t\telse if(count%100000000000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t\
    }\n\t\t\telse if(count%1000000000000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\
    \t\telse if(count%10000000000000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\t\
    else if(count%100000000000000==7)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t\telse\
    \ if(count%1000000000000000==7)\n\t\t\t{\n\t\t\t\tret++;", "{\n\tauto res = 0L;\n\
    \tforeach(i; iota(n))\n\t{\n\t\t//auto j = i;\n\t\tif (mod(i, 11) || mod(i, 13))\n\
    \t\t{\n\t\t\tint x = 0;\n\t\t\twhile (i != 0)\n\t\t\t{\n\t\t\t\tauto digit = i\
    \ % 10;\n\t\t\t\tif (digit == 7)\n\t\t\t\t{\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\
    \ti /= 10;\n\t\t\t}\n\t\t\tres += x;\n\t\t}\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ true if exactly three of the integers are positive, and the sum of the two largest\
    \ is greater than the smallest.\n    >>> check_three([1, 2, 3, 4, 5])\n    False\n\
    \    >>> check_three([1, 2, 3, 4, 5, -6])\n    True\n*/", "{\n    return (n/11).filter!(x\
    \ => x % 13 == 0).count!(x => contains_digit(x, 7));\n}\n \n/*\nReturn the number\
    \ of times the digit 7 appears in integers less than n which are divisible by\
    \ 11 or 13.\n    >>> fizz_buzz(50L)\n    0L\n    >>> fizz_buzz(78L)\n    2L\n\
    \    >>> fizz_buzz(79L)\n    3L\n    \n*/\nlong fizz_buzz(long n) \n{\n    return\
    \ (n/11).filter!(x => x % 13 == 0).count!(x => contains_digit(x, 7));\n}\n/*\n\
    Return the number of times the digit 7 appears in integers less than n which are\
    \ divisible by 11 or 13.\n    >>> fizz_buzz(50L)\n    0L\n    >>> fizz_buzz(78L)\n\
    \    2L\n    >>> fizz_buzz(79L)\n    3L\n    \n*/\nlong fizz_buzz(long n) \n{\n\
    \    return (n/11).filter!(x => x % 13 == 0).count!(x => contains_digit(x, 7));\n\
    }\n// very simple test", "{\n    long res = 0;\n    bool x = false;\n    for (long\
    \ i = 1; i < n; i++)\n    {\n        x = false;\n        if (i % 11 == 0 || i\
    \ % 13 == 0)\n        {\n            x = true;\n        }\n        if (x == true)\n\
    \        {\n            foreach (elem; to!string(i))\n            {\n        \
    \        if (elem == '7')\n                {\n                    res += 1;\n\
    \                }\n            }\n        }\n    }\n    return res;\n}", "{\n\
    \  import std.algorithm.iteration : filter, map;\n  import std.range : takeWhile;\n\
    \  import std.conv : to;\n  long res = 0;\n  foreach(int i;0..n)\n  {\n    if(i%11\
    \ == 0 || i%13 == 0)\n    {\n      int temp = i;\n      while(temp > 0)\n    \
    \  {\n        if(temp%10 == 7)\n        {\n          res++;\n        }\n     \
    \   temp /= 10;\n      }\n    }\n  }\n  return res;\n}\n/*\nReturn the mean number\
    \ of characters needed to add to a word to make it a palindrome.\n    >>> average_palindrome_length([\"\
    hello\", \"a\", \"bc\", \"d\"])\n    1.75\n    >>> average_palindrome_length([\"\
    hello\", \"A\", \"bc\", \"d\"])\n    2.0\n*/\nlong average_palindrome_length(string[]\
    \ words) \n{\n  import std.algorithm.iteration : map;\n  import std.range : takeWhile;\n\
    \  long res = 0;\n  foreach(string w;words)\n  {\n    long len = w.length;\n \
    \   long res1 = 0;\n    while(len > 0)\n    {\n      if(w[res1] != w[len-1])\n\
    \      {\n        res++;\n      }\n      len--;\n      res1++;\n    }\n  }\n \
    \ return res/(words.length);\n}\n/*\nReturn the average word length for the string,\
    \ ignoring all non-alphabetic characters and ignoring case.\n    >>> average_word_length(\"\
    Hello, world!\")\n    5.0\n    >>> average_word_length(\"I'm not crazy.\")\n \
    \   3.8\n    >>> average_word_length(\"I'm not crazy. At least, I don't think\
    \ I am.\")\n    4.0\n*/\ndouble average_word_length(string s) \n{\n  import std.algorithm.iteration\
    \ : map;\n  import std.range : takeWhile;\n  import std.conv : to;\n  import std.array\
    \ : split;\n  s", "{\n    return iota(n)\n        .filter!(i => (i % 11 == 0)\
    \ || (i % 13 == 0))\n        .map!(to!string)\n        .joiner(\"\")\n       \
    \ .filter!(a => a == '7')\n        .length;\n}", "{\n    long result = 0L;\n \
    \   for (long i = 0L; i < n; i++) \n    {\n        if (i % 11L == 0L || i % 13L\
    \ == 0L) \n        {\n            result += count_7(i);\n        }\n    }\n  \
    \  return result;\n}", "{\n    long r = 0L;\n    foreach(i; iota(n))\n    {\n\
    \        string s = to!string(i);\n        if(s.count(\"7\") > 0)\n        {\n\
    \            if(i % 11 == 0 || i % 13 == 0)\n            {\n                r++;\n\
    \            }\n        }\n    }\n    return r;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
