language: d
name: HumanEval_126_is_sorted
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else if (lst.length == 2)\n        return lst[0] < lst[1];\n    else\n\
    \    {\n        for (int i = 0; i < lst.length - 1; i++)\n        {\n        \
    \    if (lst[i] > lst[i + 1])\n                return false;\n        }\n    \
    \    return true;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp563h7cf2.d(38): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285ce]

    ??:? bool tmp563h7cf2.is_sorted(long[]) [0x427da4]

    ??:? void tmp563h7cf2.__unittest_L44_C1() [0x428052]

    ??:? void tmp563h7cf2.__modtest() [0x4282a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c59f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b432]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430551]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b409]

    ??:? runModuleUnitTests [0x42c375]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    if (lst.length < 2) \n        return\
    \ true;\n    int prev = lst[0];\n    foreach (int x; lst[1..$]) \n    {\n    \
    \    if (x > prev)\n            prev = x;\n        else\n            return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjll1jjc_.d(32): Error: cannot implicitly convert expression `lst[0]`
    of type `long` to `int`

    /tmp/tmpjll1jjc_.d(33): Error: cannot implicitly convert expression `__r73[__key74]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjll1jjc_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long d_lst = lst.dup;\n    d_lst.sort;\n\
    \    foreach(i, val; lst) {\n        if(val != d_lst[i]) return false;\n    }\n\
    \    return true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n  \
    \  assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx7dxwtyw.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx7dxwtyw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto len = lst.length;\n    if (len\
    \ == 1) \n    {\n        return true;\n    } \n    else \n    {\n        long\
    \ prev = lst[0];\n        bool is_dup = false;\n        foreach (i, ref n; lst[1..len])\
    \ \n        {\n            if (n < prev) \n            {\n                return\
    \ false;\n            }\n            if (n == prev) \n            {\n        \
    \        if (is_dup) \n                {\n                    return false;\n\
    \                } \n                else \n                {\n              \
    \      is_dup = true;\n                }\n            } \n            else \n\
    \            {\n                is_dup = false;\n            }\n            prev\
    \ = n;\n        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp74nycvp1.d(37): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285de]

    ??:? bool tmp74nycvp1.is_sorted(long[]) [0x427d3d]

    ??:? void tmp74nycvp1.__unittest_L65_C1() [0x42805e]

    ??:? void tmp74nycvp1.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b442]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430561]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]

    ??:? runModuleUnitTests [0x42c385]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else\n    {\n        bool result = true;\n        auto it = lst.front;\n\
    \        while (it != lst.back)\n        {\n            auto next = it + 1;\n\
    \            if (*it >= *next)\n            {\n                result = false;\n\
    \                break;\n            }\n            it = next;\n        }\n  \
    \      return result;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1k4ct6bf.d(35): Error: no property `front` for type `long[]`

    /tmp/tmp1k4ct6bf.d(36): Error: no property `back` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1k4ct6bf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) return true;\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsbliz4au.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsbliz4au.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    long i = 0;\n    long j = 1;\n  \
    \  long len = lst.length;\n    while (j < len)\n    {\n        if (lst[i] > lst[j])\
    \ \n        {\n            return false;\n        } \n        else \n        {\n\
    \            i++;\n            j++;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdk5yucti.d(60): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpdk5yucti.__unittest_L47_C1() [0x428105]

    ??:? void tmpdk5yucti.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    \n    \n    if (lst.length == 1) return\
    \ true;\n    bool val = true;\n    for (int i = 0; i < lst.length - 1; i++)\n\
    \    {\n        if (lst[i] < lst[i + 1])\n        {\n            continue;\n \
    \       }\n        else\n        {\n            val = false;\n            break;\n\
    \        }\n    }\n    return val;\n}\n/*\n    Given an array of numbers and a\
    \ target number, return whether or not\n    there are two numbers in the array\
    \ which add up to the target number.\n    Assume only positive integers, no negatives.\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_sk8sajn.d(48): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_sk8sajn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool found_dup = false;\n    foreach(i,\
    \ v; lst) \n    {\n        if(v == lst[i-1]) \n        {\n            found_dup\
    \ = true;\n        }\n        if(v < lst[i-1]) \n        {\n            return\
    \ false;\n        }\n    }\n    return !found_dup;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp5ku2l5au.d(33): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285b6]

    ??:? bool tmp5ku2l5au.is_sorted(long[]) [0x427d73]

    ??:? void tmp5ku2l5au.__unittest_L44_C1() [0x427e0c]

    ??:? void tmp5ku2l5au.__modtest() [0x428288]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c587]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b41a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a5c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430539]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3f1]

    ??:? runModuleUnitTests [0x42c35d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    // Initialize a boolean variable sorted\
    \ to be true\n    bool sorted = true;\n    // Create a variable called previous\
    \ and set it to the first element in lst\n    long previous = lst[0];\n    //\
    \ Create a for loop. for i in 2..lst.length\n    for (int i = 1; i < lst.length;\
    \ i++)\n    {\n        // if previous > lst[i]\n        if (previous > lst[i])\n\
    \        {\n            // sorted = false\n            sorted = false;\n     \
    \       // break\n            break;\n        }\n        // previous = lst[i]\n\
    \        previous = lst[i];\n    }\n    // Return sorted\n    return sorted;\n\
    }\n// Define is_sorted\n// Create a boolean is_sorted\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpmbw7ylkw.d(33): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42859e]

    ??:? bool tmpmbw7ylkw.is_sorted(long[]) [0x427d2f]

    ??:? void tmpmbw7ylkw.__unittest_L53_C1() [0x42801e]

    ??:? void tmpmbw7ylkw.__modtest() [0x42826c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c56f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b402]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430595]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430521]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]

    ??:? runModuleUnitTests [0x42c345]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) \n    {\n   \
    \     return true;\n    }\n    if (lst.length == 2) \n    {\n        return lst[0]\
    \ != lst[1];\n    }\n    if (lst.length == 3) \n    {\n        return lst[0] !=\
    \ lst[1] && lst[1] != lst[2];\n    }\n    int index = 1;\n    long curr = lst[0];\n\
    \    while (index < lst.length) \n    {\n        if (curr != lst[index]) \n  \
    \      {\n            curr = lst[index];\n            index++;\n        }\n  \
    \      else \n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5yu9jquc.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285e5]

    ??:? void tmp5yu9jquc.__unittest_L58_C1() [0x427fc2]

    ??:? void tmp5yu9jquc.__modtest() [0x428368]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c667]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43068d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430619]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d1]

    ??:? runModuleUnitTests [0x42c43d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428aa8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] sorted = sort(lst);\n    long\
    \ length = lst.length;\n    bool is_sorted = true;\n    long i = 0L;\n    while(i\
    \ < length && is_sorted) \n    {\n        if(lst[i] != sorted[i]) \n        {\n\
    \            is_sorted = false;\n        }\n        i += 1L;\n    }\n    return\
    \ is_sorted;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcbkmiskf.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbkmiskf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    foreach(i; 1..lst.length)\n    {\n\
    \        if(lst[i-1] > lst[i])\n        {\n            return false;\n       \
    \ }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6g5atte2.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6g5atte2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    return lst.sorted();\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuhawrldz.d(30): Error: no property `sorted` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuhawrldz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = lst[0];\n    foreach(el;\
    \ lst)\n    {\n        if(el < prev) return false;\n        prev = el;\n    }\n\
    \    return true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n  \
    \  assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptbdjmaxq.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptbdjmaxq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = lst[0];\n    foreach(long\
    \ e; lst)\n    {\n        if(e == prev)\n            return false;\n        prev\
    \ = e;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdfmjvosw.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmpdfmjvosw.__unittest_L39_C1() [0x427ddb]

    ??:? void tmpdfmjvosw.__modtest() [0x428240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c53f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430565]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3a9]

    ??:? runModuleUnitTests [0x42c315]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428980]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool sorted = true;\n    for (long\
    \ a = 0; a < lst.length - 1; a++)\n    {\n        if (lst[a] > lst[a + 1])\n \
    \       {\n            sorted = false;\n        }\n    }\n    return sorted;\n\
    }\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsus672sc.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsus672sc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    /*\n    //solution 1\n    long last\
    \ = lst[0];\n    foreach(int i, long element; lst)\n    {\n        if(last >=\
    \ element)\n            return false;\n        last = element;\n    }\n    return\
    \ true;\n    */\n    //solution 2\n    long[] lst_copy = lst[0..$];\n    sort(lst_copy);\n\
    \    return lst == lst_copy;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeq7lcz6t.d(43): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeq7lcz6t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length<=1)\n        return\
    \ true;\n    auto current, previous = lst[0];\n    for (long i=1; i<lst.length;\
    \ i++)\n    {\n        current = lst[i];\n        if (current>previous)\n    \
    \        previous = current;\n        else\n            return false;\n    }\n\
    \    return true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n  \
    \  assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpti173sjl.d(32): Error: no identifier for declarator `current`

    /tmp/tmpti173sjl.d(32): Error: found `,` instead of statement

    /tmp/tmpti173sjl.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpti173sjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = lst[0];\n    foreach(item;\
    \ lst[1..$])\n    {\n        if(prev > item)\n            return false;\n    \
    \    prev = item;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp5lyiokqz.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428596]

    ??:? bool tmp5lyiokqz.is_sorted(long[]) [0x427d2b]

    ??:? void tmp5lyiokqz.__unittest_L39_C1() [0x428016]

    ??:? void tmp5lyiokqz.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c567]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43058d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430519]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d1]

    ??:? runModuleUnitTests [0x42c33d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1) \n    {\n   \
    \     return true;\n    }\n    else \n    {\n        long last_value = lst[0];\n\
    \        long current_value;\n        for (size_t i = 1; i < lst.length; i++)\
    \ \n        {\n            current_value = lst[i];\n            if (current_value\
    \ == last_value) \n            {\n                return false;\n            }\n\
    \            if (current_value < last_value) \n            {\n               \
    \ return false;\n            }\n            last_value = current_value;\n    \
    \    }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdnzkab7a.d(69): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284f5]

    ??:? void tmpdnzkab7a.__unittest_L54_C1() [0x428208]

    ??:? void tmpdnzkab7a.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c577]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b40a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43059d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430529]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]

    ??:? runModuleUnitTests [0x42c34d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    //return false;\n    long[] newLst\
    \ = lst.dup;\n    newLst.sort;\n    if (newLst == lst)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n\
    \    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2mp52ugu.d(32): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2mp52ugu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto i = 0;\n    while (i < lst.length\
    \ - 1)\n    {\n        // If the next number is less than the current number,\
    \ it is not sorted.\n        if (lst[i + 1] < lst[i])\n        {\n           \
    \ return false;\n        }\n        // If two numbers are the same, check for\
    \ duplicates by seeing if the\n        // next number is the same. If it is, it\
    \ is not sorted.\n        else if (lst[i + 1] == lst[i])\n        {\n        \
    \    if (i < lst.length - 2 && lst[i + 2] == lst[i])\n            {\n        \
    \        return false;\n            }\n        }\n        i++;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpiw0watoe.d(34): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428626]

    ??:? bool tmpiw0watoe.is_sorted(long[]) [0x427d4d]

    ??:? void tmpiw0watoe.__unittest_L51_C1() [0x4280aa]

    ??:? void tmpiw0watoe.__modtest() [0x4282f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b48a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43061d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430acc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4305a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b461]

    ??:? runModuleUnitTests [0x42c3cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else if (lst.length == 2)\n        return lst[0] < lst[1];\n    else\n\
    \    {\n        int i;\n        int j;\n        for (i = 0; i < lst.length - 1;\
    \ i++)\n        {\n            if (lst[i] > lst[i + 1])\n                return\
    \ false;\n            else if (lst[i] == lst[i + 1])\n            {\n        \
    \        for (j = i + 1; j < lst.length - 1; j++)\n                {\n       \
    \             if (lst[j] != lst[j + 1])\n                        break;\n    \
    \            }\n                if (j == lst.length - 1)\n                   \
    \ return false;\n            }\n        }\n        return true;\n    }\n}\n/*\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjqf04x33.d(56): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjqf04x33.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] lst_cmp = lst[0..$-1];\n  \
    \  lst_cmp.sort;\n    return lst_cmp == lst[0..$-1];\n}\nassert(is_sorted([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]));\nassert(!is_sorted([1L, 3L, 2L, 4L, 5L, 6L, 7L]));\n\
    /*\n    Given a character, return if its a vowel or not.\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qq57bur.d(34): Error: declaration expected, not `assert`

    /tmp/tmp6qq57bur.d(35): Error: declaration expected, not `assert`

    /tmp/tmp6qq57bur.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qq57bur.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto current= lst[0];\n    foreach(i;\
    \ lst)\n    {\n        if(i<current)\n        {\n            return false;\n \
    \       }\n        current=i;\n    }\n    return true;\n}\n/*\nunittest\n{\n \
    \   alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0et9roue.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0et9roue.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev_l;\n    long curr_l;\n \
    \   /*\n    If the number of elements in the array is less than 1\n    then return\
    \ true.\n    */\n    if (lst.length < 1) \n    {\n        return true;\n    }\n\
    \    // Assign the first element in the array to prev_l\n    prev_l = lst[0];\n\
    \    /*\n    Loop through the list and assign the current element\n    to curr_l.\
    \ If current element is less than the previous\n    element, return false. Otherwise,\
    \ assign the current\n    element to the previous element and continue looping\n\
    \    through the list.\n    */\n    foreach (l; lst) \n    {\n        curr_l =\
    \ l;\n        if (curr_l < prev_l) \n        {\n            return false;\n  \
    \      }\n        prev_l = curr_l;\n    }\n    return true;\n}\n/*\n    Given\
    \ an array of numbers, return whether or not they are sorted\n    in ascending\
    \ order. If array has more than 1 duplicate of the same\n    number, return false.\
    \ Assume no negative numbers and only integers.\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfnyzy3dc.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfnyzy3dc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else if (lst.length == 2)\n        return lst[0] <= lst[1];\n   \
    \ else\n    {\n        if (lst[0] > lst[1])\n            return false;\n     \
    \   else\n            return is_sorted(lst[1..$]);\n    }\n}\nunittest\n{\n  \
    \  alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp__3aeni9.d(36): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285de]

    ??:? bool tmp__3aeni9.is_sorted(long[]) [0x427d8a]

    ??:? void tmp__3aeni9.__unittest_L42_C1() [0x42805e]

    ??:? void tmp__3aeni9.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b442]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430561]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]

    ??:? runModuleUnitTests [0x42c385]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \nin {\n    assert(lst.length > 0);\n    assert(lst.length\
    \ == uniq(lst).length);\n}\nout (bool result) \n{\n    forall(j in 1..(lst.length-1))\
    \ \n    { \n        result ==> lst[j-1] <= lst[j];\n    }\n}\n{\n    // Take care\
    \ of the case where the list is length 1\n    if (lst.length == 1) \n    {\n \
    \       return true;\n    }\n    // Iterate over the list, checking if the next\
    \ element is\n    // greater than or equal to the previous one\n    for (long\
    \ i = 1; i < lst.length; i++) \n    {\n        if (lst[i] < lst[i-1]) \n     \
    \   {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp100ebmgh.d(33): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `bool`

    /tmp/tmp100ebmgh.d(33): Error: found `result` when expecting `)`

    /tmp/tmp100ebmgh.d(33): Error: statement expected to be `{ }`, not `)`

    /tmp/tmp100ebmgh.d(33): Error: found `)` instead of statement

    /tmp/tmp100ebmgh.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp100ebmgh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    //if the list is empty then return\
    \ true\n    if(lst.length == 0)\n    {\n        return true;\n    }\n    //if\
    \ the list is only 1 element return true\n    if(lst.length == 1)\n    {\n   \
    \     return true;\n    }\n    for(size_t index = 0; index < lst.length - 1; index++)\n\
    \    {\n        //if the element before the current element is greater than the\
    \ current element then return false\n        if(lst[index] > lst[index + 1])\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6v8mzfaj.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmp6v8mzfaj.__unittest_L50_C1() [0x428115]

    ??:? void tmp6v8mzfaj.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430585]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430511]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]

    ??:? runModuleUnitTests [0x42c335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    if (lst.length == 1) return true;\n\
    \    long prev = lst[0];\n    foreach (index, value; lst)\n    {\n        if (index\
    \ == 0) continue;\n        if (prev >= value) return false;\n        prev = value;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpzpou_7o6.d(31): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? bool tmpzpou_7o6.is_sorted(long[]) [0x427d39]

    ??:? void tmpzpou_7o6.__unittest_L40_C1() [0x428002]

    ??:? void tmpzpou_7o6.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    lst = sort(lst);\n    if(lst.length\
    \ == 1) return true;\n    for(long i = 0; i < lst.length - 1; i++)\n    {\n  \
    \      if(lst[i] == lst[i + 1]) return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20vv1cw8.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20vv1cw8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    long[] arr = lst.dup;\n    arr.sort;\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] != lst[i])\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp01hu35vr.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp01hu35vr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    // NOTE: This solution does not check\
    \ for duplicates\n    // Check that the list isn't empty\n    if (lst.length ==\
    \ 0) \n    {\n        return false;\n    }\n    // Go through each number and\
    \ check that it is less than the next one\n    long prev = lst[0];\n    foreach\
    \ (long next; lst[1..$]) \n    {\n        if (prev > next) \n        {\n     \
    \       return false;\n        }\n        prev = next;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0wwhhg_d.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284f5]

    ??:? void tmp0wwhhg_d.__unittest_L48_C1() [0x42803b]

    ??:? void tmp0wwhhg_d.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c577]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b40a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43059d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430529]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]

    ??:? runModuleUnitTests [0x42c34d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    lst = lst.dup; \n    lst.sort; \n\
    \    return lst == lst.dup; \n}\nlong[] nums = [1L, 2L, 3L, 4L, 5L, 6L, 7L];\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpydju60lu.d(31): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydju60lu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    for (int i = 0; i < lst.length - 1; i++)\n    {\n        if (lst[i]\
    \ > lst[i + 1])\n            return false;\n    }\n    return true;\n}\n/*\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkjb9xjm3.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjb9xjm3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    bool prev\
    \ = false;\n    int i = 0;\n    foreach(long x; lst)\n    {\n        if(prev)\n\
    \        {\n            if(x < lst[i-1])\n            {\n                result\
    \ = false;\n                break;\n            }\n        }\n        else\n \
    \       {\n            prev = true;\n        }\n        i++;\n    }\n    return\
    \ result;\n}\n \n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprn6siy6v.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprn6siy6v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    foreach(i; 1..lst.length) \n    {\
    \ \n        if(lst[i-1] > lst[i]) \n        { \n            return false; \n \
    \       } \n    } \n    return true; \n} \n//}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpol8inzc_.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284c5]

    ??:? void tmpol8inzc_.__unittest_L40_C1() [0x428101]

    ??:? void tmpol8inzc_.__modtest() [0x428248]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428988]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    foreach(idx,val;lst)\n\
    \    {\n        if(idx != lst.length - 1)\n        {\n            if(val == lst[idx+1])\n\
    \            {\n                result = false;\n                break;\n    \
    \        }\n            else if(val > lst[idx+1])\n            {\n           \
    \     result = false;\n                break;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_tzekc31.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x428515]

    ??:? void tmp_tzekc31.__unittest_L49_C1() [0x428228]

    ??:? void tmp_tzekc31.__modtest() [0x428294]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c597]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b42a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a6c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430549]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b401]

    ??:? runModuleUnitTests [0x42c36d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    long last\
    \ = 0;\n    foreach(long i; lst) \n    {\n        if(last != 0 && i < last) \n\
    \        {\n            result = false;\n            break;\n        }\n     \
    \   last = i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpue7bufws.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284ad]

    ??:? void tmpue7bufws.__unittest_L43_C1() [0x4280e9]

    ??:? void tmpue7bufws.__modtest() [0x428230]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b34e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430990]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43046d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b325]

    ??:? runModuleUnitTests [0x42c291]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int length = lst.length;\n    if (length\
    \ < 2)\n    {\n        return true;\n    }\n    else\n    {\n        for (int\
    \ i = 0; i < length - 1; i++)\n        {\n            if (lst[i] > lst[i + 1])\n\
    \            {\n                return false;\n            }\n        }\n    \
    \    return true;\n    }\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl2yzfqkt.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2yzfqkt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto tmp = lst[0];\n    foreach(n;\
    \ lst)\n    {\n        if(n > tmp)\n        {\n            tmp = n;\n        }\n\
    \        else\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt55aergm.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmpt55aergm.__unittest_L44_C1() [0x427ddb]

    ??:? void tmpt55aergm.__modtest() [0x428240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c53f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430565]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3a9]

    ??:? runModuleUnitTests [0x42c315]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428980]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool ret = true;\n    if (lst.length\
    \ >= 2)\n    {\n        long compare = lst[0];\n        int index = 1;\n     \
    \   while (index < lst.length)\n        {\n            if (lst[index] == compare)\n\
    \            {\n                ret = false;\n                break;\n       \
    \     }\n            if (lst[index] < compare)\n            {\n              \
    \  ret = false;\n                break;\n            }\n            compare =\
    \ lst[index];\n            index++;\n        }\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1ehb3sag.d(68): unittest failure

    ----------------

    ??:? _d_unittestp [0x42852d]

    ??:? void tmp1ehb3sag.__unittest_L53_C1() [0x428244]

    ??:? void tmp1ehb3sag.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b442]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a84]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430561]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]

    ??:? runModuleUnitTests [0x42c385]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289f0]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool sorted = true;\n    long prev\
    \ = -1;\n    long dup = -1;\n    foreach(cur; lst)\n    {\n        if(prev ==\
    \ cur)\n        {\n            dup = cur;\n        }\n        if(cur < prev)\n\
    \        {\n            if(dup != cur)\n            {\n                sorted\
    \ = false;\n            }\n        }\n        prev = cur;\n    }\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp77v2736o.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp77v2736o.__unittest_L50_C1() [0x428105]

    ??:? void tmp77v2736o.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b36e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430501]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43048d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b345]

    ??:? runModuleUnitTests [0x42c2b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42891c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n\tforeach(i; 0 .. lst.length - 1)\n\t\
    {\n\t\tif(lst[i] > lst[i + 1])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp6_v9y8sq.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428576]

    ??:? bool tmp6_v9y8sq.is_sorted(long[]) [0x427d4a]

    ??:? void tmp6_v9y8sq.__unittest_L39_C1() [0x427ff6]

    ??:? void tmp6_v9y8sq.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    // Write implementation here \n  \
    \  return false;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzvusxs1j.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428435]

    ??:? void tmpzvusxs1j.__unittest_L33_C1() [0x427d53]

    ??:? void tmpzvusxs1j.__modtest() [0x4281b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c443]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430469]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430918]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2ad]

    ??:? runModuleUnitTests [0x42c219]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428884]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    if (lst.length <= 1) \n    {\n  \
    \      return true;\n    } \n    else \n    {\n        long[] sortedLst = lst.dup;\n\
    \        sort(sortedLst);\n        // debug(lst, sortedLst);\n        long[] result\
    \ = lst.zip(sortedLst).map!(tuple => tuple[0] == tuple[1] ? tuple[0] : tuple[0]\
    \ - tuple[1]).array;\n        return result.every!(el => el == 0);\n    }\n}\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpncy2za4z.d(37): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpncy2za4z.d(39): Error: no property `zip` for type `long[]`

    /tmp/tmpncy2za4z.d(40): Error: no property `every` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpncy2za4z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) return true;\n\
    \    else\n    {\n        for (int i = 0; i < lst.length - 1; i++)\n        {\n\
    \            if (lst[i] >= lst[i + 1])\n            {\n                return\
    \ false;\n            }\n        }\n        return true;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp0wkr0fhf.d(35): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? bool tmp0wkr0fhf.is_sorted(long[]) [0x427d53]

    ??:? void tmp0wkr0fhf.__unittest_L43_C1() [0x428002]

    ??:? void tmp0wkr0fhf.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool is_sorted = true;\n    if (lst.length\
    \ == 1)\n    {\n        return is_sorted;\n    }\n    else if (lst.length > 1)\n\
    \    {\n        for (long i = 0; i < lst.length - 1; i++)\n        {\n       \
    \     if (lst[i] > lst[i + 1])\n            {\n                is_sorted = false;\n\
    \                break;\n            }\n        }\n    }\n    return is_sorted;\n\
    }\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpexkl_8b_.d(48): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpexkl_8b_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    \n    long prev = lst[0];\n    foreach (i, _; lst[1..$])\n    {\n\
    \        if (i < prev)\n            return false;\n        prev = i;\n    }\n\
    \    return true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n  \
    \  assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq21cotdf.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq21cotdf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = std.int.min;\n    foreach(el;\
    \ lst) \n    {\n        if(el < prev) \n        {\n            return false;\n\
    \        }\n        prev = el;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb2tqg73w.d(30): Error: identifier expected following `.`, not `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb2tqg73w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] lst_uniq;\n    if (lst.length\
    \ == 1) \n    {\n        return true;\n    }\n    else if (lst.length == 2) \n\
    \    {\n        return lst[0] <= lst[1];\n    }\n    else \n    {\n        auto\
    \ lst_uniq = std.algorithm.uniq(lst).array;\n        if (lst_uniq.length != lst.length)\
    \ \n        {\n            return false;\n        }\n        else \n        {\n\
    \            for (long i = 0; i < lst.length - 1; i++) \n            {\n     \
    \           if (lst[i] > lst[i + 1]) \n                {\n                   \
    \ return false;\n                }\n            }\n            return true;\n\
    \        }\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5jr8nxqt.d(41): Error: undefined identifier `algorithm` in package
    `std`

    /tmp/tmp5jr8nxqt.d(41): Error: variable `lst_uniq` is shadowing variable `tmp5jr8nxqt.is_sorted.lst_uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jr8nxqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    import std.algorithm : sort;\n   \
    \ return lst.sort.equal(lst);\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81gmd66s.d(31): Error: no property `equal` for type `SortedRange!(long[],
    "a < b")`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81gmd66s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n\tif (lst.length < 2)\n    {\n       \
    \ return true;\n    }\n\t\n\tfor (int i = 0; i < lst.length - 1; i++)\n    {\n\
    \        if (lst[i] > lst[i + 1])\n        {\n            return false;\n    \
    \    }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpumuuzsqa.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpumuuzsqa.__unittest_L45_C1() [0x428109]

    ??:? void tmpumuuzsqa.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    ulong i = 0;\n    long tmp = 0;\n\
    \    long item = 0;\n    bool sorted = true;\n    immutable ulong len = lst.length;\n\
    \    for (i = 0; i < len; i++)\n    {\n        item = lst[i];\n        if (i >\
    \ 0)\n        {\n            if (item < tmp)\n            {\n                sorted\
    \ = false;\n                break;\n            }\n        }\n        tmp = item;\n\
    \    }\n    return sorted;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqvee5gc.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsqvee5gc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    for (size_t i = 0; i < lst.length\
    \ - 1; i++)\n    {\n        if (lst[i] > lst[i + 1])\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjyhzycku.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyhzycku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    \n    if (lst.length <= 1)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        int prev = lst[0];\n  \
    \      for (int i = 1; i < lst.length; i++)\n        {\n            if (lst[i]\
    \ < prev)\n            {\n                return false;\n            }\n     \
    \       else\n            {\n                prev = lst[i];\n            }\n \
    \       }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8lsljudo.d(37): Error: cannot implicitly convert expression `lst[0]`
    of type `long` to `int`

    /tmp/tmp8lsljudo.d(46): Error: cannot implicitly convert expression `lst[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8lsljudo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2) return true;\n\
    \    foreach (i, v; lst) \n    {\n        if (i == 0) continue;\n        if (v\
    \ < lst[i - 1]) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2zts58i1.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp2zts58i1.__unittest_L38_C1() [0x428109]

    ??:? void tmp2zts58i1.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool state = true;\n    bool cont\
    \ = true;\n    long current = -1;\n    long previous = -1;\n    long[] seen =\
    \ new long[0];\n    foreach(n; lst)\n    {\n        state = true;\n        foreach(nn;\
    \ seen)\n        {\n            if(n == nn)\n            {\n                state\
    \ = false;\n                cont = false;\n                break;\n          \
    \  }\n        }\n        if(!cont)\n        {\n            break;\n        }\n\
    \        seen ~= n;\n        current = n;\n        if(previous != -1)\n      \
    \  {\n            if(previous > current)\n            {\n                state\
    \ = false;\n                break;\n            }\n        }\n        previous\
    \ = current;\n    }\n    return state;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjtw6uyxa.d(65): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjtw6uyxa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool inOrder = true;\n    foreach(i,j;\
    \ zip(lst[0..$-1], lst[1..$]))\n    {\n        if(i[0] >= i[1])\n        {\n \
    \           inOrder = false;\n            break;\n        }\n    }\n    return\
    \ inOrder;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpapkbfacq.d(31): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpapkbfacq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n\tlong preNum = lst[0];\n\tbool isFirst\
    \ = true;\n\tforeach(n; lst) \n\t{\n\t\tif(n != preNum) \n\t\t{\n\t\t\tif(n <\
    \ preNum)\n\t\t\t\treturn false;\n\t\t\tpreNum = n;\n\t\t}\n\t\telse \n\t\t{\n\
    \t\t\tif(isFirst)\n\t\t\t\tisFirst = false;\n\t\t\telse\n\t\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi54w4cyg.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi54w4cyg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2)\n        return\
    \ true;\n    else\n    {\n        bool result = true;\n        long prev = lst[0];\n\
    \        int i = 1;\n        while (i < lst.length && result)\n        {\n   \
    \         if (prev > lst[i])\n                result = false;\n            prev\
    \ = lst[i];\n            i++;\n        }\n        return result;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpewmewdou.d(60): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284fd]

    ??:? void tmpewmewdou.__unittest_L47_C1() [0x428139]

    ??:? void tmpewmewdou.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c57f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b412]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a54]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430531]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e9]

    ??:? runModuleUnitTests [0x42c355]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2) return true;\n\
    \    for (size_t i = 1; i < lst.length; i++) \n    {\n        if (lst[i] <= lst[i\
    \ - 1]) return false;\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpttk5dvso.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttk5dvso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    if (lst.length == 2)\n        return lst[0] < lst[1];\n    if (lst.length\
    \ == 3)\n        return (lst[0] < lst[1]) && (lst[1] < lst[2]);\n    if (lst.length\
    \ == 4)\n        return (lst[0] < lst[1]) && (lst[1] < lst[2]) && (lst[2] < lst[3]);\n\
    \    else {\n        long[] lst_new = lst[1..$];\n        return (lst[0] < lst[1])\
    \ && is_sorted(lst_new);\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpxvxs8w2y.d(39): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42875e]

    ??:? bool tmpxvxs8w2y.is_sorted(long[]) [0x427f0e]

    ??:? void tmpxvxs8w2y.__unittest_L43_C1() [0x4281e2]

    ??:? void tmpxvxs8w2y.__modtest() [0x428430]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c72f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5c2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430755]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c04]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4306e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b599]

    ??:? runModuleUnitTests [0x42c505]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else\n    {\n        long prev = lst[0];\n        for (long i = 1;\
    \ i < lst.length; i++)\n        {\n            if (prev >= lst[i])\n         \
    \       return false;\n            prev = lst[i];\n        }\n        return true;\n\
    \    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp78688l01.d(34): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285ae]

    ??:? bool tmp78688l01.is_sorted(long[]) [0x427d39]

    ??:? void tmp78688l01.__unittest_L44_C1() [0x42802e]

    ??:? void tmp78688l01.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c57f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b412]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a54]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430531]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e9]

    ??:? runModuleUnitTests [0x42c355]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2) \n    {\n    \
    \    return true;\n    }\n    else \n    {\n        int count = 1;\n        for\
    \ (int i = 0; i < lst.length - 1; i++) \n        {\n            if (lst[i] < lst[i\
    \ + 1]) \n            {\n                count += 1;\n            }\n        }\n\
    \        return count == lst.length;\n    }\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] unique_lst = new long[];\n\
    \    bool? seen_before = null;\n    foreach(long i; lst)\n    {\n        seen_before\
    \ = i in unique_lst;\n        if(seen_before) return false;\n        else append(unique_lst,\
    \ i);\n    }\n    long[] sorted_lst = new long[];\n    foreach(long i; unique_lst)\n\
    \    {\n        append(sorted_lst, i);\n    }\n    sort(sorted_lst);\n    return\
    \ unique_lst == sorted_lst;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3d6zhjz9.d(31): Error: no identifier for declarator `bool`

    /tmp/tmp3d6zhjz9.d(31): Error: found `?` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3d6zhjz9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    // Using sort()\n    long[] lst_copy\
    \ = lst[0..$];\n    sort(lst_copy);\n    return lst_copy == lst;\n    \n    //\
    \ Iterative\n    /*\n    enum max = lst.length;\n    foreach(i; 0..max)\n    {\n\
    \        if(i+1 < max)\n        {\n            if(lst[i] >= lst[i+1])\n      \
    \      {\n                return false;\n            }\n        }\n    }\n   \
    \ return true;\n    */\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n \
    \   assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wam30fd.d(32): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wam30fd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n\tbool result = true;\n\tint size = lst.length;\n\
    \tfor (int i = 0; i < size - 1; i++) \n\t{\n\t\tif (lst[i] > lst[i + 1]) \n\t\t\
    {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n//\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn80ajs1k.d(31): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn80ajs1k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto len = lst.length;\n    long min\
    \ = 0;\n    foreach(i, element; lst)\n    {\n        if(i == 0)\n        {\n \
    \           min = element;\n        }\n        else\n        {\n            min\
    \ = element;\n            break;\n        }\n    }\n    long max = maxElement(lst);\n\
    \    if(min == max)\n    {\n        return true;\n    }\n    foreach(element;\
    \ lst)\n    {\n        if(element == min)\n        {\n            continue;\n\
    \        }\n        else if(element > min)\n        {\n            min = element;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\n// Test cases\nunittest \n{\n    assert(is_sorted([5L]));\n\
    \    assert(is_sorted([1L, 2L, 3L, 4L, 5L]));\n    assert(!is_sorted([1L, 3L,\
    \ 2L, 4L, 5L]));\n    assert(is_sorted([1L, 2L, 3L, 4L, 5L, 6L]));\n    assert(is_sorted([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]));\n    assert(!is_sorted([1L, 3L, 2L, 4L, 5L, 6L, 7L]));\n\
    \    assert(is_sorted([1L, 2L, 2L, 3L, 3L, 4L]));\n    assert(!is_sorted([1L,\
    \ 2L, 2L, 2L, 3L, 4L]));\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpakdu__8t.d(44): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpakdu__8t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    if (lst.length < 2) \n        return\
    \ true;\n    \n    int prev = lst[0];\n    int curr;\n    foreach (i, x; lst[1..$])\
    \ \n    {\n        curr = x;\n        if (curr <= prev)\n            return false;\n\
    \        prev = curr;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpihyttmr8.d(33): Error: cannot implicitly convert expression `lst[0]`
    of type `long` to `int`

    /tmp/tmpihyttmr8.d(37): Error: cannot implicitly convert expression `x` of type
    `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpihyttmr8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    static struct State\n    {\n     \
    \   long prev = long.min;\n        bool in_a_run = false;\n    }\n    bool is_sorted_impl(ref\
    \ State state, in long l)\n    {\n        if (l < state.prev)\n            return\
    \ false;\n        if (l == state.prev)\n        {\n            if (state.in_a_run)\n\
    \                return false;\n            state.in_a_run = true;\n        }\n\
    \        else\n        {\n            state.in_a_run = false;\n        }\n   \
    \     state.prev = l;\n        return true;\n    }\n    State state;\n    return\
    \ lst.all!(a => is_sorted_impl(state, a));\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9_2avvj.d(53): Error: no property `all` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9_2avvj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    size_t prev\
    \ = lst[0];\n    size_t current = lst[0];\n    foreach(long x; lst)\n    {\n \
    \       if(prev > x)\n        {\n            result = false;\n            break;\n\
    \        }\n        prev = x;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpbzh9sjt5.d(31): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428596]

    ??:? bool tmpbzh9sjt5.is_sorted(long[]) [0x427d2f]

    ??:? void tmpbzh9sjt5.__unittest_L44_C1() [0x42801a]

    ??:? void tmpbzh9sjt5.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c567]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43058d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430519]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d1]

    ??:? runModuleUnitTests [0x42c33d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] sub = lst[0..$-1];\n    long[]\
    \ rst = lst[1..$];\n    return lst.length == 1 ||\n           (rst.length == 0\
    \ && lst.length == 0) ||\n           (rst.length == 0 && lst.length != 0) ||\n\
    \           (rst.length != 0 && lst.length != 0 && \n           zip(sub, rst).reduce!((a,\
    \ b) => a && b[0] <= b[1])) &&\n           is_sorted(rst);\n}\nunittest\n{\n \
    \   alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvggjnnq6.d(36): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvggjnnq6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int length = lst.length;\n    if (length\
    \ <= 1) \n    {\n        return true;\n    }\n    auto prev = lst[0];\n    auto\
    \ prev_count = 1;\n    for (auto current = 1; current < length; current++) \n\
    \    {\n        if (lst[current] == prev) \n        {\n            prev_count++;\n\
    \            if (prev_count > 1) \n            {\n                return false;\n\
    \            }\n        }\n        else if (lst[current] < prev) \n        {\n\
    \            return false;\n        }\n        else \n        {\n            prev\
    \ = lst[current];\n            prev_count = 1;\n        }\n    }\n    return true;\n\
    }\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo720_fa7.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo720_fa7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n\tlong prev = lst[0];\n\tforeach(item;\
    \ lst) \n\t{\n\t\tif(item > prev) \n\t\t{\n\t\t\tprev = item;\n\t\t}\n\t\telse\
    \ \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n/*\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsnsx0fu9.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsnsx0fu9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    bool sorted = true; \n    bool duplicate_found\
    \ = false; \n    long prev; \n    long curr; \n    foreach(idx, val; lst) \n \
    \   { \n        if(idx == 0) \n        { \n            prev = val; \n        \
    \    continue; \n        } \n        curr = val; \n        if(curr > prev) \n\
    \        { \n            prev = curr; \n            continue; \n        } \n \
    \       else if(curr == prev) \n        { \n            if(duplicate_found) \n\
    \            { \n                sorted = false; \n                break; \n \
    \           } \n            else \n            { \n                duplicate_found\
    \ = true; \n                prev = curr; \n                continue; \n      \
    \      } \n        } \n        else \n        { \n            sorted = false;\
    \ \n            break; \n        } \n    } \n    return sorted; \n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp46h_ebvc.d(84): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284f5]

    ??:? void tmp46h_ebvc.__unittest_L69_C1() [0x428208]

    ??:? void tmp46h_ebvc.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c503]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b396]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430529]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b36d]

    ??:? runModuleUnitTests [0x42c2d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428944]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else if (lst.length > 1)\n    {\n        // T[int] is a key-value\
    \ pair with key being an int\n        // and value being another int.\n      \
    \  T[int] hist = new T[int](0);\n        for (long l : lst)\n        {\n     \
    \       int i = cast(int) l;\n            if (i in hist)\n                hist[i]\
    \ += 1;\n            else\n                hist[i] = 1;\n        }\n        int[]\
    \ keys = hist.keys();\n        if (keys.length == lst.length)\n        {\n   \
    \         keys.sort;\n            for (int i=0; i<keys.length; i++)\n        \
    \    {\n                if (keys[i] != i+1)\n                    return false;\n\
    \            }\n            return true;\n        }\n        else\n          \
    \  return false;\n    }\n    else\n        return false;\n}\nunittest\n{\n   \
    \ alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmnyhif6f.d(36): Error: need size of rightmost array, not type `int`

    /tmp/tmpmnyhif6f.d(37): Error: semicolon expected, not `:`

    /tmp/tmpmnyhif6f.d(37): Error: expression expected, not `:`

    /tmp/tmpmnyhif6f.d(37): Error: found `lst` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmnyhif6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto slst = lst.copy.sort;\n    if\
    \ (lst == slst)\n    {\n        for (int i = 0; i < lst.length; i++)\n       \
    \ {\n            for (int j = i + 1; j < lst.length; j++)\n            {\n   \
    \             if (lst[i] == lst[j])\n                {\n                    return\
    \ false;\n                }\n            }\n        }\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjuz0h1t4.d(30): Error: no property `copy` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjuz0h1t4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    lst = lst.map!(a => a)(lst);\n  \
    \  lst = lst.sort;\n    foreach(a; lst)\n    {\n        if(a[0] != a[1])\n   \
    \     {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmple1t06s6.d(30): Error: no property `map` for type `long[]`

    /tmp/tmple1t06s6.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmple1t06s6.d(34): Error: only one index allowed to index `long`

    /tmp/tmple1t06s6.d(34): Error: only one index allowed to index `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmple1t06s6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2) \n    {\n    \
    \    return true;\n    }\n    else \n    {\n        /* \n            We will iterate\
    \ through the list, and \n            compare the element with the element\n \
    \           that comes after it. If it is smaller\n            then the array\
    \ is not sorted, otherwise\n            we move onto the next element. If we\n\
    \            make it to the end of the list and\n            haven't found any\
    \ differences, then\n            we return true.\n        */\n        foreach\
    \ (i, elem; lst) \n        {\n            if (i < lst.length - 1) \n         \
    \   {\n                if (elem > lst[i + 1]) \n                {\n          \
    \          return false;\n                }\n            }\n        }\n      \
    \  return true;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n \
    \   assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9gm166zv.d(72): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmp9gm166zv.__unittest_L59_C1() [0x428119]

    ??:? void tmp9gm166zv.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430585]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430511]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]

    ??:? runModuleUnitTests [0x42c335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] myArray = sort(lst);\n    if\
    \ (myArray.equal(lst)) \n    {\n        return true;\n    }\n    else \n    {\n\
    \        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0mimnh67.d(30): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp0mimnh67.d(31): Error: no property `equal` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mimnh67.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1) \n    {\n   \
    \     return true;\n    } \n    else \n    {\n        long prev_num = lst[0];\n\
    \        long prev_prev_num = lst[0];\n        foreach (num; lst[1..$]) \n   \
    \     {\n            if (num > prev_num) \n            {\n                prev_prev_num\
    \ = prev_num;\n                prev_num = num;\n            } \n            else\
    \ if (num == prev_num && num != prev_prev_num) \n            {\n             \
    \   return false;\n            } \n            else \n            {\n        \
    \        return false;\n            }\n        }\n        return true;\n    }\n\
    }\n// low-level names for long unsigned int and long unsigned int\nalias ulong\
    \ = long;\nalias uint = int;\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxb9gf40u.d(58): Error: no identifier for declarator `ulong`

    /tmp/tmpxb9gf40u.d(58): Error: found `;` when expecting `.` following long

    /tmp/tmpxb9gf40u.d(59): Error: found `alias` when expecting identifier following
    `long`.

    /tmp/tmpxb9gf40u.d(59): Error: alias cannot have initializer

    /tmp/tmpxb9gf40u.d(59): Error: semicolon expected to close `alias` declaration

    /tmp/tmpxb9gf40u.d(59): Error: no identifier for declarator `uint`

    /tmp/tmpxb9gf40u.d(59): Error: declaration expected, not `=`

    /tmp/tmpxb9gf40u.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxb9gf40u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    bool is_sorted = true;\n    if (lst.length\
    \ > 1)\n    {\n        int i = 0;\n        long prev = lst[i];\n        i++;\n\
    \        while (i < lst.length)\n        {\n            long curr = lst[i];\n\
    \            if (prev > curr)\n            {\n                is_sorted = false;\n\
    \                break;\n            }\n            prev = curr;\n           \
    \ i++;\n        }\n    }\n    return is_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpayxj5ipk.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmpayxj5ipk.__unittest_L50_C1() [0x428115]

    ??:? void tmpayxj5ipk.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430585]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430511]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]

    ??:? runModuleUnitTests [0x42c335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = lst[0];\n    bool is_prev_duplicate\
    \ = false;\n    foreach(long n; lst)\n    {\n        if(is_prev_duplicate && n\
    \ == prev)\n            return false;\n        if(n < prev)\n            return\
    \ false;\n        prev = n;\n        is_prev_duplicate = n == prev;\n    }\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp0tfiehs2.d(30): Range violation

    ----------------'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last = lst[0];\n    foreach(item;\
    \ lst)\n    {\n        if(item < last)\n            return false;\n        else\
    \ if(item == last)\n            continue;\n        else\n            last = item;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwraq2gy0.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428576]

    ??:? bool tmpwraq2gy0.is_sorted(long[]) [0x427d2b]

    ??:? void tmpwraq2gy0.__unittest_L42_C1() [0x427ff6]

    ??:? void tmpwraq2gy0.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n    in { \n        assert(lst.length > 0);\n\
    \        assert(allSatisfy(lst, (x => x > 0)));\n    }\n    out (result) { \n\
    \        assert(result in [true, false]);\n    }\n    body {\n        bool res\
    \ = true;\n        lst = sort(lst);\n        foreach(i; 0..lst.length-1) {\n \
    \           if(i != 0 && lst[i] == lst[i-1]) {\n                res = false;\n\
    \                break;\n            }\n        }\n        return res;\n    }\n\
    /*\n    Given a list of integer numbers, sort them in descending order.\n    Assume\
    \ no negative numbers and only integers.\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi2zuubc6.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi2zuubc6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2)\n        return\
    \ true;\n    \n    bool result = true;\n    long prev = lst[0];\n    foreach (long\
    \ current; lst[1..$])\n    {\n        if (current < prev)\n        {\n       \
    \     result = false;\n            break;\n        }\n        prev = current;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj4vja1ij.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284f5]

    ??:? void tmpj4vja1ij.__unittest_L46_C1() [0x42812d]

    ??:? void tmpj4vja1ij.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c577]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b40a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43059d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430529]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]

    ??:? runModuleUnitTests [0x42c34d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long curr_prev_num = lst[0];\n   \
    \ bool result = true;\n    lst = lst[1 .. $];\n    // int num_unique_nums = 0;\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp407g25_f.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp407g25_f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \nin {\n    assert(lst.length > 0);\n    assert(forall(i\
    \ in 0 .. lst.length - 1) {lst[i] > 0});\n}\nout (result) {\n    assert(forall(i\
    \ in 0 .. lst.length - 1, j in i + 1 .. lst.length - 1){(!result) ? true : lst[i]\
    \ < lst[j]});\n}\n{\n    long[] sorted = lst.map!(x => x).sort();\n    if(lst\
    \ == sorted) {\n        return true;\n    } else {\n        return false;\n  \
    \  }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0nt5y_yr.d(31): Error: found `..` when expecting `,`

    /tmp/tmp0nt5y_yr.d(31): Error: found `{` when expecting `)`

    /tmp/tmp0nt5y_yr.d(31): Error: found `lst` when expecting `;` following statement

    /tmp/tmp0nt5y_yr.d(31): Error: found `}` when expecting `;` following statement

    /tmp/tmp0nt5y_yr.d(31): Error: found `)` instead of statement

    /tmp/tmp0nt5y_yr.d(34): Error: found `..` when expecting `,`

    /tmp/tmp0nt5y_yr.d(34): Error: found `..` when expecting `,`

    /tmp/tmp0nt5y_yr.d(34): Error: found `{` when expecting `)`

    /tmp/tmp0nt5y_yr.d(34): Error: found `}` when expecting `;` following statement

    /tmp/tmp0nt5y_yr.d(34): Error: found `)` instead of statement

    /tmp/tmp0nt5y_yr.d(36): Error: missing `do { ... }` after `in` or `out`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0nt5y_yr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    foreach(i; 0 .. lst.length - 1)\n\
    \    {\n        if(lst[i] > lst[i + 1])\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpifkzl55m.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428576]

    ??:? bool tmpifkzl55m.is_sorted(long[]) [0x427d4a]

    ??:? void tmpifkzl55m.__unittest_L39_C1() [0x427ff6]

    ??:? void tmpifkzl55m.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] nlst = lst.dup;\n    nlst.sort;\n\
    \    if (nlst.equal(lst))\n    {\n        return true;\n    }\n    else\n    {\n\
    \        return false;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2j_a6gf8.d(31): Error: no property `sort` for type `long[]`

    /tmp/tmp2j_a6gf8.d(32): Error: no property `equal` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j_a6gf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length<2)\n        return\
    \ true;\n    long first = lst[0];\n    long second = lst[1];\n    foreach(i;2..lst.length)\n\
    \    {\n        if (lst[i]==first)\n            return false;\n        first =\
    \ lst[i-1];\n        second = lst[i];\n        if(first>second)\n            return\
    \ false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long t = lst[0];\n    foreach(x; lst)\n\
    \    {\n        if(x < t) return false;\n        t = x;\n    }\n    return true;\n\
    }\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpat50liow.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpat50liow.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    foreach(i; 1..lst.length) \n    {\n\
    \        if(lst[i] < lst[i-1]) \n        {\n            return false;\n      \
    \  }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuxrh6qw_.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284c5]

    ??:? void tmpuxrh6qw_.__unittest_L39_C1() [0x4280fd]

    ??:? void tmpuxrh6qw_.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428988]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    // // Good enough for now\n    //\
    \ long r = lst[0];\n    // for (long x in lst) {\n    //     if (x < r)\n    //\
    \         return false;\n    //     r = x;\n    // }\n    // return true;\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv913ngc1.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv913ngc1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164469
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1)\n        return\
    \ true;\n    \n    auto a = lst[0];\n    foreach (i, b; lst[1..$])\n    {\n  \
    \      if (a > b)\n            return false;\n        a = b;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6eh_99o2.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284f5]

    ??:? void tmp6eh_99o2.__unittest_L42_C1() [0x42812d]

    ??:? void tmp6eh_99o2.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c577]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b40a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43059d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430529]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]

    ??:? runModuleUnitTests [0x42c34d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    bool chk;\n    int len = lst.length;\n\
    \    for (int i = 0; i < len - 1; i++)\n    {\n        chk = lst[i] < lst[i +\
    \ 1];\n        if (!chk)\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n \
    \   assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpolxvohmb.d(31): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolxvohmb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long min = 0;\n    long max = 0;\n\
    \    foreach(i; lst) \n    {\n        if(i < min) \n        {\n            return\
    \ false;\n        }\n        else if(i > max) \n        {\n            max = i;\n\
    \        }\n        else \n        {\n            return false;\n        }\n \
    \   }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3ntrzr4g.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmp3ntrzr4g.__unittest_L49_C1() [0x4281d0]

    ??:? void tmp3ntrzr4g.__modtest() [0x42823c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b35e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43047d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b335]

    ??:? runModuleUnitTests [0x42c2a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42890c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    if (lst.length == 2)\n        return lst[0] <= lst[1];\n    bool\
    \ sorted = true;\n    for (int i = 0; i < lst.length - 1; i++)\n    {\n      \
    \  if (lst[i] > lst[i + 1])\n        {\n            sorted = false;\n        \
    \    break;\n        }\n    }\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp179eg85r.d(37): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285d6]

    ??:? bool tmp179eg85r.is_sorted(long[]) [0x427da8]

    ??:? void tmp179eg85r.__unittest_L45_C1() [0x428056]

    ??:? void tmp179eg85r.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430559]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]

    ??:? runModuleUnitTests [0x42c37d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) \n    {\n   \
    \     return true;\n    } \n    else \n    {\n        long[] copy = lst[1..$];\n\
    \        sort(copy);\n        return copy == lst[1..$];\n    }\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpix7qn4g_.d(37): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpix7qn4g_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    for (int i = 0; i < lst.length - 1;\
    \ i++) \n    {\n        if (lst[i] >= lst[i + 1])\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwq2lnwi2.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwq2lnwi2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int length = lst.length;\n    long\
    \ last = min(lst);\n    for (int i = 0; i < length; i++) \n    {\n        if (lst[i]\
    \ > last) \n        {\n            last = lst[i];\n        }\n        else \n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    /*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx0sf8hym.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0sf8hym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool sorted = true;\n    size_t len\
    \ = lst.length;\n    foreach(immutable i, ref el1; lst) \n    {\n        if(i\
    \ < len - 1) \n        {\n            immutable el2 = lst[i + 1];\n          \
    \  if(el1 > el2) \n            {\n                sorted = false;\n          \
    \      break;\n            }\n        }\n    }\n    return sorted;\n}\n/*\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpah24_tyv.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpah24_tyv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    long _state;\n    typeof(lst.front)\
    \ __last_value;\n    for (__last_value = lst.front, _state = 0; ; __last_value\
    \ = __last_value + 1, _state = _state + 1) {\n        switch (_state) {\n    \
    \        case 0:\n                if (__last_value != lst.front) {\n         \
    \           _state = 1;\n                    continue;\n                }\n  \
    \              else {\n                    return true;\n                }\n \
    \           case 1:\n                if (__last_value > lst.front) {\n       \
    \             _state = 2;\n                    continue;\n                }\n\
    \                else {\n                    return false;\n                }\n\
    \            case 2:\n                if (__last_value != lst.front) {\n     \
    \               _state = 3;\n                    continue;\n                }\n\
    \                else {\n                    return true;\n                }\n\
    \            case 3:\n                if (__last_value > lst.front) {\n      \
    \              _state = 2;\n                    continue;\n                }\n\
    \                else {\n                    return false;\n                }\n\
    \        }\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmputtjtau4.d(31): Error: no property `front` for type `long[]`

    /tmp/tmputtjtau4.d(35): Error: no property `front` for type `long[]`

    /tmp/tmputtjtau4.d(43): Error: no property `front` for type `long[]`

    /tmp/tmputtjtau4.d(51): Error: no property `front` for type `long[]`

    /tmp/tmputtjtau4.d(59): Error: no property `front` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmputtjtau4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long last_number = 0;\n    bool has_duplicate\
    \ = false;\n    long len = lst.length;\n    if (len > 1) {\n        last_number\
    \ = lst[0];\n        foreach (long i, long num; lst) {\n            if (num <=\
    \ last_number) {\n                has_duplicate = true;\n                break;\n\
    \            }\n            last_number = num;\n        }\n    }\n    return !has_duplicate;\n\
    }\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcs1bkr43.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcs1bkr43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) \n    {\n   \
    \     return true;\n    }\n    for (int i = 0; i < lst.length - 1; i++) \n   \
    \ {\n        if (lst[i] >= lst[i + 1]) \n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpygp9lshp.d(36): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? bool tmpygp9lshp.is_sorted(long[]) [0x427d53]

    ??:? void tmpygp9lshp.__unittest_L43_C1() [0x428002]

    ??:? void tmpygp9lshp.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool sorted;\n    long i = 0;\n  \
    \  long last = lst[0];\n    while (i < lst.length)\n    {\n        if (last >\
    \ lst[i])\n        {\n            sorted = false;\n            break;\n      \
    \  }\n        else\n        {\n            last = lst[i];\n            sorted\
    \ = true;\n        }\n        i++;\n    }\n    return sorted;\n}\nunittest\n{\n\
    \    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp4jxnnsv9.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285a6]

    ??:? bool tmp4jxnnsv9.is_sorted(long[]) [0x427d37]

    ??:? void tmp4jxnnsv9.__unittest_L49_C1() [0x428026]

    ??:? void tmp4jxnnsv9.__modtest() [0x428274]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c577]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b40a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43059d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430529]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]

    ??:? runModuleUnitTests [0x42c34d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    return is_sorted(lst, 0UL, lst.length);\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxce0j0lc.d(30): Error: function `tmpxce0j0lc.is_sorted(long[] lst)`
    is not callable using argument types `(long[], ulong, ulong)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxce0j0lc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n  bool is_sorted = true;\n  for (int\
    \ i = 0; i < lst.length; i++) \n  {\n    for (int k = i + 1; k < lst.length; k++)\
    \ \n    {\n      if (lst[i] > lst[k])\n      {\n        is_sorted = false;\n \
    \     }\n    }\n  }\n  return is_sorted;\n}\n \n/*\n    Given an array of integers,\
    \ return the range. The range is the\n    difference between the maximum and minimum\
    \ values in the array.\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkj6_hz8p.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkj6_hz8p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \nin {\n  assert(lst.length >= 0);\n  long\
    \ old = lst[0];\n  foreach (i; 1 .. lst.length) {\n    long curr = lst[i];\n \
    \   assert(curr >= old);\n    old = curr;\n  }\n}\nout (bool result) \n{\n  assert(lst.length\
    \ >= 0);\n  long old = lst[0];\n  foreach (i; 1 .. lst.length) {\n    long curr\
    \ = lst[i];\n    assert(curr >= old);\n    old = curr;\n  }\n}\n{\n    if (lst.length\
    \ == 0) {\n        return true;\n    }\n    long num_prev = lst[0];\n    long\
    \ num_curr;\n    foreach (i; 1 .. lst.length) {\n        num_curr = lst[i];\n\
    \        if (num_curr <= num_prev) {\n            return false;\n        }\n \
    \       num_prev = num_curr;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn9yqflj9.d(38): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `bool`

    /tmp/tmpn9yqflj9.d(38): Error: found `result` when expecting `)`

    /tmp/tmpn9yqflj9.d(38): Error: statement expected to be `{ }`, not `)`

    /tmp/tmpn9yqflj9.d(38): Error: found `)` instead of statement

    /tmp/tmpn9yqflj9.d(42): Error: declaration expected, not `foreach`

    /tmp/tmpn9yqflj9.d(42): Error: declaration expected, not `1`

    /tmp/tmpn9yqflj9.d(44): Error: declaration expected, not `assert`

    /tmp/tmpn9yqflj9.d(45): Error: no identifier for declarator `old`

    /tmp/tmpn9yqflj9.d(45): Error: declaration expected, not `=`

    /tmp/tmpn9yqflj9.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn9yqflj9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool ret = true;\n    foreach(index,\
    \ item; lst) \n    {\n        if(index > 0) \n        {\n            if(lst[index-1]\
    \ > item)\n            {\n                ret = false;\n                break;\n\
    \            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptkca5n4x.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmptkca5n4x.__unittest_L44_C1() [0x428105]

    ??:? void tmptkca5n4x.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1)\n        return\
    \ true;\n    return sort(lst) == lst;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpftwe8air.d(32): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftwe8air.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool flag = true;\n    long temp =\
    \ 0;\n    foreach(i; 0 .. lst.length)\n    {\n        if(lst[i] < temp)\n    \
    \    {\n            flag = false;\n            break;\n        }\n        temp\
    \ = lst[i];\n    }\n    return flag;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpb8q2w_y9.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpb8q2w_y9.__unittest_L43_C1() [0x428111]

    ??:? void tmpb8q2w_y9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c557]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43057d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430509]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c1]

    ??:? runModuleUnitTests [0x42c32d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    size_t size = lst.length;\n    if\
    \ (size == 1)\n    {\n        return true;\n    }\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpez_ohb9t.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpez_ohb9t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    for (int i = 0; i < lst.length - 1;\
    \ i++) \n    {\n        if (lst[i] >= lst[i + 1])\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp35gzcs25.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42856e]

    ??:? bool tmp35gzcs25.is_sorted(long[]) [0x427d45]

    ??:? void tmp35gzcs25.__unittest_L39_C1() [0x427ff2]

    ??:? void tmp35gzcs25.__modtest() [0x428240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c53f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430565]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3a9]

    ??:? runModuleUnitTests [0x42c315]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    bool result = true;\n    foreach (i, n; lst)\n    {\n        if (i\
    \ != 0)\n        {\n            if (n < lst[i - 1])\n                result =\
    \ false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9sdx7o0f.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9sdx7o0f.__unittest_L43_C1() [0x428111]

    ??:? void tmp9sdx7o0f.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c557]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43057d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430509]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c1]

    ??:? runModuleUnitTests [0x42c32d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    long prev\
    \ = 0;\n    foreach(i; lst)\n    {\n        if(prev == i)\n        {\n       \
    \     result = false;\n            break;\n        }\n        else if(prev > i)\n\
    \        {\n            result = false;\n            break;\n        }\n     \
    \   prev = i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq8siupkh.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmpq8siupkh.__unittest_L48_C1() [0x4281d0]

    ??:? void tmpq8siupkh.__modtest() [0x42823c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b35e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43047d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b335]

    ??:? runModuleUnitTests [0x42c2a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42890c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    /*\n    // Naive solution\n    if\
    \ (lst.length <= 1) return true;\n    long previous = lst[0];\n    foreach (long\
    \ item; lst[1..])\n    {\n        if (item < previous) return false;\n       \
    \ previous = item;\n    }\n    return true;\n    */\n    // More optimized solution\n\
    \    if (lst.length <= 1) return true;\n    long previous = lst[0];\n    foreach\
    \ (long item; lst[1..])\n    {\n        if (item < previous) return false;\n \
    \       previous = item;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpykre8l44.d(44): Error: expression expected, not `]`

    /tmp/tmpykre8l44.d(44): Error: found `)` when expecting `,`

    /tmp/tmpykre8l44.d(49): Error: found `return` when expecting `,`

    /tmp/tmpykre8l44.d(49): Error: found `;` when expecting `,`

    /tmp/tmpykre8l44.d(50): Error: expression expected, not `}`

    /tmp/tmpykre8l44.d(51): Error: found `unittest` when expecting `,`

    /tmp/tmpykre8l44.d(69): Error: found `void` when expecting `,`

    /tmp/tmpykre8l44.d(69): Error: found `{` when expecting `,`

    /tmp/tmpykre8l44.d(69): Error: expression expected, not `}`

    /tmp/tmpykre8l44.d(69): Error: found `End of File` when expecting `,`

    /tmp/tmpykre8l44.d(69): Error: found `End of File` when expecting `]`

    /tmp/tmpykre8l44.d(69): Error: found `End of File` when expecting `)`

    /tmp/tmpykre8l44.d(69): Error: found `End of File` instead of statement

    /tmp/tmpykre8l44.d(69): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpykre8l44.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = long.min;\n    bool first\
    \ = true;\n    foreach(val; lst)\n    {\n        if(first)\n        {\n      \
    \      prev = val;\n            first = false;\n        }\n        else\n    \
    \    {\n            if(prev >= val)\n            {\n                return false;\n\
    \            }\n            prev = val;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0ymehrum.d(65): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp0ymehrum.__unittest_L50_C1() [0x4281e0]

    ??:? void tmp0ymehrum.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b36e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430501]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43048d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b345]

    ??:? runModuleUnitTests [0x42c2b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42891c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool ascending;\n    bool duplicate;\n\
    \    foreach(i; 0 .. lst.length - 1)\n    {\n        if(lst[i] > lst[i + 1])\n\
    \        {\n            ascending = false;\n        }\n        if(lst[i] == lst[i\
    \ + 1])\n        {\n            duplicate = true;\n        }\n    }\n    return\
    \ ascending && !duplicate;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7kt_3l2z.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428535]

    ??:? void tmp7kt_3l2z.__unittest_L45_C1() [0x427e4f]

    ??:? void tmp7kt_3l2z.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b44a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a8c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430569]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b421]

    ??:? runModuleUnitTests [0x42c38d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    \n    \n    // enumerate zip_longest(lst,\
    \ lst[1:]))\n    foreach((long item,long next) in zip_longest(lst, lst[1..$]))\n\
    \    {\n        \n        if(item > next)\n        {\n            return false;\n\
    \        }\n        \n    }\n    \n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_a061h4.d(33): Error: basic type expected, not `(`

    /tmp/tmp5_a061h4.d(33): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp5_a061h4.d(33): Error: no identifier for declarator `_error_(long item,
    long next)`

    /tmp/tmp5_a061h4.d(33): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_a061h4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \nin {\n    foreach(i; 0 .. lst.length)\n \
    \       assert(lst[i] >= 0);\n} \nout {\n    foreach(j; 0 .. lst.length)\n   \
    \     assert(lst[j] >= 0);\n}\nbody {\n    if (lst.length == 0) return true;\n\
    \    for (int i = 0; i < lst.length-1; i++) {\n        if (lst[i] >= lst[i+1])\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp46sk2r0a.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x428669]

    ??:? void tmp46sk2r0a.__unittest_L44_C1() [0x4282cc]

    ??:? void tmp46sk2r0a.__modtest() [0x428338]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6eb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b57e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430711]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430bc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43069d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b555]

    ??:? runModuleUnitTests [0x42c4c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b2c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    /*\n    if (lst.length == 1)\n   \
    \     return true;\n    bool retval = true;\n    for (long i = 0; i < lst.length\
    \ - 1; i++)\n    {\n        if (lst[i] > lst[i + 1])\n        {\n            retval\
    \ = false;\n            break;\n        }\n    }\n    return retval;\n    */\n\
    \    auto v = sort(lst);\n    return v == lst;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb7x7v_s2.d(44): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb7x7v_s2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    size_t len = lst.length;\n    foreach(size_t\
    \ i; 0..len-1)\n    {\n        foreach(size_t j; i+1..len)\n        {\n      \
    \      if(lst[i]>lst[j])\n            {\n                return false;\n     \
    \       }\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164486
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    bool result = true;\n    bool first\
    \ = true;\n    long last = 0;\n    foreach(n; lst)\n    {\n        if(!first)\n\
    \        {\n            if(last > n)\n            {\n                result =\
    \ false;\n                break;\n            }\n        }\n        last = n;\n\
    \        first = false;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9bnmxiqk.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmp9bnmxiqk.__unittest_L48_C1() [0x4280f9]

    ??:? void tmp9bnmxiqk.__modtest() [0x428240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4cb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b35e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43047d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b335]

    ??:? runModuleUnitTests [0x42c2a1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42890c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1) return true;\n\
    \    long curr = lst[0];\n    int i = 1;\n    while (i < lst.length)\n    {\n\
    \        if (lst[i] < curr) return false;\n        else curr = lst[i];\n     \
    \   i += 1;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4ncbqi5o.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284fd]

    ??:? void tmp4ncbqi5o.__unittest_L41_C1() [0x428139]

    ??:? void tmp4ncbqi5o.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c57f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b412]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a54]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430531]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e9]

    ??:? runModuleUnitTests [0x42c355]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    assert(!lst.empty);\n    long expected\
    \ = lst[0];\n    foreach(actual; lst[1..$])\n    {\n        if(actual < expected)\n\
    \            return false;\n        expected = actual;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0xd28fcd.d(30): Error: no property `empty` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0xd28fcd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto const size = lst.length;\n  \
    \  auto last_element = lst[0];\n    for (size_t i = 1; i < size; i++) \n    {\n\
    \        if (lst[i] <= last_element)\n            return false;\n        last_element\
    \ = lst[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpsrda3l6u.d(31): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42859e]

    ??:? bool tmpsrda3l6u.is_sorted(long[]) [0x427d2f]

    ??:? void tmpsrda3l6u.__unittest_L40_C1() [0x428022]

    ??:? void tmpsrda3l6u.__modtest() [0x428270]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c56f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b402]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430595]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430521]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]

    ??:? runModuleUnitTests [0x42c345]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    // return true;\n    if (lst.length\
    \ == 1) return true;\n    long[] copy = lst.dup;\n    sort(copy);\n    int counter\
    \ = 0;\n    foreach(long i; copy) {\n        if (lst[counter] == i) ++counter;\n\
    \        else return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuqzqvl89.d(33): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuqzqvl89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n  // set prev = null\n  long? prev = null;\n\
    \  // iterate over the list \n  foreach(long i; lst) \n  {\n    // if prev !=\
    \ null and prev > i return false\n    if (prev is not null && prev > i)\n    \
    \  return false;\n    // prev = i\n    prev = i;\n  }\n  // return true\n  return\
    \ true;\n}\n \nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo91lhbwh.d(31): Error: no identifier for declarator `long`

    /tmp/tmpo91lhbwh.d(31): Error: found `?` instead of statement

    /tmp/tmpo91lhbwh.d(36): Error: found `null` when expecting `)`

    /tmp/tmpo91lhbwh.d(36): Error: found `&&` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo91lhbwh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2) return true;\n\
    \    long prev = lst[0];\n    for (long i=1; i<lst.length; i++)\n    {\n     \
    \   if (prev > lst[i]) return false;\n        prev = lst[i];\n    }\n    return\
    \ true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnsczisn7.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnsczisn7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool flag = true;\n    for (int i\
    \ = 0; i < lst.length - 1; i++)\n    {\n        if (lst[i] >= lst[i + 1])\n  \
    \      {\n            flag = false;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpeg6rypt_.d(33): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428576]

    ??:? bool tmpeg6rypt_.is_sorted(long[]) [0x427d49]

    ??:? void tmpeg6rypt_.__unittest_L41_C1() [0x427ff6]

    ??:? void tmpeg6rypt_.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n     auto num_elements = lst.length;\n\
    \     auto value_seen = false;\n     for (size_t i = 0; i < num_elements - 1;\
    \ i++)\n     {\n         if (value_seen)\n         {\n             if (lst[i]\
    \ == lst[i+1])\n             {\n                 return false;\n             }\n\
    \         }\n         if (lst[i] >= lst[i+1])\n         {\n             value_seen\
    \ = true;\n         }\n     }\n     return true;\n}\n \n/*\n    Given a list of\
    \ numbers, return whether or not the list is an arithmetic\n    sequence. An arithmetic\
    \ sequence is a list of numbers where each number\n    is the last number plus\
    \ some constant.\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztxao55j.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztxao55j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    return lst.length < 2 || lst[0..$-1].all!((e,\
    \ i) => lst[i] <= lst[i + 1]);\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsrsrs6ee.d(30): Error: no property `all` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsrsrs6ee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool isSorted = true;\n    int arrSize\
    \ = lst.length;\n    int[] numOccurences = new int[arrSize];\n    for (int i =\
    \ 0; i < arrSize; i++)\n    {\n        numOccurences[i] = 0;\n    }\n    foreach(int\
    \ i; 0..arrSize-1)\n    {\n        foreach(int j; 0..arrSize-1)\n        {\n \
    \           if (lst[i] == lst[j])\n            {\n                numOccurences[i]\
    \ += 1;\n            }\n        }\n    }\n    foreach(int i; 0..arrSize-1)\n \
    \   {\n        if (numOccurences[i] > 1)\n        {\n            isSorted = false;\n\
    \        }\n    }\n    foreach(int i; 0..arrSize-1)\n    {\n        if (i > 0)\n\
    \        {\n            if (lst[i] < lst[i-1])\n            {\n              \
    \  isSorted = false;\n            }\n        }\n    }\n    return isSorted;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwqw21tm.d(31): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwqw21tm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    long prev = lst[0];\n    for (inout\
    \ long num : lst) \n    {\n        if (num < prev) \n        {\n            return\
    \ false;\n        }\n        prev = num;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpchdxjocv.d(31): Error: semicolon expected, not `:`

    /tmp/tmpchdxjocv.d(31): Error: expression expected, not `:`

    /tmp/tmpchdxjocv.d(31): Error: found `lst` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchdxjocv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto t = tuple(lst);\n    auto l =\
    \ to!(long[])(t);\n    l.sort();\n    return l == lst;\n}\n \n/*\n    This version\
    \ works on any range, not just arrays.\n    The only reason we use a tuple at\
    \ all is that\n    array comparison needs the elements of the array\n    to be\
    \ Comparable.\n*/\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9qf_jl3o.d(31): Error: template instance `to!(long[])` template
    `to` is not defined, did you mean t?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qf_jl3o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    // TODO implement this function\n\
    \    // note that the arrays are passed in by reference\n    // to indicate this,\
    \ the variable name is prefixed\n    // with an &\n    long previous = lst[0];\n\
    \    int size = lst.length;\n    for (int i = 1; i < size; i++) {\n        if\
    \ (lst[i] <= previous) {\n            return false;\n        }\n        previous\
    \ = lst[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgo3q3pph.d(35): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgo3q3pph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) \n    {\n   \
    \     return true;\n    }\n    for (size_t i = 0; i < lst.length - 1; i++) \n\
    \    {\n        if (lst[i] >= lst[i + 1]) \n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate =\
    \ is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4y9oegb.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4y9oegb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int i = 0;\n    int j = 0;\n    int\
    \ len = lst.length;\n    long cur = 0;\n    long last = 0;\n    bool ret = true;\n\
    \    bool first = true;\n    if (len > 1)\n    {\n        for (i = 0; i < len;\
    \ i++)\n        {\n            cur = lst[i];\n            if (first)\n       \
    \     {\n                last = cur;\n                first = false;\n       \
    \     }\n            else\n            {\n                if (cur >= last)\n \
    \               {\n                    j = i;\n                    if (j < len\
    \ - 1)\n                    {\n                        last = cur;\n         \
    \           }\n                }\n                else\n                {\n  \
    \                  ret = false;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return ret;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6govxklt.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6govxklt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    import std.algorithm;\n    import\
    \ std.math;\n    bool res = true;\n    long[] temp = lst.dup;\n    temp.sort;\n\
    \    if (temp != lst) res = false;\n    return res;\n}\n \n/*\n    Given a key,\
    \ modify a hash such that the modified hash is\n    equal to the hash of the key,\
    \ if the key exists in the hash.\n    If the key does not exist, add it to the\
    \ hash and make the\n    value of the key equal to the hash of the key.\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcnvsz06n.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcnvsz06n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    immutable long? old_num = null; \n\
    \    immutable long? new_num = null; \n    immutable bool ok = true; \n    foreach(num;\
    \ lst) \n    { \n        if(ok && new_num is null) \n        { \n            new_num\
    \ = num; \n        } \n        else if(old_num == num) \n        { \n        \
    \    ok = false; \n        } \n        else if(new_num <= num) \n        { \n\
    \            old_num = new_num; \n            new_num = num; \n        } \n  \
    \      else \n        { \n            ok = false; \n        } \n    } \n    return\
    \ ok; \n} \n/*\n    Return true if there is a difference of 1 or less \n    between\
    \ any two adjacent numbers, else return false. \n    If array has more than 1\
    \ duplicate of the same number, \n    return false. Assume no negative numbers\
    \ and only integers. \n    \n    >>> is_consecutive([1L, 1L, 2L, 3L, 4L, 5L])\n\
    \    true\n    >>> is_consecutive([1L, 1L, 1L, 2L, 3L, 4L])\n    false\n    >>>\
    \ is_consecutive([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n    >>> is_consecutive([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_consecutive([1L, 2L, 3L, 4L,\
    \ 5L, 6L, 7L, 8L])\n    true\n    >>> is_consecutive([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L, 9L])\n    true\n    >>> is_consecutive([1L, 2L, 3L, 4L, 5L, 6L, 7L,\
    \ 8L, 9L, 10L])\n    true\n    >>> is_consecutive([1L, 2L, 3L, 4L, 5L, 6L, 7L,\
    \ 8\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd20bchsj.d(30): Error: no identifier for declarator `long`

    /tmp/tmpd20bchsj.d(30): Error: found `?` instead of statement

    /tmp/tmpd20bchsj.d(31): Error: no identifier for declarator `long`

    /tmp/tmpd20bchsj.d(31): Error: found `?` instead of statement

    /tmp/tmpd20bchsj.d(55): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd20bchsj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool res = true;\n    long[] arr =\
    \ [5L, 1L, 3L, 2L, 4L, 5L, 1L, 3L, 2L, 4L, 5L, 6L, 1L, 3L, 2L, 4L, 5L, 6L, 7L,\
    \ 1L, 3L, 2L, 4L, 5L, 6L, 7L, 1L, 2L, 2L, 3L, 3L, 4L, 1L, 2L, 2L, 2L, 3L, 4L];\n\
    \    foreach(i; lst)\n    {\n        if(arr[i] >= arr[i + 1])\n        {\n   \
    \         res = false;\n        }\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprxr6z3og.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x42861d]

    ??:? void tmprxr6z3og.__unittest_L41_C1() [0x427f3b]

    ??:? void tmprxr6z3og.__modtest() [0x4283a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b532]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b509]

    ??:? runModuleUnitTests [0x42c475]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ae0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length==1) return true;\n\
    \    for (long i=0; i<lst.length-1; i++) \n    {\n        if (lst[i]==lst[i+1])\
    \ return false;\n        if (lst[i]>lst[i+1]) return false;\n    }\n    return\
    \ true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt7c8xsqi.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7c8xsqi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool sorted;\n    long value_last\
    \ = 0;\n    long value_current = 0;\n    long value_next = 0;\n    bool is_duplicate;\n\
    \    bool is_duplicate_last;\n    bool is_duplicate_current;\n    long count_duplicate;\n\
    \    bool has_duplicate;\n    bool duplicate_found;\n    bool duplicates_found;\n\
    \    bool true_value;\n    long i;\n    long a;\n    long b;\n    long c;\n  \
    \  long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long length;\n\
    \    long xxx;\n    long yyy;\n    long zzz;\n    long last_value;\n    long current_value;\n\
    \    long next_value;\n    bool has_duplicate;\n    bool duplicate_found;\n  \
    \  bool duplicates_found;\n    bool is_duplicate;\n    bool is_duplicate_last;\n\
    \    bool is_duplicate_current;\n    long count_duplicate;\n    bool true_value;\n\
    \    long i;\n    long a;\n    long b;\n    long c;\n    long j;\n    long k;\n\
    \    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n    long q;\n\
    \    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n\
    \    long x;\n    long y;\n    long z;\n    // \n    true_value = 1;\n    false_value\
    \ = 0;\n    count_duplicate = 0;\n    length = lst.length;\n    has_duplicate\
    \ = false;\n    duplicate_found = false;\n    duplicates_found = false;\n    is_duplicate\
    \ = false;\n    is_dupl\nunittest\n{\n    alias candidate = is_sorted;\n\n   \
    \ assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxihki3h9.d(109): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpxihki3h9.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxihki3h9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto sorted = true;\n    auto prev\
    \ = lst[0];\n    foreach(l; lst) \n    {\n        if(l < prev) \n        {\n \
    \           sorted = false;\n            break;\n        }\n        prev = l;\n\
    \    }\n    return sorted;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpigaqktvq.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpigaqktvq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto copy = lst.dup;\n    return copy.length\
    \ == copy.sort.length;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int len = lst.length;\n    if (len\
    \ < 2) return true;\n    for (int i = 1; i < len; i++)\n    {\n        if (lst[i-1]\
    \ >= lst[i]) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpddcczk6c.d(30): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpddcczk6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto temp = lst[0];\n    foreach(item;\
    \ lst)\n    {\n        if(temp >= item)\n        {\n            temp = item;\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n \
    \   assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpddukxidl.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmpddukxidl.__unittest_L44_C1() [0x427e3d]

    ??:? void tmpddukxidl.__modtest() [0x428240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c53f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430565]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3a9]

    ??:? runModuleUnitTests [0x42c315]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428980]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    foreach(int index, long elem; lst)\
    \ \n    {\n        if(index + 1 == lst.length)\n            return true;\n   \
    \     long next_elem = lst[index + 1];\n        if(elem > next_elem)\n       \
    \     return false;\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphxtjdpzg.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphxtjdpzg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool sorted = true;\n    long temp\
    \ = -1;\n    long prev = -1;\n    foreach(elem; lst)\n    {\n        if(elem <\
    \ temp)\n        {\n            sorted = false;\n            break;\n        }\n\
    \        if(elem == prev)\n        {\n            sorted = false;\n          \
    \  break;\n        }\n        temp = elem;\n        prev = elem;\n    }\n    return\
    \ sorted;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmb5v84zf.d(65): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284c5]

    ??:? void tmpmb5v84zf.__unittest_L50_C1() [0x4281d8]

    ??:? void tmpmb5v84zf.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b366]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430485]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b33d]

    ??:? runModuleUnitTests [0x42c2a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428914]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1) \n    {\n   \
    \     return true;\n    }\n    /*\n    auto tpl = zip(lst[0..$-1], lst[1..$]);\n\
    \    foreach (Idx, Pair; tpl) \n    {\n        if (Pair[0] > Pair[1]) \n     \
    \   {\n            return false;\n        }\n    }\n    */\n    for (int i = 0;\
    \ i < lst.length-1; i++)\n    {\n        if (lst[i] > lst[i+1])\n        {\n \
    \           return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpefcl5g35.d(66): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpefcl5g35.__unittest_L53_C1() [0x428109]

    ??:? void tmpefcl5g35.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    bool is_ok = true;\n    long prev\
    \ = lst[0];\n    foreach(i; lst)\n    {\n        if(prev != i)\n        {\n  \
    \          if(prev > i)\n            {\n                is_ok = false;\n     \
    \           break;\n            }\n        }\n        prev = i;\n    }\n    return\
    \ is_ok;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpij132hdm.d(31): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? bool tmpij132hdm.is_sorted(long[]) [0x427d2f]

    ??:? void tmpij132hdm.__unittest_L46_C1() [0x427ffe]

    ??:? void tmpij132hdm.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    size_t size = lst.length;\n    foreach(i,\
    \ j; zip(iota(size - 1), iota(1, size)))\n    {\n        if(lst[i] > lst[j])\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0bhk_1ud.d(31): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0bhk_1ud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int count = 0;\n    foreach(i; lst)\n\
    \    {\n        if(i == lst[0])\n        {\n            count++;\n        }\n\
    \    }\n    if(count == lst.length)\n    {\n        return true;\n    }\n    for(int\
    \ i = 0; i < lst.length - 1; i++)\n    {\n        if(lst[i] > lst[i + 1])\n  \
    \      {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps16e9og6.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x42853d]

    ??:? void tmps16e9og6.__unittest_L51_C1() [0x428175]

    ??:? void tmps16e9og6.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b452]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a94]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430571]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b429]

    ??:? runModuleUnitTests [0x42c395]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    \n    assert (lst.length > 0);\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc0qkr0sm.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0qkr0sm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    long prev = lst[0];\n    for (long\
    \ i = 1; i < lst.length; i++)\n    {\n        if (prev > lst[i])\n        {\n\
    \            return false;\n        }\n        else if (prev == lst[i])\n    \
    \    {\n            return false;\n        }\n        prev = lst[i];\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpcak9t3al.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285d6]

    ??:? bool tmpcak9t3al.is_sorted(long[]) [0x427d2b]

    ??:? void tmpcak9t3al.__unittest_L45_C1() [0x42805a]

    ??:? void tmpcak9t3al.__modtest() [0x4282a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a7c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430559]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]

    ??:? runModuleUnitTests [0x42c37d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool isSorted = true;\n    long prevItem\
    \ = lst[0];\n    foreach(item; lst) \n    {\n        if(item < prevItem) \n  \
    \      {\n            isSorted = false;\n            break;\n        }\n     \
    \   prevItem = item;\n    }\n    return isSorted;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpin439azo.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpin439azo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n    if (lst.length > 1) \n        for (i\
    \ in 0..lst.length-2) \n            if (lst[i] > lst[i+1]) \n                return\
    \ false;\n    return true;\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8m6b0mle.d(29): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmp8m6b0mle.d(29): Error: declaration expected, not `if`

    /tmp/tmp8m6b0mle.d(33): Error: declaration expected, not `return`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8m6b0mle.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    for (int i = 0; i < lst.length - 1;\
    \ i++)\n    {\n        if (lst[i] > lst[i + 1])\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0banxhaj.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0banxhaj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    /*\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (i > 0 && lst[i] < lst[i - 1])\n        {\n        \
    \    return false;\n        }\n    }\n    return true;\n    */\n    return lst.equal(array(0L,\
    \ 1L, 2L, 3L, 4L, 5L, 6L, 7L));\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpej4ufo_q.d(40): Error: no property `equal` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpej4ufo_q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int index = 0;\n    if (lst.length\
    \ == 1) return true;\n    while (index < lst.length - 1)\n    {\n        if (lst[index]\
    \ <= lst[index + 1])\n        {\n            index += 1;\n        }\n        else\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpj_alokvx.d(34): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428586]

    ??:? bool tmpj_alokvx.is_sorted(long[]) [0x427d53]

    ??:? void tmpj_alokvx.__unittest_L42_C1() [0x42800a]

    ??:? void tmpj_alokvx.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c557]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43057d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430509]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c1]

    ??:? runModuleUnitTests [0x42c32d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2)\n        return\
    \ true;\n    auto range = minmaxElement(lst);\n    auto min = range.getFirst;\n\
    \    auto max = range.getSecond;\n    auto result = false;\n    if ((max - min\
    \ + 1) == lst.length) \n    {\n        result = true;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_eox_wmg.d(32): Error: undefined identifier `minmaxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_eox_wmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    /*\n        lst.length > 0\n     \
    \   lst.length == 1 \n        lst.length > 1 \n    */\n    if (lst.length == 0)\n\
    \    {\n        return true;\n    }\n    else if (lst.length == 1)\n    {\n  \
    \      return true;\n    }\n    else\n    {\n        return is_sorted(lst[1 ..\
    \ $]);\n    }\n}\n/*\n    Given an array of numbers and a number, return the array\
    \ sorted \n    ascendingly and with the given number inserted in the correct spot.\
    \ \n    You should modify the input array and not create a new array.\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0qqckt_.d(48): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0qqckt_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) return true;\n\
    \    if (lst.length == 2) return lst[0] < lst[1];\n    for (iota(0L, lst.length-1,\
    \ 1L))\n    {\n        if (lst[i] > lst[i+1]) return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmibse8l.d(32): Error: found `)` when expecting `;` following statement

    /tmp/tmpwmibse8l.d(36): Error: found `return` when expecting `;` following `for`
    condition

    /tmp/tmpwmibse8l.d(36): Error: found `;` when expecting `)`

    /tmp/tmpwmibse8l.d(37): Error: found `}` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmibse8l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    if (lst.length\
    \ > 1)\n    {\n        auto lst_length = lst.length;\n        for (int i = 0;\
    \ i < lst_length - 1; i++)\n        {\n            if (lst[i] > lst[i + 1])\n\
    \            {\n                result = false;\n                break;\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa497ffqy.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpa497ffqy.__unittest_L45_C1() [0x428109]

    ??:? void tmpa497ffqy.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1)\n        return\
    \ true;\n    return is_sorted_rec(lst.take(lst.length - 1), lst[lst.length - 1]);\n\
    }\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyc5geuim.d(32): Error: undefined identifier `is_sorted_rec`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyc5geuim.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \nin {\n    assert(lst.length > 0L);\n    assert(lst.length\
    \ < 8L);\n    foreach (i, v; lst) {\n        assert(v > 0L);\n    }\n}\nout (bool\
    \ result) \n{\n    assert(result || !result);\n}\n{\n    bool result = true;\n\
    \    long previous = lst[0L];\n    foreach (index, value; lst) {\n        if (index\
    \ > 0L) {\n            if (value == previous) {\n                result = false;\n\
    \                break;\n            }\n            if (value < previous) {\n\
    \                result = false;\n                break;\n            }\n    \
    \    }\n        previous = value;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe3waxrsw.d(36): Error: `(identifier) { ... }` or `(identifier;
    expression)` following `out` expected, not `bool`

    /tmp/tmpe3waxrsw.d(36): Error: found `result` when expecting `)`

    /tmp/tmpe3waxrsw.d(36): Error: statement expected to be `{ }`, not `)`

    /tmp/tmpe3waxrsw.d(36): Error: found `)` instead of statement

    /tmp/tmpe3waxrsw.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3waxrsw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1) return true;\n\
    \    for (size_t i = 0; i < lst.length-1; i++)\n    {\n        if (lst[i] >= lst[i+1])\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpgkvsj4gs.d(33): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42857e]

    ??:? bool tmpgkvsj4gs.is_sorted(long[]) [0x427d51]

    ??:? void tmpgkvsj4gs.__unittest_L37_C1() [0x427ffe]

    ??:? void tmpgkvsj4gs.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length < 2) \n    {\n    \
    \    return true;\n    } \n    else \n    {\n        auto zipped_list = zip(lst[0..$-1],\
    \ lst[1..$]);\n        for (auto l; zipped_list) \n        {\n            if (l[0]\
    \ >= l[1]) \n            {\n                return false;\n            }\n   \
    \     }\n        return true;\n    }\n}\n// Given an array of numbers, return\
    \ whether or not they are sorted\n// in ascending order. If array has more than\
    \ 1 duplicate of the same\n// number, return false. Assume no negative numbers\
    \ and only integers.\n \n// Examples\n// >>> is_sorted([5L])\n// true\n// >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L])\n// true\n// >>> is_sorted([1L, 3L, 2L, 4L,\
    \ 5L])\n// false\n// >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n// true\n// >>>\
    \ is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n// true\n// >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L, 6L, 7L])\n// false\n// >>> is_sorted([1L, 2L, 2L, 3L, 3L, 4L])\n\
    // true\n// >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n// false\n \n \nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvj_smj_t.d(37): Error: no identifier for declarator `l`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvj_smj_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    /*\n    bool sorted = true;\n    int\
    \ i;\n    for (i = 0; i < lst.length - 1; i++)\n    {\n        if (lst[i] > lst[i\
    \ + 1])\n        {\n            sorted = false;\n            break;\n        }\n\
    \    }\n    return sorted;\n    */\n    if (lst.length < 2)\n    {\n        return\
    \ true;\n    }\n    if (lst[0] > lst[1])\n    {\n        return false;\n    }\n\
    \    return is_sorted(lst[1..$]);\n    \n}\n/*\n    Returns the index in the lst\
    \ of the item if the item is in the list,\n    -1 otherwise.\n    \n    Examples\n\
    \    >>> linear_search([1L, 3L, 2L, 4L, 5L, 6L, 7L], 1L)\n    0\n    >>> linear_search([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L], 2L)\n    2\n    >>> linear_search([1L, 3L, 2L, 4L,\
    \ 5L, 6L, 7L], 7L)\n    6\n    >>> linear_search([1L, 3L, 2L, 4L, 5L, 6L, 7L],\
    \ 8L)\n    -1\n*/\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6o633_lv.d(81): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmp6o633_lv.__unittest_L68_C1() [0x428115]

    ??:? void tmp6o633_lv.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430585]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430511]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]

    ??:? runModuleUnitTests [0x42c335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    return lst.isSorted();\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxvalykyt.d(30): Error: no property `isSorted` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxvalykyt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    int len = lst.length;\n    if (len\
    \ < 2)\n        return true;\n    int value = lst[0];\n    for (int i = 1; i <\
    \ len; i++)\n    {\n        if (lst[i] == value)\n            return false;\n\
    \        if (lst[i] < value)\n            return false;\n        value = lst[i];\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20vvg3mt.d(30): Error: cannot implicitly convert expression `lst.length`
    of type `ulong` to `int`

    /tmp/tmp20vvg3mt.d(33): Error: cannot implicitly convert expression `lst[0]` of
    type `long` to `int`

    /tmp/tmp20vvg3mt.d(40): Error: cannot implicitly convert expression `lst[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20vvg3mt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    long length\
    \ = lst.length;\n    if (length == 1) \n    {\n        return true;\n    }\n \
    \   else \n    {\n        long end = length - 1;\n        foreach (i, x; lst)\
    \ \n        {\n            if (i == end)\n            {\n                break;\n\
    \            }\n            else \n            {\n                long next =\
    \ i + 1;\n                if (lst[i] >= lst[next]) \n                {\n     \
    \               result = false;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nunittest\n{\n   \
    \ alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4h0zfvbp.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4h0zfvbp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool b = true;\n    for (int i = 0;\
    \ i < lst.length - 1; i++)\n    {\n        if (lst[i] < lst[i + 1])\n        {\n\
    \            b = true;\n        }\n        else\n        {\n            b = false;\n\
    \            break;\n        }\n    }\n    return b;\n}\n/*\nunittest\n{\n   \
    \ alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeqo2g0sh.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeqo2g0sh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto i = 0;\n    auto n = lst.length;\n\
    \    while (i < n - 1)\n    {\n        if (lst[i] > lst[i + 1])\n            return\
    \ false;\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpy2_hlb2m.d(34): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428576]

    ??:? bool tmpy2_hlb2m.is_sorted(long[]) [0x427d49]

    ??:? void tmpy2_hlb2m.__unittest_L40_C1() [0x427ff6]

    ??:? void tmpy2_hlb2m.__modtest() [0x428244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1)\n        return\
    \ true;\n    long prev_elem = lst[0];\n    foreach (elem; lst[1..$])\n    {\n\
    \        if (elem < prev_elem)\n            return false;\n        prev_elem =\
    \ elem;\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcsdnm4kr.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsdnm4kr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    if (lst.length == 2)\n        return lst[0] <= lst[1];\n    \n  \
    \  int i = 0;\n    while (i < lst.length - 1)\n    {\n        if (lst[i] > lst[i\
    \ + 1])\n            return false;\n        i++;\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpy3w545mb.d(38): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4285ce]

    ??:? bool tmpy3w545mb.is_sorted(long[]) [0x427da4]

    ??:? void tmpy3w545mb.__unittest_L44_C1() [0x428052]

    ??:? void tmpy3w545mb.__modtest() [0x4282a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c59f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b432]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4305c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a74]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430551]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b409]

    ??:? runModuleUnitTests [0x42c375]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1)\n        return\
    \ true;\n    \n    bool b = true;\n    long prev = lst[0];\n    for (long i =\
    \ 1; i < lst.length; i++)\n    {\n        if (prev > lst[i])\n        {\n    \
    \        b = false;\n            break;\n        }\n        prev = lst[i];\n \
    \   }\n    return b;\n}\n/*\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp44jqsh78.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp44jqsh78.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    for (int i = 0; i < lst.length - 1;\
    \ i++) \n    {\n        if (lst[i] >= lst[i + 1])\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwq2lnwi2.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwq2lnwi2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164470
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length > 1)\n    {\n     \
    \   for (int i = 0; i < lst.length - 1; i++)\n        {\n            if (lst[i]\
    \ > lst[i + 1])\n            {\n                return false;\n            }\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpju8zlr2k.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpju8zlr2k.__unittest_L42_C1() [0x428105]

    ??:? void tmpju8zlr2k.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto it = lst.begin();\n    auto end\
    \ = lst.end();\n    if (it != end) {\n        auto prev = *it;\n        while\
    \ (++it != end) {\n            if (prev >= *it) return false;\n            prev\
    \ = *it;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplbnvx7oh.d(30): Error: no property `begin` for type `long[]`

    /tmp/tmplbnvx7oh.d(31): Error: no property `end` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplbnvx7oh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n  bool res;\n  long prev = 0;\n  bool\
    \ first = true;\n  foreach(n; lst)\n  {\n    if(first)\n    {\n      prev = n;\n\
    \      first = false;\n    }\n    else\n    {\n      if(prev != n)\n      {\n\
    \        if(prev > n)\n        {\n          res = false;\n          break;\n \
    \       }\n        else\n        {\n          prev = n;\n        }\n      }\n\
    \      else\n      {\n        res = false;\n        break;\n      }\n    }\n \
    \ }\n  return res;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsqdc3qt3.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpsqdc3qt3.__unittest_L63_C1() [0x427df3]

    ??:? void tmpsqdc3qt3.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b376]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430509]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430495]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b34d]

    ??:? runModuleUnitTests [0x42c2b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428924]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length <= 1)\n        return\
    \ true;\n    \n    if (lst[0] > lst[1])\n        return false;\n    \n    long[]\
    \ tail = lst[1..$];\n    return is_sorted(tail);\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6gx06ww9.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmp6gx06ww9.__unittest_L39_C1() [0x428119]

    ??:? void tmp6gx06ww9.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430585]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430511]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]

    ??:? runModuleUnitTests [0x42c335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool result = true;\n    foreach(i,j;\
    \ zip(lst[0..$-1], lst[1..$]))\n    {\n        if(i[0] > i[1]) result = false;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm06iwjv5.d(31): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm06iwjv5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{ \n    auto tpl = tuple(lst[0L], true);\n\
    \    foreach(e; lst[1L..$])\n    {\n        tpl[1] = (tpl[0] <= e) && tpl[1];\n\
    \        tpl[0] = e;\n    }\n    return tpl[1];\n}\n \n/*\n    Given a sorted\
    \ array of numbers, return whether or not the array\n    contains an element with\
    \ given value. Assume no negative numbers\n    and only integers.\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_biggvbx.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_biggvbx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n    if (lst.length == 1) \n        return\
    \ true;\n    else \n        return is_sorted_helper(lst, 0);\n    \nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxao9_57f.d(29): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpxao9_57f.d(29): Error: declaration expected, not `if`

    /tmp/tmpxao9_57f.d(31): Error: declaration expected, not `else`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxao9_57f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    auto prev = lst[0];\n    foreach(i;\
    \ lst[1..$])\n    {\n        if(i < prev)\n            return false;\n       \
    \ prev = i;\n    }\n    return true;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9oa98uho.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9oa98uho.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n    pure nothrow @safe\n{\n    size_t length\
    \ = lst.length;\n    if (length == 0) return true;\n    foreach (index, l; lst)\
    \ \n    {\n        if (index == 0) \n        {\n            continue;\n      \
    \  }\n        else if (lst[index - 1] > l) \n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\
    \n    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L,\
    \ 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp5wgtccp.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmpp5wgtccp.__unittest_L46_C1() [0x428119]

    ??:? void tmpp5wgtccp.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c55f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430585]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a34]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430511]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]

    ??:? runModuleUnitTests [0x42c335]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev;\n    if(lst.length > 0)\n\
    \    {\n        prev = lst[0];\n        foreach(curr; lst)\n        {\n      \
    \      if(curr < prev)\n            {\n                return false;\n       \
    \     }\n            prev = curr;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps55chdv6.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmps55chdv6.__unittest_L45_C1() [0x428109]

    ??:? void tmps55chdv6.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    assert(lst.length > 0);\n    long\
    \ n = lst[0];\n    int  i = 1;\n    while (i < lst.length)\n    {\n        long\
    \ curr = lst[i];\n        if (curr < n)\n            return false;\n        n\
    \ = curr;\n        i++;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpemda90m9.d(30): Assertion failure

    ----------------

    ??:? _d_assertp [0x4284e5]

    ??:? bool tmpemda90m9.is_sorted(long[]) [0x427d5b]

    ??:? void tmpemda90m9.__unittest_L43_C1() [0x428046]

    ??:? void tmpemda90m9.__modtest() [0x428294]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c64b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4de]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430671]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b20]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4305fd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4b5]

    ??:? runModuleUnitTests [0x42c421]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[]'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    if (lst.length == 1)\n        return\
    \ true;\n    else if (lst.length == 2)\n        return lst[0] < lst[1];\n    else\n\
    \    {\n        long[] head = lst[0..$-1];\n        long[] tail = lst[1..$];\n\
    \        long[] sa1 = sort(head);\n        long[] sa2 = sort(tail);\n        return\
    \ sa1 == sa2;\n    }\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n   \
    \ assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4j_oez93.d(38): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp4j_oez93.d(39): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4j_oez93.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    bool? is_sorted = null;\n    int len\
    \ = lst.length;\n    foreach(i, e; lst) \n    {\n        if (is_sorted.isNone)\
    \ \n        {\n            if (i + 1 >= len) break;\n            is_sorted = lst[i]\
    \ <= lst[i + 1];\n        } \n        else if (is_sorted.isSome) \n        {\n\
    \            if (i + 1 >= len) break;\n            if (lst[i] <= lst[i + 1] !=\
    \ is_sorted.get) return false;\n        }\n    }\n    return true;\n}\n// NOTE:\
    \ Not efficient, but simple\nunittest\n{\n    alias candidate = is_sorted;\n\n\
    \    assert(candidate([5L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L])\
    \ == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n\
    \    assert(candidate([]) == true);\n    assert(candidate([1L]) == true);\n  \
    \  assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L, 2L, 2L,\
    \ 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdohlabwt.d(30): Error: no identifier for declarator `bool`

    /tmp/tmpdohlabwt.d(30): Error: found `?` instead of statement

    /tmp/tmpdohlabwt.d(42): Error: found `!=` when expecting `)`

    /tmp/tmpdohlabwt.d(42): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdohlabwt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n    if (lst.length == 1) return true;\n \
    \   return lst.every!(a => a > a[0]) && lst.every!(a => a < a[$ - 1]);\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa5fgrk8j.d(29): Error: cannot use function constraints for non-template
    functions. Use `static if` instead

    /tmp/tmpa5fgrk8j.d(29): Error: declaration expected, not `if`

    /tmp/tmpa5fgrk8j.d(30): Error: declaration expected, not `return`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa5fgrk8j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long max = lst[0];\n    for (long\
    \ i = 1; i < lst.length; i++)\n    {\n        if (lst[i] <= max)\n        {\n\
    \            return false;\n        }\n        max = lst[i];\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpudauxy0i.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42859e]

    ??:? bool tmpudauxy0i.is_sorted(long[]) [0x427d2b]

    ??:? void tmpudauxy0i.__unittest_L41_C1() [0x42801e]

    ??:? void tmpudauxy0i.__modtest() [0x42826c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c56f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b402]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430595]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430521]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]

    ??:? runModuleUnitTests [0x42c345]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    //<--Template begins here\n    int\
    \ i = 0;\n    while (i < lst.length - 1) \n    {\n        if (lst[i] > lst[i +\
    \ 1]) \n        {\n            return false;\n        }\n        i++;\n    }\n\
    \    return true;\n    //Template ends here-->\n}\n/*\n    Given a sorted array\
    \ of numbers, return whether or not the array contains a given number.\nunittest\n\
    {\n    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaih2czd8.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaih2czd8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n  long comparer = 0;\n  for (long i =\
    \ 0; i < lst.length; i++)\n  {\n    if (lst[i] <= comparer)\n    {\n      return\
    \ false;\n    }\n    comparer = lst[i];\n  }\n  return true;\n}\nunittest\n{\n\
    \    alias candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
    \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n  \
    \  assert(candidate([1L, 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([])\
    \ == true);\n    assert(candidate([1L]) == true);\n    assert(candidate([3L, 2L,\
    \ 1L]) == false);\n    assert(candidate([1L, 2L, 2L, 2L, 3L, 4L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L, 2L, 3L, 4L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoj627_bp.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284c5]

    ??:? void tmpoj627_bp.__unittest_L41_C1() [0x4281dc]

    ??:? void tmpoj627_bp.__modtest() [0x428248]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c547]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43056d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a1c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]

    ??:? runModuleUnitTests [0x42c31d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428988]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long prev = lst[0];\n    foreach(long\
    \ x; lst) \n    {\n        if (x < prev) \n        {\n            return false;\n\
    \        }\n        prev = x;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpsnqus19a.d(30): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42856e]

    ??:? bool tmpsnqus19a.is_sorted(long[]) [0x427d2b]

    ??:? void tmpsnqus19a.__unittest_L41_C1() [0x427ff2]

    ??:? void tmpsnqus19a.__modtest() [0x428240]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c53f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430565]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3a9]

    ??:? runModuleUnitTests [0x42c315]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164471
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an array of numbers,\
    \ return whether or not they are sorted\n    in ascending order. If array has\
    \ more than 1 duplicate of the same\n    number, return false. Assume no negative\
    \ numbers and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L,\
    \ 2L, 4L, 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n\
    \    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L,\
    \ 3L, 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L,\
    \ 4L])\n    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n   \
    \ \n*/\nbool is_sorted(long[] lst) \n{\n    long[] temp = lst.dup;\n    temp.sort;\n\
    \    lst.sort;\n    return lst == temp;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = is_sorted;\n\n    assert(candidate([5L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L, 3L, 2L, 4L, 5L,\
    \ 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
    \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
    \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
    \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8j2kzp3f.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8j2kzp3f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164471
