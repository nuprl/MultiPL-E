name: HumanEval_49_modp
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n\
  \    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
  \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n"
tests: "unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
  \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
  \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
  \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
  \ == 3L);\n}\nvoid main(){}"
completions: ["in\n{\n  assert(p > 0);\n  assert(n >= 0);\n}\nbody\n{\n  alias P =\
    \ tuple(long, long);\n  alias T = tuple(P, long);\n  long N = n;\n  assert(N >=\
    \ 0);\n  T t = tuple(tuple(1L, 0L), p);\n  if(N == 0)\n  {\n    return 1L;\n \
    \ }\n  while(N != 1)\n  {\n    if(N & 1)\n    {\n      t = tuple(tuple(get!1(t)[0]\
    \ * get!0(t)[0] + get!1(t)[1] * get!0(t)[1], \n                      get!1(t)[0]\
    \ * get!0(t)[1] + get!1(t)[1] * get!0(t)[0]), \n                get!1(t)[1] *\
    \ get!1(t)[1] - 2L * get!1(t)[0] * get!1(t)[1] + get!1(t)[0] * get!1(t)[0]);\n\
    \    }\n    else\n    {\n      t = tuple(tuple(get!0(t)[0] * get!0(t)[0] + get!1(t)[1]\
    \ * get!0(t)[1], \n                      get!0(t)[0] * get!0(t)[1] + get!1(t)[1]\
    \ * get!0(t)[0]), \n                get!1(t)[1] * get!1(t)[1] - 2L * get!1(t)[0]\
    \ * get!1(t)[1] + get!1(t)[0] * get!1(t)[0]);\n    }\n    N >>= 1;\n  }\n  long\
    \ result = (get!0(t)[0] + get!1(t)[1]) % p;\n  assert(result > 0);\n  return result;\n\
    }\n/*\nReturn a random integer from [0, n).\n*/\nlong random(long n) \nin\n{\n\
    \  assert(n > 0);\n}\nbody\n{\n  import", "{\n  if(n == 0)\n    return 1;\n  /*\n\
    \  return  (modp(n/2, p) ** 2) % p if n % 2 == 0 \n  else  (modp(n/2, p) ** 2\
    \ * a) % p\n  */\n  if(n % 2 == 0)\n    return  pow(modp(n/2, p), 2) % p;\n  else\n\
    \    return  (pow(modp(n/2, p), 2) * n) % p;\n}", "    if (n<p)\n    {\n    return\
    \ n;\n    }\n    else\n    {\n    long m;\n    long q;\n    q = n/p;\n    m =\
    \ n-q*p;\n    return m;\n    }\n    \n    \n/* Return True iff n is prime.\n \
    \   >>> isprime(11L)\n    True\n    >>> isprime(111L)\n    False\n    >>> isprime(17L)\n\
    \    True\n    >>> isprime(2L)\n    True\n    >>> isprime(199L)\n    True\n  \
    \  >>> isprime(200L)\n    False\n*/", "{\n    if (n == 0) \n    {\n        return\
    \ 1;\n    }\n    /*\n        p(a+b) == (pa+pb) mod m\n        *2 == *2 mod m\n\
    \        *2 == (+0+*2) mod m\n        *2 == (+(p*1)+*2) mod m\n    */\n    return\
    \ ((p * modp(n / 2, p)) + modp(n % 2, p)) % p;\n}\n/*\n  Find a generator for\
    \ the multiplicative group of integers modulo p, where p is prime. \n  Such a\
    \ generator is called a primitive root modulo p. Returns None if no primitive\
    \ root \n  exists (i.e., if p is a prime power).\n  >>> find_generator(11L)\n\
    \  10L\n  >>> find_generator(7L)\n  3L\n  >>> find_generator(9L)\n*/\nlong find_generator(long\
    \ p) \n{\n    long g;\n    long n = p - 1;\n    if (p == 2) \n    {\n        return\
    \ 1;\n    }\n    // find the maximum power of 2 dividing n\n    long q = 1;\n\
    \    while (n % 2 == 0) \n    {\n        n /= 2;\n        q += 1;\n    }\n   \
    \ // we're only interested in multiplicative orders that are 1 modulo 2\n    n\
    \ = n * (pow(2, q - 1) - 1);\n    for (g = 2; g < p; g += 1) \n    {\n       \
    \ // check if g is a generator\n        // if g^{2^i} != 1 mod p for 0 <= i <\
    \ q, then g is a generator\n        if (all!((x) => (modp(g, p) != modp(1, p)),\
    \ iota(q))) \n        {\n            return g;\n        }\n    }\n    return 0;\n\
    }\n// Compute a^b mod m.\n// Note: modp is faster, but is limited to 64-bit integers.\n\
    long modexp(long a, long b, long m) \n{\n    if (a == 0) \n    {\n", "{\n    const\
    \ long TWO = 2L;\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    Tuple!(long,\
    \ long) qr = divmod(n, TWO);\n    long a = modp(qr[0], p);\n    long m = a * a\
    \ % p;\n    if (qr[1] == 1L) \n    {\n        m = (m * TWO) % p;\n    }\n    return\
    \ m;\n}\n/*\nGenerate the n-th prime.  Note that n=1 returns 2.\n    >>> primes(1)\n\
    \    2L\n    >>> primes(2)\n    3L\n    >>> primes(3)\n    5L\n    >>> primes(4)\n\
    \    7L\n    >>> primes(10)\n    29L\n    >>> primes(11)\n    31L\n    \n*/\n\
    long primes(long n) \n{\n    long p = 2L;\n    long i = 1L;\n    while (i < n)\
    \ \n    {\n        p += 1L;\n        if (isprime(p)) \n        {\n           \
    \ i += 1L;\n        }\n    }\n    return p;\n}\n/*\nReturn true if p is prime,\
    \ false otherwise.\n    >>> isprime(2L)\n    true\n    >>> isprime(3L)\n    true\n\
    \    >>> isprime(4L)\n    false\n    >>> isprime(5L)\n    true\n    >>> isprime(6L)\n\
    \    false\n    >>> isprime(7L)\n    true\n    >>> isprime(8L)\n    false\n  \
    \  >>> isprime(9L)\n    false\n    >>> isprime(10L)\n    false\n    >>> isprime(11L)\n\
    \    true\n    >>> isprime(12L)\n    false\n    >>> isprime(13L)\n    true\n \
    \   >>> isprime(15L)\n    false\n    >>> isprime(17L)\n    true\n    >>> isprime(2147483647L)\n\
    \    true\n    >>> isprime(18446744073709551557L)\n    true\n   ", "{\n    auto[exponent,\
    \ base] = split(n);\n    long result = 1L;\n    for (long i = 0L; i < exponent;\
    \ i++) \n    {\n        result = result * base % p;\n    }\n    return result;\n\
    }", "{\n    if(n == 0L) \n    {\n        return 1L;\n    }\n    else if(n == 1L)\
    \ \n    {\n        return 2L % p;\n    }\n    else \n    {\n        long k = n\
    \ / 2L;\n        return pow(modp(k, p), 2L) % p;\n    }\n}\n/*\n    >>> powmodp(7L,\
    \ 4L, 97L)\n    63L\n    >>> powmodp(17L, 4L, 97L)\n    17L\n    >>> powmodp(8L,\
    \ 1L, 97L)\n    8L\n    >>> powmodp(8L, 0L, 97L)\n    1L\n    >>> powmodp(8L,\
    \ -1L, 97L)\n    73L\n    >>> powmodp(8L, -2L, 97L)\n    48L\n*/\nlong powmodp(long\
    \ a, long n, long p) \n{\n    if(n == 0L) \n    {\n        return 1L;\n    }\n\
    \    else if(n > 0L) \n    {\n        long k = n / 2L;\n        return pow(powmodp(a,\
    \ k, p), 2L) % p;\n    }\n    else \n    {\n        return powmodp(powmodp(a,\
    \ -1L, p), -n, p);\n    }\n}\n/*\n    >>> truediv(2L, 3L)\n    '2/3'\n    >>>\
    \ truediv(21L, -21L)\n    '-1/1'\n    >>> truediv(11L, 7L)\n    '11/7'\n    >>>\
    \ truediv(8L, 6L)\n    '4/3'\n    >>> truediv(3L, 15L)\n    '1/5'\n    >>> truediv(6L,\
    \ 15L)\n    '2/5'\n    >>> truediv(6L, 30L)\n    '1/5'\n    >>> truediv(6L, 60L)\n\
    \    '1/10'\n    >>> truediv(", "{\n    auto r = 1L;\n    auto b = to!int(n) %\
    \ p;\n    if(b < 0)\n        b += p;\n    foreach(i; 0 .. bits!long)\n    {\n\
    \        if(b & (1L << i))\n            r = (r * 2L) % p;\n    }\n    return r;\n\
    }\n/*\nReturn the n-th Fibonacci number modulo p.\n    >>> fibp(8L, 7L)\n    6L\n\
    \    >>> fibp(8L, 101L)\n    44L\n    >>> fibp(8L, 100L)\n    44L\n    >>> fibp(8L,\
    \ 11L)\n    9L\n    >>> fibp(8L, 29L)\n    20L\n    >>> fibp(8L, 31L)\n    4L\n\
    */\nlong fibp(long n, long p) \n{\n    return (modp(n, p) * (1L + modp(n, p)))\
    \ % p;\n}\n/*\nReturn k, such that (n ** k) % p == 1.\n    >>> multiplicative_order(3L,\
    \ 7L)\n    6L\n    >>> multiplicative_order(3L, 101L)\n    100L\n    >>> multiplicative_order(3L,\
    \ 11L)\n    10L\n    >>> multiplicative_order(3L, 29L)\n    28L\n    >>> multiplicative_order(100L,\
    \ 101L)\n    50L\n*/\nlong multiplicative_order(long n, long p) \n{\n    auto\
    \ k = 1L;\n    auto b = n % p;\n    if(b < 0)\n        b += p;\n    foreach(i;\
    \ 0 .. bits!long)\n    {\n        if(b & (1L << i))\n            k = k * 2L;\n\
    \    }\n    return k;\n}\n/*\nReturn the number of distinct prime factors.\n \
    \   >>> distinct_prime_factors(1L)\n    0L\n    >>> distinct_prime_factors(2L)\n\
    \    1L\n    >>> distinct_prime_factors(3L)\n    1L\n", "{\n    if (n == 0)\n\
    \    {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return\
    \ 2;\n    }\n    else if (n % 2 == 0)\n    {\n        return modp(n / 2, p) *\
    \ modp(n / 2, p) % p;\n    }\n    else\n    {\n        return modp(n / 2, p) *\
    \ modp(n / 2, p) * 2 % p;\n    }\n}\n/*\nTest if n is probably prime.\n    >>>\
    \ is_probable_prime(7L)\n    True\n    >>> is_probable_prime(10000000000000000039L)\n\
    \    True\n    >>> is_probable_prime(9999999999999999991L)\n    False\n    >>>\
    \ is_probable_prime(10000000000000000007L)\n    True\n    >>> is_probable_prime(85L)\n\
    \    False\n*/", "{\n\tlong a = 1L;\n\twhile (n != 0L) {\n\t\twhile ((n % 2L)\
    \ == 0L) {\n\t\t\tn /= 2L;\n\t\t\tlong b = p % 8L;\n\t\t\tif (b == 3L || b ==\
    \ 5L)\n\t\t\t\tp = -p;\n\t\t}\n\t\tn -= 1L;\n\t\tif (p < 0L)\n\t\t\ta = -a;\n\t\
    \ta = (a * n) % p;\n\t}\n\tif (p == 1L)\n\t\treturn 0L;\n\tif (a < 0L)\n\t\ta\
    \ += p;\n\treturn a;\n}\n// \nlong poly_horner(inout(long[]) A, long x) {\n\t\
    long n = A.length;\n\tlong s = A[n - 1];\n\tlong i = n - 2;\n\twhile (i >= 0)\
    \ {\n\t\ts = s * x + A[i];\n\t\ti -= 1;\n\t}\n\treturn s;\n}\n// ", "{\n    if\
    \ (p == 1) \n    {\n        return 0;\n    }\n    return powmod(2L, n, p);\n}",
  "{\n\tif (n == 0) return 1;\n\tlong c = 1L;\n\tlong e = p - 2L;\n\twhile (e > 0)\
    \ \n\t{\n\t\tif (e & 1) c = (c * n) % p;\n\t\tn = (n * n) % p;\n\t\te = e >> 1;\n\
    \t}\n\treturn c;\n}", "{\n    long ans = 1L;\n    long a = 2L;\n    while (n >\
    \ 0L) {\n        if (n % 2L == 1L) {\n            ans = (ans * a) % p;\n     \
    \   }\n        a = (a * a) % p;\n        n /= 2L;\n    }\n    return ans;\n}",
  "{\n    ulong r = 1;\n    for (int i = 0; i < n; i++)\n        r = r * 2 % p;\n\
    \    return r;\n}\n/*\nReturn the number of bits required to express n (be aware\
    \ of numerics).\n    >>> bits_required(0L)\n    0\n    >>> bits_required(1L)\n\
    \    1\n    >>> bits_required(2L)\n    2\n    >>> bits_required(3L)\n    2\n \
    \   >>> bits_required(4L)\n    3\n    >>> bits_required(5L)\n    3\n*/", "{\n\
    \  if (n < 0) {\n    return modp(-n, p);\n  }\n  else if (n == 0) {\n    return\
    \ 1;\n  }\n  else if (n == 1) {\n    return 0;\n  }\n  else if (n % 2 == 0) {\n\
    \    long m = modp(n / 2, p);\n    return (m + m) % p;\n  }\n  else {\n    return\
    \ (modp(n - 1, p) + p - 1) % p;\n  }\n}\n/*\nA power of 2.\n    >>> ispow2(0)\n\
    \    True\n    >>> ispow2(1)\n    True\n    >>> ispow2(2)\n    True\n    >>> ispow2(3)\n\
    \    False\n    >>> ispow2(4)\n    True\n    >>> ispow2(0x1000000000000000L)\n\
    \    True\n    >>> ispow2(0x1000000000000001L)\n    False\n*/", "    @safe pure\
    \ nothrow\n{\n    /*\n        if p == 1 or n == 0, return 0\n        if p == 2,\
    \ return (n % 2 == 0) ? 0 : 1\n        if p == -1, return (n % 2 == 0) ? 1 : -1\n\
    \    */\n    import std.bitmanip;\n    if (p == 1 || n == 0)\n        return 0;\n\
    \    if (p == 2)\n        return (n % 2 == 0) ? 0 : 1;\n    if (p == -1)\n   \
    \     return (n % 2 == 0) ? 1 : -1;\n    return powmod(2, n, p);\n}", "{\n   \
    \ if (n == 0) \n    {\n        return 1;\n    }\n    else \n    {\n        long\
    \ c = modp(n >> 1, p);\n        if (n & 1) \n        {\n            return (c\
    \ * c * 2) % p;\n        }\n        else \n        {\n            return (c *\
    \ c) % p;\n        }\n    }\n}", "{\n    long res = 1L;\n    foreach (i; 0 ..\
    \ n)\n    {\n        res = (res * 2L) % p;\n    }\n    return res;\n}\n/*\nReturn\
    \ n*2^-1 modulo p (be aware of numerics).\n*/\nlong modpinv(long n, long p) \n\
    {\n    long res = 1L;\n    foreach (i; 0 .. n)\n    {\n        res = (res * 2L)\
    \ % p;\n    }\n    return (res * n) % p;\n}", "{\n\tif (n == 0) return 1;\n\t\
    long pow = modp(n / 2, p);\n\tpow = pow * pow % p;\n\tif (n % 2) pow = pow * 2\
    \ % p;\n\treturn pow;\n}", "{\n    if (n < 1) \n    {\n        return 1;\n   \
    \ }\n    if (n == 1) \n    {\n        return 2;\n    }\n    if (n % 2 == 0) \n\
    \    {\n        long x = modp(n / 2, p);\n        return (x * x) % p;\n    }\n\
    \    else \n    {\n        return (2 * modp(n - 1, p)) % p;\n    }\n}", "in {\n\
    \    assert(n >= 0L);\n    assert(p > 0L);\n}\nbody {\n    auto a = 1L;\n    auto\
    \ i = n;\n    while (i != 0L)\n    {\n        auto k = i % 2L;\n        if (k\
    \ == 1L)\n        {\n            a = (a * 2L) % p;\n        }\n        i = i /\
    \ 2L;\n        p = (p * p) % p;\n    }\n    return a;\n}", "{\n    assert(0L <=\
    \ n && n < 2L * p);\n    if (n >= p)\n    {\n        return (n * 2L - p) % p;\n\
    \    }\n    else\n    {\n        return n;\n    }\n}", "{\n    if (n < 0L) \n\
    \    {\n        return p - modp(-n, p);\n    }\n    auto x = (ulong)n;\n    auto\
    \ y = 1UL;\n    while (x > 0UL) \n    {\n        y = (y * 2UL) % p;\n        x\
    \ -= 1UL;\n    }\n    return (long)y;\n}\n/*\nReturn tuple of two lists of numbers\
    \ which are connected in the factor graph.\n    >>> [filter(lambda x: x[0], d)\
    \ for d in fg(2L, 3L)]\n    [[(1L, (1L, 1L))], [(2L, (2L, 1L))]]\n    >>> [filter(lambda\
    \ x: x[0], d) for d in fg(3L, 5L)]\n    [[(1L, (1L, 1L))], [(2L, (2L, 2L))], [(3L,\
    \ (3L, 3L))]]\n    >>> [filter(lambda x: x[0], d) for d in fg(5L, 7L)]\n    [[(1L,\
    \ (1L, 1L))], [(2L, (2L, 4L))], [(3L, (3L, 5L))], [(4L, (4L, 2L))], [(5L, (5L,\
    \ 6L))]]\n    >>> [filter(lambda x: x[0], d) for d in fg(2L, 7L)]\n    [[(1L,\
    \ (1L, 1L))], [(2L, (2L, 4L))]]\n    >>> [filter(lambda x: x[0], d) for d in fg(11L,\
    \ 13L)]\n    [[(1L, (1L, 1L))], [(2L, (2L, 3L))], [(3L, (3L, 10L))], [(4L, (4L,\
    \ 12L))], [(5L, (5L, 9L))], [(6L, (6L, 4L))], [(7L, (7L, 6L))], [(8L, (8L, 11L))],\
    \ [(9L, (9L, 8", "{\n    enum long a = 1L;\n    long x = p;\n    for (; n > 0L;\
    \ n >>= 1L) \n    {\n        if (n & 1L) a = a * x % p;\n        x = x * x % p;\n\
    \    }\n    return a;\n}\n/*\nReturn gcd of a and b.\n    >>> gcd(37L, 6L)\n \
    \   1L\n    >>> gcd(2016L, 60L)\n    4L\n*/\nlong gcd(long a, long b) \n{\n  \
    \  while (b) \n    {\n        long t = a % b;\n        a = b;\n        b = t;\n\
    \    }\n    return a;\n}\n/*\nReturn list of factors of n.\n    >>> listFactors(1L)\n\
    \    [1L]\n    >>> listFactors(10L)\n    [1L, 2L, 5L, 10L]\n    >>> listFactors(11L)\n\
    \    [1L, 11L]\n    >>> listFactors(100L)\n    [1L, 2L, 4L, 5L, 10L, 20L, 25L,\
    \ 50L, 100L]\n*/\nlong[] listFactors(long n) \n{\n    import std.array;\n    assert(n\
    \ > 0L);\n    auto d = cast(long[])array(1L);\n    for (long k = 2L; k <= n /\
    \ k; k++) \n    {\n        if (n % k == 0L) \n        {\n            d ~= k;\n\
    \            if (k != n / k) d ~= n / k;\n        }\n    }\n    return d;\n}\n\
    /*\nReturn tuple (n, a, b) such that n = a*b.\n    >>> factor(5L)\n    (5L, 1L,\
    \ 5L)\n    >>> factor(2016L)\n    (2016L, 1L, 2016L)\n    >>> factor(2017L)\n\
    \    (2017L, 1L, 2017L)\n    >>> factor(100L)\n    (100L, 2L, 50L)\n*/\nTuple!(",
  "{\n    long result = 1L;\n    long halfp = p >> 1L;\n    long i = n;\n    while\
    \ (i > 0L)\n    {\n        if (i & 1L)\n        {\n            result = (result\
    \ * n) % p;\n        }\n        i >>= 1L;\n        n = (n * n) % p;\n    }\n \
    \   return result;\n}\n/*\nCompute the number of permutations of n items taken\
    \ k at a time.\n    >>> combinations(1L, 1L)\n    1L\n    >>> combinations(2L,\
    \ 1L)\n    2L\n    >>> combinations(2L, 2L)\n    1L\n    >>> combinations(4L,\
    \ 2L)\n    6L\n    >>> combinations(5L, 3L)\n    10L\n    >>> combinations(6L,\
    \ 4L)\n    15L\n*/\nlong combinations(long n, long k) \n{\n    if (k > n)\n  \
    \  {\n        return 0L;\n    }\n    else\n    {\n        long a = 1L;\n     \
    \   long b = 1L;\n        long i = n;\n        long j = 1L;\n        while (i\
    \ > n - k)\n        {\n            a *= i;\n            b *= j;\n            i\
    \ -= 1L;\n            j += 1L;\n        }\n        return a / b;\n    }\n}\nstruct\
    \ modular_t \n{\n    long modulus;\n    long number;\n};\n@safe unittest\n{\n\
    \    modular_t a = (modular_t) { 3L, 2L };\n    modular_t b = (modular_t) { 3L,\
    \ 1L };\n    assert((a + b).number == 0L);\n    assert((a - b).number == 1L);\n\
    \    assert((a * b).number == 2L);\n    assert((a / b).number == 2L);\n    assert((a\
    \ + b).modulus == 3L);\n    assert((a - b).modulus == 3L);\n    assert((a * b).modulus\
    \ == 3L);\n    assert((a / b).modulus == 3L);\n", "{\n    int x = 1;\n    while\
    \ (n > 0) {\n        x = (int)(n % 2) ? x * 2 % p : x;\n        n /= 2;\n    \
    \    x = (int)(n % 2) ? x * 2 * x % p : x * x % p;\n        n /= 2;\n    }\n \
    \   return x;\n}\n/*\nInvert n modulo p if exists (be aware of numerics).\n  \
    \  >>> inverse(2L, 101L)\n    51L\n    >>> inverse(11L, 101L)\n    91L\n    >>>\
    \ inverse(100L, 101L)\n    1L\n    >>> inverse(1L, 101L)\n    1L\n    >>> inverse(0L,\
    \ 101L)\n    Traceback (most recent call last):\n        ...\n    std.exception.ValueError:\
    \ 0 has no inverse modulo 101\n    \n*/\nlong inverse(long n, long p) \n{\n  \
    \  assert(n % p != 0);\n    int a = n;\n    int b = p;\n    int x = 0;\n    int\
    \ lastx = 1;\n    int y = 1;\n    int lasty = 0;\n    while (b != 0) {\n     \
    \   int quot = a / b;\n        a %= b;\n        auto t = a;\n        a = b;\n\
    \        b = t;\n        t = x;\n        x = lastx - quot * x;\n        lastx\
    \ = t;\n        t = y;\n        y = lasty - quot * y;\n        lasty = t;\n  \
    \  }\n    if (lasty < 0) {\n        lasty += p;\n    }\n    return lasty;\n}\n\
    /*\nReturn integer square root of n modulo p (see https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm).\n\
    \    >>> isqrt(17L, 41L)\n    9L\n    >>> isqrt(20L, 101L)\n    81L\n    >>> isqrt(5L,\
    \ 101L)\n    2L\n    >>> isqrt(10L, 101L)\n    Traceback (most recent", "{\n \
    \ long d, r;\n  if (n < 0) \n  {\n    d = -n / p;\n    r = n - d * p;\n  }\n \
    \ else \n  {\n    d = n / p;\n    r = n - d * p;\n  }\n  return r;\n}", "{\n \
    \   size_t x = 1L;\n    for (size_t i = 0; i < n; i++) {\n        x = (x * 2L)\
    \ % p;\n    }\n    return x;\n}", "{\n    long result = 1L;\n    long pow = n;\n\
    \    while (p > 0L) \n    {\n        if (p & 1L)\n            result = (result\
    \ * pow) % p;\n        pow = (pow * pow) % p;\n        p = p >> 1L;\n    }\n \
    \   return result;\n}", "{\n    if (p == 1) return 0;\n    long result = 1;\n\
    \    long factor = n;\n    long power = p;\n    while (power > 0) {\n        long\
    \ remainder = power % 2;\n        if (remainder == 1) result = (result * factor)\
    \ % p;\n        factor = (factor * factor) % p;\n        power = power / 2;\n\
    \    }\n    return result;\n}\n// Find the first number with n divisors.\nlong\
    \ find_first_n_divisors(long n) \n{\n    long test = n;\n    while (true) {\n\
    \        long count = 0;\n        foreach (i; 1 .. test) {\n            if (test\
    \ % i == 0) count = count + 1;\n        }\n        if (count == n) return test;\n\
    \        test = test + 1;\n    }\n}\n/*\nFind the product of the coefficients,\
    \ a and b, for the quadratic expression that produces the maximum number of primes\
    \ for consecutive values of n, starting with n = 0.\n    >>> euler27()\n    -59231\n\
    */\nlong euler27() \n{\n    long max_num_primes = 0;\n    long max_a = 0;\n  \
    \  long max_b = 0;\n    foreach (a; -999 .. 1000) {\n        foreach (b; -1000\
    \ .. 1001) {\n            long n = 0;\n            while (true) {\n          \
    \      long result = (n * n) + (a * n) + b;\n                if (result < 2) break;\n\
    \                if (is_prime(result)) n = n + 1;\n                else break;\n\
    \            }\n            if (n > max_num_primes) {\n                max_num_primes\
    \ = n;\n                max_a = a;\n                max_b = b;\n            }\n\
    \        }\n    }\n    return max_a * max_b;\n}\n/*\nFind the sum of the digits\
    \ in the number 100!\n    >>> euler20()\n    648\n*/\nlong euler20() \n{\n   \
    \ long[] factorial = [1L];\n    for (long i =", "{\n    long r = 1L;\n    long\
    \ b = 2L;\n    while (n != 0L) \n    {\n        if (n % 2L != 0L)\n          \
    \  r = (r * b) % p;\n        n /= 2L;\n        b = (b * b) % p;\n    }\n    return\
    \ r;\n}\n/*\nReturn the inverse of n modulo p.\n    >>> modinv(3L, 11L)\n    4L\n\
    \    >>> modinv(4L, 11L)\n    3L\n    >>> modinv(5L, 7L)\n    5L\n    >>> modinv(4L,\
    \ 7L)\n    5L\n    >>> modinv(100L, 101L)\n    99L\n    >>> modinv(100L, 10007L)\n\
    \    99L\n    >>> modinv(100L, 10009L)\n    9L\n*/\nlong modinv(long n, long p)\
    \ \n{\n    assert(gcd(n, p) == 1L);\n    return modp(p - 2L, p);\n}\n/*\nGenerate\
    \ a random prime number p with 1 <= p <= n.\n    >>> random_prime(2L)\n    2L\n\
    \    >>> random_prime(3L)\n    3L\n    >>> random_prime(4L)\n    3L\n    >>> random_prime(10L)\n\
    \    7L\n    >>> random_prime(11L)\n    11L\n    >>> random_prime(100)\n    73L\n\
    */\nlong random_prime(long n) \n{\n    long p = cast(long) random_number(n);\n\
    \    if (p % 2L == 0L)\n        p += 1L;\n    while (!is_prime(p))\n        p\
    \ += 2L;\n    return p;\n}\n/*\nExtended Euclidean algorithm.", "in\n{\n    assert(p\
    \ > 0);\n    assert(p == 101L);\n    long result = 1L;\n    long b = 2L;\n   \
    \ while (n != 0L)\n    {\n        if ((n & 1L) != 0L)\n        {\n           \
    \ result = (result * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b)\
    \ % p;\n    }\n    return result;\n}\n/*\nReturn the number of bits in the binary\
    \ representation of x.\n    >>> bitlength(3L)\n    2\n    >>> bitlength(100L)\n\
    \    7\n    >>> bitlength(2L**1000L)\n    1001\n    >>> bitlength(2L**1000L-1)\n\
    \    1000\n    >>> bitlength(2L**1000L+2)\n    1001\n    \n*/\nlong bitlength(long\
    \ x) \nin\n{\n    long n = 0L;\n    while (x != 0L)\n    {\n        n += 1L;\n\
    \        x >>= 1L;\n    }\n    return n;\n}\n/*\nReturn the base 2 logarithm of\
    \ x.", "{\n  long n2 = n;\n  long p2 = p;\n  long result = 1L;\n  while (n2 >\
    \ 0L) \n  {\n    result = (result * (((n2 % 2L) == 1L) ? ((n2 * result) % p2)\
    \ : 1L)) % p2;\n    n2 = n2 / 2L;\n  }\n  return result;\n}\nlong factorial(long\
    \ n) \n{\n  long n2 = n;\n  long result = 1L;\n  long n3 = n2;\n  while (n3 >\
    \ 0L) \n  {\n    result = (result * n3) % 987654321L;\n    n3 = n3 - 1L;\n  }\n\
    \  return result;\n}\nlong modularInverse(long a, long n) \n{\n  long t = 0L;\n\
    \  long newt = 1L;\n  long r = n;\n  long newr = a;\n  long quotient = 0L;\n \
    \ while (newr != 0L) \n  {\n    quotient = r / newr;\n    typeof(t) tmp = newt;\n\
    \    newt = t - (quotient * newt);\n    t = tmp;\n    tmp = newr;\n    newr =\
    \ r - (quotient * newr);\n    r = tmp;\n  }\n  if (r > 1L) {\n    return 0L;\n\
    \  }\n  if (t < 0L) {\n    t = t + n;\n  }\n  return t;\n}", "{\n    long n0,p0,z;\n\
    \    n0 = n;\n    p0 = p;\n    z = 1L;\n    if (n0>-1) \n    {\n        for (int\
    \ i = 0; i<n0; i++) \n        {\n            z = z*2L % p0;\n        }\n    }\n\
    \    else \n    {\n        for (int i = 0; i<-n0; i++) \n        {\n         \
    \   z = z*(p0-1) % p0;\n        }\n    }\n    return z;\n}\n/*\nReturn (n, m)\
    \ Jacobi symbol.\n    >>> jacobi(8L, 15L)\n    -1L\n    >>> jacobi(12L, 25L)\n\
    \    1L\n    >>> jacobi(12L, -25L)\n    -1L\n    >>> jacobi(1234567890123456789L,\
    \ 313107L)\n    -1L\n    >>> jacobi(12, 11)\n    1L\n    >>> jacobi(13, -11)\n\
    \    -1L\n*/\nlong jacobi(long n, long m) \n{\n    long b = 1L;\n    long x =\
    \ n;\n    long t,y;\n    if (m%2==0) \n    {\n        return 0L;\n    }\n    if\
    \ (m<0) \n    {\n        m = -m;\n        if (n%4==3) \n        {\n          \
    \  b = -b;\n        }\n    }\n    for (;;) \n    {\n        if (x%2==0) \n   \
    \     {\n            t = 0L;\n            while (x%2==0) \n            {\n   \
    \             t = t+1L;\n                x = x/2L;\n            }\n          \
    \  if (t%2==1) \n            {\n                if (m%8==3 || m%8==5) \n     \
    \           {\n                    b = -b;\n                }\n            }\n\
    \        }\n        y = m;\n        m = x;\n        x = y%x", "{\n    long b =\
    \ 1L;\n    while (n != 0L) {\n        if (n % 2L == 1L) {\n            b = (b\
    \ * 2L) % p;\n        }\n        n /= 2L;\n    }\n    return b;\n}\n/*\nMultiply\
    \ two matrices.\n    >>> mmul([[1L,2L],[3L,4L]], [[5L,6L],[7L,8L]])\n    [[19L,\
    \ 22L], [43L, 50L]]\n    >>> mmul([[1L,2L],[3L,4L]], [[3L,4L],[5L,6L]])\n    [[13L,\
    \ 16L], [29L, 36L]]\n    >>> mmul([[3L,4L],[5L,6L]], [[1L,2L],[3L,4L]])\n    [[13L,\
    \ 16L], [29L, 36L]]\n    >>> mmul([[2L,4L],[6L,8L]], [[1L,3L],[5L,7L]])\n    [[26L,\
    \ 38L], [62L, 92L]]\n    >>> mmul([[1L,2L,3L],[4L,5L,6L]], [[1L,3L,5L],[2L,4L,6L]])\n\
    \    [[9L, 12L, 15L], [19L, 26L, 33L], [29L, 40L, 51L]]\n    >>> mmul([[1L,2L,3L],[4L,5L,6L]],\
    \ [[0L,0L,0L],[0L,0L,0L]])\n    [[0L, 0L, 0L], [0L, 0L, 0L], [0L, 0L, 0L]]\n \
    \   >>> mmul([[0L,0L,0L],[0L,0L,0L]], [[1L,2L,3L],[4L,5L,6L]])\n    [[0L, 0L,\
    \ 0L], [0L, 0L, 0L]]\n    >>> mmul([[-1L,", "{\n    long t;\n    if (n == 0) {\n\
    \        return 1;\n    }\n    if (n & 1) {\n        t = modp(n-1, p);\n     \
    \   return ((t*2) % p) - 1;\n    }\n    else {\n        t = modp(n/2, p);\n  \
    \      return (t*t) % p;\n    }\n}\nlong modp_rec(long n, long p) \n{\n    if\
    \ (n == 0) {\n        return 1;\n    }\n    if (n & 1) {\n        return ((modp_rec(n-1,\
    \ p)*2) % p) - 1;\n    }\n    else {\n        return (modp_rec(n/2, p)*modp_rec(n/2,\
    \ p)) % p;\n    }\n}\nlong[] modp_iter(long n, long p) \n{\n    long[] rn = new\
    \ long[1];\n    rn[0] = 1;\n    long[] rn_1 = new long[1];\n    rn_1[0] = 0;\n\
    \    long[] rn_2 = new long[1];\n    rn_2[0] = 0;\n    long[] t = new long[1];\n\
    \    t[0] = 0;\n    long[] n_2 = new long[1];\n    n_2[0] = n;\n    long[] n_1\
    \ = new long[1];\n    n_1[0] = n - 1;\n    while(n_2[0] > 0) {\n        if (n_2[0]\
    \ & 1) {\n            if (n_1[0] & 1) {\n                t[0] = rn_1[0];\n   \
    \             rn_1[0] = rn[0];\n                rn[0] = (rn[0]*2) % p;\n     \
    \           rn[0] = rn[0] - 1;\n                rn_2[0] = t[0];\n            }\n\
    \            else {\n                rn_2[0] = rn_1[0];\n                rn_",
  "{\n    long z = 1L;\n    while (n != 0L) {\n        if (n % 2L == 1L) {\n     \
    \       z = z * 2L % p;\n        }\n        n = n / 2L;\n        if (n != 0L)\
    \ {\n            z = z * z % p;\n        }\n    }\n    return z;\n}", "{\n   \
    \ if (p == 1)\n        return 0;\n    if (n < 0)\n        n += p;\n    long res\
    \ = 1;\n    foreach (i, long; iota(n))\n        res = (res * 2) % p;\n    return\
    \ res;\n}\n/*\nReturn the Hamming distance between integers a and b.\n    >>>\
    \ hamming_distance(1, 2)\n    2\n    >>> hamming_distance(16, 31)\n    5\n*/\n\
    long hamming_distance(long a, long b) \n{\n    return a ^ b;\n}\n/*\nReturn the\
    \ Hamming weight of the integer x (number of non-zero bits).\n    >>> hamming_weight(3)\n\
    \    2\n    >>> hamming_weight(4)\n    1\n    >>> hamming_weight(5)\n    2\n \
    \   >>> hamming_weight(7)\n    3\n    >>> hamming_weight(31)\n    5\n*/\nlong\
    \ hamming_weight(long x) \n{\n    return hamming_distance(x, 0);\n}\n/*\nReturn\
    \ the parity of the binary representation of the integer x (number of ones modulo\
    \ 2).\n    >>> parity(0)\n    0\n    >>> parity(1)\n    1\n    >>> parity(2)\n\
    \    1\n    >>> parity(3)\n    0\n    >>> parity(7)\n    1\n    >>> parity(9)\n\
    \    0\n*/\nlong parity(long x) \n{\n    if (x == 0)\n        return 0;\n    return\
    \ 1 - parity(x & (x - 1));\n}\n/*\nReturn the number of leading 0s in the binary\
    \ representation of the integer x.\n    >>> clz(1)\n    0\n    >>> clz(2)\n  \
    \  1\n    >>> clz(7)\n    29\n    >>> clz(9)\n    28\n*/\nlong clz(long x) \n\
    {\n    if (x == 0)\n        return 64;\n    long p = 0;\n    while ((x & 1) ==\
    \ 0) \n    {\n        x >>= 1;\n        p++;\n    }\n    return p;\n}\n/*\n",
  "{\n    long t = 2;\n    if (n == 0)\n    {\n        return 1;\n    }\n    for (size_t\
    \ k = floor(log(n, 2.0)); k > 0; k--)\n    {\n        t = (t * t) % p;\n     \
    \   if (bit(n, k - 1) == 1)\n        {\n            t = (t * 2) % p;\n       \
    \ }\n    }\n    return t;\n}\n/*\nReturn a tuple of the composition of n and modp(n,\
    \ p).\n    >>> compose2(15L, 3L)\n    (2L, 1L)\n    >>> compose2(15L, 5L)\n  \
    \  (2L, 4L)\n    >>> compose2(1L, 7L)\n    (0L, 1L)\n    >>> compose2(0L, 7L)\n\
    \    (0L, 1L)\n*/\ntuple!(long, long) compose2(long n, long p) \n{\n    size_t\
    \ k = floor(log(n, 2.0));\n    long t = modp(n, p);\n    return tuple(k, t);\n\
    }\n/*\nReturn a tuple of the composition of n and modp(n, p)\nfor all p in primes.\n\
    \    >>> compose([2L, 3L, 5L, 7L], 15L)\n    ((2L, 1L), (2L, 4L), (2L, 3L), (1L,\
    \ 6L))\n*/\ntuple!(tuple!(long, long), tuple!(long, long), tuple!(long, long),\
    \ tuple!(long, long)) compose(Primes primes, long n) \n{\n    auto res = tuple(compose2(n,\
    \ primes.prime(0)), compose2(n, primes.prime(1)), compose2(n, primes.prime(2)),\
    \ compose2(n, primes.prime(3)));\n    return res;\n}\n/*\nGiven a tuple of a number\
    \ and its modp(n, p) for each prime p in\nprimes, return the number.\n    >>>\
    \ decompose([(0L, 1L),", "{\n    long b = 1L;\n    while (n != 0L) \n    {\n \
    \       if (n & 1L != 0L) \n        {\n            b = b * 2L % p;\n        }\n\
    \        n = n >> 1L;\n        if (n != 0L) \n        {\n            b = b * b\
    \ % p;\n        }\n    }\n    return b;\n}", "{\n    long r = 1L;\n    long s\
    \ = 2L;\n    long t = 2L;\n    long u = 2L;\n    long v = 2L;\n    long w = 2L;\n\
    \    long x = 2L;\n    long y = 2L;\n    long z = 2L;\n    long a = 2L;\n    long\
    \ b = 2L;\n    long c = 2L;\n    long d = 2L;\n    long e = 2L;\n    long f =\
    \ 2L;\n    long g = 2L;\n    long h = 2L;\n    long i = 2L;\n    long j = 2L;\n\
    \    long k = 2L;\n    long l = 2L;\n    long m = 2L;\n    long o = 2L;\n    long\
    \ q = 2L;\n    long n_t = n;\n    for (; n_t > 0L; n_t--)\n    {\n        r =\
    \ (r * s) % p;\n        s = (s * t) % p;\n        t = (t * u) % p;\n        u\
    \ = (u * v) % p;\n        v = (v * w) % p;\n        w = (w * x) % p;\n       \
    \ x = (x * y) % p;\n        y = (y * z) % p;\n        z = (z * a) % p;\n     \
    \   a = (a * b) % p;\n        b = (b * c) % p;\n        c = (c * d) % p;\n   \
    \     d = (d * e) % p;\n        e = (e * f) % p;\n        f = (f * g) % p;\n \
    \       g = (g * h) % p;\n        h = (h * i) % p;\n        i = (i * j) % p;\n\
    \        j = (j * k) % p;\n        k = (k * l) % p;\n        l = (l * m) % p;\n\
    \        m = (m * o) % p;\n        o = (o * q) % p;\n        q = (q * n_t) % p",
  "{\n    long ans = 1L;\n    long a = 2L;\n    long b = n;\n    while (b > 0L) \n\
    \    {\n        if (b % 2L == 1L) \n        {\n            ans = (ans * a) % p;\n\
    \        }\n        a = (a * a) % p;\n        b = b / 2L;\n    }\n    return ans;\n\
    }\n/*\nReturn the number of bits set in n (be aware of numerics).\n    >>> bitcount(1L)\n\
    \    1\n    >>> bitcount(2L)\n    1\n    >>> bitcount(3L)\n    2\n    >>> bitcount(0L)\n\
    \    0\n    >>> bitcount(10L)\n    2\n    >>> bitcount(100L)\n    3\n*/", "{\n\
    \    long result = 1L;\n    long b = 2L;\n    while (n != 0L) {\n        if (n\
    \ % 2L == 1L) {\n            result = (result * b) % p;\n        }\n        n\
    \ = n / 2L;\n        b = (b * b) % p;\n    }\n    return result;\n}", "{\n  long\
    \ r;\n  if (n > 0) \n  {\n    n %= p - 1;\n    r = pow(2L, n);\n  }\n  else \n\
    \  {\n    n = -n;\n    n %= p - 1;\n    r = pow(2L, p - 1 - n);\n  }\n  return\
    \ r % p;\n}\n/*\nReturn the number of digits in n (base 2)\n    >>> bitcount(7L)\n\
    \    3\n    >>> bitcount(4L)\n    3\n    >>> bitcount(0L)\n    0\n*/", "{\n  \
    \  long result = 1L;\n    long factor = 2L;\n    while (n != 0L) {\n        if\
    \ (n % 2L != 0L) {\n            result = (result * factor) % p;\n        }\n \
    \       factor = (factor * factor) % p;\n        n = n / 2L;\n    }\n    return\
    \ result;\n}", "{\n    return power(2L, n, p);\n}\n/*\nConvert an integer to a\
    \ string of binary digits, e.g., '1101'.\n    >>> _int2bin(2L)\n    '10'\n   \
    \ >>> _int2bin(4L)\n    '100'\n    >>> _int2bin(16L)\n    '10000'\n    >>> _int2bin(1234L)\n\
    \    '10011010010'\n    \n*/\nstring _int2bin(long n) {\n    // Convert an integer\
    \ to a string of binary digits.\n    if (n < 0L) {\n        throw new Exception(\"\
    Negative numbers not supported\");\n    }\n    if (n == 0L) {\n        return\
    \ \"0\";\n    }\n    return format(\"%0b\", n);\n}\n/*\nReturn a string of n space\
    \ characters.\n    >>> _spaces(2)\n    '  '\n    >>> _spaces(3)\n    '   '\n \
    \   \n*/\nstring _spaces(int n) {\n    return repeat(\" \", n);\n}\n/*\nReturn\
    \ a 64-bit integer of the form 2^0 + 2^1 + ... + 2^n.\n    >>> _powers_of_two(2)\n\
    \    3L\n    >>> _powers_of_two(3)\n    7L\n    >>> _powers_of_two(5)\n    31L\n\
    \    \n*/\nlong _powers_of_two(int n) {\n    if (n < 0) {\n        throw new Exception(\"\
    Negative numbers not supported\");\n    }\n    return (1L << n) - 1L;\n}\n/*\n\
    Return a non-negative integer of the form n0 + n1*2 + n2*4 + ... + n_63*2^63.\n\
    \    >>> _index_to_integer(5, 3, 2, 1)\n    1152921504606846977L\n    >>> _index_to_integer(1,\
    \ 0, 0, 0)\n    1L\n    >>> _index_to_integer(0, 0, 0, 0)\n    0L\n    \n*/\n\
    long _index_to_integer(int n0, int n1", "{\n  long r = 1L;\n  while (n > 0L) {\n\
    \    if (n & 1L) {\n      r = r * 3L % p;\n    }\n    n >>= 1L;\n    long s =\
    \ 3L * 3L % p;\n    if (s != 1L) {\n      r = r * s % p;\n    }\n  }\n  return\
    \ r;\n}\n/*\nReturn n^p modulo mod.\n    >>> modpow(10L, 0L, 1001L)\n    1L\n\
    \    >>> modpow(10L, 1L, 1001L)\n    10L\n    >>> modpow(10L, 2L, 1001L)\n   \
    \ 100L\n    >>> modpow(10L, 10L, 1001L)\n    10L\n    >>> modpow(10L, 11L, 1001L)\n\
    \    1L\n    >>> modpow(10L, 20L, 1001L)\n    1L\n    >>> modpow(10L, 40L, 1001L)\n\
    \    1L\n    >>> modpow(10L, 80L, 1001L)\n    1L\n    >>> modpow(2L, 3L, 10L)\n\
    \    8L\n    >>> modpow(13L, 4L, 11L)\n    9L\n    >>> modpow(2L, 3L, 10L)\n \
    \   8L\n    >>> modpow(10L, 10L, 10L)\n    0L\n*/\nlong modpow(long n, long p,\
    \ long mod) \n{\n  n %= mod;\n  if (n == 0L) {\n    return 0L;\n  }\n  long r\
    \ = 1L;\n  while (p > 0L) {\n    if (p & 1L) {\n      r = r * n % mod;\n    }\n\
    \    p >>= 1L;\n    long s = n * n % mod;\n    if (s != 1L) {\n      n = s;\n\
    \    }\n  }\n  return r;\n}\n/*\nReturn the Lucas sequence for n, modulo p.\n\
    \    >>> lucas(", "    if (n < 0)\n        return modp(-n, p);\n    else if (n\
    \ >= 0)\n        return powmod(2L, n, p);", "{\n    long result = 1L;\n    long\
    \ temp = p;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result\
    \ = (result * temp) % p;\n        }\n        temp = (temp * temp) % p;\n     \
    \   n = n / 2L;\n    }\n    return result;\n}\n/*\nFor a prime p and integer n,\
    \ compute a power of\np that is congruent to n modulo p^2.\n    >>> p = 101L\n\
    \    >>> [pow101(i, p) for i in range(p)]\n    [1L, 1L, 41L, 27L, 91L, 70L, 46L,\
    \ 78L, 17L, 96L, 53L, 84L, 12L, 10L,\n    62L, 98L, 35L, 7L, 23L, 31L, 5L, 25L,\
    \ 50L, 94L, 89L, 57L, 3L, 37L,\n    66L, 82L, 45L, 85L, 9L, 99L, 68L, 74L, 63L,\
    \ 88L, 42L, 77L, 71L, 19L,\n    32L, 6L, 95L, 100L, 81L, 48L, 76L, 29L, 59L, 21L,\
    \ 61L, 39L, 33L,\n    80L, 51L, 65L, 13L, 40L, 30L, 87L, 93L, 60L, 44L, 75L, 55L,\
    \ 15L,\n    47L, 73L, 26L, 97L, 52L, 11L, 24L, 92L, 79L, 58L, 64L, 14L, 4L, 69L,\n\
    \    67L, 86L, 18L, 34L, 38L, 8L, 56L, 83L, 49L, 54L, 28L, 43L, 72L, 20L,\n  \
    \  90L, 16L, 22L, 36L, 2L]\n*/\nlong pow101(long n, long p) \n{\n    long z =\
    \ n % p;\n    long result = z;\n    long temp = p;\n    while (z >= temp) {\n\
    \       ", "{\n    long _pow=pow(2L, n);\n    long _mod=_pow % p;\n    return\
    \ _mod;\n}\n/*\nReturn a list of up to n left-to-right Huffman codewords and their\n\
    respective probabilities from the Huffman code tree.\n    >>> huffman({'A': 8L,\
    \ 'B': 5L, 'C': 3L})\n    [('A', '0'), ('B', '10'), ('C', '11')]\n    >>> huffman({'A':\
    \ 8L, 'B': 5L, 'C': 3L, 'D': 4L})\n    [('D', '11'), ('C', '100'), ('B', '101'),\
    \ ('A', '110')]\n    >>> huffman({'A': 1L, 'B': 1L, 'C': 1L, 'D': 1L, 'E': 1L})\n\
    \    [('A', '00000'), ('B', '00001'), ('C', '00010'), ('D', '00011'), ('E', '00100')]\n\
    \    >>> huffman({'A': 5L, 'B': 4L, 'C': 3L, 'D': 2L, 'E': 1L})\n    [('E', '00'),\
    \ ('D', '01'), ('C', '10'), ('B', '110'), ('A', '111')]\n*/\nauto huffman(dictionary\
    \ d) \n{\n    //tuple is like a std::pair\n    alias tuple_alias=typeof(tuple(1L,\
    \ \"0\"));\n    //std::priority_queue\n    auto pq=std.priorityqueue!(tuple_alias,\
    \ \"a > b\")(tuple(d.value, d.key));\n    while(pq.length > 1)\n    {\n      \
    \  auto t=pq.pop();\n        auto l=t[1];\n        auto f=t[0];\n        t=pq.pop();\n\
    \        auto r=t[1];\n        f+=t[0];\n        pq.push(tuple(f, l ~ r));\n \
    \   }\n    alias huffman_alias=typeof(tuple(\"0", "{\n    long result;\n    if\
    \ (n == 0) \n    {\n        result = 1;\n    } \n    else \n    {\n        ulong\
    \ n1 = (ulong)n;\n        long s = n1 % p;\n        int i = 0;\n        while\
    \ (n1 > 1) \n        {\n            i++;\n            n1 /= 2;\n            s\
    \ = (s * s) % p;\n        }\n        result = s;\n    }\n    return result;\n\
    }\n/*\nReturn the Jacobi symbol.\n    >>> jacobi(1L, 3L)\n    1\n    >>> jacobi(2L,\
    \ 3L)\n    -1\n    >>> jacobi(0L, 1L)\n    0\n    >>> jacobi(1L, -1L)\n    1\n\
    \    >>> jacobi(2L, -1L)\n    1\n    >>> jacobi(3L, -1L)\n    -1\n    >>> jacobi(6L,\
    \ -1L)\n    0\n    \n*/", "{\n    long result = 1L;\n    foreach (i; 0 .. n)\n\
    \    {\n        result = result * 2L % p;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits needed to represent integer n.\n    >>> num_bits(1L)\n\
    \    1\n    >>> num_bits(3L)\n    2\n    >>> num_bits(63L)\n    6\n*/\nlong num_bits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L)\n    {\n        result = result\
    \ + 1L;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of decimal digits needed to represent integer n.\n    >>> num_digits(1L)\n \
    \   1\n    >>> num_digits(31L)\n    2\n    >>> num_digits(10L**100L)\n    101\n\
    */\nlong num_digits(long n) \n{\n    long result = 0L;\n    while (n > 0L)\n \
    \   {\n        result = result + 1L;\n        n = n / 10L;\n    }\n    return\
    \ result;\n}\n/*\nReturn a string representation of integer n.\n    >>> str(0L)\n\
    \    '0'\n    >>> str(1L)\n    '1'\n    >>> str(31L)\n    '31'\n    >>> str(10L**100L)\n\
    \    '10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n\
    */\nstring str(long n) \n{\n    string result = \"\";\n    while (n > 0L)\n  \
    \  {\n        result = result ~ char(n % 10L + '0');\n        n = n / 10L;\n \
    \   }\n    if (result == \"\")\n    {\n        result = \"0\";\n    }\n    return\
    \ std.algorithm.retro(result);\n}\n/*\nReturn a decimal string representation\
    \ of integer n.\n    >>> decimal_str(0L)\n    '0'\n    >>> decimal_str(1L)\n \
    \   '1'\n    >>> decimal_str(31L)\n    '31'\n    >>> decimal", "    return n <\
    \ 0L ? powmod(2L, n, p) : powmod(2L, n, p);\n}", "{\n  assert(0 <= n);\n  if (n\
    \ == 0)\n    return 1;\n  if (even(n))\n    return modp(n / 2, p) ^ 2;\n  else\n\
    \    return modp(n / 2, p) ^ 2 * modp(n / 2 + 1, p);\n}\n/*\n    >>> modprod(3L,\
    \ 5L, 7L)\n    1L\n    >>> modprod(3L, 5L, 11L)\n    5L\n    >>> modprod(3L, 5L,\
    \ 101L)\n    15L\n    >>> modprod(3L, 5L, 1001L)\n    15L\n    >>> modprod(3L,\
    \ 11L, 101L)\n    33L\n    >>> modprod(3L, 101L, 1001L)\n    303L\n*/\nlong modprod(long\
    \ a, long b, long p) \n{\n  long j = 0;\n  long r = 0;\n  while (j < b) \n  {\n\
    \    r = modp(a, p) * modp(2 * j + 1, p) + r;\n    j = j + 1;\n  }\n  return r;\n\
    }\n/*\n    >>> modpowsum(3L, 5L, 7L)\n    12L\n    >>> modpowsum(3L, 5L, 11L)\n\
    \    20L\n    >>> modpowsum(3L, 5L, 101L)\n    150L\n    >>> modpowsum(3L, 5L,\
    \ 1001L)\n    1500L\n    >>> modpowsum(3L, 11L, 101L)\n    330L\n    >>> modpowsum(3L,\
    \ 101L, 1001L)\n    30300L\n*/\nlong modpowsum(long a, long b, long p) \n{\n \
    \ long j = 0;\n  long r = 0;\n  while (j < b) \n  {\n    r = modp(a, p) * modp(2\
    \ * j + 1, p) + r;\n    j = j + 1;\n  }\n  return r;\n", "{\n    //assert(n >=\
    \ 0L);\n    return pow(2L, n) % p;\n}", "{\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        auto r = modp(n >> 1, p);\n        r = r\
    \ * r % p;\n        if (n & 1)\n        {\n            r = r * 2 % p;\n      \
    \  }\n        return r;\n    }\n}\n/*\nReturn the modular inverse of a modulo\
    \ p (be aware of numerics).\n    >>> modinv(2L, 11L)\n    6L\n    >>> modinv(3L,\
    \ 11L)\n    4L\n*/\nlong modinv(long a, long p) \n{\n    return modp(p - 2, p);\n\
    }\n/*\nReturn the Jacobi symbol of a and n.\n    >>> jacobi(2L, 3L)\n    -1\n\
    \    >>> jacobi(2L, 11L)\n    1\n    >>> jacobi(121L, 11L)\n    1\n    >>> jacobi(121L,\
    \ 19L)\n    -1\n    >>> jacobi(7L, 13L)\n    1\n    >>> jacobi(21L, 13L)\n   \
    \ -1\n    >>> jacobi(11L, 17L)\n    1\n    >>> jacobi(13L, 17L)\n    -1\n    >>>\
    \ jacobi(17L, 17L)\n    1\n    >>> jacobi(18L, 17L)\n    -1\n    >>> jacobi(23L,\
    \ 17L)\n    1\n    >>> jacobi(24L, 17L)\n    -1\n    >>> jacobi(0L, 7L)\n    0\n\
    \    >>> jacobi(0L, 11L)\n    0\n    >>> jacobi(0L, 19L)\n    0\n    >>> jacobi(0L,\
    \ 23L)\n    0\n    >>> jacobi(1L, 23L)\n    1\n    >>> jacobi(2L, 23L)\n    1\n\
    \    >>> jacobi(3L, 23L)\n    1\n    >>> jacobi(4L, 23L)\n    1\n    >>> jacobi(",
  "{\n    /* http://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method\
    \ */\n    long r = 1L;\n    foreach (i; 0 .. n.popCount) {\n        r = (r * r)\
    \ % p;\n        if (n & (1L << i))\n            r = (r * 2) % p;\n    }\n    return\
    \ r;\n}", "{\n    long prod = 1L;\n    long base = 2L;\n    while (n > 0L) \n\
    \    {\n        if (n & 1L) \n        {\n            prod = (prod * base) % p;\n\
    \        }\n        base = (base * base) % p;\n        n >>= 1L;\n    }\n    return\
    \ prod;\n}\n/*\nReturn the n-th term of the Legendre sequence modulo p (be aware\
    \ of numerics).\n    >>> legendre(3L, 5L)\n    3L\n    >>> legendre(5L, 5L)\n\
    \    1L\n    >>> legendre(3L, 11L)\n    6L\n    >>> legendre(1000L, 11L)\n   \
    \ 6L\n    >>> legendre(1001L, 11L)\n    7L\n*/\nlong legendre(long n, long p)\
    \ \n{\n    long t = modp(n, p - 1L);\n    return pow(t, (p - 1L) / 2L, p);\n}\n\
    /*\nReturn a 2D array of Legendre coefficients (be aware of numerics).\n    >>>\
    \ legendre_array(1L, 11L)\n    [[1L]]\n    >>> legendre_array(2L, 11L)\n    [[1L,\
    \ 0L], [1L, 3L]]\n    >>> legendre_array(3L, 11L)\n    [[1L, 0L, 0L], [1L, 3L,\
    \ 6L], [1L, 2L, 4L]]\n    >>> legendre_array(4L, 11L)\n    [[1L, 0L, 0L, 0L],\
    \ [1L, 3L, 6L, 3L], [1L, 2L, 4L, 7L], [1L, 9L, 1L, 6L]]\n    >>> legendre_array(5L,\
    \ 11L)\n    [[1L, 0L, 0L, 0L, 0L], [1L, 3L, 6L, 3L, 6L], [1L, 2L, 4L, 7L, 4L],\n\
    \    [1L, 9L, 1L, 6L, 9L], [", "{\n    long result = 1L;\n    while (n != 0L)\
    \ \n    {\n        if (n & 1L != 0L) \n        {\n            result = (result\
    \ * n) % p;\n        }\n        n >>= 1L;\n        n %= p;\n    }\n    return\
    \ result;\n}\n/*\nReturn (p-1)^n modulo p (be aware of numerics).\n    >>> modp1(3L,\
    \ 5L)\n    3L\n    >>> modp1(1101L, 101L)\n    2L\n    >>> modp1(0L, 101L)\n \
    \   1L\n    >>> modp1(3L, 11L)\n    8L\n    >>> modp1(100L, 101L)\n    1L\n  \
    \  >>> modp1(1L, 5L)\n    4L\n*/\nlong modp1(long n, long p) \n{\n    long result\
    \ = 1L;\n    long t = p - 1L;\n    while (n != 0L) \n    {\n        if (n & 1L\
    \ != 0L) \n        {\n            result = (result * t) % p;\n        }\n    \
    \    t = (t * t) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ n^-1 modulo p (be aware of numerics).\n    >>> modinv(3L, 5L)\n    2L\n    >>>\
    \ modinv(10L, 17L)\n    13L\n    >>> modinv(10L, 3L)\n*/\nlong modinv(long n,\
    \ long p) \n{\n    return modp(n, p);\n}\n/*\nReturn (p-1)^-1 modulo p (be aware\
    \ of numerics).\n    >>> modinv1(1L, 5L)\n    4L\n    >>> modinv1(10L, 17L)\n\
    \    13L\n    >>> modinv1(10L, 3L)\n*/\nlong modinv1(long n, long p) \n{\n   \
    \ return modp1(n, p);\n}\n/*\nReturn the Jacobi symbol for a and", "\t{\n\treturn\
    \ n ?  modp(n >> 1, p) * (((n & 1) ? 2 : 1) % p) % p : 1;\n\t}", "{\n    long\
    \ result = 1L;\n    long x = n;\n    while (n != 0L) {\n        if ((n & 1L) !=\
    \ 0L) {\n            result = (result * x) % p;\n        }\n        x = (x * x)\
    \ % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the nth Fibonacci\
    \ number.\n    >>> fibonacci(1)\n    1\n    >>> fibonacci(8)\n    21\n    >>>\
    \ fibonacci(32)\n    2178309\n*/\nlong fibonacci(long n) \n{\n    if (n <= 1L)\
    \ {\n        return n;\n    }\n    long a = 0L;\n    long b = 1L;\n    long c\
    \ = 1L;\n    long i = 2L;\n    while (i < n) {\n        c = a + b;\n        a\
    \ = b;\n        b = c;\n        i += 1L;\n    }\n    return c;\n}\n/*\nCompute\
    \ the nth prime number.\n    >>> nth_prime(1)\n    2\n    >>> nth_prime(2)\n \
    \   3\n    >>> nth_prime(3)\n    5\n    >>> nth_prime(10)\n    29\n    >>> nth_prime(50)\n\
    \    229\n    >>> nth_prime(100)\n    541\n    >>> nth_prime(1000)\n    7919\n\
    */\nlong nth_prime(long n) \n{\n    long i = 2L;\n    long j = 1L;\n    while\
    \ (true) {\n        if (is_prime(i)) {\n            if (j == n) {\n          \
    \      return i;\n            }\n            j += 1L;\n        }\n        i +=\
    \ 1L;\n    }\n    return -1L;\n}", "    long res = 1L;\n    long a = 2L;\n   \
    \ long p_1 = (p - 1L);\n    while (n > 0L)\n        if (n & 1L)\n            res\
    \ = (res * a) % p;\n        n = n >> 1L;\n        a = (a * a) % p;\n    return\
    \ res;\n}\n/*\nCompute the square root of a modulo p (be aware of numerics).",
  "{\n    auto res = 1L;\n    auto b = 2L;\n    auto i = n;\n    while (i > 0) {\n\
    \        auto temp = i % 2;\n        i = i / 2;\n        if (temp == 1) {\n  \
    \          res = res * b % p;\n        }\n        b = b * b % p;\n    }\n    return\
    \ res;\n}\n/*\nReturn a pair of integers (u, v) such that au + bv = gcd(a, b).\n\
    \    >>> pairgcd(92L, 82L)\n    (2L, -2L)\n    >>> pairgcd(111L, 1009L)\n    (1L,\
    \ -11L)\n    >>> pairgcd(26L, 16L)\n    (2L, -1L)\n    >>> pairgcd(100L, 1000L)\n\
    \    (100L, 0L)\n    >>> pairgcd(11L, 0L)\n    (11L, 0L)\n    >>> pairgcd(11L,\
    \ 1L)\n    (1L, 0L)\n    >>> pairgcd(0L, 0L)\n    (0L, 0L)\n    >>> pairgcd(1L,\
    \ 0L)\n    (1L, 0L)\n    >>> pairgcd(0L, 1L)\n    (0L, 1L)\n    >>> pairgcd(11L,\
    \ 11L)\n    (11L, 0L)\n*/\nTuple!(long, long) pairgcd(long a, long b) {\n    alias\
    \ P = Tuple!(long, long);\n    if (a == 0 && b == 0) {\n        return P(0L, 0L);\n\
    \    }\n    if (a == 0) {\n        return P(b, 0L);\n    }\n    if (b == 0) {\n\
    \        return P(a, 0L);\n    }\n    if (a == b) {\n        return P(a, 0L);\n\
    \    }\n    //std.stdio.writeln(\"pa\",a,\"pb\",b);\n    auto n = (cast(long)max(a,\
    \ b)) / (cast(long", "{\n    long r = 1L;\n    long i = 1L;\n    while (i <= n)\
    \ {\n        r = (r * 2L) % p;\n        i = i + 1L;\n    }\n    return r;\n}\n\
    /*", "{\n    if (n == 0)\n    {\n        return 1;\n    }\n    long result = modp(n\
    \ / 2, p);\n    result = (result * result) % p;\n    if (n % 2 != 0)\n    {\n\
    \        result = (result * 2) % p;\n    }\n    return result;\n}\n/*\nReturn\
    \ the greatest common divisor.\n    >>> gcd(12, 8)\n    4\n    >>> gcd(16, 12)\n\
    \    4\n    >>> gcd(2, 12)\n    2\n    >>> gcd(7, 1)\n    1\n    >>> gcd(9, 9)\n\
    \    9\n    >>> gcd(10, 6)\n    2\n*/\nlong gcd(long a, long b) \n{\n    if (b\
    \ == 0)\n    {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n/*\nEuclid's\
    \ extended algorithm.\n    >>> x, y, d = egcd(12, 8)\n    >>> d\n    4\n    >>>\
    \ x * 12 + y * 8\n    4\n    >>> x, y, d = egcd(10, 6)\n    >>> d\n    2\n   \
    \ >>> x * 10 + y * 6\n    2\n    >>> x, y, d = egcd(9, 9)\n    >>> d\n    9\n\
    \    >>> x * 9 + y * 9\n    9\n*/\nTuple!(long, long, long) egcd(long a, long\
    \ b) \n{\n    if (b == 0)\n    {\n        return tuple(1, 0, a);\n    }\n    long\
    \ x, y, d;\n    Tuple!(long, long, long) temp = egcd(b, a % b);\n    x = temp[1];\n\
    \    y = temp[0] - a / b * temp[1];\n    d = temp[2];\n    return tuple(x, y,\
    \ d);\n}\n/*\nReturn the modular inverse.\n    >>> modinv(11, 101)\n    89\n \
    \   >>> modinv(2, 3)\n    2\n    >>> modinv(3, 11)\n   ", "{\n    // assert(p\
    \ >= 2);\n    long i = 0;\n    long c = 1;\n    for (i = 0; i < n; i++) {\n  \
    \      c = (c * 2) % p;\n    }\n    return c;\n}\n/*\nReturn the parity of n (0\
    \ if even, 1 if odd).\n    >>> parity(0L)\n    0\n    >>> parity(1L)\n    1\n\
    \    >>> parity(2L)\n    0\n    >>> parity(1023L)\n    1\n    >>> parity(1024L)\n\
    \    0\n*/", "    long r = pow(2L, n) % p;\n    return r;", "{\n    if (n == 0)\n\
    \        return 1;\n    else if (n == 1)\n        return p;\n    else if (n ==\
    \ 2)\n        return ((p ^ 2) % p);\n    else if (n % 2 == 0)\n        return\
    \ modp(2, p) * modp(n / 2, p) % p;\n    else\n        return modp(n - 1, p) *\
    \ p % p;\n}\n// Return n choose r modulo p (be aware of numerics).\nlong ncr(long\
    \ n, long r, long p) \n{\n    auto terms = new long[n + 1];\n    terms[0] = 1;\n\
    \    for (auto i = 1; i <= n; i++)\n        terms[i] = ((terms[i - 1] * (n - i\
    \ + 1)) % p * modp(i, p)) % p;\n    return terms[r];\n}\n// Return the number\
    \ of arrangements of n things with k things out of place.\nlong derangements(long\
    \ n, long k) \n{\n    auto terms = new long[n + 1];\n    terms[0] = 1;\n    for\
    \ (auto i = 1; i <= n; i++)\n        terms[i] = i * (terms[i - 1] + 1);\n    return\
    \ terms[n] - k;\n}\n// Return (n choose 2) modulo p (be aware of numerics).\n\
    long nchoose2(long n, long p) \n{\n    return (n * (n - 1) / 2) % p;\n}\n// Return\
    \ n^2 modulo p (be aware of numerics).\nlong nsquare(long n, long p) \n{\n   \
    \ return (n * n) % p;\n}\n// Return n modulo p (be aware of numerics).\nlong nmodp(long\
    \ n, long p) \n{\n    return n % p;\n}\n// Return n choose r modulo p (be aware\
    \ of numerics).\nlong nchooser(long n, long r, long p) \n{\n    return ncr(n,\
    \ r, p);\n}\n// Return n choose r modulo p (be aware of", '    return mod(cast(big)
    pow(2L, n), p);', "{\n    if(n < 0) return modp(-n, p);\n    if(n == 0) return\
    \ 1;\n    if(n % 2 == 0)\n    {\n        long tmp = modp(n / 2, p);\n        return\
    \ tmp * tmp % p;\n    }\n    else return n * modp(n - 1, p) % p;\n}\n//long modp(long\
    \ n, long p) \n//{\n//    if(n < 0) return modp(-n, p);\n//    if(n == 0) return\
    \ 1;\n//    if(n % 2 == 0)\n//    {\n//        long tmp = modp(n / 2, p);\n//\
    \        return tmp * tmp % p;\n//    }\n//    else return n * modp(n - 1, p)\
    \ % p;\n//}", "    if (isInputRange!(long)) \n{\n    import std.bigint;\n    BigInt\
    \ bi = BigInt(2L);\n    bi ^= n;\n    bi %= p;\n    return bi.to!long;\n}\n/*\n\
    Return the prime factors of n (be aware of numerics).\n    >>> factors(1L)\n \
    \   [1L]\n    >>> factors(2L)\n    [2L]\n    >>> factors(3L)\n    [3L]\n    >>>\
    \ factors(4L)\n    [2L, 2L]\n    >>> factors(8L)\n    [2L, 2L, 2L]\n    >>> factors(11L)\n\
    \    [11L]\n    >>> factors(2*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3*3",
  "{\n  long result = 1L;\n  long m = n % (p - 1L);\n  auto exp = cast(ulong)m;\n\
    \  for (int i = 0; i < 64; i++) \n  {\n    if (exp & 1L) \n    {\n      result\
    \ = (result * n) % p;\n    }\n    n = (n * n) % p;\n    exp = exp >> 1L;\n  }\n\
    \  return result;\n}", "    if (n == 0)\n    {\n        return 1;\n    }\n   \
    \ else if (n < p)\n    {\n        return n;\n    }\n    else\n    {\n        return\
    \ (modp(n / p, p) * modp(n % p, p)) % p;\n    }\n}", "{\n  long z = 1L;\n  while\
    \ (n != 0L) \n  {\n    if (n & 1L) \n    {\n      z = (z * 2L) % p;\n    }\n \
    \   n >>= 1L;\n  }\n  return z;\n}\n/*\nReturn 3^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong modp3(long n, long p) \n{\n  long z = 1L;\n  while (n !=\
    \ 0L) \n  {\n    if (n & 1L) \n    {\n      z = (z * 3L) % p;\n    }\n    n >>=\
    \ 1L;\n  }\n  return z;\n}\n/*\nPerform one step of the division algorithm.\n\
    */", "{\n  if (n == 0) \n  {\n    return 1;\n  }\n  final long q = modp(n >> 1,\
    \ p);\n  const long d = n & 1;\n  return (d == 0) ? (q * q) % p : (q * q * 2)\
    \ % p;\n}", "    { return pow(cast(real)2, cast(real)n) % p; }\n/*\nReturn 1+2+2^2+...+2^n\
    \ modulo p.\n    >>> mod2p(3L, 5L)\n    6L\n    >>> mod2p(1101L, 101L)\n    80L\n\
    \    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L, 11L)\n    9L\n    >>> mod2p(100L,\
    \ 101L)\n    1L\n    \n*/\nlong mod2p(long n, long p) \n    { return (modp(n,\
    \ p) + 1) % p; }\n/*\nReturn p-1 modulo p.\n    >>> pminus1(101L)\n    100L\n\
    \    >>> pminus1(11L)\n    10L\n    \n*/\nlong pminus1(long p) \n    { return\
    \ (p - 1) % p; }\n/*\nReturn (p-1)! modulo p.\n    >>> pminus1fac(101L)\n    100L\n\
    \    >>> pminus1fac(11L)\n    10L\n    \n*/\nlong pminus1fac(long p) \n    { return\
    \ mod2p(pminus1(p), p); }\n/*\nReturn (2^a)! modulo p.\n    >>> p2afac(3L, 5L)\n\
    \    3L\n    >>> p2afac(0L, 101L)\n    1L\n    >>> p2afac(3L, 11L)\n    5L\n \
    \   >>> p2afac(100L, 101L)\n    1L\n    \n*/\nlong p2afac(long a, long p) \n \
    \   { return mod2p(a, p); }\n/*\nReturn (2^a+1)! modulo p.\n    >>> p2aplus1fac(3L,\
    \ 5L)\n    4L\n    >>> p2aplus1fac(0L, 101L)\n    1L\n    >>> p2aplus1fac(3L,\
    \ 11L)\n    4L\n    >>> p2aplus1fac(100L, 101L", "{\n    if (n <= 0)\n       \
    \ return 1L;\n    return (2L*modp(n-1L, p)) % p;\n}\n/*\nCalculate binomial coefficients\
    \ without overflowing.\n    >>> binomial(5L, 2L)\n    10L\n    >>> binomial(5L,\
    \ 3L)\n    10L\n    >>> binomial(5L, 4L)\n    5L\n    >>> binomial(5L, 5L)\n \
    \   1L\n*/\nlong binomial(long n, long k) \n{\n    long i = 1L;\n    long k2 =\
    \ k;\n    long n2 = n;\n    while (n2 > n-k2)\n    {\n        i *= n2;\n     \
    \   n2 -= 1L;\n    }\n    while (k2 > 1L)\n    {\n        i /= k2;\n        k2\
    \ -= 1L;\n    }\n    return i;\n}\n/*\nCalculate binomial coefficients without\
    \ overflowing.\n    >>> [binomial2(n, k) for n in [5L, 6L, 7L, 8L] for k in [0L,\
    \ 1L, 2L, 3L, 4L, 5L]]\n    [1L, 5L, 10L, 10L, 5L, 1L, 1L, 6L, 15L, 20L, 15L,\
    \ 6L, 1L, 7L, 21L, 35L, 35L, 21L, 7L, 1L, 8L, 28L, 56L, 70L, 56L, 28L, 8L]\n*/\n\
    long binomial2(long n, long k) \n{\n    return binomial(n, k);\n}\n/*\n    >>>\
    \ [pascal(i) for i in [0L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L]]\n    [[1L],\
    \ [1L, 1L], [1L, 2L, 1L], [1L, 3L, 3L, 1L], [1L, 4L, 6L, 4L, 1L], [1L, 5L, 10L,",
  "{\n    long res = 1L;\n    while (n != 0L) {\n        res = ((res % p) * (n % 2L\
    \ == 0L ? 1L : 2L)) % p;\n        n /= 2L;\n    }\n    return res;\n}", "{\n \
    \ return pow(2L, n) % p;\n}\n/*\nReturn the number of left shifts on x until it\
    \ is zero.\n    >>> floorLog2(1L)\n    0L\n    >>> floorLog2(2L)\n    1L\n   \
    \ >>> floorLog2(3L)\n    1L\n    >>> floorLog2(4L)\n    2L\n    >>> floorLog2(7L)\n\
    \    2L\n    >>> floorLog2(8L)\n    3L\n    >>> floorLog2(9L)\n    3L\n    >>>\
    \ floorLog2(10L)\n    3L\n*/\nlong floorLog2(long x) \n{\n  long lg = 0L;\n  while\
    \ (x >> lg != 0L)\n  {\n    lg += 1L;\n  }\n  return lg - 1L;\n}\n/*\nReturn x\
    \ with a single 1-bit at index i.\n    >>> singleton(0L)\n    1L\n    >>> singleton(1L)\n\
    \    2L\n    >>> singleton(2L)\n    4L\n    >>> singleton(3L)\n    8L\n    >>>\
    \ singleton(4L)\n    16L\n    >>> singleton(5L)\n    32L\n    >>> singleton(6L)\n\
    \    64L\n    >>> singleton(7L)\n    128L\n    >>> singleton(8L)\n    256L\n \
    \   >>> singleton(9L)\n    512L\n    >>> singleton(10L)\n    1024L\n    >>> singleton(11L)\n\
    \    2048L\n    >>> singleton(12L)\n    4096L\n    >>> singleton(13L)\n    8192L\n\
    \    >>> singleton(14L)\n    16384L\n    >>> singleton(15L)\n    32768L\n    >>>\
    \ singleton(16L)\n    65536L\n    >>> singleton(17L)\n    131072L\n    >>> singleton(18L)\n\
    \    262144L\n    >>> singleton(19L)\n    524288L\n    >>> singleton(20L)\n  \
    \  1048576L\n    >>> singleton(21L", "{\n    long result = 1L;\n    while (n >\
    \ 0L) \n    {\n        if (n % 2L == 1L)\n            result = (result * n) %\
    \ p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn (a * b) modulo\
    \ p (be aware of numerics).\n    >>> modprod(3L, 8L, 11L)\n    2L\n    >>> modprod(1101L,\
    \ 101L, 101L)\n    0L\n    >>> modprod(100L, 101L, 101L)\n    1L\n    >>> modprod(0L,\
    \ 0L, 101L)\n    0L\n    >>> modprod(1L, 1L, 101L)\n    1L\n    \n*/\nlong modprod(long\
    \ a, long b, long p) \n{\n    long result = 0L;\n    while (b > 0L) \n    {\n\
    \        if (b % 2L == 1L)\n            result = (result + a) % p;\n        a\
    \ = (2L * a) % p;\n        b = b / 2L;\n    }\n    return result;\n}\n/*\nReturn\
    \ (a ** b) modulo p (be aware of numerics).\n    >>> modpow(3L, 8L, 11L)\n   \
    \ 7L\n    >>> modpow(1101L, 101L, 101L)\n    1L\n    >>> modpow(100L, 101L, 101L)\n\
    \    1L\n    >>> modpow(0L, 0L, 101L)\n    1L\n    >>> modpow(1L, 1L, 101L)\n\
    \    1L\n    \n*/\nlong modpow(long a, long b, long p) \n{\n    long result =\
    \ 1L;\n    while (b > 0L) \n    {\n        if (b % 2L == 1L)\n            result\
    \ = modprod(result, a, p);\n        a = modprod(a, a, p);\n        b = b / 2L;\n\
    \    }\n    return result;\n}\n/*\nReturn True", "{\n\tlong r = 1L;\n\tforeach\
    \ (i; 0 .. n)\n\t{\n\t\tr = (r * 2L) % p;\n\t}\n\treturn r;\n}\n/*\nReturn 3^n\
    \ modulo p (be aware of numerics).\n    >>> modp3(3L, 5L)\n    4L\n    >>> modp3(1101L,\
    \ 101L)\n    37L\n    >>> modp3(0L, 101L)\n    1L\n    >>> modp3(3L, 11L)\n  \
    \  1L\n    >>> modp3(100L, 101L)\n    50L\n*/\nlong modp3(long n, long p) \n{\n\
    \tlong r = 1L;\n\tforeach (i; 0 .. n)\n\t{\n\t\tr = (r * 3L) % p;\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn the nth Fibonacci number modulo p (be aware of numerics).\n\
    \    >>> fibonacci(1L, 5L)\n    1L\n    >>> fibonacci(2L, 5L)\n    1L\n    >>>\
    \ fibonacci(3L, 5L)\n    2L\n    >>> fibonacci(4L, 5L)\n    3L\n    >>> fibonacci(5L,\
    \ 5L)\n    3L\n    >>> fibonacci(16L, 5L)\n    3L\n    >>> fibonacci(1L, 101L)\n\
    \    1L\n    >>> fibonacci(2L, 101L)\n    1L\n    >>> fibonacci(3L, 101L)\n  \
    \  2L\n    >>> fibonacci(4L, 101L)\n    3L\n    >>> fibonacci(5L, 101L)\n    5L\n\
    \    >>> fibonacci(6L, 101L)\n    8L\n    >>> fibonacci(7L, 101L)\n    13L\n \
    \   >>> fibonacci(8L, 101L)\n    21L\n    >>> fibonacci(9L, 101L)\n    34L\n \
    \   >>> fibonacci(10L, 101L)\n    55L\n    >>> fibon", "{\n\treturn (n == 0 ?\
    \ 1 : modp(n / 2, p) * (n % 2 == 0 ? 1 : p) % p);\n}", "{\n    if (n == 0) \n\
    \    {\n        return 1;\n    }\n    auto z = modp(n >> 1, p);\n    if (n & 1)\
    \ \n    {\n        return (2 * z * z) % p;\n    }\n    else \n    {\n        return\
    \ (z * z) % p;\n    }\n}", "{\n\tlong pow = 1L;\n\tlong x = n;\n\twhile (n !=\
    \ 0L) {\n\t\tpow = (pow * x) % p;\n\t\tn -= 1L;\n\t}\n\treturn pow;\n}", "{\n\t\
    if (n == 0)\n\t\treturn 1;\n\tif (n == 1)\n\t\treturn n;\n\treturn (modp(n-1,\
    \ p) * n) % p;\n}\n/*\nReturn x to the power of n modulo p (be aware of numerics).\n\
    \    >>> modpow(3L, 3L, 5L)\n    2L\n    >>> modpow(1101L, 101L, 101L)\n    11L\n\
    \    >>> modpow(12L, 10L, 101L)\n    72L\n    >>> modpow(3L, 9L, 11L)\n    9L\n\
    \    >>> modpow(0L, 0L, 101L)\n    1L\n    >>> modpow(0L, 1L, 101L)\n    0L\n\
    \    >>> modpow(1L, 0L, 101L)\n    1L\n    >>> modpow(1L, 1L, 101L)\n    1L\n\
    */\nlong modpow(long x, long n, long p) \n{\n\tif (n == 0)\n\t\treturn 1;\n\t\
    if (n == 1)\n\t\treturn x % p;\n\treturn modpow(x, n - 1, p) * x % p;\n}\n/*\n\
    Given the prime modulus p, find the remainder of the Fibonacci sequence\n    modulo\
    \ p at a given index.\n    >>> fibonacci(1L, 101L)\n    1L\n    >>> fibonacci(7L,\
    \ 101L)\n    18L\n    >>> fibonacci(100L, 101L)\n    6L\n    >>> fibonacci(2L,\
    \ 11L)\n    1L\n    >>> fibonacci(14L, 11L)\n    7L\n    >>> fibonacci(101L, 11L)\n\
    \    5L\n    >>> fibonacci(3L, 3L)\n    1L\n    >>> fibonacci(10L, 3L)\n    1L\n\
    \    >>> fibonacci(11L, 3L)\n    0L\n*/\nlong fibonacci(long n, long p) \n{\n\t\
    return modpow(n,", "{\n    long q;\n    assert(p > 0);\n    q = n % p;\n    if\
    \ (q < 0) {\n        q += p;\n    }\n    return q;\n}\n/*\nReturn a pair of numbers\
    \ x and y such that x*u1 + y*u2 = gcd(u1, u2).\n    >>> gcdex(6L, 3L)\n    (2L,\
    \ -1L)\n    >>> gcdex(5L, 5L)\n    (1L, 0L)\n    >>> gcdex(2L, 3L)\n    (1L, -1L)\n\
    \    >>> gcdex(2L, 4L)\n    (1L, -2L)\n    >>> gcdex(3L, 9L)\n    (1L, -3L)\n\
    \    >>> gcdex(6L, 9L)\n    (3L, -2L)\n    >>> gcdex(11L, 2L)\n    (1L, -5L)\n\
    */\ntuple!(long, long) gcdex(long u1, long u2) \n{\n    long s0, s1, t0, t1, r0,\
    \ r1, r, q;\n    assert(u1 >= 0);\n    assert(u2 >= 0);\n    s0 = 1;\n    s1 =\
    \ 0;\n    t0 = 0;\n    t1 = 1;\n    r0 = u1;\n    r1 = u2;\n    while (true) {\n\
    \        if (r1 == 0) {\n            if (r0 == 1) {\n                return tuple(s0,\
    \ t0);\n            }\n            else {\n                assert(0);\n      \
    \      }\n        }\n        q = r0 / r1;\n        r = r0 - q * r1;\n        r0\
    \ = r1;\n        r1 = r;\n        s = s0 - q * s1;\n        s0 = s1;\n       \
    \ s1 = s;\n        t = t0 - q * t1;\n        t0 = t1;\n        t1 = t;\n    }\n\
    }\n/*\nReturn the modular", "{\n    if (n == 0) {\n        return 1;\n    }\n\
    \    auto x = n % (p - 1);\n    return pow(2L, x) % p;\n}", "{\n    out(n);\n\
    \    out(p);\n    long nn=n;\n    long i=1;\n    while (n>1) {\n        out(\"\
    in while loop\");\n        out(n);\n        if (n%2==1) {\n            i = (i*nn)%p;\n\
    \        }\n        nn = (nn*nn)%p;\n        n = n/2;\n    }\n    return i;\n}",
  "{\n  long res = 1L;\n  while (n > 0L) \n  {\n    if (n % 2L == 1L) \n    {\n  \
    \    res = (res * p) % MOD;\n    }\n    n /= 2L;\n    p = (p * p) % MOD;\n  }\n\
    \  return res;\n}", "{\n    if (n == 0)\n    {\n        return 1;\n    }\n   \
    \ else\n    {\n        return modp(n - 1, p) * 2 % p;\n    }\n}", "    if (is(typeof(pow(n,\
    \ 1L)) == long))\n{\n    assert(n >= 0L);\n    assert(p >= 2L);\n    if (n ==\
    \ 0L) return 1L;\n    if (n == 1L) return n;\n    long a = modp(n >> 1L, p);\n\
    \    long b = cast(long)((a * a) % p);\n    if (n & 1L) b = cast(long)((b * n)\
    \ % p);\n    return b;\n}", "{\n\tlong ans = 1L;\n\tfor (int i = 0; i < n; i++)\n\
    \t{\n\t\tans = (ans * 2L) % p;\n\t}\n\treturn ans;\n}\n/*\nCheck whether the given\
    \ point is on the curve y^2 = x^3 + ax + b,\nreturning a boolean.\n    >>> is_on_curve(2L,\
    \ 3L, 17L, 13L)\n    True\n    >>> is_on_curve(4L, 2L, 11L, 7L)\n    False\n \
    \   >>> is_on_curve(4L, 2L, 7L, 3L)\n    True\n    >>> is_on_curve(2L, 0L, 7L,\
    \ 3L)\n    True\n    >>> is_on_curve(0L, 0L, 11L, 7L)\n    True\n    >>> is_on_curve(0L,\
    \ 0L, 7L, 3L)\n    True\n*/", "{\n    long res = 1L;\n    foreach (i; 0L .. n)\
    \ \n    {\n        res = (res * 2L) % p;\n    }\n    return res;\n}\n/*\nReturn\
    \ 2^(n*t) modulo p (be aware of numerics).\n    >>> modp_mult(3L, 2L, 5L)\n  \
    \  4L\n    >>> modp_mult(3L, 2L, 11L)\n    4L\n*/\nlong modp_mult(long n, long\
    \ t, long p) \n{\n    return modp(n * t, p);\n}\n/*\nReturn the order of 2 modulo\
    \ p (be aware of numerics).\n    >>> order_modp(2L, 5L)\n    3L\n    >>> order_modp(2L,\
    \ 11L)\n    10L\n*/\nlong order_modp(long n, long p) \n{\n    long r = modp(1L,\
    \ p);\n    long q = n;\n    long ord = 0L;\n    while (r != 1L) \n    {\n    \
    \    r = (r * q) % p;\n        ord += 1L;\n    }\n    return ord;\n}\n/*\nReturn\
    \ the result of the extended Euclidean algorithm.\n    >>> x, y, z = ext_gcd(18L,\
    \ 39L)\n    >>> x\n    1L\n    >>> y\n    3L\n    >>> z\n    3L\n    >>> x, y,\
    \ z = ext_gcd(39L, 18L)\n    >>> x\n    1L\n    >>> y\n    -3L\n    >>> z\n  \
    \  3L\n    >>> x, y, z = ext_gcd(18L, 5L)\n    >>> x\n    -1L\n    >>> y\n   \
    \ 2L\n    >>> z\n    3L\n    >>> x, y, z = ext_gcd(24L, 4L)\n    >>> x\n    4L\n\
    \    >>> y\n    -1L\n    >>> z\n    0L\n*/\nauto ext_gcd(long a, long b)\n{\n\
    \    if (b == 0L)\n    {\n", "{\n    \n    return powmod(2L, n, p);\n}", "{\n\
    \    long result = 1L;\n    long b = 2L;\n    tuple!(long,long) t = std.typecons.tuple(n,\
    \ p);\n    t[0] = n;\n    t[1] = p;\n    foreach (i;0..t[0]) {\n        result\
    \ = (result * b) % t[1];\n    }\n    return result;\n}", "{\n    if (p == 0L)\n\
    \    {\n        throw new Exception(\"mod 0\");\n    }\n    return (n + p) % p;\n\
    }\n/*\nReturn the number of digits in `n`.\n    >>> numdigits(0L)\n    1\n   \
    \ >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1000L)\n    4\n    >>> numdigits(12345678900L)\n   \
    \ 10\n*/\nlong numdigits(long n) \n{\n    long numdigits = 1L;\n    while (n >\
    \ 9L)\n    {\n        numdigits++;\n        n /= 10L;\n    }\n    return numdigits;\n\
    }\n/*\nReturn the nth prime number.\n    >>> nthprime(0)\n    2\n    >>> nthprime(1)\n\
    \    3\n    >>> nthprime(2)\n    5\n    >>> nthprime(10)\n    31\n    >>> nthprime(15)\n\
    \    47\n*/\nlong nthprime(long n) \n{\n    if (n < 0L)\n    {\n        throw\
    \ new Exception(\"number negative\");\n    }\n    else if (n == 0L)\n    {\n \
    \       return 2L;\n    }\n    else if (n == 1L)\n    {\n        return 3L;\n\
    \    }\n    else\n    {\n        long lastprime = 2L;\n        long counter =\
    \ 1L;\n        long i = 3L;\n        while (counter < n)\n        {\n        \
    \    if (isprime(i))\n            {\n                lastprime = i;\n        \
    \        counter++;\n            }\n            i += 2L;\n        }\n        return\
    \ lastprime;\n    }\n}\n/*\nReturn the product of the integers x through y.\n\
    \    >>> product(1, 2)\n    2\n    >>> product(1, 4)\n    24\n    >>> product(5,\
    \ 6)\n    30\n    >>> product(7, 8)\n    56\n    >>> product(3, 3)\n    3\n  \
    \  >>>", "{\n    auto m = n % p;\n    return m < 0 ? p + m : m;\n}\n/*\nReturn\
    \ the largest integer n such that 2^n <= p.\n    >>> largestPower(1L)\n    0L\n\
    \    >>> largestPower(2L)\n    1L\n    >>> largestPower(3L)\n    1L\n    >>> largestPower(1000L)\n\
    \    9L\n    >>> largestPower(100000000000000000L)\n    50L\n    >>> largestPower(1024L\
    \ * 1024L * 1024L)\n    30L\n    \n*/\nlong largestPower(long p) \n{\n    long\
    \ n = 1L;\n    long t = 2L;\n    while (t <= p) {\n        t *= 2L;\n        n\
    \ += 1L;\n    }\n    return n - 1L;\n}\n/*\nReturn the jacobi symbol (a|n).\n\
    \    \n    The Jacibi symbol (a|n) is a multiplicative function.\n    Calculate\
    \ using:\n        (a|n) =\n        0                            if n divides a\n\
    \        1                            if a = 1 mod 4 and n = 1 mod 4\n       -1\
    \                            if a = 3 mod 4 and n = 1 mod 4\n        (-1)^((n-1)/2)\
    \ if (a|n) = -1\n        (b|n) if a = b^2 mod n\n        ((a|n)*(b|n)) if (a|n)\
    \ = 1 and (b|n) = 1\n    >>> jacobi(2L, 3L)\n    1L\n    >>> jacobi(5L, 29L)\n\
    \    1L\n    >>> jacobi(3L, 7L)\n    -1L\n    >>> jacobi(7L, 13L)\n    -1L\n \
    \   >>> jacobi(3L, 28L)\n    0L\n    >>> jacobi(2L, 13L)\n    1L\n    >>> jacobi(4L,\
    \ 13L)\n    1L\n    >>> jacobi(6L, 13L)\n    -1L\n    >>> jacobi(8L, 13L)\n  \
    \  -1L\n   ", "{\n    assert(n >= 0L);\n    assert(p >= 2L);\n    assert(p < 1000000L);\n\
    \    if (n < p)\n    {\n        return n;\n    }\n    else\n    {\n        auto\
    \ prod = p;\n        auto i = 1L;\n        while (n >= prod * 2L)\n        {\n\
    \            prod *= prod;\n            i *= 2L;\n        }\n        auto res\
    \ = 1L;\n        while (i > 0L)\n        {\n            if (n >= prod)\n     \
    \       {\n                res = res * p;\n                n -= prod;\n      \
    \      }\n            prod /= 2L;\n            i -= 1L;\n        }\n        return\
    \ res;\n    }\n}\n/*\nReturn the Legendre symbol (a, p).\nIf p is an odd prime,\
    \ it is an integer 0, 1 or -1 such that::\n    a**((p-1)/2) == 1 if (a, p) ==\
    \ 1\n    a**((p-1)/2) == -1 if (a, p) == -1\n    0 otherwise.\nIf x is not prime,\
    \ values will be calculated modulo x, but\nthis is not a true Legendre symbol.\n\
    \    >>> legendre(1, 11)\n    1\n    >>> legendre(3, 11)\n    -1\n    >>> legendre(9,\
    \ 11)\n    0\n    >>> legendre(10, 11)\n    1\n*/\nlong legendre(long a, long\
    \ p) \n{\n    assert(p >= 2L);\n    assert(p < 1000000L);\n    if (a >= p)\n \
    \   {\n        a %= p;\n    }\n    auto l = modp(a, p);\n    if (l == 0L)\n  \
    \  {\n        return 0L;\n    }\n    else if (l == 1L)\n    {\n        return\
    \ 1L;\n    }\n    else\n    {\n        auto exp = (p - 1L) / 2L;\n        return\
    \ (-1L) * modp(a, p) * modp(exp, p);\n    }\n}\n/*\nReturn the Jacobi symbol (a,\
    \ n", "{\n\tif(p==0) \n\t{\n\t\tprintf(\"Modulus can't be zero.\\n\");\n\t\treturn\
    \ 0;\n\t}\n\tif(n<0) \n\t{\n\t\tn = -n;\n\t}\n\tif(n<p-1) \n\t{\n\t\treturn n;\n\
    \t}\n\tlong r = n%p;\n\tif(r<1) \n\t{\n\t\treturn 1;\n\t}\n\treturn r;\n}", "{\n\
    \    // From Hacker's Delight\n    ulong m = 1L;\n    if (n >= 0) {\n        while\
    \ (n != 0) {\n            if ((n & 1) != 0)\n                m = (m * cast(ulong)p)\
    \ % cast(ulong)p;\n            n >>= 1;\n            p = (p * cast(ulong)p) %\
    \ cast(ulong)p;\n        }\n    }\n    else {\n        n = -n;\n        while\
    \ (n != 0) {\n            if ((n & 1) != 0)\n                m = (m * cast(ulong)p)\
    \ % cast(ulong)p;\n            n >>= 1;\n            p = (p * cast(ulong)p) %\
    \ cast(ulong)p;\n        }\n        m = cast(ulong)p - m;\n    }\n    return cast(long)m;\n\
    }", "{\n  if (n < 0L)\n  {\n    return modp(-n, p);\n  }\n  if (n == 0L)\n  {\n\
    \    return 1L;\n  }\n  auto t = modp(n / 2L, p);\n  return (2L * t) % p;\n}",
  "{\n  /*  */\n  object(long) a;\n  a = 1L;\n  return mulmod(a, powmod(2L, n, p),\
    \ p);\n}", "    {\n    return (1L << n) % p;\n    }\n/*\nReturn the length of\
    \ the binary string of a number.\n    >>> log2(1L)\n    0L\n    >>> log2(2L)\n\
    \    1L\n    >>> log2(3L)\n    2L\n    >>> log2(4L)\n    2L\n    >>> log2(5L)\n\
    \    3L\n*/\nlong log2(long n) \n    {\n    long x = 0L;\n    while (n >>= 1)\n\
    \        {\n        x++;\n        }\n    return x;\n    }\n/*\nReturn the length\
    \ of the binary string of a number including the sign bit.\n    >>> log2s(1L)\n\
    \    1L\n    >>> log2s(2L)\n    2L\n    >>> log2s(3L)\n    2L\n    >>> log2s(4L)\n\
    \    3L\n    >>> log2s(5L)\n    3L\n*/\nlong log2s(long n) \n    {\n    long x\
    \ = 0L;\n    while (n != 0L)\n        {\n        n >>= 1;\n        x++;\n    \
    \    }\n    return x;\n    }", "{\n    if (n == 0)\n    {\n        return 1;\n\
    \    }\n    else\n    {\n        long temp = modp(n/2, p);\n        if (n%2 ==\
    \ 0)\n        {\n            return temp*temp % p;\n        }\n        else\n\
    \        {\n            return p*temp*temp % p;\n        }\n    }\n}", "{\n  return\
    \ mod(pow(2L, n), p);\n}", "{\n    long result = 1L;\n    while (n > 0L) {\n \
    \       if (n % 2L == 1L) {\n            result = (result * 2L) % p;\n       \
    \ }\n        n = n / 2L;\n    }\n    return result;\n}\n/*\n    >>> gcd(12L, 14L)\n\
    \    2L\n    >>> gcd(15L, 12L)\n    3L\n*/\nlong gcd(long a, long b) {\n    Tuple!(long,\
    \ long) r;\n    r = extendedEuclid(a, b);\n    return r[0];\n}\n/*\n    Extended\
    \ Euclid algorithm for the greatest common divisor\n    >>> a,b = 48L,36L\n  \
    \  >>> x,y,g = extendedEuclid(a,b)\n    >>> g\n    12L\n    >>> a*x + b*y\n  \
    \  12L\n    >>> a,b = 36L,48L\n    >>> x,y,g = extendedEuclid(a,b)\n    >>> g\n\
    \    12L\n    >>> a*x + b*y\n    12L\n    >>> a,b = 48L,24L\n    >>> x,y,g = extendedEuclid(a,b)\n\
    \    >>> g\n    24L\n    >>> a*x + b*y\n    24L\n    >>> a,b = 12L,18L\n    >>>\
    \ x,y,g = extendedEuclid(a,b)\n    >>> g\n    6L\n    >>> a*x + b*y\n    6L\n\
    \    >>> a,b = 12L,9L\n    >>> x,y,g = extendedEuclid(a,b)\n    >>> g\n    3L\n\
    \    >>> a*x + b*y\n    3L\n*/\nTuple!(long, long, long) extendedEuclid(long a,\
    \ long b) {\n    long g, x, y;\n    if (b == 0L) {\n        return tuple(a, 1L,\
    \ 0L);\n    }\n    auto t = extendedEuclid(b, a % b);\n    return tuple(t[0],\
    \ t[", "{\n    alias X = long;\n    while (n > p) \n    {\n        ulong t = cast(ulong)p\
    \ << 31;\n        X x = cast(X)t;\n        X y = cast(X)n;\n        n = cast(long)(y\
    \ & ~x);\n    }\n    return n;\n}", "    if (is(CommonType!(long,double) : long))\n\
    {\n    if (n < 0L) {\n        long f = pow(2L, -n, p);\n        return p - f;\n\
    \    }\n    else {\n        return pow(2L, n, p);\n    }\n}", "{\n    return pow(2L,\
    \ n, p);\n}", '    return n < 0L ? modp(p - (-n % p), p) : n % p;', "{\n  if (n\
    \ == 0)\n  {\n    return 1;\n  }\n  else\n  {\n    long tp = modp(n >> 1, p);\n\
    \    tp = (tp * tp) % p;\n    if (n & 1)\n    {\n      tp = (tp * 2) % p;\n  \
    \  }\n    return tp;\n  }\n}", "    long modp(long n, long p) \n        return\
    \ pow(2L, n) % p;\n    \n}\n/*\nReturn the length of the repetition cycle in the\
    \ binary expansion of 1/n.\n    >>> cycle_length(2L)\n    0L\n    >>> cycle_length(3L)\n\
    \    1L\n    >>> cycle_length(6L)\n    1L\n    >>> cycle_length(7L)\n    6L\n\
    \    >>> cycle_length(10L)\n    1L\n    >>> cycle_length(11L)\n    2L\n    >>>\
    \ cycle_length(999999999L)\n    3L\n*/\nlong cycle_length(long n) \n    long cycle_length(long\
    \ n) \n        immutable ValueError \n            ValueError(\"n must be larger\
    \ than 0\")\n        assert(n > 0L);\n        /*\n        A map from the reminder\
    \ of 1/n to the position of the last\n        remainder. The reminder is always\
    \ between 0 and n-1. We can stop\n        when we see the same reminder the second\
    \ time.\n        \n        */\n        immutable seen = dict[long, long]();\n\
    \        immutable l = 0L;\n        immutable r = 1L;\n        while (true) \n\
    \            /*\n            A remainder of 0 means we are at the end of the recurring\
    \ cycle.\n            \n            */\n            if (r == 0L) \n          \
    \      return l;\n            /*\n            We have seen this remainder before.\
    \ So we have reached the start\n            of the recurring cycle.\n        \
    \    \n            */\n            if (r in seen) \n                return l -\
    \ seen[r];\n            /*\n            Save the current reminder and position.\n\
    \            \n            */\n            seen[r] = l;\n            /*\n    \
    \        Compute the next reminder by multiplying r by 10 and computing\n    \
    \        the modulo n.\n            \n            */\n            r = r * 10L\
    \ % n;\n            l += 1L;\n        \n    }", "{\n    if (n == 0)\n    {\n \
    \       return 1;\n    }\n    long m = modp(n >> 1, p);\n    m = (m * m) % p;\n\
    \    if (n & 1)\n    {\n        m = (m * 2) % p;\n    }\n    return m;\n}\n/*\n\
    Return the square of n modulo p (be aware of numerics).\n    >>> modp2(3L, 5L)\n\
    \    4L\n    >>> modp2(3L, 11L)\n    9L\n    >>> modp2(13L, 19L)\n    16L\n  \
    \  >>> modp2(200L, 101L)\n    1L\n*/\nlong modp2(long n, long p) \n{\n    return\
    \ (n * n) % p;\n}\n/*\nReturn the square root of n modulo p (be aware of numerics).\n\
    \    >>> modsqrt(3L, 5L)\n    2L\n    >>> modsqrt(5L, 7L)\n    2L\n    >>> modsqrt(24L,\
    \ 13L)\n    5L\n    >>> modsqrt(24L, 19L)\n    17L\n*/\nlong modsqrt(long n, long\
    \ p) \n{\n    long nn = modp2(n, p);\n    foreach (i; 1 .. p)\n    {\n       \
    \ if (nn == modp2(i, p))\n        {\n            return i;\n        }\n    }\n\
    \    return -1;\n}\n/*\nCompute the multiplicative inverse of a modulo p.\n  \
    \  >>> moebius(3L, 5L)\n    2L\n    >>> moebius(2L, 5L)\n    3L\n    >>> moebius(4L,\
    \ 5L)\n    -1L\n    >>> moebius(3L, 7L)\n    5L\n    >>> moebius(4L, 7L)\n   \
    \ -1L\n    >>> moebius(3L, 9L)\n    -1L\n    >>> moebius(3L, 11L)\n    4L\n  \
    \  >>> moebius(5L, 11", "{\n    if (p < 0L)\n    {\n        p = abs(p);\n    }\n\
    \    if (n < 0L)\n    {\n        n = abs(n);\n    }\n    return pow(2L, n) % p;\n\
    }", "{\n    long product = 1L;\n    long k = 0L;\n    long i = 0L;\n    /*\n \
    \   k = 0\n    product = 1\n    i = 0\n    */\n    while ((i < n)) {\n       \
    \ product = (product * 2L) % p;\n        /*\n        product = (product * 2) %\
    \ p\n        */\n        k = k + 1L;\n        /*\n        k = k + 1\n        */\n\
    \        i = i + 1L;\n        /*\n        i = i + 1\n        */\n    }\n    return\
    \ product;\n    /*\n    return product\n    */\n}\n/*\nThe Miller-Rabin test for\
    \ primality.  Return True if n is probably prime.\n    >>> is_prime(2L)\n    True\n\
    \    >>> is_prime(3L)\n    True\n    >>> is_prime(4L)\n    False\n    >>> is_prime(5L)\n\
    \    True\n    >>> is_prime(6L)\n    False\n    >>> is_prime(7L)\n    True\n \
    \   >>> is_prime(8L)\n    False\n    >>> is_prime(9L)\n    False\n    >>> is_prime(10L)\n\
    \    False\n    >>> is_prime(11L)\n    True\n    >>> is_prime(12L)\n    False\n\
    \    >>> is_prime(13L)\n    True\n    >>> is_prime(14L)\n    False\n    >>> is_prime(15L)\n\
    \    False\n    >>> is_prime(16L)\n    False\n    >>> is_prime(17L)\n    True\n\
    \    >>> is_prime(18L)\n    False\n    >>> is_prime(19L)\n    True\n    >>> is_prime(20L)\n\
    \    False\n    >>> is_prime(21L)\n    False\n    >>> is_prime(22L)\n    False\n\
    \    >>> is_prime(23L)\n    True\n    >>> is_prime(24L)\n    False\n    >>> is_prime(25L)\n\
    \    False\n    >>> is_prime(26L)\n    False\n    >>> is_prime(27L)\n    False\n\
    \   ", "{\n    if (n == 0) \n    {\n        return 1;\n    }\n    auto a = modp(n\
    \ >> 1, p);\n    a = (a * a) % p;\n    if (n & 1) \n    {\n        a = (a * 2)\
    \ % p;\n    }\n    return a;\n}", "{\n    ref long result = 1L;\n    immutable\
    \ long two = 2L;\n    while (n > 0L) \n    {\n        if (n % two == 1L)\n   \
    \         result = (result * two) % p;\n        n = n / two;\n        two = (two\
    \ * two) % p;\n    }\n    return result;\n}", "{\n    if (n == 0) \n    {\n  \
    \      return 1;\n    }\n    else \n    {\n        return powmod(2, n - 1, p)\
    \ * 2 % p;\n    }\n}\n/*\nCalculate a prime number.\n    >>> nextprime(3L)\n \
    \   5L\n    >>> nextprime(109L)\n    113L\n    >>> nextprime(123L)\n    127L\n\
    \    \n*/\nlong nextprime(long n) \n{\n    while (!isprime(n)) \n    {\n     \
    \   n++;\n    }\n    return n;\n}\n/*\nFactorize a number.\n    >>> factorize(1L)\n\
    \    []\n    >>> factorize(3L)\n    [3L]\n    >>> factorize(100L)\n    [2L, 2L,\
    \ 5L, 5L]\n    >>> factorize(97L)\n    [97L]\n    \n*/\n@safe immutable(ulong)[]\
    \ factorize(ulong n) \n{\n    return factorize(n, 1);\n}\n/*\nFactorize a number\
    \ with a minimum number of factors.\n    >>> factorize(100L, 3)\n    [2L, 2L,\
    \ 5L, 5L]\n    >>> factorize(100L, 4)\n    [2L, 2L, 5L, 5L]\n    >>> factorize(100L,\
    \ 5)\n    [4L, 5L, 5L]\n    >>> factorize(100L, 6)\n    [4L, 5L, 5L]\n    \n*/\n\
    @safe immutable(ulong)[] factorize(ulong n, ulong min_factors) \n{\n    static\
    \ assert(is(typeof(factorize!(1, 1)) == immutable(ulong)[]));\n    static if (n\
    \ == 1 || n == 0) \n    {\n        return [];\n    }\n    else \n    {\n     \
    \   if (n % 2 == 0) \n        {\n            immutable(ulong)[] result = factorize(n\
    \ / 2, min_factors);\n            if (2 == result[$ - 1]) \n            {\n  \
    \              return result;\n            }", "{\n    auto s, t;\n    while (true)\
    \ {\n        s = p / n;\n        t = p - s * n;\n        if (t != 0L) {\n    \
    \        break;\n        }\n        p = n;\n        n = s;\n    }\n    return\
    \ n;\n}", "{\n    long pow = 1L;\n    long i = 0L;\n    for (; i < n; i += 1L)\
    \ {\n        pow = (pow * 2L) % p;\n    }\n    return pow;\n}\n/*\nReturn the\
    \ inverse of x modulo p (be aware of numerics).\n    >>> inverse(2L, 7L)\n   \
    \ 4L\n    >>> inverse(3L, 11L)\n    4L\n    >>> inverse(3L, 5L)\n    2L\n    >>>\
    \ inverse(3L, 2L)\n    Traceback (most recent call last):\n        ...\n    ValueError:\
    \ modulus must be larger than 0\n    >>> inverse(5L, 0L)\n    Traceback (most\
    \ recent call last):\n        ...\n    ValueError: modulus must be larger than\
    \ 0\n*/\nlong inverse(long x, long p) \n{\n    static int warn_numerics = 0;\n\
    \    if (p <= 0L) {\n        throw new ValueError(\"modulus must be larger than\
    \ 0\");\n    }\n    long a = p;\n    long b = x;\n    tuple2<long, long> u = std.typecons.tuple2(1L,\
    \ 0L);\n    tuple2<long, long> v = std.typecons.tuple2(0L, 1L);\n    long quotient\
    \ = 0L;\n    long tmp = 0L;\n    while (b != 0L) {\n        quotient = a / b;\n\
    \        tmp = a;\n        a = b;\n        b = tmp - quotient * b;\n        tmp\
    \ = u._0;\n        u._0 = v._0;\n        v._0 = tmp - quotient * v._0;\n     \
    \   tmp = u._1;\n        u._1 = v._1;\n        v._1 = tmp - quotient * v._1;\n\
    \    }\n    if (u._0 < 0L) {\n        u._0 += p;\n    }\n    if (warn_numerics\
    \ == 0) {\n        warn_numerics = 1;\n        /*\n                if a != 1:\n\
    \                    print \"Warning: numerics in inverse()\"\n        */", "{\n\
    \    long result = 1L;\n    long x = n;\n    while (n > 0L) {\n        if (n %\
    \ 2L == 1L) {\n            result = (result * x) % p;\n        }\n        x =\
    \ (x * x) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\n    test\
    \ if n is probably prime, the chance of this function making a mistake is 1/10^(n-2)",
  "{\n    long result;\n    while (n > 0) {\n        switch (n % 3) {\n          \
    \  case 0:\n                n = n / 3;\n                break;\n            case\
    \ 1:\n                result = (4 * result) % p;\n                n = (n - 1)\
    \ / 3;\n                break;\n            case 2:\n                result =\
    \ (2 * result) % p;\n                n = (n - 2) / 3;\n                break;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn the greatest common divisor\
    \ of two non-negative integers.\n    >>> gcd(36, 63)\n    9\n    \n*/\nlong gcd(long\
    \ a, long b) \n{\n    a = abs(a);\n    b = abs(b);\n    if (a < b) {\n       \
    \ long tmp = a;\n        a = b;\n        b = tmp;\n    }\n    while (b != 0) {\n\
    \        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return\
    \ a;\n}\n/*\nAn arbitrary precision rational.\n    \n*/\nclass Rational {\n  \
    \  public static long gcd(long a, long b) \n    {\n        a = abs(a);\n     \
    \   b = abs(b);\n        if (a < b) {\n            long tmp = a;\n           \
    \ a = b;\n            b = tmp;\n        }\n        while (b != 0) {\n        \
    \    long tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n\
    \        return a;\n    }\n    long numer;\n    long denom;\n    @property\n \
    \   long _numer(long value) {\n        return numer;\n    }\n    @property\n \
    \   long _denom(long value) {\n        return denom;\n    }\n    @property\n \
    \   @safe\n    long numer(long value) {\n        numer = value;\n        long\
    \ g = gcd(numer, denom);\n        numer /= g;\n        denom /= g;\n        if\
    \ (denom < 0) {\n            numer = -numer;\n            denom = -", "{\n  if\
    \ (n == 0) {\n    return 1;\n  } else {\n    long sq = modp(n / 2, p);\n    if\
    \ (n % 2 == 0) {\n      return (sq * sq) % p;\n    } else {\n      return (sq\
    \ * sq * 2) % p;\n    }\n  }\n}\n/*\nBase conversion function.\n    >>> basecon(5L,\
    \ 2L)\n    101L\n    >>> basecon(4L, 3L)\n    11L\n    >>> basecon(2L, 3L)\n \
    \   2L\n    >>> basecon(10L, 2L)\n    1010L\n    >>> basecon(1000L, 3L)\n    110001001L\n\
    \    >>> basecon(1000L, 10L)\n    1000L\n    >>> basecon(1000L, 16L)\n    3e8L\n\
    */\nlong basecon(long number, long base) \n{\n  if (number == 0) {\n    return\
    \ 0;\n  } else {\n    return (number % base) + 10 * basecon(number / base, base);\n\
    \  }\n}\n/*\nCalculate a*b modulo n (be aware of numerics).\n    >>> modmult(3L,\
    \ 2L, 5L)\n    1L\n    >>> modmult(3L, 2L, 3L)\n    2L\n    >>> modmult(3L, 2L,\
    \ 1L)\n    0L\n    >>> modmult(0L, 2L, 5L)\n    0L\n    >>> modmult(10L, 2L, 11L)\n\
    \    8L\n    >>> modmult(10L, 2L, 17L)\n    16L\n*/\nlong modmult(long a, long\
    \ b, long n) \n{\n  if (a == 0 || b == 0) {\n    return 0;\n  } else {\n    return\
    \ (modmult(a, b - 1, n) + a) % n;\n  }\n}\n/*\nCalculate a^b modulo n (be aware\
    \ of numerics).\n    >>> modexp(2L, 5L, 3L)\n    2L\n    >>> modexp(", "{\n  \
    \  long r = 1L;\n    long b = 2L;\n    while (n > 0L) \n    {\n        if (n %\
    \ 2L == 1L) \n        {\n            r = (r * b) % p;\n        }\n        n =\
    \ n / 2L;\n        b = (b * b) % p;\n    }\n    return r;\n}", "{\n    n = n %\
    \ p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n =\
    \ n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n   \
    \ n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n % p;\n\
    \    n = n % p;\n    n = n % p;\n    n = n % p;\n    n = n %", "{\n    if (n ==\
    \ 0) \n    {\n        return 1;\n    }\n    if (n % 2 == 0) \n    {\n        long\
    \ t = modp(n / 2, p);\n        return (t * t) % p;\n    }\n    else \n    {\n\
    \        return (modp(n - 1, p) * 2) % p;\n    }\n}", "{\n    return (n >= p)\
    \ ? p : (n < 1) ? 1 : (n == 1) ? 1 : (n == 2) ? (p - 1) : modp(modp(n - 1, p)\
    \ * n, p);\n}\nlong div2(long n) \n{\n    return n / 2;\n}\n/*\nCheck if n is\
    \ a power of 2.\n    >>> isPow2(2L)\n    True\n    >>> isPow2(3L)\n    False\n\
    \    >>> isPow2(4L)\n    True\n    >>> isPow2(5L)\n    False\n    >>> isPow2(8L)\n\
    \    True\n    >>> isPow2(9L)\n    False\n    >>> isPow2(16L)\n    True\n    >>>\
    \ isPow2(17L)\n    False\n*/", "{\n    long res = 1L;\n    while (n > 0L) {\n\
    \        res = res * ((n % 2L) != 0L ? 2L : 1L) % p;\n        n /= 2L;\n    }\n\
    \    return res;\n}\n/*\nCompute the order of 2 modulo p.\n    >>> get_order(3L)\n\
    \    2L\n    >>> get_order(7L)\n    3L\n    >>> get_order(11L)\n    2L\n    >>>\
    \ get_order(13L)\n    6L\n*/\nlong get_order(long p) {\n    long order = p - 1L;\n\
    \    while (modp(order, p) == 1L) {\n        order--;\n    }\n    return order;\n\
    }\n/*\nCompute the orders of all primes up to p.\n    >>> get_orders(11L)\n  \
    \  [2L, 2L, 2L, 3L, 2L, 4L, 2L, 4L, 2L, 6L, 2L]\n*/\nauto get_orders(long p) {\n\
    \    return map!((n) => get_order(n))(filter!((n) => isPrime(n))(iota(p)));\n\
    }\n/*\nCompute the length of the period when dividing by p.\n    >>> get_period(11L)\n\
    \    5L\n    >>> get_period(13L)\n    6L\n    >>> get_period(7L)\n    3L\n*/\n\
    long get_period(long p) {\n    long l = 1L;\n    while (modp(10L, p) != 1L) {\n\
    \        l++;\n    }\n    return l;\n}\n/*\nCompute the length of the periods\
    \ of all primes up to p.\n    >>> get_periods(11L)\n    [1L, 1L, 1L, 2L, 1L, 3L,\
    \ 1L, 2L, 1L, 2L, 1L]\n*/\nauto get_periods(long p) {\n    return map!((n) =>\
    \ get_period(n))(filter!((n) => isPrime(n))(iota(p", "{\n    if (n==0) return\
    \ 1;\n    n%=p;\n    long result = 1;\n    long x = n;\n    for (long i = 0; i\
    \ < p; i++)\n    {\n        result = (result * x) % p;\n    }\n    return result;\n\
    }", "{\n    if (n == 0)\n    {\n        return 1;\n    }\n    long r = modp(n\
    \ >> 1, p);\n    r *= r;\n    r %= p;\n    if (n & 1)\n    {\n        r *= 2;\n\
    \        r %= p;\n    }\n    return r;\n}", "{\n    int r = 1;\n    while (n >\
    \ 0) {\n        if (n % 2 == 1) r = (r * n) % p;\n        n = n / 2;\n    }\n\
    \    return r;\n}", "{\n    bool is_even = (n & 1) == 0;\n    long x = n;\n  \
    \  long result = 1;\n    long factor = 2;\n    while (x > 0) \n    {\n       \
    \ if ((x & 1) != 0) \n        {\n            result = (result * factor) % p;\n\
    \        }\n        factor = (factor * factor) % p;\n        x = x >> 1;\n   \
    \ }\n    if (is_even) \n    {\n        result = p - result;\n    }\n    return\
    \ result;\n}", "{\n    assert(p > 0L);\n    if (n < 0L) \n    {\n        return\
    \ modp(n + p * div_t.quotient(n, p).quot, p);\n    }\n    long a = n;\n    long\
    \ r = 1L;\n    while (a > 0L) \n    {\n        if ((div_t.quotient(a, 2L).rem)\
    \ == 1L) \n        {\n            r = div_t.quotient(r * n, p).rem;\n        }\n\
    \        a = div_t.quotient(a, 2L);\n        n = div_t.quotient(n * n, p).rem;\n\
    \    }\n    return r;\n}\nlong modp(long n, long p) = modp;", "{\n    @nogc:\n\
    \    {\n        if (n < 0L) \n        {\n            n = n % p + p;\n        }\n\
    \        if (n == 0L) \n        {\n            return 1L;\n        }\n       \
    \ long prod = 2L;\n        long last = 2L;\n        long i = 1L;\n        while\
    \ (i < n) \n        {\n            if (prod >= p) \n            {\n          \
    \      prod = (prod - p) * last;\n            }\n            else \n         \
    \   {\n                prod *= last;\n            }\n            i++;\n      \
    \  }\n        return prod % p;\n    }\n}", "{\n    return n>0 ? (1+ (p-1) * modp(n-1,\
    \ p)) % p : 1;\n}\n/*\nReturn True if x is a Fermat pseudoprime to base a, else\
    \ False.\n    >>> is_fermat_pseudoprime(2L, 2L)\n    True\n    >>> is_fermat_pseudoprime(2L,\
    \ 3L)\n    True\n    >>> is_fermat_pseudoprime(0L, 2L)\n    False\n    >>> is_fermat_pseudoprime(5L,\
    \ 3L)\n    False\n    >>> is_fermat_pseudoprime(561L, 17L)\n    True\n    >>>\
    \ is_fermat_pseudoprime(561L, 18L)\n    False\n    >>> is_fermat_pseudoprime(561L,\
    \ 19L)\n    False\n    >>> is_fermat_pseudoprime(561L, 20L)\n    False\n    >>>\
    \ is_fermat_pseudoprime(561L, 21L)\n    False\n    >>> is_fermat_pseudoprime(561L,\
    \ 22L)\n    False\n    >>> is_fermat_pseudoprime(561L, 23L)\n    False\n    >>>\
    \ is_fermat_pseudoprime(561L, 24L)\n    False\n    >>> is_fermat_pseudoprime(561L,\
    \ 25L)\n    False\n    >>> is_fermat_pseudoprime(561L, 26L)\n    False\n    >>>\
    \ is_fermat_pseudoprime(561L, 27L)\n    False\n    >>> is_fermat_pseudoprime(561L,\
    \ 28L)\n    False\n    >>> is_fermat_pseudoprime(561L, 29L)\n    False\n    >>>\
    \ is_fermat_pseudoprime(561L, 30L)\n    False\n    >>> is_fermat_pseudoprime(561L,\
    \ 31L)\n    False\n    >>> is_fermat_pseudoprime(561L, 32L", "{\n    if(n == 0)\
    \ return 1;\n    else if(n % 2 == 0) \n    {\n        long h = modp(n/2, p);\n\
    \        return (h*h) % p;\n    }\n    else return (n * modp(n-1, p)) % p;\n}",
  "{\n    return n >= 0 ? n % p : p - 1 - (-n - 1) % p;\n}", "{\n    long r = 1L;\n\
    \    long e = n;\n    while (e != 0L) {\n        if ((e & 1L) != 0L) {\n     \
    \       r = (r * n) % p;\n        }\n        n = (n * n) % p;\n        e = e >>\
    \ 1L;\n    }\n    return r;\n}", "{\n    long r = 1L;\n    while (n > 0L) {\n\
    \        if (n % 2L != 0L) {\n            r = (r * 2L) % p;\n        }\n     \
    \   n = n / 2L;\n    }\n    return r;\n}", "{\n    enum {\n        int32_t = $int32_t,\n\
    \        int64_t = $int64_t,\n        uint32_t = $uint32_t,\n        uint64_t\
    \ = $uint64_t,\n        size_t = $size_t,\n        };\n    // C implementation\
    \ of modp(n, p).\n    if (!n) return 1;\n    if (n < 0) {\n        return p -\
    \ modp(-n, p);\n    }\n    long ans = 1;\n    long a = n;\n    while (p) {\n \
    \       if (p & 1) ans = (ans * a) % n;\n        a = (a * a) % n;\n        p >>=\
    \ 1;\n    }\n    return ans;\n}", "{\n    return pow(cast(long)2, n) % p;\n}\n\
    /*\nGiven p, the characteristic of F_p, return the field itself.\n    >>> GF(3)\n\
    \    [0, 1, 2]\n    >>> GF(11)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>>\
    \ GF(13)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n*/", "{\n\tn %= p;\n\
    \tif(n < 0) n += p;\n\treturn n;\n}\n/*\nReturn a^2 modulo p (be aware of numerics).\n\
    \    >>> modp2(3L, 5L)\n    4L\n    >>> modp2(3L, 11L)\n    9L\n    >>> modp2(3L,\
    \ 101L)\n    9L\n*/\nlong modp2(long a, long p) \n{\n\treturn modp(a*a, p);\n\
    }\n/*\nReturn a^(-1) modulo p (be aware of numerics).\n    >>> modpinv(3L, 5L)\n\
    \    2L\n    >>> modpinv(3L, 11L)\n    4L\n    >>> modpinv(3L, 101L)\n    37L\n\
    \    >>> modpinv(100L, 101L)\n    1L\n*/\nlong modpinv(long a, long p) \n{\n\t\
    auto ret = modp(a, p);\n\tauto[] small = new long[32];\n\tlong m = p;\n\tlong\
    \ x = 1L;\n\tlong i = 0;\n\twhile(m > 0) \n\t{\n\t\tsmall[i] = ret;\n\t\tret =\
    \ modp(ret * ret, p);\n\t\tx = modp(x * ret, p);\n\t\tm >>= 1;\n\t\ti++;\n\t}\n\
    \tauto[xn, n] = tuple(x, i);\n\twhile(n > 0) \n\t{\n\t\tif(n == 1) \n\t\t{\n\t\
    \t\tret = modp(ret * xn, p);\n\t\t\tbreak;\n\t\t}\n\t\tn--;\n\t\tret = modp(ret\
    \ * small[n], p);\n\t}\n\treturn ret;\n}\n/*\nReturn the greatest common divisor\
    \ of a and b.\n    >>> gcd(2L, 3L)\n    1L\n    >>> gcd(6L, 12L)\n    6L\n   \
    \ >>> gcd(12L, 6L)\n    6L\n    >>> gcd(1", "{\n\tlong accum = 1L;\n\twhile (n\
    \ != 0L) {\n\t\tif ((n & 1L) != 0L) {\n\t\t\taccum = accum * n % p;\n\t\t}\n\t\
    \tn = n >> 1L;\n\t\tn = n * n % p;\n\t}\n\treturn accum;\n}\n/*\nReturn a random\
    \ number in the range (0, n).\n    >>> random.randrange(0L, 1L)\n    0L\n    >>>\
    \ random.randrange(0L, 10L)\n    7L\n    >>> random.randrange(0L, 10L)\n    6L\n\
    \    >>> random.randrange(0L, 10L)\n    5L\n    >>> random.randrange(0L, 10L)\n\
    \    2L\n    >>> random.randrange(0L, 10L)\n    1L\n    >>> random.randrange(0L,\
    \ 10L)\n    9L\n    >>> random.randrange(0L, 10L)\n    3L\n    >>> random.randrange(0L,\
    \ 10L)\n    0L\n    >>> random.randrange(0L, 10L)\n    9L\n    >>> random.randrange(0L,\
    \ 10L)\n    1L\n    >>> random.randrange(0L, 10L)\n    4L\n    >>> random.randrange(0L,\
    \ 10L)\n    6L\n    >>> random.randrange(0L, 10L)\n    7L\n    >>> random.randrange(0L,\
    \ 10L)\n    2L\n    >>> random.randrange(0L, 10L)\n    6L\n    >>> random.randrange(0L,\
    \ 10L)\n    2L\n    >>> random.randrange(0L, 10L)\n    7L\n    >>> random.randrange(0L,\
    \ 10L)\n    0L\n    >>> random.randrange(0L, 10L)\n    6L\n    >>> random.randrange(0L,\
    \ 10L)\n    3L\n    >>> random.randrange(0L, 10L)\n    8L\n    >>> random.randrange(0L,\
    \ 10L)\n    7L", "{\n    if (n > 0) {\n        return (p-1) & bitxor(bitxor(n,\
    \ n>>1), n>>2);\n    } else {\n        return p-1;\n    }\n}\n// Throw away the\
    \ higher bits\n//    >>> modp3(3L, 5L)\n//    3L\n//    >>> modp3(1101L, 101L)\n\
    //    3L\n//    >>> modp3(0L, 101L)\n//    0L\n//    >>> modp3(3L, 11L)\n//  \
    \  3L\n//    >>> modp3(100L, 101L)\n//    100L\nlong modp3(long n, long p) {\n\
    \    return (p-1) & n;\n}\n// Pascal's triangle\n//    >>> modp2(3L, 5L)\n// \
    \   3L\n//    >>> modp2(1101L, 101L)\n//    2L\n//    >>> modp2(0L, 101L)\n//\
    \    1L\n//    >>> modp2(3L, 11L)\n//    8L\n//    >>> modp2(100L, 101L)\n// \
    \   1L\nlong modp2(long n, long p) {\n    if (n < p) {\n        return n;\n  \
    \  } else {\n        long d = n / p;\n        return (p - 1) & (n - p * d);\n\
    \    }\n}\n/*\n    >>> binomial(4, 3)\n    4\n    >>> binomial(4, 2)\n    6\n\
    \    >>> binomial(4, 1)\n    4\n    >>> binomial(4, 0)\n    1\n    >>> binomial(4,\
    \ -1)\n    0\n    >>> binomial(4, 5)\n    0\n    >>> binomial(5, 3)\n    10\n\
    \    >>> binomial(9, 3)\n    84\n    >>> binomial(9, 6)\n    84\n    >>> binomial(9,\
    \ -1)\n    0\n    >>> binomial(9, 10)\n    0\n    >>> binomial(10, 10)\n    1\n\
    \    >>> binomial", "{\n    if (n < 0L)\n    {\n        return modp(n % p + p,\
    \ p);\n    }\n    if (n < p)\n    {\n        return n;\n    }\n    ulong s = 0UL;\n\
    \    ulong t = 1UL;\n    while ((p >> s) > n)\n    {\n        s++;\n    }\n  \
    \  while (s != 0UL)\n    {\n        s--;\n        t = t * t % p;\n        if (((p\
    \ >> s) & 1UL) != 0UL)\n        {\n            t = t * n % p;\n        }\n   \
    \ }\n    return t;\n}", "{\n    return pow(2L, n, p);\n}\n/*\nReturn the first\
    \ prime >= n.\n*/\nlong next_prime(long n) \n{\n    while (1) \n    {\n      \
    \  if (is_prime(n)) \n        {\n            return n;\n        }\n        n++;\n\
    \    }\n}\n/*\nReturn the first prime >= n.\n    >>> next_prime(3)\n    3\n  \
    \  >>> next_prime(12)\n    13\n    >>> next_prime(2L**64 - 1)\n    18446744073709551557L\n\
    \    >>> next_prime(9999999999999999999999999999999999999L)\n    100000000000000000000000000000000000000039L\n\
    \    >>> next_prime(999999999999999999999999999999999999999999999L)\n    10000000000000000000000000000000000000000000000019L\n\
    \    \n*/\nlong next_prime(long n) \n{\n    if (n < 2) \n    {\n        return\
    \ 2;\n    }\n    n = next_prime(n - 1);\n    if (n >= 2**32) \n    {\n       \
    \ n = next_prime(2**32 - 2);\n        n = next_prime(2**32 + n);\n    }\n    return\
    \ n;\n}\n/*\nBatch test some numbers for primality and return a list of\n(number,\
    \ is_prime) tuples.\n    >>> primes1m = read_primes1m(2**20)\n    >>> len(primes1m)\n\
    \    78498\n    >>> sum(1 for _, prime in primes1m if prime)\n    78498\n    >>>\
    \ [number for number, prime in primes1m if not prime]\n    [2047, 3277, 4033,\
    \ 4681, 8321, 15841, 29341, 42799, 49141, 52633, 65281, 74665, 80581, 85489, 88357,\
    \ 90751, 104653, 130561, 196093, 220729, 233017, 252601, 253241, 256999, 271951,\
    \ 280601, 314821, 357761, 390937, 458989, 476971, 486737]\n    >>> primes1", "{\n\
    \    long result = 1L;\n    for (; n > 0L; n >>= 1L) {\n        if (n & 1L) {\n\
    \            result = (result * 2L) % p;\n        }\n    }\n    return result;\n\
    }", "{\n    long res = 1L;\n    long cur = 2L;\n    while (n > 0L) \n    {\n \
    \       if (n % 2L == 1L) \n        {\n            res = (res * cur) % p;\n  \
    \      }\n        cur = (cur * cur) % p;\n        n /= 2L;\n    }\n    return\
    \ res;\n}\n/*\nExtended binary GCD algorithm\n*/\nlong[] exbin_gcd(long a, long\
    \ b) \n{\n    long[] ys = new long[2];\n    long[] rs = new long[2];\n    if (a\
    \ < b) \n    {\n        ys[0] = 0L;\n        ys[1] = 1L;\n        rs[0] = b;\n\
    \        rs[1] = a;\n    }\n    else \n    {\n        ys[0] = 1L;\n        ys[1]\
    \ = 0L;\n        rs[0] = a;\n        rs[1] = b;\n    }\n    long[] qr = new long[2];\n\
    \    while (rs[1] != 0L) \n    {\n        qr = divmod(rs[0], rs[1]);\n       \
    \ long q = qr[0];\n        rs[0] = rs[1];\n        rs[1] = qr[1];\n        long\
    \ t = ys[0] - (q * ys[1]);\n        ys[0] = ys[1];\n        ys[1] = t;\n    }\n\
    \    return rs;\n}\n/*\nReturn the inverse of x modulo p.\n    >>> inverse(3L,\
    \ 5L)\n    2L\n    >>> inverse(3L, 11L)\n    4L\n    >>> inverse(100L, 101L)\n\
    \    51L\n*/\nlong inverse(long x, long p) \n{\n    return (exbin_gcd(x, p)[1]\
    \ % p + p) % p;\n}\n/*\nMontgomery modular exponentiation\n*/\nlong montexp(long\
    \ n, long p, long g) \n{\n    long r = 1L;\n", "{\n    return modp(cast(real)n,\
    \ p);\n}", "    long r = 1L;\n    while (n > 0L)\n    {\n        if (n % 2L ==\
    \ 1L)\n        {\n            r = (r * 2L) % p;\n        }\n        n /= 2L;\n\
    \        if (n > 0L)\n        {\n            p = (p * p) % n;\n        }\n   \
    \ }\n    return r;\n}", "{\n    long r = 1L;\n    while (n > 0L) {\n        if\
    \ (n % 2L == 1L) {\n            r = (r * 2L) % p;\n        }\n        n = n /\
    \ 2L;\n    }\n    return r;\n}\nlong modp2(long n, long p) {\n    if (n == 0L)\
    \ {\n        return 1L;\n    }\n    else {\n        return 2L * modp2(n - 1L,\
    \ p) % p;\n    }\n}\nlong modp3(long n, long p) {\n    return ((2L % p) ^ n) %\
    \ p;\n}\nlong modp4(long n, long p) {\n    long b = 2L;\n    long r = 1L;\n  \
    \  while (n > 0L) {\n        while (b % p == 0L) {\n            b = b / p;\n \
    \       }\n        if (n % 2L == 1L) {\n            r = (r * b) % p;\n       \
    \ }\n        b = (b * b) % p;\n        n = n / 2L;\n    }\n    return r;\n}\n\
    long modp5(long n, long p) {\n    return ((2L ^ n) % p);\n}", "{\n    if (n <\
    \ 0L) \n    {\n        long r = modp(n + ((-n / p) + 1L) * p, p);\n        if\
    \ (r == 0L) \n        {\n            return p;\n        }\n        return r;\n\
    \    }\n    long result = 1L;\n    for (long i = 0L; i < n; i++) \n    {\n   \
    \     result = (result * 2L) % p;\n    }\n    return result;\n}\n/*\nReturn the\
    \ inverse of n modulo p (n and p are not necessarily coprime).\n    >>> invp(3L,\
    \ 5L)\n    2L\n    >>> invp(2L, 5L)\n    3L\n    >>> invp(7L, 11L)\n    8L\n \
    \   >>> invp(7L, 8L)\n    7L\n    >>> invp(7L, 12L)\n    7L\n*/\nlong invp(long\
    \ n, long p) \n{\n    return powmod(n, p - 2L, p);\n}\n/*\nCascading modulo reductions.\n\
    \    >>> mod(3L, 5L, 7L)\n    3L\n    >>> mod(3L, 5L, 101L)\n    3L\n    >>> mod(3L,\
    \ 5L, 101L, 103L)\n    109L\n*/\nlong mod(R, p__) \n{\n    if (p__.length == 0)\
    \ \n    {\n        return 0L;\n    }\n    else if (p__.length == 1) \n    {\n\
    \        return modp(R, p__[0L]);\n    }\n    else \n    {\n        return mod(modp(R,\
    \ p__[0L]), p__[1..]);\n    }\n}\n/*\nNumerical representation of factorials (be\
    \ aware of numerics).\n    >>> factorial(0L)\n    1L\n    >>> factorial(1L)\n\
    \    1L\n    >>> factorial(2L)\n    2L\n    >>> factorial(3L)\n    6L\n    >>>\
    \ factorial(100L)\n    93326215", "{\n    if (n < 0L)\n    {\n        throw new\
    \ Exception(\"modp: n < 0 not implemented\");\n    }\n    else if (n == 0L)\n\
    \    {\n        return 1L;\n    }\n    else if (n == 1L)\n    {\n        return\
    \ 2L % p;\n    }\n    else if (n % 2L == 0L)\n    {\n        return modp(n / 2L,\
    \ p) * modp(n / 2L, p) % p;\n    }\n    else\n    {\n        return 2L * modp(n\
    \ - 1L, p) % p;\n    }\n}", "{\n    import std.stdio;\n    writeln(\"n = \", n,\
    \ \" p = \", p);\n    if (n == 0)\n        return 1;\n    long x = modp(n / 2,\
    \ p);\n    writeln(\"x = \", x);\n    if (n % 2 == 0)\n        return (x * x)\
    \ % p;\n    else\n        return (x * x * 2) % p;\n}\n/*\nCompute the order of\
    \ a number modulo p.\n*/\nlong order(long a, long p)\n{\n    import std.stdio;\n\
    \    writeln(\"order a = \", a, \" p = \", p);\n    //assert(gcd(a, p) == 1)\n\
    \    long i = 1;\n    while (modp(i, p) != 1)\n        i++;\n    return i;\n}\n\
    /*\nReturn True if gcd(x, y) != 1.\nThis is used to find non-primes in Miller-Rabin.\n\
    \    >>> gcd1(6L, 5L)\n    True\n    >>> gcd1(5L, 6L)\n    True\n    >>> gcd1(6L,\
    \ 6L)\n    True\n    >>> gcd1(6L, 1L)\n    True\n    >>> gcd1(1L, 6L)\n    True\n\
    \    >>> gcd1(11L, 6L)\n    False\n    >>> gcd1(6L, 11L)\n    False\n    >>> gcd1(12L,\
    \ 11L)\n    True\n    >>> gcd1(11L, 12L)\n    True\n    >>> gcd1(11L, 2L)\n  \
    \  False\n    >>> gcd1(2L, 11L)\n    False\n*/", "{\n    long e = 1L;\n    long\
    \ b = 2L;\n    long mask = rshift(n, 1L);\n    while (mask != 0L) \n    {\n  \
    \      if (and(mask, 1L) != 0L) \n        {\n            e = e * b % p;\n    \
    \    }\n        b = b * b % p;\n        mask = rshift(mask, 1L);\n    }\n    return\
    \ e;\n}\n/*\nReturn x^n modulo p (be aware of numerics).\n    >>> modp(3L, 4L,\
    \ 5L)\n    3L\n    >>> modp(1101L, 3L, 101L)\n    16L\n    >>> modp(0L, 10L, 101L)\n\
    \    1L\n    >>> modp(3L, 11L, 11L)\n    1L\n    >>> modp(100L, 100L, 101L)\n\
    \    1L\n    \n*/\nlong modp(long x, long n, long p) \n{\n    long e = 1L;\n \
    \   long b = x;\n    long mask = rshift(n, 1L);\n    while (mask != 0L) \n   \
    \ {\n        if (and(mask, 1L) != 0L) \n        {\n            e = e * b % p;\n\
    \        }\n        b = b * b % p;\n        mask = rshift(mask, 1L);\n    }\n\
    \    return e;\n}\n/*\nReturn the index of the highest bit set in n.\n    >>>\
    \ bit(1L)\n    0L\n    >>> bit(2L)\n    1L\n    >>> bit(5L)\n    2L\n    >>> bit(1L\
    \ << 100)\n    100L\n    >>> bit(0L)\n    Traceback (most recent call last):\n\
    \        ...\n    ValueError: n must be non-zero\n    \n*/\nlong bit(long n) \n\
    {\n    if (n == 0L) \n    {\n        throw new ValueError(\"n must be non-zero\"\
    );\n    }\n    long b = 0L;\n    long m = 1L;\n    while (and(n, m", '    return
    n % p;', "    if (is(typeof(pow(n, n)) : double) && !is(typeof(pow(n, n)) : int))\n\
    {\n    double res;\n    if (n == 0) \n    {\n        res = 1;\n    }\n    else\
    \ \n    {\n        long sq = modp(n / 2, p);\n        res = sq * sq;\n       \
    \ if (n % 2) \n        {\n            res *= n;\n        }\n    }\n    return\
    \ res % p;\n}", "{\n    long z = 1L;\n    while (n > 0L) {\n        if (n % 2L\
    \ == 1L)\n            z = (z * 2L) % p;\n        n = n / 2L;\n    }\n    return\
    \ z;\n}\n/*\nReturn x^y modulo p (be aware of numerics).\n    >>> modpow(3L, 2L,\
    \ 5L)\n    4L\n    >>> modpow(3L, 2L, 4L)\n    1L\n    >>> modpow(3L, 2L, 7L)\n\
    \    2L\n    >>> modpow(3L, 3L, 5L)\n    2L\n    >>> modpow(1101L, 103L, 101L)\n\
    \    4L\n    >>> modpow(3L, 10L, 10L)\n    0L\n    >>> modpow(2L, 10L, 10L)\n\
    \    0L\n    >>> modpow(2L, 10L, 9L)\n    1L\n*/\nlong modpow(long x, long y,\
    \ long p) \n{\n    long z = 1L;\n    while (y > 0L) {\n        if (y % 2L == 1L)\n\
    \            z = (z * x) % p;\n        x = (x * x) % p;\n        y = y / 2L;\n\
    \    }\n    return z;\n}\n/*\nReturn the logarithm base 2 of x.\n    >>> log2(1L)\n\
    \    0L\n    >>> log2(2L)\n    1L\n    >>> log2(4L)\n    2L\n    >>> log2(5L)\n\
    \    2L\n    >>> log2(15L)\n    3L\n    >>> log2(16L)\n    4L\n    >>> log2(2000L)\n\
    \    9L\n    >>> log2(1024L)\n    10L\n    >>> log2(1025L)\n    10L\n*/\nlong\
    \ log2(long x) \n{\n    long y = 0L;\n    while (x > 1L) {\n        x = x / 2L;\n\
    \        y = y", "{\n  long r = 1L;\n  long b = 2L;\n  while (n != 0L) \n  {\n\
    \    if (n % 2L == 1L) \n    {\n      r = (r * b) % p;\n    }\n    n = n / 2L;\n\
    \    b = (b * b) % p;\n  }\n  return r;\n}\n/*\nReturn True if a or b is even.\n\
    \    >>> r1 = (1L, 2L)\n    >>> r2 = (3L, 4L)\n    >>> r3 = (5L, 6L)\n    >>>\
    \ ww(r1, r2, r3)\n    (1L, 2L, 3L, 4L, 5L, 6L)\n    >>> xy(r1, r2, r3)\n    (5L,\
    \ 6L, 3L, 4L, 1L, 2L)\n    >>> yx(r1, r2, r3)\n    (3L, 4L, 5L, 6L, 1L, 2L)\n\
    \    >>> yy(r1, r2, r3)\n    (3L, 4L, 5L, 6L, 1L, 2L)\n*/\nTuple!(long, long,\
    \ long, long, long, long) ww(Tuple!(long, long) r1, Tuple!(long, long) r2, Tuple!(long,\
    \ long) r3) \n{\n  return tuple(r1[0L], r1[1L], r2[0L], r2[1L], r3[0L], r3[1L]);\n\
    }\nTuple!(long, long, long, long, long, long) xy(Tuple!(long, long) r1, Tuple!(long,\
    \ long) r2, Tuple!(long, long) r3) \n{\n  return tuple(r3[0L], r3[1L], r2[0L],\
    \ r2[1L], r1[0L], r1[1L]);\n}\nTuple!(long, long, long, long, long, long) yx(Tuple!(",
  "{\n    enum p = p;\n    uint i;\n    long acc = 1L;\n    for (i = 0; i < 64; i++)\
    \ {\n        acc = (acc * acc) % p;\n        if (n & (1L << i)) {\n          \
    \  acc = (acc * 2) % p;\n        }\n    }\n    return acc;\n}\n/*\nReturn 2^n\
    \ - 1 modulo p (be aware of numerics).\n    >>> modm(3L, 5L)\n    4L\n    >>>\
    \ modm(1101L, 101L)\n    75L\n    >>> modm(0L, 101L)\n    0L\n    >>> modm(3L,\
    \ 11L)\n    4L\n    >>> modm(100L, 101L)\n    100L\n    \n*/\nlong modm(long n,\
    \ long p) \n{\n    enum p = p;\n    uint i;\n    long acc = 1L;\n    for (i =\
    \ 0; i < 64; i++) {\n        acc = (acc * acc) % p;\n        if (n & (1L << i))\
    \ {\n            acc = (acc * 2) % p;\n            acc = (acc + 1) % p;\n    \
    \    }\n    }\n    return acc;\n}\n/*\n   def lift(x, y, p):\n   '''\n   Return\
    \ a solution to the congruence\n       x^2 == y (mod p)\n   as a list. Raise an\
    \ exception if no solution.\n   '''\n   for i in range(0, p):\n       if ((i *\
    \ i) % p) == y:\n           return [i, p - i]\n   raise ValueError('No solution\
    \ for congruence')\n   \n*/", "{\n    struct out_tuple2;\n    long a = p - 1L;\n\
    \    long b = 0L;\n    long c = 1L;\n    for (; ; ) \n    {\n        if (a ==\
    \ 0L) \n        {\n            break;\n        }\n        if (a % 2L == 0L) \n\
    \        {\n            a /= 2L;\n            b /= 2L;\n            c *= 2L;\n\
    \        }\n        else \n        {\n            a -= 1L;\n            b += n;\n\
    \            c *= 2L;\n        }\n        b %= p;\n        c %= p;\n    }\n  \
    \  return c;\n}", "{\n    long temp = 1L;\n    long x = 2L;\n    long i = 0L;\n\
    \    i = n;\n    while (0L < i)\n    {\n        if ((i & 1L) != 0L)\n        {\n\
    \            temp = (temp * x) % p;\n        }\n        x = (x * x) % p;\n   \
    \     i = (i >> 1L);\n    }\n    return temp;\n}\n/*\nReturn the Jacobi symbol\
    \ (a/n) (be aware of numerics).\n    >>> jacobi(6L, 11L)\n    1L\n    >>> jacobi(2L,\
    \ 11L)\n    1L\n    >>> jacobi(5L, 11L)\n    -1L\n    >>> jacobi(1L, 11L)\n  \
    \  1L\n    >>> jacobi(0L, 11L)\n    Traceback (most recent call last):\n     \
    \ ...\n    ValueError: jacobi(0,b)\n    >>> jacobi(1L, 0L)\n    Traceback (most\
    \ recent call last):\n      ...\n    ValueError: jacobi(a,0)\n    \n*/\nlong jacobi(long\
    \ a, long n) \n{\n    long x = 0L;\n    long e = 0L;\n    long k = 0L;\n    long\
    \ p = 0L;\n    long t = 0L;\n    if (a == 0L)\n    {\n        throw new ValueError(\"\
    jacobi(0,b)\");\n    }\n    if (n == 0L)\n    {\n        throw new ValueError(\"\
    jacobi(a,0)\");\n    }\n    if (n < 0L)\n    {\n        if ((((n % 2L) != 0L)\
    \ && ((a % 2L) != 0L)))\n        {\n            return jacobi((-a), (-n));\n \
    \       }\n        else\n        {\n            return jacobi(a, (-n));\n    \
    \    }\n    }\n    if (a < 0L)\n    {\n        a = -a;\n        if ((n % 4L) ==\
    \ 3L)\n        {\n            x =", "{\n    if (n < 0L) {\n        return modp(-n,\
    \ p);\n    }\n    long r = 1L;\n    long b = 2L;\n    while (n > 0L) {\n     \
    \   while (n % 2L == 0L) {\n            n /= 2L;\n            if (b >= p) {\n\
    \                b -= p;\n            }\n            b *= b;\n        }\n    \
    \    n -= 1L;\n        if (b >= p) {\n            b -= p;\n        }\n       \
    \ r *= b;\n        if (r >= p) {\n            r -= p;\n        }\n    }\n    return\
    \ r;\n}\n/*\nReturn the kth-order Lucas number as a pair (Lk, Lk+1)\nmodulo p\
    \ (be aware of numerics).\n    >>> lucas(3L, 7L)\n    (4L, 11L)\n    >>> lucas(3L,\
    \ 11L)\n    (4L, 7L)\n    >>> lucas(17L, 23L)\n    (10L, 19L)\n    >>> lucas(0L,\
    \ 101L)\n    (2L, 1L)\n    >>> lucas(1L, 101L)\n    (1L, 2L)\n    >>> lucas(500L,\
    \ 101L)\n    (2L, 1L)\n    >>> lucas(10001L, 101L)\n    (2L, 1L)\n    >>> lucas(1000000000L,\
    \ 101L)\n    (2L, 1L)\n*/\ntuple!(long, long) lucas(long k, long p) \n{\n    if\
    \ (k < 0L) {\n        auto u = lucas(-k, p);\n        return tuple(u[1], u[0]);\n\
    \    }\n    if (k == 0L) {\n        return tuple(2L, 1L);\n    }\n    if (k ==\
    \ 1L) {\n        return tuple(1L, 2L);\n    }\n    if (k % 2L == 0L) {\n     \
    \   long b = modp(k / 2L, p);\n        auto u = lucas(k /", "{\n    long ans =\
    \ 1L;\n    /*\n    * For each bit in n, square the running product, and then if\
    \ the bit\n    * is set multiply in another copy of the product.\n    */\n   \
    \ foreach (immutable bit; 0 .. sizeof(int) * 8) \n    {\n        ans = (ans *\
    \ ans) % p;\n        if (n & (1 << bit)) \n        {\n            ans = (ans *\
    \ 2) % p;\n        }\n    }\n    return ans;\n}", "{\n  if (n == 0)\n    return\
    \ 1;\n  else if (n == 1)\n    return p;\n  else\n  {\n    long r;\n    if (n %\
    \ 2)\n      r = p * modp(n - 1, p);\n    else\n      r = modp(n / 2, p) * modp(n\
    \ / 2, p);\n    return r % p;\n  }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp2(3L, 5L)\n    3L\n    >>> modp2(1101L, 101L)\n    2L\n    >>> modp2(0L,\
    \ 101L)\n    1L\n    >>> modp2(3L, 11L)\n    8L\n    >>> modp2(100L, 101L)\n \
    \   1L\n    \n*/\nlong modp2(long n, long p) \n{\n  long r = 1;\n  long step =\
    \ n;\n  while (step > 0)\n  {\n    r = (r * step) % p;\n    step /= 2;\n  }\n\
    \  return r;\n}", "{\n    if (n == 0)\n        return 1;\n    else \n    {\n \
    \       auto m = modp(n >> 1, p);\n        if (n & 1)\n            return m *\
    \ m * 2 % p;\n        else\n            return m * m % p;\n    }\n}\n/*\nReturn\
    \ a random integer in [0, n).\n    >>> randint(10)\n    7\n    >>> randint(10)\n\
    \    2\n    >>> randint(10)\n    6\n*/\nlong randint(long n) {\n    return random()\
    \ % n;\n}\n/*\nReturn a random tuple of integers in [0, n) with m elements.\n\
    \    >>> randomtuple(7, 3)\n    (1, 3, 6)\n    >>> randomtuple(7, 3)\n    (2,\
    \ 4, 3)\n    >>> randomtuple(7, 3)\n    (0, 4, 6)\n*/\nTuple!(long, \"m\") randomtuple(long\
    \ n, long m) {\n    auto t = tuple(m);\n    for (auto i = 0L; i < m; i++)\n  \
    \      t[i] = randint(n);\n    return t;\n}\n/*\nReturn a random choice from a\
    \ list (see also choice() in std.random).\n    >>> randomchoice([1, 2, 3])\n \
    \   3\n    >>> randomchoice([1, 2, 3])\n    2\n    >>> randomchoice([1, 2, 3])\n\
    \    1\n*/\nauto randomchoice(List!(long) l) {\n    return l[randint(l.length)];\n\
    }\n/*\nInitialize a tuple of n random longs in [0, n).\n    >>> randomtuple(7)\n\
    \    (1, 3, 6)\n    >>> randomtuple(7)\n    (2, 4, 3)\n    >>> randomtuple(7)\n\
    \    (0, 4, 6)\n*/\nTuple!(long, \"n\") randomtuple(long n) {\n    return randomtuple(n,\
    \ n);\n}\n/*\nInitialize a tuple of n random ints in [0, n).\n    >>> randominttuple(7",
  "{\n\treturn (n == 0L) ? 1L : ((n & 1L) == 0L) ? modp(n / 2L, p) * modp(n / 2L,\
    \ p) % p : modp(n / 2L, p) * modp(n / 2L, p) * 2L % p;\n}\n/*\nReturn m^(-1) modulo\
    \ p (be aware of numerics).\n    >>> minv(0L, 101L)\n    Traceback (most recent\
    \ call last):\n    ...\n    ZeroDivisionError: modulus must be nonzero\n    >>>\
    \ minv(1L, 101L)\n    1L\n    >>> minv(5L, 101L)\n    76L\n    >>> minv(2L, 11L)\n\
    \    6L\n    >>> minv(2L, 101L)\n    51L\n    >>> minv(3L, 11L)\n    4L\n    >>>\
    \ minv(5L, 7L)\n    5L\n    >>> minv(3L, 7L)\n    5L\n    >>> minv(2L, 3L)\n \
    \   2L\n    >>> minv(2L, 2L)\n    1L\n    >>> minv(2L, 9L)\n    5L\n*/\nlong minv(long\
    \ m, long p) {\n\tif (p == 0L) {\n\t\tthrow new Error(\"modulus must be nonzero\"\
    );\n\t}\n\tbool _ = false;\n\tbool _1 = false;\n\tbool _2 = false;\n\tbool _3\
    \ = false;\n\tbool _4 = false;\n\tbool _5 = false;\n\tbool _6 = false;\n\tbool\
    \ _7 = false;\n\tbool _8 = false;\n\tbool _9 = false;\n\tbool _10 = false;\n\t\
    bool _11 = false;\n\tbool _12 = false;\n\tbool _13 = false;\n\tbool _14 = false;\n\
    \tbool _15 = false;\n\tbool _16 = false;\n\tbool _17 = false;\n\tbool _18 = false;\n\
    \tbool _19 = false;\n\tbool _20 = false;\n\tbool _21 = false;", "{\n    long r\
    \ = 1L;\n    long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n\
    \            r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b\
    \ * b) % p;\n    }\n    return r;\n}\n/*\nMiller-Rabin deterministic primality\
    \ test.\n    \n    1. n not divisible by 2 or 3.\n    2. a^d = 1 mod n or a^(2^rd)\
    \ = -1 mod n, where r is the smallest integer\n       such that 2^r divides d.\n\
    \    \nMiller (1976) Algorithm M.\n*/", "{\n    if (n == 0) \n    {\n        return\
    \ 1;\n    }\n    else \n    {\n        long x = modp(n / 2, p);\n        if (n\
    \ % 2 == 0) \n        {\n            return ((x * x) % p);\n        }\n      \
    \  else \n        {\n            return (((x * x) % p) * 2) % p;\n        }\n\
    \    }\n}", "{\n    if (n == 0)\n    {\n      return 1;\n    }\n    else\n   \
    \ {\n        long r = modp(n / 2, p);\n        if (n % 2 == 0)\n        {\n  \
    \        return (r * r) % p;\n        }\n        else\n        {\n          return\
    \ (r * r * 2) % p;\n        }\n    }\n}\n/*\nCompute the repeating part of the\
    \ decimal expansion of 1/n\n    >>> repeating(7)\n    (1, 1)\n    >>> repeating(3)\n\
    \    (3, None)\n    >>> repeating(13)\n    (1, 6)\n    >>> repeating(8)\n    (12,\
    \ None)\n    >>> repeating(1000)\n    (0, 25)\n    \n*/", "{\n    long s = 1L;\n\
    \    while (n != 0L) {\n        if (mod(n, 2L) == 1L) {\n            s = mod(s\
    \ * n, p);\n        }\n        n = div(n, 2L);\n        n = mod(n, p);\n    }\n\
    \    return s;\n}\n/*\nCompute the number of primes less than n.\n    >>> primesbelow(0L)\n\
    \    0L\n    >>> primesbelow(1L)\n    0L\n    >>> primesbelow(2L)\n    0L\n  \
    \  >>> primesbelow(3L)\n    1L\n    >>> primesbelow(4L)\n    2L\n    >>> primesbelow(100L)\n\
    \    25L\n    >>> primesbelow(10**6)\n    78498L\n    \n*/\nlong primesbelow(long\
    \ n) \n{\n    long r = 0L;\n    long i = 2L;\n    while (i < n) {\n        if\
    \ (isprime(i)) {\n            r = r + 1L;\n        }\n        i = i + 1L;\n  \
    \  }\n    return r;\n}\n/*\nReturn True if n is prime, False otherwise.\n    >>>\
    \ isprime(1L)\n    False\n    >>> isprime(2L)\n    True\n    >>> isprime(3L)\n\
    \    True\n    >>> isprime(4L)\n    False\n    >>> isprime(100L)\n    False\n\
    \    >>> isprime(101L)\n    True\n    >>> isprime(10**9+7)\n    True\n    \n*/",
  "{\n    long result = 1L;\n    while (n != 0L) {\n        if (n % 2L != 0L) {\n\
    \            result = (result * 2L) % p;\n        }\n        n /= 2L;\n    }\n\
    \    return result;\n}", "{\n    long  y = 1;\n    long  x = n;\n    while (p\
    \ > 0) {\n        if (p & 1) {\n            y = (y * x) % M;\n        }\n    \
    \    p >>= 1;\n        x = (x * x) % M;\n    }\n    return y;\n}", "{\n    auto&\
    \ n = n % p;\n    if (n < 0) n += p;\n    return n;\n}\n/*\nCalculate the inverse\
    \ of n modulo p.\n    >>> inverse(2L, 5L)\n    3L\n    >>> inverse(3L, 5L)\n \
    \   2L\n    >>> inverse(11L, 101L)\n    87L\n    >>> inverse(3L, 11L)\n    4L\n\
    \    >>> inverse(100L, 101L)\n    41L\n    >>> inverse(11L, 101L) == (11L ** (101L\
    \ - 2L)) % 101L\n    True\n*/\nlong inverse(long n, long p) \n{\n    auto n %=\
    \ p;\n    auto x = n;\n    for (auto i = 1L; i < p; i++) \n    {\n        x =\
    \ (x * n) % p;\n    }\n    return modp(x - p, p);\n}\n/*\n    \nCalculate a^n\
    \ (mod p).\n    >>> power(2L, 3L, 5L)\n    3L\n    >>> power(11L, 11L, 101L)\n\
    \    1L\n    >>> power(2L, 5L, 11L)\n    2L\n    >>> power(3L, 100L, 101L)\n \
    \   1L\n    >>> power(11L, 11L, 101L) == (11L ** 11L) % 101L\n    True\n*/\nlong\
    \ power(long a, long n, long p) \n{\n    auto& n = n % (p - 1L);\n    if (n <\
    \ 0) n += p - 1L;\n    auto x = 1L;\n    for (auto i = 0L; i < n; i++) \n    {\n\
    \        x = (x * a) % p;\n    }\n    return x;\n}\n/*\nExtended Euclid algorithm:\
    \ Return (gcd(a, b), x, y) such that gcd(a, b) = a * x + b * y.\n    >>> extended_euclid(2L,\
    \ 4L)\n    (2L, -1L, 1L)\n    >>> extended", "{\n    int x;\n    n = n % p;\n\
    \    x = n;\n    for (size_t i = 1; i < p; i ++)\n    {\n        x = (x * n) %\
    \ p;\n    }\n    return x;\n}", "{\n    long r = 1L;\n    while (n) \n    {\n\
    \        if (n % 2L) \n        {\n            r = (r * 2L) % p;\n        }\n \
    \       n /= 2L;\n    }\n    return r;\n}", "{\n\tif (p == 1) return 0;\n\tconst\
    \ long pow2_table = {1L,2L,4L,8L,16L,32L,64L,128L,256L,512L,1024L,2048L,4096L,8192L,16384L,32768L,65536L,131072L,262144L,524288L,1048576L,2097152L,4194304L,8388608L,16777216L,33554432L,67108864L,134217728L,268435456L,536870912L,1073741824L,2147483648L,4294967296L,8589934592L,17179869184L,34359738368L,68719476736L,137438953472L,274877906944L,549755813888L,1099511627776L,2199023255552L,4398046511104L,8796093022208L,17592186044416L,35184372088832L,70368744177664L,140737488355328L,281474976710656L,562949953421312L,1125899906842624L,2251799813685248L,4503599627370496L,9007199254740992L,18014398509481984L,36028797018963968L,72057594037927936L,144115188075855872L,288230376151711744L,576460752303423488L,1152921504606846976L,2305843009213693952L,4611686018427387904L,9223372036854775808L};\n\
    \tlong pow2 = pow2_table[log2(n)];\n\tlong y = 1;\n\twhile (pow2 > 0) \n\t{\n\t\
    \tpow2 /= 2;\n\t\tif (n >= pow2) \n\t\t{\n\t\t\ty = (y * y) % p;\n\t\t", "{\n\
    \    long r = 1L;\n    while (n != 0L) \n    {\n        if (n % 2L != 0L) r =\
    \ (r * p) % 101L;\n        n = n / 2L;\n        p = (p * p) % 101L;\n    }\n \
    \   return r;\n}\n/*\n    >>> invmodp(2L, 101L)\n    51L\n    >>> invmodp(51L,\
    \ 101L)\n    2L\n    >>> invmodp(13L, 101L)\n    77L\n*/\nlong invmodp(long n,\
    \ long p) \n{\n    long x = 1L;\n    long y = 0L;\n    long q = p;\n    long temp;\n\
    \    while (n != 0L) \n    {\n        long r = q % n;\n        long s = q / n;\n\
    \        temp = x;\n        x = y;\n        y = temp - y * s;\n        q = n;\n\
    \        n = r;\n    }\n    if (q == 1L) return x % p;\n    else throw new Exception(\"\
    no inverse\");\n}\n/*\n>>> encode('HELLO',13)\n'URYYB'\n*/\nenum ALPHABET = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nchar[] encode(string s, long n) \n{\n    return\
    \ s.map!(a => ALPHABET[(ALPHABET.indexOf(a) + n) % ALPHABET.length]);\n}\n/*\n\
    >>> encode('HELLO',13)\n'URYYB'\n*/\nchar[] decode(string s, long n) \n{\n   \
    \ return s.map!(a => ALPHABET[(ALPHABET.indexOf(a) - n) % ALPHABET.length]);\n\
    }\n// input: a string of length 10\n// output: its hash code\nlong hash(string\
    \ s) \n{\n    return s.sum!(a => ALPHABET.indexOf(a) * 53L) % 101L;\n}\n// input:\
    \ a string of length 10\n// output: its hash code", "{\n    if (p == 1) return\
    \ 0;\n    long r = 1;\n    while (n > 0) \n    {\n        if (n % 2 != 0) \n \
    \       {\n            r = (r * 2) % p;\n        }\n        n /= 2;\n        if\
    \ (n > 0) \n        {\n            r = (r * r) % p;\n        }\n    }\n    return\
    \ r;\n}", "{\n    return (n ? expmod(2L, n, p) : 1L);\n}", "{\n    if( n == 0\
    \ )\n        return 1;\n    long result = modp(n >> 1, p);\n    result = (result\
    \ * result) % p;\n    if( n & 1 )\n        result = (result * 2) % p;\n    return\
    \ result;\n}", "{\n\tif (n == 0) \n\t{\n\t\treturn 1;\n\t}\n\tlong result = modp(n\
    \ >> 1, p);\n\tresult = (result * result) % p;\n\tif (n & 1) \n\t{\n\t\tresult\
    \ = (result * 2) % p;\n\t}\n\treturn result;\n}\n/*\nReturn a random integer r\
    \ in [a, b] using a uniform distribution.\n    >>> random()  # Random float\n\
    \    0.37444887175646646\n    >>> import random; random.seed(1); random()\n  \
    \  0.8444218515250481\n    >>> randomint(10)\n    8\n    >>> randomint(3, 6)\n\
    \    4\n    >>> import random; random.seed(1); randomint(3, 6)\n    3\n*/\nlong\
    \ randomint(long a, long b) \n{\n\tif (a < b) \n\t{\n\t\treturn b-a + randomint(0,\
    \ b-a);\n\t}\n\treturn a;\n}\n/*\nReturn a random integer r in [0, n-1] using\
    \ a uniform distribution.\n    >>> randomint(10)\n    8\n    >>> import random;\
    \ random.seed(1); randomint(10)\n    8\n*/\nlong randomint(long n) \n{\n\treturn\
    \ randomint(0, n-1);\n}\n/*\nReturn true with probability p, and false with probability\
    \ 1-p.\n    >>> randomfloat()  # Random float\n    0.37444887175646646\n    >>>\
    \ import random; random.seed(1); randomfloat()\n    0.8444218515250481\n    >>>\
    \ randombool(0.7)\n    True\n    >>> randombool(0.4)\n    False\n    >>> import\
    \ random; random.seed(1); randombool(0.4)\n    False\n*/", "{\n    if (n < 0)\
    \ \n    {\n        return modp(-n, p);\n    }\n    long result = 1L;\n    for\
    \ (int i = 0; i < n; i++) \n    {\n        result = result * 2L % p;\n    }\n\
    \    return result;\n}", "{\n    long result = 1L;\n    while (n > 0L) {\n   \
    \     if (n & 1L != 0L) {\n            result = (result * pow(2L, n)) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nDivide big integers,\
    \ with integer rounding.\n    >>> div_int(10L, 3L)\n    3L\n    >>> div_int(9L,\
    \ 3L)\n    3L\n    >>> div_int(10L, -3L)\n    -3L\n    >>> div_int(-10L, 3L)\n\
    \    -3L\n    >>> div_int(-10L, -3L)\n    3L\n    >>> div_int(3L, 10L)\n    0L\n\
    \    >>> div_int(5L, 2L)\n    2L\n    >>> div_int(5L, -2L)\n    -2L\n    >>> div_int(-5L,\
    \ 2L)\n    -2L\n    >>> div_int(-5L, -2L)\n    2L\n    >>> div_int(9L, 4L)\n \
    \   2L\n    >>> div_int(9L, -4L)\n    -2L\n    >>> div_int(-9L, 4L)\n    -2L\n\
    \    >>> div_int(-9L, -4L)\n    2L\n    >>> div_int(10L, 4L)\n    2L\n    >>>\
    \ div_int(10L, -4L)\n    -2L\n    >>> div_int(-10L, 4L)\n    -2L\n    >>> div_int(-10L,\
    \ -4L)\n    2L\n    >>> div_int(11L, 4L)\n    2L\n    >>> div_int(11L, -4L)\n\
    \    -3L\n    >>> div_int(-11L, 4L)\n    -3L\n    >>> div_int(-11L, -4L)\n   \
    \ 2L\n    >>> div_int(12L, 4L)\n    3L\n    >>> div_int(12L, -4L)\n    -3", "{\n\
    \    long r = 1L;\n    foreach (immutable i; 0 .. n) \n    {\n        r = (r *\
    \ 2L) % p;\n    }\n    return r;\n}\n/*\nReturn the prime factors of n together\
    \ with their exponent.\n    >>> primeFactors(2L * 3L**2 * 5L * 7L**3)\n    [Tuple!(long,\
    \ long)(2L, 1L), Tuple!(long, long)(3L, 2L), Tuple!(long, long)(5L, 1L), Tuple!(long,\
    \ long)(7L, 3L)]\n*/\nlong[][2] primeFactors(long n) \n{\n    long[][2] result;\n\
    \    for (immutable p = 2L; p * p <= n; p++) \n    {\n        immutable e = 0L;\n\
    \        while (n % p == 0L) \n        {\n            n /= p;\n            e++;\n\
    \        }\n        if (e > 0L) \n        {\n            result ~= [p, e];\n \
    \       }\n    }\n    if (n > 1L) \n    {\n        result ~= [n, 1L];\n    }\n\
    \    return result;\n}\n/*\nFind the smallest number of the form 2^i * 3^j * 5^k\
    \ * 7^l that is >= n.\n    >>> findNextRepunit(1L)\n    2L\n    >>> findNextRepunit(100L)\n\
    \    128L\n    >>> findNextRepunit(12093L)\n    12093L\n    >>> findNextRepunit(12094L)\n\
    \    13056L\n*/\nlong findNextRepunit(long n) \n{\n    while (true) \n    {\n\
    \        if (n % 2L == 0L) \n        {\n            n /= 2L;\n        }\n    \
    \    else if (n % 3L == 0L) \n        {\n            n /= 3L;\n        }\n   \
    \     else if (n % 5L == 0L) \n        {\n            n /= 5L;\n        }\n  \
    \      else if (n % 7L == 0", "{\n    long x = n;\n    while (n>0) {\n       \
    \ if (n%2==1)\n            x = (x*x)%p;\n        n = n/2;\n        x = (x*x)%p;\n\
    \    }\n    return x;\n}\n/*\nCompute the number of ints m such that m=p1^e1*p2^e2*...*pk^ek,\n\
    where p1, p2, ..., pk are prime numbers and e1, e2, ..., ek are integers >= 0.\n\
    \    >>> Nint(1L, 2L, 5L)\n    5L\n    >>> Nint(1L, 2L, 7L)\n    6L\n    >>> Nint(1L,\
    \ 2L, 5L, 7L)\n    5L\n    >>> Nint(1L, 2L, 5L, 8L)\n    0L\n    >>> Nint(1L,\
    \ 2L, 5L, 20L)\n    3L\n    >>> Nint(1L, 2L, 5L, 25L)\n    1L\n    >>> Nint(1L,\
    \ 2L, 5L, 125L)\n    0L\n    >>> Nint(1L, 2L, 5L, 10L)\n    2L\n    >>> Nint(1L,\
    \ 2L, 5L, 11L)\n    0L\n    >>> Nint(1L, 2L, 3L, 11L)\n    2L\n    >>> Nint(1L,\
    \ 2L, 5L, 13L)\n    0L\n    >>> Nint(1L, 2L, 7L, 13L)\n    2L\n    >>> Nint(1L,\
    \ 2L, 5L, 14L)\n    1L\n    >>> Nint(1L, 2L, 7L, 14L)\n    1L\n    >>> Nint(1L,\
    \ 2L, 5L, 15L)\n    0L\n    >>> Nint(1L, 2L, 3L, 15L)\n    2L\n    >>> Nint(1L,\
    \ 2L, 5L, 16L)\n    0L\n    >>> Nint(1L,", "{\n    auto i = 0L;\n    auto ans\
    \ = 1L;\n    assert (n >= 0L);\n    while (i < n) {\n        ans = (ans * 2L)\
    \ % p;\n        i = i + 1L;\n    }\n    return ans;\n}\n/*\nReturn k^n modulo\
    \ p (be aware of numerics).\n    >>> modp(4L, 3L, 2L)\n    0L\n    >>> modp(4L,\
    \ 3L, 3L)\n    1L\n    >>> modp(4L, 3L, 5L)\n    4L\n    >>> modp(4L, 3L, 11L)\n\
    \    4L\n    >>> modp(4L, 3L, 13L)\n    1L\n    >>> modp(4L, 3L, 15L)\n    1L\n\
    \    >>> modp(4L, 3L, 31L)\n    1L\n    >>> modp(4L, 3L, 41L)\n    4L\n    >>>\
    \ modp(4L, 3L, 101L)\n    4L\n    >>> modp(4L, 3L, 1009L)\n    4L\n*/\nlong modp(long\
    \ k, long n, long p) \n{\n    auto i = 0L;\n    auto ans = 1L;\n    assert (n\
    \ >= 0L);\n    while (i < n) {\n        ans = (ans * k) % p;\n        i = i +\
    \ 1L;\n    }\n    return ans;\n}", "{\n    int c = 0;\n    size_t r = 1;\n   \
    \ for (; c < n; c++) \n    {\n        r = mulmod(r, 2, p);\n    }\n    return\
    \ r;\n}", "{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n   \
    \ {\n        return (modp(n >> 1, p) * modp(n >> 1, p) * modp(n & 1, p)) % p;\n\
    \    }\n}\n/*\nAddition and multiplication modulo p (be aware of numerics).\n\
    \    >>> a, b = 3L, 5L\n    >>> modp_add(a, b, 7L)\n    2L\n    >>> modp_mult(a,\
    \ b, 7L)\n    1L\n*/\nlong modp_add(long a, long b, long p) \n{\n    return (a\
    \ + b) % p;\n}\nlong modp_mult(long a, long b, long p) \n{\n    return (a * b)\
    \ % p;\n}\n/*\nTrue if n is a prime number.\n    >>> is_prime(2L)\n    True\n\
    \    >>> is_prime(3L)\n    True\n    >>> is_prime(4L)\n    False\n    >>> is_prime(5L)\n\
    \    True\n    >>> is_prime(6L)\n    False\n    >>> is_prime(7L)\n    True\n \
    \   >>> is_prime(8L)\n    False\n    >>> is_prime(9L)\n    False\n    >>> is_prime(10L)\n\
    \    False\n    >>> is_prime(11L)\n    True\n    >>> is_prime(12L)\n    False\n\
    \    >>> is_prime(2L ** 59 - 1)\n    True\n    >>> is_prime(2L ** 61 - 1)\n  \
    \  True\n    >>> is_prime(2L ** 62 - 1)\n    False\n*/", "{\n    if (n == 0) \n\
    \    {\n        return 1;\n    }\n    else \n    {\n        long r;\n        if\
    \ (n % 2 == 0) \n        {\n            long t = modp(n / 2, p);\n           \
    \ r = (t * t) % p;\n        }\n        else \n        {\n            long t =\
    \ modp(n - 1, p);\n            r = (2 * t) % p;\n        }\n        return r;\n\
    \    }\n}\n/*\nFibonacci numbers.\n    >>> f = fibonacci()\n    >>> for n in xrange(1,\
    \ 10):\n    ...     print n, f.next()\n    1 1\n    2 1\n    3 2\n    4 3\n  \
    \  5 5\n    6 8\n    7 13\n    8 21\n    9 34\n*/\nstruct fibonacci \n{\n    long\
    \ n;\n    long v;\n    fibonacci() \n    {\n        n = 0;\n        v = 0;\n \
    \   }\n    long next() \n    {\n        n += 1;\n        if (n <= 2) \n      \
    \  {\n            v = 1;\n        }\n        else \n        {\n            long\
    \ t = v;\n            v += v;\n            v -= t;\n        }\n        return\
    \ v;\n    }\n}\n/*\nPrimes.\n    >>> f = primes()\n    >>> for n in xrange(1,\
    \ 10):\n    ...     print n, f.next()\n    1 2\n    2 3\n    3 5\n    4 7\n  \
    \  5 11\n    6 13\n    7 17\n    8 19\n    9 23\n*/\nstruct primes \n{\n    long\
    \ n;\n    long v;\n    primes() \n    {\n        n = 0;\n        v = 1;\n    }\n\
    \    long next() \n    {\n        n += 1;\n        if (n == 1) \n        {\n \
    \           v = 2;\n        }\n        else \n        {\n            bool found\
    \ = false;\n            long i = v + 1;\n            while (!found) \n       \
    \     {\n                if (is", "{\n    tuple!(long, long)(powres, p) = powmod(2L,\
    \ n, p);\n    return powres[1];\n}", "{\n    if(n == 0)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        long r;\n        long[2] qr = divmod(n,\
    \ 2);\n        r = qr[1];\n        long a = qr[0];\n        long sq = modp(a,\
    \ p);\n        long res = sq * sq;\n        if(r == 1)\n        {\n          \
    \  res = res * 2;\n        }\n        res = res % p;\n        return res;\n  \
    \  }\n}", "{\n    long r = 1L;\n    long a = 2L;\n    while (n > 0L) \n    {\n\
    \        if (n % 2L == 1L) \n        {\n            r = (r * a) % p;\n       \
    \ }\n        a = (a * a) % p;\n        n /= 2L;\n    }\n    return r;\n}\n/*\n\
    Solve ax == b (mod p) for x (if possible).\n    \n    >>> modinv(1L, 3L, 5L)\n\
    \    3L\n    >>> modinv(2L, 3L, 5L)\n    2L\n    >>> modinv(3L, 3L, 5L)\n    1L\n\
    \    >>> modinv(4L, 3L, 5L)\n    4L\n    >>> modinv(6L, 3L, 5L)\n    1L\n    \n\
    */\nlong modinv(long a, long b, long p) \n{\n    tuple!(long, long, long) gcd\
    \ = gcdExtended(a, p);\n    long x = gcd[1L];\n    if (b % gcd[0L] != 0L) \n \
    \   {\n        return -1L;\n    }\n    return (x * (b / gcd[0L])) % p;\n}\n/*\n\
    Return a tuple of gcd and x and y, where ax + by = gcd(a, b).\n    >>> gcdExtended(5L,\
    \ 7L)\n    (1L, -2L, 3L)\n    >>> gcdExtended(11L, 9L)\n    (1L, 2L, -1L)\n  \
    \  \n*/\ntuple!(long, long, long) gcdExtended(long a, long b) \n{\n    if (a ==\
    \ 0L) \n    {\n        return tuple(b, 0L, 1L);\n    }\n    else \n    {\n   \
    \     auto result = gcdExtended(b % a, a);\n        return tuple(result[0L], result[2L]\
    \ - (b / a) * result[1L], result[1L]);\n    }\n}\n", "{\n    if (n == 0)\n   \
    \     return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if (n\
    \ & 1)\n        r = (r * 2) % p;\n    return r;\n}", "{\n    if (n == 0) \n  \
    \  {\n        return 1;\n    }\n    auto x = modp(n ~/ 2, p);\n    if (n % 2 ==\
    \ 0) \n    {\n        return (x * x) % p;\n    }\n    else \n    {\n        return\
    \ (x * x * 2) % p;\n    }\n}", "{\n    ulong result = 1L;\n    ulong exp = (ulong)n;\n\
    \    ulong base = 2L;\n    ulong mod = (ulong)p;\n    while (exp != 0L) \n   \
    \ {\n        if ((exp & 1L) != 0L) \n        {\n            result = (result *\
    \ base) % mod;\n        }\n        exp >>= 1L;\n        base = (base * base) %\
    \ mod;\n    }\n    return (long)result;\n}", '    return modp(n, p, 0);', "{\n\
    \    long res = 1L;\n    long k = 1L;\n    while (k <= n) {\n        k <<= 1L;\n\
    \    }\n    while (k >= 1L) {\n        k >>= 1L;\n        res = (res * res) %\
    \ p;\n        if (n & k) {\n            res = (res * 2) % p;\n        }\n    }\n\
    \    return res;\n}", "{\n    alias BigInteger = std.bigint.BigInteger;\n    immutable\
    \ BigInteger bigp = BigInteger(p);\n    if (n == 0) \n    {\n        return 1;\n\
    \    }\n    else \n    {\n        return BigInteger(2).pow(n) % bigp;\n    }\n\
    }", "{\n    d_switch(n)\n    {\n        d_case(>= 0) \n        {\n           \
    \ d_break;\n        }\n        d_case(< 0) \n        {\n            d_break;\n\
    \        }\n    }\n    long x = 1L;\n    while (n > 0) \n    {\n        if (n\
    \ & 1) \n        {\n            x = (x * 2) % p;\n        }\n        n >>= 1;\n\
    \    }\n    return x;\n}\n/*\nReturn (a * b) modulo p (be aware of numerics).\n\
    \    >>> modp(10L, 20L, 101L)\n    11L\n    >>> modp(1101L, 101L, 101L)\n    3L\n\
    \    >>> modp(100L, 101L, 101L)\n    0L\n*/\nlong modp(long a, long b, long p)\
    \ \n{\n    a %= p;\n    b %= p;\n    long x = 0L;\n    while (b > 0) \n    {\n\
    \        if (b & 1) \n        {\n            x = (x + a) % p;\n        }\n   \
    \     a = (a * 2) % p;\n        b >>= 1;\n    }\n    return x;\n}\n/*\nReturn\
    \ the greatest common divisor of a and b.\n    >>> gcd(10L, 20L)\n    10L\n  \
    \  >>> gcd(20L, 10L)\n    10L\n    >>> gcd(10L, 10L)\n    10L\n    >>> gcd(1L,\
    \ 1L)\n    1L\n    >>> gcd(0L, 0L)\n    0L\n    >>> gcd(10L, 0L)\n    10L\n  \
    \  >>> gcd(0L, 10L)\n    10L\n*/\nlong gcd(long a, long b) \n{\n    while (b >\
    \ 0) \n    {\n        long c = a % b;\n        a = b;\n        b = c;\n    }\n\
    \    return a;\n}\n/*\nReturn the least common multiple of a and b.\n   "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
