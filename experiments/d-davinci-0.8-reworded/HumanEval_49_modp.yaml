name: HumanEval_49_modp
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n\
  \    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
  \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n"
tests: "unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
  \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
  \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
  \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
  \ == 3L);\n}\nvoid main(){}"
completions: ["in\n{\n  assert(p > 0);\n  assert(n >= 0);\n}\nbody\n{\n  alias P =\
    \ tuple(long, long);\n  alias T = tuple(P, long);\n  long N = n;\n  assert(N >=\
    \ 0);\n  T t = tuple(tuple(1L, 0L), p);\n  if(N == 0)\n  {\n    return 1L;\n \
    \ }\n  while(N != 1)\n  {\n    if(N & 1)\n    {\n      t = tuple(tuple(get!1(t)[0]\
    \ * get!0(t)[0] + get!1(t)[1] * get!0(t)[1], \n                      get!1(t)[0]\
    \ * get!0(t)[1] + get!1(t)[1] * get!0(t)[0]), \n                get!1(t)[1] *\
    \ get!1(t)[1] - 2L * get!1(t)[0] * get!1(t)[1] + get!1(t)[0] * get!1(t)[0]);\n\
    \    }\n    else\n    {\n      t = tuple(tuple(get!0(t)[0] * get!0(t)[0] + get!1(t)[1]\
    \ * get!0(t)[1], \n                      get!0(t)[0] * get!0(t)[1] + get!1(t)[1]\
    \ * get!0(t)[0]), \n                get!1(t)[1] * get!1(t)[1] - 2L * get!1(t)[0]\
    \ * get!1(t)[1] + get!1(t)[0] * get!1(t)[0]);\n    }\n    N >>= 1;\n  }\n  long\
    \ result = (get!0(t)[0] + get!1(t)[1]) % p;\n  assert(result > 0);\n  return result;\n\
    }\n/*\nReturn a random integer from [0, n).\n*/\nlong random(long n) \nin\n{\n\
    \  assert(n > 0);\n}\nbody\n{\n  import", "{\n  if(n == 0)\n    return 1;\n  /*\n\
    \  return  (modp(n/2, p) ** 2) % p if n % 2 == 0 \n  else  (modp(n/2, p) ** 2\
    \ * a) % p\n  */\n  if(n % 2 == 0)\n    return  pow(modp(n/2, p), 2) % p;\n  else\n\
    \    return  (pow(modp(n/2, p), 2) * n) % p;\n}", "    if (n<p)\n    {\n    return\
    \ n;\n    }\n    else\n    {\n    long m;\n    long q;\n    q = n/p;\n    m =\
    \ n-q*p;\n    return m;\n    }\n    \n    \n/* Return True iff n is prime.\n \
    \   >>> isprime(11L)\n    True\n    >>> isprime(111L)\n    False\n    >>> isprime(17L)\n\
    \    True\n    >>> isprime(2L)\n    True\n    >>> isprime(199L)\n    True\n  \
    \  >>> isprime(200L)\n    False\n*/", "{\n    if (n == 0) \n    {\n        return\
    \ 1;\n    }\n    /*\n        p(a+b) == (pa+pb) mod m\n        *2 == *2 mod m\n\
    \        *2 == (+0+*2) mod m\n        *2 == (+(p*1)+*2) mod m\n    */\n    return\
    \ ((p * modp(n / 2, p)) + modp(n % 2, p)) % p;\n}\n/*\n  Find a generator for\
    \ the multiplicative group of integers modulo p, where p is prime. \n  Such a\
    \ generator is called a primitive root modulo p. Returns None if no primitive\
    \ root \n  exists (i.e., if p is a prime power).\n  >>> find_generator(11L)\n\
    \  10L\n  >>> find_generator(7L)\n  3L\n  >>> find_generator(9L)\n*/\nlong find_generator(long\
    \ p) \n{\n    long g;\n    long n = p - 1;\n    if (p == 2) \n    {\n        return\
    \ 1;\n    }\n    // find the maximum power of 2 dividing n\n    long q = 1;\n\
    \    while (n % 2 == 0) \n    {\n        n /= 2;\n        q += 1;\n    }\n   \
    \ // we're only interested in multiplicative orders that are 1 modulo 2\n    n\
    \ = n * (pow(2, q - 1) - 1);\n    for (g = 2; g < p; g += 1) \n    {\n       \
    \ // check if g is a generator\n        // if g^{2^i} != 1 mod p for 0 <= i <\
    \ q, then g is a generator\n        if (all!((x) => (modp(g, p) != modp(1, p)),\
    \ iota(q))) \n        {\n            return g;\n        }\n    }\n    return 0;\n\
    }\n// Compute a^b mod m.\n// Note: modp is faster, but is limited to 64-bit integers.\n\
    long modexp(long a, long b, long m) \n{\n    if (a == 0) \n    {\n", "{\n    const\
    \ long TWO = 2L;\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    Tuple!(long,\
    \ long) qr = divmod(n, TWO);\n    long a = modp(qr[0], p);\n    long m = a * a\
    \ % p;\n    if (qr[1] == 1L) \n    {\n        m = (m * TWO) % p;\n    }\n    return\
    \ m;\n}\n/*\nGenerate the n-th prime.  Note that n=1 returns 2.\n    >>> primes(1)\n\
    \    2L\n    >>> primes(2)\n    3L\n    >>> primes(3)\n    5L\n    >>> primes(4)\n\
    \    7L\n    >>> primes(10)\n    29L\n    >>> primes(11)\n    31L\n    \n*/\n\
    long primes(long n) \n{\n    long p = 2L;\n    long i = 1L;\n    while (i < n)\
    \ \n    {\n        p += 1L;\n        if (isprime(p)) \n        {\n           \
    \ i += 1L;\n        }\n    }\n    return p;\n}\n/*\nReturn true if p is prime,\
    \ false otherwise.\n    >>> isprime(2L)\n    true\n    >>> isprime(3L)\n    true\n\
    \    >>> isprime(4L)\n    false\n    >>> isprime(5L)\n    true\n    >>> isprime(6L)\n\
    \    false\n    >>> isprime(7L)\n    true\n    >>> isprime(8L)\n    false\n  \
    \  >>> isprime(9L)\n    false\n    >>> isprime(10L)\n    false\n    >>> isprime(11L)\n\
    \    true\n    >>> isprime(12L)\n    false\n    >>> isprime(13L)\n    true\n \
    \   >>> isprime(15L)\n    false\n    >>> isprime(17L)\n    true\n    >>> isprime(2147483647L)\n\
    \    true\n    >>> isprime(18446744073709551557L)\n    true\n   ", "{\n    auto[exponent,\
    \ base] = split(n);\n    long result = 1L;\n    for (long i = 0L; i < exponent;\
    \ i++) \n    {\n        result = result * base % p;\n    }\n    return result;\n\
    }", "{\n    if(n == 0L) \n    {\n        return 1L;\n    }\n    else if(n == 1L)\
    \ \n    {\n        return 2L % p;\n    }\n    else \n    {\n        long k = n\
    \ / 2L;\n        return pow(modp(k, p), 2L) % p;\n    }\n}\n/*\n    >>> powmodp(7L,\
    \ 4L, 97L)\n    63L\n    >>> powmodp(17L, 4L, 97L)\n    17L\n    >>> powmodp(8L,\
    \ 1L, 97L)\n    8L\n    >>> powmodp(8L, 0L, 97L)\n    1L\n    >>> powmodp(8L,\
    \ -1L, 97L)\n    73L\n    >>> powmodp(8L, -2L, 97L)\n    48L\n*/\nlong powmodp(long\
    \ a, long n, long p) \n{\n    if(n == 0L) \n    {\n        return 1L;\n    }\n\
    \    else if(n > 0L) \n    {\n        long k = n / 2L;\n        return pow(powmodp(a,\
    \ k, p), 2L) % p;\n    }\n    else \n    {\n        return powmodp(powmodp(a,\
    \ -1L, p), -n, p);\n    }\n}\n/*\n    >>> truediv(2L, 3L)\n    '2/3'\n    >>>\
    \ truediv(21L, -21L)\n    '-1/1'\n    >>> truediv(11L, 7L)\n    '11/7'\n    >>>\
    \ truediv(8L, 6L)\n    '4/3'\n    >>> truediv(3L, 15L)\n    '1/5'\n    >>> truediv(6L,\
    \ 15L)\n    '2/5'\n    >>> truediv(6L, 30L)\n    '1/5'\n    >>> truediv(6L, 60L)\n\
    \    '1/10'\n    >>> truediv(", "{\n    auto r = 1L;\n    auto b = to!int(n) %\
    \ p;\n    if(b < 0)\n        b += p;\n    foreach(i; 0 .. bits!long)\n    {\n\
    \        if(b & (1L << i))\n            r = (r * 2L) % p;\n    }\n    return r;\n\
    }\n/*\nReturn the n-th Fibonacci number modulo p.\n    >>> fibp(8L, 7L)\n    6L\n\
    \    >>> fibp(8L, 101L)\n    44L\n    >>> fibp(8L, 100L)\n    44L\n    >>> fibp(8L,\
    \ 11L)\n    9L\n    >>> fibp(8L, 29L)\n    20L\n    >>> fibp(8L, 31L)\n    4L\n\
    */\nlong fibp(long n, long p) \n{\n    return (modp(n, p) * (1L + modp(n, p)))\
    \ % p;\n}\n/*\nReturn k, such that (n ** k) % p == 1.\n    >>> multiplicative_order(3L,\
    \ 7L)\n    6L\n    >>> multiplicative_order(3L, 101L)\n    100L\n    >>> multiplicative_order(3L,\
    \ 11L)\n    10L\n    >>> multiplicative_order(3L, 29L)\n    28L\n    >>> multiplicative_order(100L,\
    \ 101L)\n    50L\n*/\nlong multiplicative_order(long n, long p) \n{\n    auto\
    \ k = 1L;\n    auto b = n % p;\n    if(b < 0)\n        b += p;\n    foreach(i;\
    \ 0 .. bits!long)\n    {\n        if(b & (1L << i))\n            k = k * 2L;\n\
    \    }\n    return k;\n}\n/*\nReturn the number of distinct prime factors.\n \
    \   >>> distinct_prime_factors(1L)\n    0L\n    >>> distinct_prime_factors(2L)\n\
    \    1L\n    >>> distinct_prime_factors(3L)\n    1L\n", "{\n    if (n == 0)\n\
    \    {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return\
    \ 2;\n    }\n    else if (n % 2 == 0)\n    {\n        return modp(n / 2, p) *\
    \ modp(n / 2, p) % p;\n    }\n    else\n    {\n        return modp(n / 2, p) *\
    \ modp(n / 2, p) * 2 % p;\n    }\n}\n/*\nTest if n is probably prime.\n    >>>\
    \ is_probable_prime(7L)\n    True\n    >>> is_probable_prime(10000000000000000039L)\n\
    \    True\n    >>> is_probable_prime(9999999999999999991L)\n    False\n    >>>\
    \ is_probable_prime(10000000000000000007L)\n    True\n    >>> is_probable_prime(85L)\n\
    \    False\n*/", "{\n\tlong a = 1L;\n\twhile (n != 0L) {\n\t\twhile ((n % 2L)\
    \ == 0L) {\n\t\t\tn /= 2L;\n\t\t\tlong b = p % 8L;\n\t\t\tif (b == 3L || b ==\
    \ 5L)\n\t\t\t\tp = -p;\n\t\t}\n\t\tn -= 1L;\n\t\tif (p < 0L)\n\t\t\ta = -a;\n\t\
    \ta = (a * n) % p;\n\t}\n\tif (p == 1L)\n\t\treturn 0L;\n\tif (a < 0L)\n\t\ta\
    \ += p;\n\treturn a;\n}\n// \nlong poly_horner(inout(long[]) A, long x) {\n\t\
    long n = A.length;\n\tlong s = A[n - 1];\n\tlong i = n - 2;\n\twhile (i >= 0)\
    \ {\n\t\ts = s * x + A[i];\n\t\ti -= 1;\n\t}\n\treturn s;\n}\n// ", "{\n    if\
    \ (p == 1) \n    {\n        return 0;\n    }\n    return powmod(2L, n, p);\n}",
  "{\n\tif (n == 0) return 1;\n\tlong c = 1L;\n\tlong e = p - 2L;\n\twhile (e > 0)\
    \ \n\t{\n\t\tif (e & 1) c = (c * n) % p;\n\t\tn = (n * n) % p;\n\t\te = e >> 1;\n\
    \t}\n\treturn c;\n}", "{\n    long ans = 1L;\n    long a = 2L;\n    while (n >\
    \ 0L) {\n        if (n % 2L == 1L) {\n            ans = (ans * a) % p;\n     \
    \   }\n        a = (a * a) % p;\n        n /= 2L;\n    }\n    return ans;\n}",
  "{\n    ulong r = 1;\n    for (int i = 0; i < n; i++)\n        r = r * 2 % p;\n\
    \    return r;\n}\n/*\nReturn the number of bits required to express n (be aware\
    \ of numerics).\n    >>> bits_required(0L)\n    0\n    >>> bits_required(1L)\n\
    \    1\n    >>> bits_required(2L)\n    2\n    >>> bits_required(3L)\n    2\n \
    \   >>> bits_required(4L)\n    3\n    >>> bits_required(5L)\n    3\n*/", "{\n\
    \  if (n < 0) {\n    return modp(-n, p);\n  }\n  else if (n == 0) {\n    return\
    \ 1;\n  }\n  else if (n == 1) {\n    return 0;\n  }\n  else if (n % 2 == 0) {\n\
    \    long m = modp(n / 2, p);\n    return (m + m) % p;\n  }\n  else {\n    return\
    \ (modp(n - 1, p) + p - 1) % p;\n  }\n}\n/*\nA power of 2.\n    >>> ispow2(0)\n\
    \    True\n    >>> ispow2(1)\n    True\n    >>> ispow2(2)\n    True\n    >>> ispow2(3)\n\
    \    False\n    >>> ispow2(4)\n    True\n    >>> ispow2(0x1000000000000000L)\n\
    \    True\n    >>> ispow2(0x1000000000000001L)\n    False\n*/", "    @safe pure\
    \ nothrow\n{\n    /*\n        if p == 1 or n == 0, return 0\n        if p == 2,\
    \ return (n % 2 == 0) ? 0 : 1\n        if p == -1, return (n % 2 == 0) ? 1 : -1\n\
    \    */\n    import std.bitmanip;\n    if (p == 1 || n == 0)\n        return 0;\n\
    \    if (p == 2)\n        return (n % 2 == 0) ? 0 : 1;\n    if (p == -1)\n   \
    \     return (n % 2 == 0) ? 1 : -1;\n    return powmod(2, n, p);\n}", "{\n   \
    \ if (n == 0) \n    {\n        return 1;\n    }\n    else \n    {\n        long\
    \ c = modp(n >> 1, p);\n        if (n & 1) \n        {\n            return (c\
    \ * c * 2) % p;\n        }\n        else \n        {\n            return (c *\
    \ c) % p;\n        }\n    }\n}", "{\n    long res = 1L;\n    foreach (i; 0 ..\
    \ n)\n    {\n        res = (res * 2L) % p;\n    }\n    return res;\n}\n/*\nReturn\
    \ n*2^-1 modulo p (be aware of numerics).\n*/\nlong modpinv(long n, long p) \n\
    {\n    long res = 1L;\n    foreach (i; 0 .. n)\n    {\n        res = (res * 2L)\
    \ % p;\n    }\n    return (res * n) % p;\n}", "{\n\tif (n == 0) return 1;\n\t\
    long pow = modp(n / 2, p);\n\tpow = pow * pow % p;\n\tif (n % 2) pow = pow * 2\
    \ % p;\n\treturn pow;\n}", "{\n    if (n < 1) \n    {\n        return 1;\n   \
    \ }\n    if (n == 1) \n    {\n        return 2;\n    }\n    if (n % 2 == 0) \n\
    \    {\n        long x = modp(n / 2, p);\n        return (x * x) % p;\n    }\n\
    \    else \n    {\n        return (2 * modp(n - 1, p)) % p;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
