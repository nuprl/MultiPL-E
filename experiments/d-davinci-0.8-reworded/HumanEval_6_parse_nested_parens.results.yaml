language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto result\
    \ = new long[](0);\n\tforeach(paren_string_group; paren_string.split(\" \"))\n\
    \t{\n\t\t//Stack to keep track of the level of nested parentheses\n\t\tauto depth_stack\
    \ = new Stack!long();\n\t\tlong depth = 0;\n\t\tlong max_depth = 0;\n\t\t//Iterate\
    \ through each of the character in the string,\n\t\t//get the depth and then pop\
    \ the stack.\n\t\t//Keep doing that until the end of the string.\n\t\tforeach(paren;\
    \ paren_string_group)\n\t\t{\n\t\t\tif(paren == '(')\n\t\t\t{\n\t\t\t\tdepth +=\
    \ 1;\n\t\t\t\tdepth_stack.push(depth);\n\t\t\t}\n\t\t\telse if(paren == ')')\n\
    \t\t\t{\n\t\t\t\tdepth = depth_stack.pop;\n\t\t\t}\n\t\t\t//Get the maximum value\
    \ of the depth\n\t\t\tmax_depth = max(max_depth, depth);\n\t\t}\n\t\tresult ~=\
    \ max_depth;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5c9y6h7c.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5c9y6h7c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // tokenize\n\
    \    string[] tokens = split(paren_string, ' ');\n    // container for the result\n\
    \    long[] counter = new long[tokens.length];\n    // iterate over each token\n\
    \    foreach (i, token; tokens) \n    {\n        // calculate the depth of nesting\n\
    \        int depth = 0;\n        int maxDepth = 0;\n        foreach (c; token)\
    \ \n        {\n            switch (c) \n            {\n                case '(':\n\
    \                    depth++;\n                    maxDepth = max(maxDepth, depth);\n\
    \                    break;\n                case ')':\n                    depth--;\n\
    \                    break;\n            }\n        }\n        counter[i] = maxDepth;\n\
    \    }\n    return counter;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqix_wsc4.d(15): Error: undefined identifier `split`

    /tmp/tmpqix_wsc4.d(30): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqix_wsc4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Tokenize\
    \ the input string using space as the delimiter\n    string[] tokens = paren_string.split(\"\
    \ \");\n    long[] results = new long[tokens.length];\n    foreach (i, token;\
    \ tokens) \n    {\n        import std.range;\n        auto r = filter!(a => a\
    \ == '(' || a == ')')(token);\n        import std.algorithm.comparison : max;\n\
    \        results[i] = max(count_parens(r), 0L);\n    }\n    return results;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h_kbfqr.d(15): Error: no property `split` for type `string`

    /tmp/tmp6h_kbfqr.d(20): Error: template instance `filter!((a) => a == ''('' ||
    a == '')'')` template `filter` is not defined

    /tmp/tmp6h_kbfqr.d(22): Error: undefined identifier `count_parens`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h_kbfqr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting_level;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphfv2zagh.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphfv2zagh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ input_list = split(paren_string, \" \");\n    long[] output_list;\n    long\
    \ deep = 0L;\n    foreach(paren_group; input_list) \n    {\n        foreach(symbol;\
    \ paren_group) \n        {\n            if(symbol == '(') \n            {\n  \
    \              deep += 1L;\n            } \n            else if(symbol == ')')\
    \ \n            {\n                deep -= 1L;\n            }\n        }\n   \
    \     output_list ~= deep;\n        deep = 0L;\n    }\n    return output_list;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7lh0__8.d(14): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7lh0__8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ token_stream = paren_string.split(\" \");\n    auto paren_groups = token_stream.map!(g\
    \ => g.strip);\n    return paren_groups.map!(\n        (group) => \n        {\n\
    \            long count = 0;\n            long last_max = 0;\n            foreach(paren;\
    \ group)\n            {\n                if(paren == '(')\n                {\n\
    \                    count++;\n                }\n                else if(paren\
    \ == ')')\n                {\n                    count--;\n                }\n\
    \                last_max = max(last_max, count);\n            }\n           \
    \ return last_max;\n        }).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36j6_xcb.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36j6_xcb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n    in \n \
    \   {\n        assert(paren_string != null);\n    }\n    body\n    {\n       \
    \ bool[] paren_stack = new bool[](paren_string.length);\n        long[] ans =\
    \ new long[](paren_string.length / 2);\n        int curr_index = 0;\n        int\
    \ curr_ans_index = 0;\n        foreach (char c; paren_string)\n        {\n   \
    \         if (c == '(')\n            {\n                paren_stack[curr_index]\
    \ = true;\n                curr_index++;\n            }\n            else if (c\
    \ == ')')\n            {\n                if (curr_index > 0)\n              \
    \  {\n                    curr_index--;\n                    paren_stack[curr_index]\
    \ = false;\n                }\n                else\n                {\n     \
    \               curr_ans_index++;\n                }\n            }\n        \
    \    else if (c == ' ')\n            {\n                ans[curr_ans_index] =\
    \ curr_index;\n                curr_index = 0;\n            }\n        }\n   \
    \     ans[curr_ans_index] = curr_index;\n        return ans[0..curr_ans_index\
    \ + 1];\n    }\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2dlotm7u.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2dlotm7u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int accum = 0;\n    foreach(j; 0 .. paren_string.length)\n\
    \    {\n        if(paren_string[j] == '(')\n        {\n            accum++;\n\
    \        }\n        else if(paren_string[j] == ')')\n        {\n            accum--;\n\
    \        }\n        else\n        {\n            result ~= cast(long)max(0, accum);\n\
    \            accum = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptmsnxpvj.d(29): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptmsnxpvj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // 0:\
    \ no open paren\n    // 1: open paren, no opening paren in the middle\n    //\
    \ 2: open paren, opening paren in the middle\n    int state = 0;\n    size_t max_nest\
    \ = 0;\n    size_t cur_nest = 0;\n    long[] res;\n    for (size_t i = 0; i <\
    \ paren_string.length; i++) \n    {\n        if (paren_string[i] == '(') \n  \
    \      {\n            if (state == 0)\n            {\n                state =\
    \ 1;\n            }\n            else\n            {\n                state =\
    \ 2;\n            }\n            cur_nest++;\n            max_nest = max(max_nest,\
    \ cur_nest);\n        }\n        else if (paren_string[i] == ')') \n        {\n\
    \            cur_nest--;\n            if (state == 2)\n            {\n       \
    \         state = 1;\n            }\n            else\n            {\n       \
    \         state = 0;\n            }\n        }\n        else if (paren_string[i]\
    \ == ' ') \n        {\n            if (state == 0)\n            {\n          \
    \      res ~= max_nest;\n                max_nest = 0;\n            }\n      \
    \  }\n    }\n    if (max_nest != 0) \n    {\n        res ~= max_nest;\n    }\n\
    \    return res;\n}\n \n/*\nTakes in an array of arrays of integers, and outputs\
    \ the smallest size of \n    these arrays, with all its elements summed up.\n\
    \    E.g.\n        Input: [[1,2], [2, 3, 4], [5, 6, 7, 8]]\n        Output: [6L,\
    \ 15L]\n    \n    >>> min_sum([[1,2], [2, 3, 4], [5, 6, 7, 8]])\n    [6L, 15L]\n\
    */\nlong[] min_sum(long[][] matrix) \n{\n    size_t min_size = std.algorithm.minElement!(a\
    \ => a.length)(matrix).length;\n    long[]\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7uf3s6fb.d(78): Error: no identifier for declarator `long[]`

    /tmp/tmp7uf3s6fb.d(78): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uf3s6fb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    auto\
    \ nParens = 0; // nParens is current nesting level \n    auto maxParens = 1; //\
    \ maxParens is max depth of nesting found so far \n    // parens.init(0, size(paren_string));\n\
    \    long[] parens;\n    for (size_t i = 0; i < size(paren_string); i++) \n  \
    \  { \n        if (paren_string[i] == '(') \n        { \n            nParens +=\
    \ 1; \n            if (nParens > maxParens) \n            { \n               \
    \ maxParens = nParens; \n            } \n        } \n        else if (paren_string[i]\
    \ == ')') \n        { \n            nParens -= 1; \n        } \n        else if\
    \ (paren_string[i] == ' ') \n        { \n            parens ~= maxParens; \n \
    \           maxParens = 1; \n            nParens = 0; \n        } \n    } \n \
    \   return parens; \n} \n/*\n\tfor example, this two lists should be summed, (3\
    \ + 2) + (2 + 4) = 7\n*/\nT[] sumArray(T)(T[] list1, T[] list2)\n{\n\tassert(list1.length\
    \ == list2.length);\n\tT[] list = new T[list1.length];\n\tforeach(i, element;\
    \ list1)\n\t{\n\t\tlist[i] = list1[i] + list2[i];\n\t}\n\treturn list;\n}\nstring[]\
    \ invertParens(string[] parens)\n{\n\tstring[] invert = new string[parens.length];\n\
    \tforeach(i, s; parens)\n\t{\n\t\tinvert[i] = \"(\" ~ s ~ \")\";\n\t}\n\treturn\
    \ invert;\n}\nstring genString(string[] parens)\n{\n\tstring s = \"\";\n\tforeach(i,\
    \ ss; parens)\n\t{\n\t\ts ~=\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32jtt6cb.d(69): Error: expression expected, not `unittest`

    /tmp/tmp32jtt6cb.d(70): Error: found `{` when expecting `;` following statement

    /tmp/tmp32jtt6cb.d(77): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32jtt6cb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    const\
    \ long max_level = 99;\n    long[][] open_parens_at_level = new long[][](paren_string.length,\
    \ max_level);\n    long[][] close_parens_at_level = new long[][](paren_string.length,\
    \ max_level);\n    long open_idx = 0;\n    long close_idx = 0;\n    long current_level\
    \ = 0;\n    foreach (paren_idx, paren_char; paren_string) \n    {\n        if\
    \ (paren_char == '(') \n        {\n            open_parens_at_level[open_idx][current_level]\
    \ = paren_idx;\n            open_idx++;\n            current_level++;\n      \
    \  }\n        else if (paren_char == ')') \n        {\n            current_level--;\n\
    \            close_parens_at_level[close_idx][current_level] = paren_idx;\n  \
    \          close_idx++;\n        }\n    }\n    long[] max_level_per_group = new\
    \ long[paren_string.length];\n    for (long i = 0; i < open_idx; i++) \n    {\n\
    \        for (long j = 0; j < max_level; j++) \n        {\n            if (open_parens_at_level[i][j]\
    \ == 0 && close_parens_at_level[i][j] == 0) \n            {\n                max_level_per_group[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return max_level_per_group;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyjcsmm9q.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429281]

    ??:? void tmpyjcsmm9q.__unittest_L49_C1() [0x4282d9]

    ??:? void tmpyjcsmm9q.__modtest() [0x42846c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e07f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ad25]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42adb4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42acb1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f35]

    ??:? runModuleUnitTests [0x42de55]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429744]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ index = 0;\n    auto result = new long[];\n    int cnt = 0;\n    int max_cnt\
    \ = 0;\n    int state = 0;\n    foreach(c; paren_string) \n    {\n        if (c\
    \ == '(') \n        {\n            cnt++;\n            if (state == 0) \n    \
    \        {\n                state = 1;\n            }\n        }\n        else\
    \ if (c == ')') \n        {\n            cnt--;\n            if (state == 1) \n\
    \            {\n                max_cnt = max(max_cnt, cnt);\n            }\n\
    \        }\n        else if (c == ' ') \n        {\n            if (state == 1)\
    \ \n            {\n                state = 0;\n                result ~= max_cnt;\n\
    \                max_cnt = 0;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp38utt4xe.d(15): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp38utt4xe.d(34): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp38utt4xe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.range;\n    import std.typecons;\n    import std.string;\n    import std.algorithm;\n\
    \    import std.stdio;\n    import std.container;\n    auto paren_array = [] {\n\
    \        long[] result;\n        foreach(paren_substr; paren_string.split()) {\n\
    \            long stack_len = 0;\n            long max_len = 0;\n            foreach(paren_char;\
    \ paren_substr) {\n                stack_len += (paren_char == '(') ? 1 : -1;\n\
    \                max_len = max(max_len, stack_len);\n            }\n         \
    \   result ~= max_len;\n        }\n        return result;\n    }();\n    return\
    \ paren_array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpniutjf99.d(20): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpniutjf99.d(32): Error: expression expected, not `)`

    /tmp/tmpniutjf99.d(32): Error: found `;` when expecting `)`

    /tmp/tmpniutjf99.d(33): Error: found `return` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpniutjf99.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm.comparison : max;\n    import std.algorithm.iteration : filter,\
    \ map;\n    import std.array : array;\n    import std.range : startsWith;\n  \
    \  import std.string : split;\n    static int maxLevel(int[] stack) \n    {\n\
    \        return stack.length - stack.filter!((int x) => x == 0).length;\n    }\n\
    \    auto parenGroups = paren_string.split(\" \");\n    return parenGroups.map!(group\
    \ => \n    {\n        int[] stack;\n        foreach (c; group) \n        {\n \
    \           if (c == '(') \n            {\n                stack ~= 1;\n     \
    \       } \n            else if (c == ')') \n            {\n                stack\
    \ ~= 0;\n            }\n        }\n        return maxLevel(stack);\n    }).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppuacih4e.d(17): Error: module `std.range` import `startsWith` not
    found

    /tmp/tmppuacih4e.d(21): Error: no property `length` for type `FilterResult!(function
    (int x) => x == 0, int[])`

    /tmp/tmppuacih4e.d(39): Error: cannot implicitly convert expression `array(map(parenGroups))`
    of type `int delegate() pure nothrow @safe[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuacih4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // TODO:\
    \ implement\n  return [0L];\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv392x95d.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282c5]

    ??:? void tmpv392x95d.__unittest_L17_C1() [0x427eb1]

    ??:? void tmpv392x95d.__modtest() [0x428044]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c2af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b142]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4302d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430784]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430261]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b119]

    ??:? runModuleUnitTests [0x42c085]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428714]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long res = 0L;\n    long max = 0L;\n    bool is_open = false;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      res += 1L;\n            if(!is_open)\n            {\n                is_open\
    \ = true;\n            }\n        }\n        else if(c == ')')\n        {\n  \
    \          res -= 1L;\n            if(res < 0L)\n            {\n             \
    \   res = 0L;\n            }\n        }\n        else if(c == ' ')\n        {\n\
    \            if(is_open)\n            {\n                result ~= res;\n    \
    \            max = max(max, res);\n                res = 0L;\n               \
    \ is_open = false;\n            }\n        }\n    }\n    if(is_open)\n    {\n\
    \        result ~= res;\n        max = max(max, res);\n    }\n    writeln(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_nsc4fq.d(41): Error: function expected before `()`, not `max`
    of type `long`

    /tmp/tmpx_nsc4fq.d(50): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmpx_nsc4fq.d(52): Error: `writeln` is not defined, perhaps `import std.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_nsc4fq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[];\n    auto current_level = 0L;\n    auto max_level = 0L;\n\
    \    foreach (paren; paren_string)\n    {\n        if (paren == '(')\n       \
    \ {\n            current_level += 1L;\n            max_level = max(max_level,\
    \ current_level);\n        }\n        else if (paren == ')')\n        {\n    \
    \        current_level -= 1L;\n        }\n        else if (paren == ' ')\n   \
    \     {\n            res ~= max_level;\n            max_level = 0L;\n        \
    \    current_level = 0L;\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7pic6bty.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp7pic6bty.d(22): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pic6bty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // parens\
    \ will contain all parenthesis groups\n    auto parens = split(paren_string, \"\
    \ \");\n    long[] result;\n    // For each paren group\n    foreach(paren; parens)\
    \ \n    {\n        size_t level = 0;\n        size_t max_level = 0;\n        //\
    \ Iterate over each character\n        foreach(c; paren) \n        {\n       \
    \     if(c == '(') \n            {\n                // Start of a new level\n\
    \                ++level;\n                // Update max level\n             \
    \   max_level = max(max_level, level);\n            } \n            else if(c\
    \ == ')') \n            {\n                // End of current level\n         \
    \       --level;\n            }\n        }\n        // Add the max_level to result\n\
    \        result ~= max_level;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo__wu505.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo__wu505.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    enum\
    \ ParenType { paren_open, paren_close }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuitr_47a.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuitr_47a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  auto left_parens\
    \ = paren_string.count!(\"(\");\n  auto right_parens = paren_string.count!(\"\
    )\");\n  if (left_parens != right_parens)\n  {\n    return null;\n  }\n  long[]\
    \ result;\n  import std.algorithm;\n  import std.range;\n  // Split groups of\
    \ nested parentheses using space\n  foreach (paren_group; paren_string.split)\n\
    \  {\n    // Remove the outside parentheses\n    // E.g. (()()) -> ()()\n    auto\
    \ paren_group_no_outer_parens = paren_group[1..$-1];\n    // Split inside parentheses\
    \ using the outside parentheses\n    // E.g. ()() -> [\"\", \"\", \"\", \"\"]\n\
    \    auto paren_group_split = paren_group_no_outer_parens.split(\"\");\n    //\
    \ Calculate the number of nested parentheses.\n    //\n    // This could be done\
    \ by counting the number of left parentheses \n    // in a group and deducting\
    \ the count of the left parens from \n    // the immediately following groups.\n\
    \    // e.g. for (()())\n    //      count the left paren for the first group,\
    \ it is 2\n    //      count the left paren for the second group, it is 1\n  \
    \  //      count the left paren for the third group, it is 0\n    //      The\
    \ number of nested parentheses should be 2 - 0 = 2\n    //      So there are two\
    \ levels of nesting in this group\n    auto number_of_nested_parens = paren_group_split.filter!(x\
    \ => x == \"(\").count;\n    if (number_of_nested_parens == 0)\n    {\n      //\
    \ For groups that contains no parens, return 1\n      // e.g. ()\n      result\
    \ ~= 1;\n    }\n    else\n    {\n      // For group with left parens, return the\
    \ count\n      // e.g. (()())\n      result ~= number_of_nested_parens;\n    }\n\
    \  }\n  return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphbjnhym4.d(14): Error: no property `count` for type `string`

    /tmp/tmphbjnhym4.d(15): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphbjnhym4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ groups = paren_string.split(' ');\n    return groups.map!((gs) => reduce!((a,\
    \ b) => max(a, b))(gs.count('('), gs.count(')')));\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpci45xxei.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci45xxei.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels;\n    size_t level = 0;\n    size_t start = 0;\n    for (size_t p = 0;\
    \ p < paren_string.length; p++) \n    {\n        if (paren_string[p] == '(') \n\
    \        {\n            if (level == 0) \n            {\n                start\
    \ = p;\n            }\n            level++;\n        }\n        else if (paren_string[p]\
    \ == ')') \n        {\n            if (level == 1) \n            {\n         \
    \       levels ~= p - start + 1;\n            }\n            level--;\n      \
    \  }\n    }\n    return levels;\n}\n/*\n    >>> parse_parens_to_tree(\"(()())\
    \ ((())) () ((())()())\")\n    [[\"()()\"], [\"(())\"], [\"()\"], [\"((()))\"\
    , \"()()\"]]\n*/\nstring[][] parse_parens_to_tree(string paren_string) \n{\n \
    \   alias Leaf = tuple(size_t start, size_t end);\n    Leaf[][] leaves;\n    size_t\
    \ level = 0;\n    size_t start = 0;\n    for (size_t p = 0; p < paren_string.length;\
    \ p++) \n    {\n        if (paren_string[p] == '(') \n        {\n            if\
    \ (level == 0) \n            {\n                start = p;\n            }\n  \
    \          level++;\n        }\n        else if (paren_string[p] == ')') \n  \
    \      {\n            if (level == 1) \n            {\n                leaves\
    \ ~= [tuple(start, p)];\n            }\n            level--;\n        }\n    }\n\
    \    string[][] tree;\n    while (leaves.length > 0) \n    {\n        Leaf[][]\
    \ next_leaves;\n        string[] sub_tree;\n        size_t end = 0;\n        for\
    \ (Leaf[] sub_leaves : leaves) \n        {\n            sub_tree ~= paren_string[sub_leaves[0].start..sub_leaves[0].end\
    \ + 1];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzk2_y9ej.d(44): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmpzk2_y9ej.d(73): Error: found `sub_leaves` when expecting `;` following
    statement

    /tmp/tmpzk2_y9ej.d(73): Error: expression expected, not `:`

    /tmp/tmpzk2_y9ej.d(73): Error: found `leaves` when expecting `;` following `for`
    condition

    /tmp/tmpzk2_y9ej.d(76): Error: found `unittest` instead of statement

    /tmp/tmpzk2_y9ej.d(84): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpzk2_y9ej.d(84): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzk2_y9ej.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    return\
    \ to!(long[])(split(paren_string, \" \").map!(paren_string => \n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_string) \n        {\n            if(paren == '(') \n            {\n  \
    \              current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else \n            {\n                current_depth--;\n\
    \            }\n        }\n        return max_depth;\n    }));\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppbgbu5er.d(14): Error: template instance `to!(long[])` template
    `to` is not defined, did you mean No?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppbgbu5er.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    immutable long counter;\n    immutable long tmp_counter;\n    immutable\
    \ long start_index;\n    immutable long end_index;\n    immutable long len_paren_string;\n\
    \    immutable long i;\n    immutable long j;\n    immutable long k;\n    immutable\
    \ long idx;\n    immutable long idx_empty;\n    immutable long max_counter;\n\
    \    immutable long no_of_parens;\n    immutable long start_of_paren;\n    immutable\
    \ long end_of_paren;\n    immutable long no_of_empty_parens;\n    immutable long\
    \ element_index;\n    immutable string tmp_string;\n    immutable string[] splitted_paren_string;\n\
    \    immutable string[] elements;\n    immutable string[] empty_paren_array;\n\
    \    immutable tuple[long] group_idx;\n    immutable tuple[long] tuple_of_idx;\n\
    \    immutable tuple[long] empty_tuple_of_idx;\n    immutable tuple[long] begin_tuple_of_idx;\n\
    \    immutable tuple[long] end_tuple_of_idx;\n    immutable tuple[long] max_tuple_of_idx;\n\
    \    immutable tuple[long] element_tuple_of_idx;\n    immutable tuple[long] tmp_tuple_of_idx;\n\
    \    immutable tuple[long] no_of_empty_parens_tuple_of_idx;\n    immutable tuple[long]\
    \ max_counter_tuple_of_idx;\n    immutable tuple[long] tuple_of_tuple_of_idx;\n\
    \    immutable tuple[long] tuple_of_tuple_of_tuple_of_idx;\n    immutable tuple[long]\
    \ tuple_of_tuple_of_tuple_of_tuple_of_idx;\n    immutable tuple[long] tuple_of_tuple_of_tuple_of_tuple_of_tuple_of_idx;\n\
    \    immutable tuple[long] tuple_of_tuple_of_tuple_of_tuple_of_tuple_of_tuple_of_idx;\n\
    \    immutable tuple[long] tuple_of_tuple_of_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpog1p4d43.d(51): Error: semicolon expected, not `unittest`

    /tmp/tmpog1p4d43.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpog1p4d43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = \n        paren_string.split.filter!(ch=>ch=='('||ch==')')().map!(ch=>ch=='('\
    \ ? 1L:-1L).\n        array();\n    long[] max = new long[parens.length];\n  \
    \  long[] min = new long[parens.length];\n    max[0] = parens[0];\n    min[0]\
    \ = parens[0];\n    foreach(i,e; parens[1..$])\n    {\n        auto new_max =\
    \ max(max[i-1] + e, e);\n        auto new_min = min(min[i-1] + e, e);\n      \
    \  max[i] = new_max;\n        min[i] = new_min;\n    }\n    return max;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu8il7rkx.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8il7rkx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    const\
    \ open = '(';\n    const close = ')';\n    auto num_parens = paren_string.length;\n\
    \    auto paren_list = paren_string.toSlice();\n    auto max_levels = new long[];\n\
    \    int level = 0;\n    bool going_up = true;\n    for (int i = 0; i < num_parens;\
    \ i++) \n    {\n        if (paren_list[i] == open) \n        {\n            if\
    \ (going_up)\n                level++;\n            else \n            {\n   \
    \             max_levels ~= level;\n                level = 1;\n             \
    \   going_up = true;\n            }\n        }\n        else \n        {\n   \
    \         if (going_up) \n            {\n                max_levels ~= level;\n\
    \                level = 1;\n                going_up = false;\n            }\n\
    \            else\n                level++;\n        }\n    }\n    return max_levels;\n\
    }\n/*\n    Given a two vectors of equal length, A, and B.\n    The task is to\
    \ group the elements of the two vectors such that all pairs have the minimum difference\
    \ between them.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm61xur_6.d(48): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm61xur_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ long[] res = [];\n    immutable long[] tmp = [];\n    foreach(paren_seq; paren_string.split)\n\
    \    {\n        // puts(paren_seq);\n        tmp = [];\n        foreach(c; paren_seq)\n\
    \        {\n            if(c == '(')\n            {\n                tmp ~= 1;\n\
    \            }\n            else if(c == ')')\n            {\n               \
    \ res ~= max(tmp);\n                tmp = [];\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxmi42c4f.d(16): Error: no property `split` for type `string`

    /tmp/tmpxmi42c4f.d(33): Error: cannot implicitly convert expression `res` of type
    `immutable(long[])` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxmi42c4f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_vect = split(paren_string);\n    long[] result;\n    foreach(paren_group;\
    \ paren_vect)\n    {\n        long max_depth = 0;\n        long depth = 0;\n \
    \       foreach(ch; paren_group)\n        {\n            if(ch == '(')\n     \
    \       {\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if(ch == ')')\n            {\n    \
    \            depth--;\n            }\n        }\n        if(depth != 0)\n    \
    \    {\n            throw new Exception(\"Error\");\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnlfyqmi.d(14): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnlfyqmi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ level;\n    int max_level = 0;\n    int cur_level = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        switch(c) \n        {\n            case '(':\n            \
    \    cur_level++;\n                break;\n            case ')':\n           \
    \     cur_level--;\n                break;\n            case ' ':\n          \
    \      level ~= cur_level;\n                cur_level = 0;\n                break;\n\
    \        }\n        max_level = max(max_level, cur_level);\n    }\n    return\
    \ level;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfsxwpo6i.d(19): Error: `switch` statement without a `default`;
    use `final switch` or add `default: assert(0);` or add `default: break;`

    /tmp/tmpfsxwpo6i.d(32): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfsxwpo6i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.conv;\n\
    \    auto parens = filter!(x => x.length).split(paren_string);\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzj0r0rwy.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzj0r0rwy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  //var\
    \ paren_list=new long[];\n  long[] paren_list;\n  int len=paren_string.length;\n\
    \  int beg_idx=0;\n  int i=0;\n  int paren_count=0;\n  long max_paren_count=0;\n\
    \  while(i<len)\n  {\n    while(paren_string[i]==' ') i++;\n    beg_idx=i;\n \
    \   paren_count=0;\n    max_paren_count=0;\n    while(i<len)\n    {\n      if(paren_string[i]=='(')\
    \ paren_count++;\n      else if(paren_string[i]==')') paren_count--;\n      else\
    \ if(paren_string[i]==' ')\n      {\n        i++;\n        break;\n      }\n \
    \     if(paren_count>max_paren_count) max_paren_count=paren_count;\n      i++;\n\
    \    }\n    if(i-beg_idx>0) paren_list~=max_paren_count;\n  }\n  return paren_list;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdqlxmz3u.d(16): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdqlxmz3u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split(' ').map!(parens => parens.length - parens.replaceAll(\"\
    [()]\", \"\").length);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9b9a018v.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9b9a018v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    import std.typecons : Tuple;\n    size_t pos;\n    foreach (paren_group;\
    \ paren_string.split(\" \"))\n    {\n        if (paren_group.empty)\n        \
    \    continue;\n        long max_depth = 0;\n        long depth = 0;\n       \
    \ for (pos = 0; pos < paren_group.length; pos++)\n        {\n            if (paren_group[pos]\
    \ == '(')\n                depth++;\n            else if (paren_group[pos] ==\
    \ ')')\n                depth--;\n            else\n                throw new\
    \ Exception(\"Invalid character in paren group.\");\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        if (depth != 0)\n            throw new Exception(\"\
    Mismatched parenthesis.\");\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9uo2ey4.d(17): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9uo2ey4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    auto\
    \ tokens = split(paren_string); \n    long[] nest_array; \n    foreach(token;\
    \ tokens) \n    { \n        long nest_depth = 0L; \n        long curr_max = 0L;\
    \ \n        foreach(ch; token) \n        { \n            if(ch == '(') \n    \
    \        { \n                nest_depth++; \n                curr_max = max(curr_max,\
    \ nest_depth); \n            } \n            else if(ch == ')') \n           \
    \ { \n                nest_depth--; \n            } \n        } \n        nest_array\
    \ ~= curr_max; \n    } \n    return nest_array; \n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzhwrp05l.d(14): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhwrp05l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    auto parsed_parens = map!(to!int(a.front.idup))(paren_string.split);\n\
    \    return map!(a => a.array.tupleof[0] - a.array.tupleof[1])(zip(parsed_parens,\
    \ parsed_parens.front));\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvy6_jqvd.d(15): Error: template instance `map!(to!int(a.front.idup))`
    template `map` is not defined

    /tmp/tmpvy6_jqvd.d(16): Error: template instance `map!((a) => a.array.tupleof[0]
    - a.array.tupleof[1])` template `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvy6_jqvd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parts = split(paren_string, \" \");\n    long[] depth;\n    foreach(group; parts)\
    \ \n    {\n        depth ~= group.count('(') - group.count(')');\n    }\n    return\
    \ depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb4ckb2z7.d(14): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4ckb2z7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = [];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoa9i4pyu.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoa9i4pyu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_depth_array;\n    string[] paren_group_array;\n    Stack!(int)[] paren_group_stack_array;\n\
    \    int[] paren_depth_array_ptr;\n    int[int] paren_depth_array_len;\n    int\
    \ i, j;\n    int num_paren_groups;\n    int max_paren_depth;\n    paren_group_array\
    \ = paren_string.split(' ');\n    num_paren_groups = paren_group_array.length;\n\
    \    paren_depth_array_ptr = new int[num_paren_groups];\n    paren_depth_array_len\
    \ = new int[num_paren_groups];\n    paren_depth_array = new long[num_paren_groups];\n\
    \    foreach (i, paren_group; paren_group_array) \n    {\n        paren_group_stack_array[i]\
    \ = new Stack!(int)();\n        max_paren_depth = 0;\n        foreach (j, paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              paren_group_stack_array[i].push(1);\n                paren_depth_array_ptr[i]++;\n\
    \            }\n            else if (paren == ')') \n            {\n         \
    \       paren_group_stack_array[i].pop();\n                paren_depth_array_ptr[i]--;\n\
    \            }\n            if (paren_depth_array_ptr[i] > max_paren_depth) \n\
    \            {\n                max_paren_depth = paren_depth_array_ptr[i];\n\
    \            }\n        }\n        paren_depth_array_len[i] = max_paren_depth;\n\
    \    }\n    foreach (i, paren_group; paren_group_array) \n    {\n        paren_depth_array[i]\
    \ = paren_depth_array_len[i];\n    }\n    return paren_depth_array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn7h07zcz.d(16): Error: template instance `Stack!int` template `Stack`
    is not defined

    /tmp/tmpn7h07zcz.d(22): Error: no property `split` for type `string`

    /tmp/tmpn7h07zcz.d(23): Error: cannot implicitly convert expression `paren_group_array.length`
    of type `ulong` to `int`

    /tmp/tmpn7h07zcz.d(25): Error: cannot implicitly convert expression `new int[](cast(ulong)num_paren_groups)`
    of type `int[]` to `int[int]`

    /tmp/tmpn7h07zcz.d(27): Error: variable `i` is shadowing variable `tmpn7h07zcz.parse_nested_parens.i`

    /tmp/tmpn7h07zcz.d(31): Error: variable `j` is shadowing variable `tmpn7h07zcz.parse_nested_parens.j`

    /tmp/tmpn7h07zcz.d(48): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpn7h07zcz.d(50): Error: variable `i` is shadowing variable `tmpn7h07zcz.parse_nested_parens.i`

    /tmp/tmpn7h07zcz.d(52): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn7h07zcz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting = new long[];\n    foreach(paren_stack; split(paren_string))\n \
    \   {\n        long max_nest = 0;\n        long current_nest = 0;\n        foreach(paren;\
    \ paren_stack)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_nest += 1;\n                max_nest = max(max_nest, current_nest);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_nest -= 1;\n            }\n        }\n        max_nesting ~= max_nest;\n\
    \    }\n    return max_nesting;\n}\nstatic assert(parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdky0qanw.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpdky0qanw.d(15): Error: undefined identifier `split`

    /tmp/tmpdky0qanw.d(35):        called from here: `parse_nested_parens("(()())
    ((())) () ((())()())")`

    /tmp/tmpdky0qanw.d(35):        called from here: `__equals(parse_nested_parens("(()())
    ((())) () ((())()())"), [2L, 3L, 1L, 3L])`

    /tmp/tmpdky0qanw.d(35):        while evaluating: `static assert(parse_nested_parens("(()())
    ((())) () ((())()())") == [2L, 3L, 1L, 3L])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdky0qanw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n\
    \    import std.range;\n    import std.regex;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\
    \ std.typecons;\n    import std.typecons;\n    import std.typecons;\n    import\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc3rscpgz.d(79): Error: identifier expected following `import`

    /tmp/tmpc3rscpgz.d(79): Error: `;` expected

    /tmp/tmpc3rscpgz.d(87): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc3rscpgz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.array;\n    import std.range;\n\
    \    import std.range.primitives;\n    import std.exception;\n    import std.stdio;\n\
    \    import std.format;\n    import std.range.primitives;\n    import std.conv;\n\
    \    import std.string;\n    import std.format;\n    import std.stdio;\n    import\
    \ std.exception;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.array;\n    import std.datetime;\n    import std.file;\n    import std.range.primitives;\n\
    \    import std.getopt;\n    import std.math;\n    import std.typecons;\n    \n\
    \    return paren_string.\n        split.\n        filter!(p => p!=\"\" && p !=\
    \ \" \").\n        map!(p => new int[p.length]).\n        map!(pp => {\n     \
    \               int sum = 0;\n                    int max_sum = 0;\n         \
    \           for (int i = 0; i < pp.length; i++)\n                    {\n     \
    \                   if (paren_string[i] == '(')\n                        {\n \
    \                           sum += 1;\n                            max_sum = max(max_sum,\
    \ sum);\n                        }\n                        else if (paren_string[i]\
    \ == ')')\n                        {\n                            sum -= 1;\n\
    \                        }\n                    }\n                    return\
    \ max_sum;\n                }).\n        map!(to!long).\n        array;\n}\nlong[]\
    \ parse_nested_parens_slow(string paren_string)\n{\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.array;\n    import std.range;\n    import\
    \ std.range.primitives;\n    import std.exception;\n    import std.stdio;\n  \
    \  import std.format;\n    import std.range.primitives;\n    import std.conv;\n\
    \    import std.string;\n    import std.format;\n    import std.stdio;\n    import\
    \ std.exception;\n    import std.range;\n    import std.algorithm\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmqb1ylhv.d(80): Error: `;` expected

    /tmp/tmpmqb1ylhv.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqb1ylhv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_list;\n    import std.algorithm : map;\n    import std.conv;\n    import\
    \ std.range;\n    import std.range : dropOne, takeWhile;\n    import std.stdio;\n\
    \    import std.typecons;\n    import std.regex;\n    import std.algorithm : reduce;\n\
    \    auto rx_paren = regex(@\"\\((.*?)\\)\");\n    foreach(paren_match; rx_paren.matchAll(paren_string))\n\
    \    {\n        long max_nesting = paren_match.group(1).reduce!((a, b) => a.count(\"\
    (\") == b.count(\"(\") ? b : a).count(\"(\");\n        writeln(max_nesting);\n\
    \    }\n    return paren_list;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmy6_1g5_.d(23): Error: expression expected, not `@`

    /tmp/tmpmy6_1g5_.d(23): Error: undefined escape sequence \(

    /tmp/tmpmy6_1g5_.d(23): Error: undefined escape sequence \)

    /tmp/tmpmy6_1g5_.d(23): Error: found `"((.*?))"` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy6_1g5_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = long[];\n    int deep = 0;\n    for (auto paren: paren_string) \n \
    \   {\n        deep += (paren == '(' ? 1 : -1);\n        if (paren == ' ') \n\
    \        {\n            result ~= deep;\n            deep = 0;\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5kgxa_2m.d(14): Error: found `[` when expecting `.` following long

    /tmp/tmp5kgxa_2m.d(14): Error: found `]` when expecting identifier following `long`.

    /tmp/tmp5kgxa_2m.d(16): Error: no identifier for declarator `paren`

    /tmp/tmp5kgxa_2m.d(16): Error: expression expected, not `:`

    /tmp/tmp5kgxa_2m.d(16): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5kgxa_2m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // <your\
    \ code here>\n  size_t open_count = 0;\n  size_t[] open_counts;\n  size_t[] result;\n\
    \  immutable size_t paren_string_length = paren_string.length;\n  foreach(immutable\
    \ char current_character; paren_string) \n  {\n    if(current_character == '(')\n\
    \    {\n      open_count++;\n    }\n    else if(current_character == ')')\n  \
    \  {\n      open_counts ~= open_count;\n      open_count--;\n    }\n    else if(current_character\
    \ == ' ')\n    {\n      open_counts ~= 0;\n    }\n  }\n  foreach(immutable size_t\
    \ current_open_count; open_counts)\n  {\n    if(current_open_count != 0)\n   \
    \ {\n      result ~= current_open_count;\n    }\n  }\n  return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp901z9mka.d(42): Error: cannot implicitly convert expression `result`
    of type `ulong[]` to `long[]`

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int[][]\
    \ cur_nest_levels = paren_string.split.map!(sub_string =>\n    {\n        int\
    \ nest_level = 0;\n        int max_nest_level = 0;\n        sub_string.chars.each!(paren_char\
    \ =>\n        {\n            if (paren_char == '(')\n            {\n         \
    \       nest_level++;\n                max_nest_level = max(max_nest_level, nest_level);\n\
    \            }\n            else if (paren_char == ')')\n            {\n     \
    \           nest_level--;\n            }\n        });\n        return [nest_level,\
    \ max_nest_level];\n    });\n    return cur_nest_levels.map!(tuple => tuple[1]).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7osoh58.d(14): Error: no property `split` for type `string`

    /tmp/tmpo7osoh58.d(32): Error: no property `map` for type `int[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7osoh58.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ counts;\n    long current_max = 0;\n    int len = paren_string.length;\n   \
    \ int spaces = 0;\n    int c = 0;\n    int i = 0;\n    // to count the number\
    \ of group in paren_string\n    for (i = 0; i < len; i++) \n    {\n        if\
    \ (paren_string[i] == ' ')\n            spaces += 1;\n    }\n    counts = new\
    \ long[spaces + 1];\n    i = 0;\n    // to count maximum nesting of each group\n\
    \    foreach (paren; paren_string) \n    {\n        if (paren == '(') \n     \
    \   {\n            current_max += 1;\n            if (current_max > counts[c])\n\
    \                counts[c] = current_max;\n        } \n        else if (paren\
    \ == ')') \n        {\n            current_max -= 1;\n        } \n        else\
    \ if (paren == ' ') \n        {\n            c += 1;\n        }\n    }\n    return\
    \ counts;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcdd0ow77.d(16): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdd0ow77.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.typecons;\n    import\
    \ std.range;\n    import std.conv;\n    import std.math;\n    import std.meta;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.range;\n    import std.conv;\n    import std.math;\n    import\
    \ std.meta;\n    long[] paren = paren_string.map!(c => c == '(' ? 1L : -1L);\n\
    \    long running_depth = 0;\n    long max_depth = 0;\n    return paren.grouped(500).map!(a\
    \ => \n    {\n        (a.reduce!((x, y) => \n        {\n            running_depth\
    \ += y;\n            max_depth = max(max_depth, running_depth);\n            return\
    \ running_depth;\n        }))[];\n        return max_depth;\n    }).array;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_fu1e64b.d(28): Error: cannot implicitly convert expression `map(paren_string)`
    of type `MapResult!(__lambda2, string)` to `long[]`

    /tmp/tmp_fu1e64b.d(31): Error: no property `grouped` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fu1e64b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Initialize\
    \ a stack to store the count of nested parentheses\n    Stack!int paren_counts\
    \ = new Stack!int();\n    // We do not have to handle the empty string because\
    \ the constraint (1 <= len(paren_string) <= 15) takes care of it.\n    foreach\
    \ (paren; paren_string) \n    {\n        if (paren == '(') \n        {\n     \
    \       // If a '(' is encountered then we increment the count of nested parentheses\
    \ by one.\n            paren_counts.push(paren_counts.empty || paren_counts.top\
    \ == 0 ? 1 : paren_counts.top + 1);\n        }\n        else if (paren == ')')\
    \ \n        {\n            // If a ')' is encountered then we pop the stack for\
    \ the current group and add it to the results.\n            assert(!paren_counts.empty,\
    \ \"Invalid input. Stack should not be empty.\");\n            long current_paren_count\
    \ = paren_counts.pop;\n            paren_counts.push(paren_counts.empty ? 0 :\
    \ paren_counts.top);\n        }\n        else if (paren == ' ') \n        {\n\
    \            // If a space is encountered then we pop the stack for the current\
    \ group and add it to the results.\n            assert(!paren_counts.empty, \"\
    Invalid input. Stack should not be empty.\");\n            long current_paren_count\
    \ = paren_counts.pop;\n            paren_counts.push(paren_counts.empty ? 0 :\
    \ paren_counts.top);\n        }\n        else \n        {\n            assert(false,\
    \ \"Invalid input.\");\n        }\n    }\n    assert(paren_counts.empty, \"Invalid\
    \ input. Stack should be empty.\");\n    return paren_counts.data;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaykux3yi.d(15): Error: template instance `Stack!int` template `Stack`
    is not defined

    /tmp/tmpaykux3yi.d(15): Error: template instance `Stack!int` template `Stack`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaykux3yi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm : map;\n    // TODO: split by ' '(space)\n    long[] a = paren_string.split.map!(x\
    \ => paren_count(x)).array;\n    return a;\n}\n/*\n    Count the levels of nesting\
    \ in a given parentheses string\n*/\nlong paren_count(string parens)\n{\n    long\
    \ count=0, result=0;\n    foreach(x; parens) {\n        if(x == '(') {\n     \
    \       count++;\n            result = max(result, count);\n        }\n      \
    \  else {\n            count--;\n        }\n    }\n    return result;\n}\n// ----------------------------------------------------------------------------------------\n\
    /*\n    Given a 2D array with nulls, write a function that takes a position (x,\
    \ y) and outputs the \n    number of ways you can go from that position to the\
    \ bottom right corner of the array.\n    E.g.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp71n2flsg.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp71n2flsg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    \n \
    \   \n    long[] results;\n    auto groups = split(paren_string,\" \");\n    //Tuple!(long,long)\
    \ tuple;\n    long max_nesting_level = 0;\n    long nesting_level = 0;\n    foreach(group;\
    \ groups) {\n        foreach(paren; group) {\n            if(paren == '(') {\n\
    \                nesting_level++;\n            }\n            else if(paren ==\
    \ ')') {\n                nesting_level--;\n            }\n        }\n       \
    \ max_nesting_level = max(max_nesting_level, nesting_level);\n        results\
    \ ~= max_nesting_level;\n        max_nesting_level = 0;\n        nesting_level\
    \ = 0;\n    }\n    return results;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm63rxngc.d(17): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm63rxngc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ lines = paren_string.splitLines();\n    long[] paren_nest_counts;\n    foreach(line;\
    \ lines)\n    {\n        int paren_count = 0;\n        int max_paren_count = 0;\n\
    \        foreach(c; line)\n        {\n            if(c == '(')\n            {\n\
    \                paren_count++;\n                if(paren_count > max_paren_count)\n\
    \                {\n                    max_paren_count = paren_count;\n     \
    \           }\n            }\n            else if(c == ')')\n            {\n \
    \               paren_count--;\n            }\n        }\n        paren_nest_counts\
    \ ~= max_paren_count;\n    }\n    return paren_nest_counts;\n}\n//Z_PARSE_NESTED_PARENS_STUDENT_CODE_END\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnzykbemm.d(14): Error: no property `splitLines` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnzykbemm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    auto toks = split(paren_string);\n    foreach(tok; toks) \n   \
    \ {\n        auto cur = tok.filter!(ch => ch == '(' || ch == ')').join;\n    \
    \    long level = 0;\n        long result_level = 0;\n        foreach(ch; cur)\
    \ \n        {\n            if(ch == '(') level++;\n            else level--;\n\
    \            result_level = max(result_level, level);\n        }\n        result\
    \ ~= result_level;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps6z4szaj.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6z4szaj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[];\n    string[] paren_groups = paren_string.split;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long idx = 0;\n        long max = 0;\n       \
    \ foreach(c; paren_group)\n        {\n            switch(c)\n            {\n \
    \               case '(':\n                    idx += 1;\n                   \
    \ break;\n                case ')':\n                    idx -= 1;\n         \
    \           break;\n            }\n            max = max(max, idx);\n        }\n\
    \        res ~= max;\n    }\n    return res;\n}\n \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_h2_3j3h.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp_h2_3j3h.d(15): Error: no property `split` for type `string`

    /tmp/tmp_h2_3j3h.d(22): Error: `switch` statement without a `default`; use `final
    switch` or add `default: assert(0);` or add `default: break;`

    /tmp/tmp_h2_3j3h.d(31): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_h2_3j3h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ l = new long[0];\n    return l;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv2swn7im.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282ad]

    ??:? void tmpv2swn7im.__unittest_L17_C1() [0x427e9d]

    ??:? void tmpv2swn7im.__modtest() [0x428030]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c2f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b186]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430411]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43039d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b15d]

    ??:? runModuleUnitTests [0x42c0c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4286fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Algorithm:\n\
    \    //   - split the paren string by spaces, this gives us a sequence of groups\n\
    \    //   - we will use a stack to keep track of the parens:\n    //       - if\
    \ we encounter an open paren, push the depth of the paren\n    //       - if we\
    \ encounter a close paren, pop from the stack and update the max depth\n    //\
    \   - at the end of each group, get the max depth from the stack\n    //   - push\
    \ back the max depth of each group into a result array\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfzw31r4u.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfzw31r4u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    import std.algorithm : map;\n    import std.math : max;\n  \
    \  import std.regex : findAll, split;\n    import std.string : repeat;\n    import\
    \ std.range : takeWhile, count;\n    import std.typecons : tuple;\n    /*\n  \
    \  This function takes a string and returns the maximum number of nested parentheses.\n\
    \    Time complexity: O(n)\n    Space complexity: O(n) for the stack, O(n) for\
    \ the output array\n    */\n    long max_nested_parens(string group) {\n     \
    \   import std.array : array;\n        long[] stack = new long[](group.length);\n\
    \        long[] output = new long[](group.length);\n        long top = 0;\n  \
    \      long max_level = 0;\n        long level = 0;\n        foreach (index, ch;\
    \ group) {\n            if (ch == '(') {\n                top++;\n           \
    \     level++;\n                max_level = max(max_level, level);\n         \
    \       stack[top] = max_level;\n            } else if (ch == ')') {\n       \
    \         output[index] = stack[top];\n                top--;\n              \
    \  level--;\n            }\n        }\n        return max_level;\n    }\n    return\
    \ paren_string.split(' ').map!max_nested_parens.array;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp9phoo5f.d(16): Error: module `std.math` import `max` not found,
    did you mean function `std.math.fmax`?

    /tmp/tmpp9phoo5f.d(17): Error: module `std.regex` import `findAll` not found

    /tmp/tmpp9phoo5f.d(18): Error: module `std.string` import `repeat` not found,
    did you mean template `std.meta.Repeat(ulong n, TList...)`?

    /tmp/tmpp9phoo5f.d(19): Error: module `std.range` import `takeWhile` not found

    /tmp/tmpp9phoo5f.d(19): Error: module `std.range` import `count` not found

    /tmp/tmpp9phoo5f.d(47): Error: template `std.regex.split` cannot deduce function
    from argument types `!()(string, char)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/regex/package.d(1588):        `std.regex.split(String,
    RegEx)(String input, RegEx rx) if (isSomeString!String && isRegexFor!(RegEx, String))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp9phoo5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ ret = new long[](paren_string.length);\n    bool is_word = false;\n    size_t\
    \ i = 0;\n    size_t j = 0;\n    long max_nesting = 0;\n    long paren_count =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == ' ')\n        {\n \
    \           if(!is_word)\n            {\n                ret[j] = max_nesting;\n\
    \                j++;\n                max_nesting = 0;\n                paren_count\
    \ = 0;\n                i = 0;\n            }\n            is_word = true;\n \
    \       }\n        else\n        {\n            is_word = false;\n           \
    \ paren_count += c == '(' ? 1 : -1;\n            max_nesting = max(max_nesting,\
    \ paren_count);\n            i++;\n        }\n    }\n    ret[j] = max_nesting;\n\
    \    return ret[0..j+1];\n}\n/*\n    Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    For each of\
    \ the group, output the deepest level of nesting of parentheses.\n    E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_zc4zhu6.d(45): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zc4zhu6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_depth = new long[];\n    long nesting_depth = 0;\n    string temp = paren_string;\n\
    \    int max = 0;\n    foreach(c; paren_string)\n    {\n        max_depth ~= 0;\n\
    \    }\n    foreach(c; paren_string)\n    {\n        // writeln(c);\n        if(c\
    \ == \"(\")\n        {\n            nesting_depth++;\n            if(nesting_depth\
    \ > max)\n            {\n                max = nesting_depth;\n            }\n\
    \        }\n        else if(c == \")\")\n        {\n            if(nesting_depth\
    \ > 0)\n            {\n                nesting_depth--;\n            }\n     \
    \   }\n        else if(c == \" \")\n        {\n            max_depth[0] = max;\n\
    \            nesting_depth = 0;\n            max = 0;\n            temp = temp[1..$];\n\
    \            int k = 0;\n            foreach(i; temp)\n            {\n       \
    \         k++;\n                if(i == \" \")\n                {\n          \
    \          break;\n                }\n            }\n            max_depth ~=\
    \ 0;\n            temp = temp[k..$];\n        }\n    }\n    max_depth[0] = max;\n\
    \    // writeln(max_depth);\n    return max_depth;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5e09bntd.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp5e09bntd.d(25): Error: incompatible types for `(c) == ("(")`: `immutable(char)`
    and `string`

    /tmp/tmp5e09bntd.d(30): Error: cannot implicitly convert expression `nesting_depth`
    of type `long` to `int`

    /tmp/tmp5e09bntd.d(33): Error: incompatible types for `(c) == (")")`: `immutable(char)`
    and `string`

    /tmp/tmp5e09bntd.d(40): Error: incompatible types for `(c) == (" ")`: `immutable(char)`
    and `string`

    /tmp/tmp5e09bntd.d(50): Error: incompatible types for `(i) == (" ")`: `immutable(char)`
    and `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5e09bntd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// take\
    \ care of input\n\tlong[] output;\n\tif (paren_string == \"\") \n\t{\n\t\treturn\
    \ output;\n\t}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqs_urb24.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqs_urb24.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Use\
    \ a stack to keep track of the parentheses\n    auto stack = new Stack!int();\n\
    \    auto paren_counts = new long[];\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        long max_count = 0;\n        foreach (paren; paren_group)\
    \ \n        {\n            if (paren == '(') \n            {\n               \
    \ stack.push(1);\n            } \n            else if (paren == ')') \n      \
    \      {\n                if (stack.empty) \n                {\n             \
    \       max_count = 0;\n                    break;\n                } \n     \
    \           else \n                {\n                    stack.pop();\n     \
    \               max_count = max(max_count, stack.length);\n                }\n\
    \            }\n        }\n        paren_counts ~= max_count;\n    }\n    return\
    \ paren_counts;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6h98wc00.d(15): Error: template instance `Stack!int` template `Stack`
    is not defined

    /tmp/tmp6h98wc00.d(16): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmp6h98wc00.d(17): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6h98wc00.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.range.primitives : isInputRange;\n    import std.range.isRandomAccessRange;\n\
    \    import std.range.isInfinite;\n    import std.range : chunkBy, chunks, empty,\
    \ dropOne, ElementType, zip, zipPairs, ElementTypeTuple, elementTypeTuple, iota,\
    \ cycle, only, take, takeExactly, takeOne, chomp, count, countUntil, cycle, drop,\
    \ dropExactly, dropOne, empty, all, indexOf, indexOfSlice, front, empty, front,\
    \ isInfinite, isInputRange, isRandomAccessRange, join, joiner, popFront, popFrontN,\
    \ pushFront, retro, retroN, save, scan, scan!\"a + b\"(\"\", 1, 2, 3, 4), scanRight,\
    \ scanRight!\"a + b\"(\"\", 1, 2, 3, 4), splitter, startsWith, startsWith!\"abc\"\
    , split, split!\"abc\", splitUntil, splitUntil!\"abc\", take, takeExactly, takeWhile,\
    \ takeWhile!\"a < 3\", takeExactlyWhile, takeExactlyWhile!\"a < 3\", retro, retroN,\
    \ save, popFront, popFrontN, pushFront, startsWith, startsWith!\"abc\", endsWith,\
    \ endsWith!\"abc\", find, find!\"a < 3\", findAfter, findAfter!\"a < 3\", findUntil,\
    \ findUntil!\"a < 3\", splitter, split, split!\"abc\", splitUntil, splitUntil!\"\
    abc\", startsWith, startsWith!\"abc\", startsWithAfter, startsWithAfter!\"abc\"\
    , startsWithUntil, startsWithUntil!\"abc\", endsWith, endsWith!\"abc\", endsWithAfter,\
    \ endsWithAfter!\"abc\", endsWithUntil, endsWithUntil!\"abc\", chunkBy, chunks,\
    \ map, map!\"a.idup\", map!\"x + 1\", filter, filter!\"a % 2 == 0\", filter!\"\
    a % 2 == 1\", filter!\"a.length > 1\", map!\"a.idup\", map!\"x + 1\", each, each!\"\
    a.idup\", each!\"x + 1\", each!\"writeln(a)\", fold, fold!\"a + b\", fold!\"a\
    \ + b\", fold!\"a + b\", reduce, reduce!\"a + b\", reduce!\"a + b\", zip, zipPairs,\
    \ zipShortest, zipShort\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6bwa4hh6.d(17): Error: `;` expected

    /tmp/tmp6bwa4hh6.d(18): Error: found `unittest` when expecting `;` following statement

    /tmp/tmp6bwa4hh6.d(26): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6bwa4hh6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    ulong\
    \ acc = 0;\n    long[] max_depth = new long[];\n    for (int i = 0; i < paren_string.length;\
    \ i++) \n    {\n        auto c = paren_string[i];\n        if (c == '(') \n  \
    \      {\n            acc++;\n        } \n        else if (c == ')') \n      \
    \  {\n            acc--;\n        } \n        else if (c == ' ') \n        {\n\
    \            max_depth ~= acc;\n            acc = 0;\n        }\n    }\n    return\
    \ max_depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpggirr9c3.d(15): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpggirr9c3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  long[]\
    \ cur_paren_levels = new long[0];\n  paren_string.split_splitter(new RedBlackTree.CharSplitter('\
    \ ')).foreach!(group => {\n    long max_paren_level = 0;\n    long paren_level\
    \ = 0;\n    group.foreach!(c => {\n      if (c == '(')\n        paren_level++;\n\
    \      else\n        paren_level--;\n      max_paren_level = max(max_paren_level,\
    \ paren_level);\n    });\n    cur_paren_levels ~= max_paren_level;\n  });\n  return\
    \ cur_paren_levels;\n}\n \n// This can be tested by running code.dlang.org\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkribu8qo.d(15): Error: identifier expected following `.`, not `foreach`

    /tmp/tmpkribu8qo.d(15): Error: found `!` when expecting `;` following statement

    /tmp/tmpkribu8qo.d(18): Error: identifier expected following `.`, not `foreach`

    /tmp/tmpkribu8qo.d(18): Error: found `!` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkribu8qo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ output;\n    // start by separating the parens into groups\n    string[] paren_groups\
    \ = split(paren_string);\n    auto max_depth = 0;\n    for (long i = 0; i < paren_groups.length;\
    \ i++) \n    {\n        max_depth = 0;\n        long[] paren_depth;\n        //\
    \ find the depth of each parenthesis in the group\n        paren_depth = paren_depth_helper(paren_groups[i]);\n\
    \        // grab the largest depth\n        for (long depth = 0; depth < paren_depth.length;\
    \ depth++) \n        {\n            if (paren_depth[depth] > max_depth)\n    \
    \        {\n                max_depth = paren_depth[depth];\n            }\n \
    \       }\n        // append the largest depth to the output list\n        output\
    \ ~= max_depth;\n    }\n    return output;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwy2hb0lu.d(16): Error: undefined identifier `split`

    /tmp/tmpwy2hb0lu.d(23): Error: undefined identifier `paren_depth_helper`

    /tmp/tmpwy2hb0lu.d(29): Error: cannot implicitly convert expression `paren_depth[cast(ulong)depth]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwy2hb0lu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tassert(paren_string.length);\n\
    \t\n\tlong[] parsed_data;\n\t\n\tstring[] substrings;\n\tif(paren_string.find(\"\
    \ \") == -1)\n\t{\n\t\tsubstrings ~= paren_string;\n\t}\n\telse\n\t{\n\t\tsubstrings\
    \ = paren_string.split(\" \");\n\t}\n\t\n\tforeach(substring; substrings)\n\t\
    {\n\t\tTuple!(long, long) parsed_substring = parse_nested_parens_helper(substring);\n\
    \t\tparsed_data ~= parsed_substring[0];\n\t}\n\t\n\treturn parsed_data;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpperisn6c.d(19): Error: no property `find` for type `string`

    /tmp/tmpperisn6c.d(25): Error: no property `split` for type `string`

    /tmp/tmpperisn6c.d(30): Error: undefined identifier `parse_nested_parens_helper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpperisn6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[];\n\tlong max_paren_depth;\n\tforeach(paren_string; paren_group;\n\
    \t{\n\t\t//clear result\n\t\tmax_paren_depth = 0L;\n\t\t//iterate through paren\
    \ group\n\t\tforeach(paren_group; paren;\n\t\t{\n\t\t\t//get depth of parenthesis\n\
    \t\t\tlong depth = paren == '(' ? 1L : -1L;\n\t\t\tmax_paren_depth += depth;\n\
    \t\t});\n\t\t//store max depth\n\t\tresult ~= max_paren_depth;\n\t});\n\t//return\
    \ result\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl58ceius.d(16): Error: found `;` when expecting `)`

    /tmp/tmpl58ceius.d(21): Error: found `;` when expecting `)`

    /tmp/tmpl58ceius.d(26): Error: found `)` instead of statement

    /tmp/tmpl58ceius.d(29): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl58ceius.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n    // We are\
    \ going to use a tuple to represent the character in the string and its nesting\
    \ depth.\n    // The first element is the character and the second element is\
    \ its nesting depth.\n    // The nesting depth starts from 0 and increased by\
    \ 1 when an opening paren is encountered and decreased by 1\n    // when a closing\
    \ paren is encountered.\n    pure @safe nothrow @nogc @nogcinit\n{\n    // Some\
    \ sanity checks for an empty string\n    if (paren_string.empty)\n        return\
    \ [];\n    \n    // accumulator to save the results, initialized to an empty array\n\
    \    auto groups = [](long[])();\n    \n    // initializing the current nesting\
    \ level to 0\n    auto current_level = 0L;\n    \n    // we are going to keep\
    \ looping through the string and update the nesting level every time\n    // we\
    \ encounter an opening or closing paren.\n    // Also, we are going to keep track\
    \ of the maximum nesting level encountered so far.\n    auto max_level = 0L;\n\
    \    \n    // Running through the string and checking for opening and closing\
    \ paren\n    for (auto c : paren_string)\n    {\n        if (c == '(')\n     \
    \   {\n            current_level++;\n            max_level = max(max_level, current_level);\n\
    \        }\n        else if (c == ')')\n        {\n            current_level--;\n\
    \        }\n        else\n        {\n            // if it is a space, we are going\
    \ to save the max nesting level for the current group and\n            // reset\
    \ max_level to 0.\n            if (c == ' ')\n            {\n                groups\
    \ ~= max_level;\n                max_level = 0;\n            }\n        }\n  \
    \  }\n    return groups;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppolwfzt6.d(24): Error: found `[` when expecting `.` following long

    /tmp/tmppolwfzt6.d(24): Error: found `]` when expecting identifier following `long`.

    /tmp/tmppolwfzt6.d(35): Error: no identifier for declarator `c`

    /tmp/tmppolwfzt6.d(35): Error: expression expected, not `:`

    /tmp/tmppolwfzt6.d(35): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppolwfzt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ rtn;\n    foreach(immutable p; paren_string.split(\" \"))\n    {\n        if(p\
    \ == \"\")\n            continue;\n        immutable c = p.count(\"(\");\n   \
    \     auto level = new S[1];\n        int count = 0;\n        for(immutable i\
    \ = 0; i < p.length; i++)\n        {\n            if(p[i] == '(')\n          \
    \  {\n                level.insertFront('(');\n                count++;\n    \
    \        }\n            else if(p[i] == ')')\n            {\n                level.removeFront();\n\
    \                count--;\n            }\n            if(count == 0)\n       \
    \         rtn ~= level.length;\n        }\n    }\n    return rtn;\n}\n \n \n \n\
    \ \n/*\n    Given a file containing a 2D grid of integers\n    find the largest\
    \ total for any path from one corner to the opposite.\n    Paths can only move\
    \ down or right.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa97vpk0k.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa97vpk0k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ depth_levels = [0, 1L];\n    auto stack = new std.typecons.Stack!(long)(depth_levels);\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsiuejqck.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsiuejqck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164103
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ parens = paren_string.split;\n    long[] results;\n    long depth = 0;\n   \
    \ foreach(paren; parens)\n    {\n        immutable parenthesis = to!string(paren);\n\
    \        immutable inside = parenthesis[1..$-1];\n        foreach(ch; inside)\n\
    \        {\n            if(ch == '(')\n                depth++;\n            else\n\
    \                depth--;\n        }\n        results ~= depth;\n        depth\
    \ = 0;\n    }\n    return results;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfec4m85j.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfec4m85j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    bool[][]\
    \ paren_matrix = \n        paren_string.split(\" \")\n            .map!(paren_string\
    \ => paren_string.byElement.map!(paren_char => paren_char == '(').array)\n   \
    \         .array;\n    long[] max_nesting_per_paren_group = \n        paren_matrix.map!(paren_group\
    \ => {\n            if (paren_group.length == 0) return 0L;\n            long[]\
    \ nesting_depth = new long[paren_group.length];\n            long max_depth =\
    \ 0L;\n            for (size_t i = 0; i < paren_group.length; i++) {\n       \
    \         if (paren_group[i]) {\n                    nesting_depth[i] = (i ==\
    \ 0 ? 1L : nesting_depth[i - 1] + 1L);\n                    max_depth = max(max_depth,\
    \ nesting_depth[i]);\n                } else {\n                    nesting_depth[i]\
    \ = (i == 0 ? 0L : nesting_depth[i - 1] - 1L);\n                }\n          \
    \  }\n            return max_depth;\n        }).array;\n    return max_nesting_per_paren_group;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptm9vc45k.d(15): Error: no property `split` for type `string`

    /tmp/tmptm9vc45k.d(19): Error: no property `map` for type `bool[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptm9vc45k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    auto paren_groups = split(paren_string);\n    foreach(paren_group;\
    \ paren_groups) \n    {\n        static if(is(typeof(paren_group) == string))\
    \ \n        {\n            auto begin = paren_group.indexOf(\"(\");\n        \
    \    auto end = paren_group.indexOf(\")\");\n            if(begin != -1 && end\
    \ != -1) \n            {\n                paren_group = paren_group[begin .. end\
    \ + 1];\n            }\n        }\n        res ~= get_paren_level(paren_group);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6elpdepg.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6elpdepg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(string group; paren_string.split(\" \")) \n    {\n    \
    \    long cur_depth = 0;\n        long max_depth = 0;\n        foreach(c; group)\
    \ \n        {\n            if(c == '(')\n                cur_depth++;\n      \
    \      else if(c == ')')\n                cur_depth--;\n            if(cur_depth\
    \ > max_depth)\n                max_depth = cur_depth;\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf3hb3cj4.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf3hb3cj4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t/*\n\t\
    Only uses one stack for tracking parenthesis nesting\n\t*/\n\tstring[] groups\
    \ = paren_string.split;\n\tlong[] counts = groups.map!(paren_group => \n\t{\n\t\
    \tint max_nesting = 0;\n\t\tint current_nesting = 0;\n\t\tforeach(paren; paren_group)\n\
    \t\t{\n\t\t\tif(paren == '(')\n\t\t\t{\n\t\t\t\t++current_nesting;\n\t\t\t\tmax_nesting\
    \ = max(max_nesting, current_nesting);\n\t\t\t}\n\t\t\telse if(paren == ')')\n\
    \t\t\t{\n\t\t\t\t--current_nesting;\n\t\t\t}\n\t\t}\n\t\tassert(current_nesting\
    \ == 0);\n\t\treturn max_nesting;\n\t}).array;\n\treturn counts;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp35vk04mb.d(17): Error: no property `split` for type `string`

    /tmp/tmp35vk04mb.d(18): Error: no property `map` for type `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp35vk04mb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    string[] input_groups = split(paren_string, \" \");\n    foreach(string\
    \ inp; input_groups) \n    {\n        long depth = 0;\n        long max_depth\
    \ = 0;\n        foreach(dchar ch; inp) \n        {\n            if(ch == '(')\
    \ \n            {\n                depth += 1;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if(ch == ')') \n            {\n   \
    \             depth -= 1;\n            }\n        }\n        res ~= max_depth;\n\
    \    }\n    return res;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp18osq39v.d(15): Error: undefined identifier `split`

    /tmp/tmp18osq39v.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18osq39v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.stdio;\n    size_t max_depth = 0;\n    long[] res;\n    for (string paren_substring\
    \ = paren_string.split(\" \"); paren_substring.length > 0; paren_substring = paren_substring[1\
    \ .. $])\n    {\n        max_depth = 0;\n        immutable current_string = paren_substring[0];\n\
    \        import std.algorithm :\n            count;\n        foreach (size_t depth;\
    \ count(\"(\" ~ paren_substring[0] ~ \")\", \"(\") ~ count(\"(\" ~ paren_substring[0]\
    \ ~ \")\", \")\"))\n        {\n            max_depth = max(max_depth, depth);\n\
    \        }\n        res ~= max_depth;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7f4sk9m.d(17): Error: no property `split` for type `string`

    /tmp/tmpz7f4sk9m.d(23): Error: incompatible types for `(count("(" ~ paren_substring[0]
    ~ ")", "(")) ~ (count("(" ~ paren_substring[0] ~ ")", ")"))`: both operands are
    of type `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7f4sk9m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ parse_nested_parens(string paren_string) \n    {\n        auto r = paren_string.by_token(space);\n\
    \        auto ret = [];\n        foreach(i, s; r)\n        {\n            int\
    \ depth = 0;\n            int max_depth = 0;\n            foreach(c; s)\n    \
    \        {\n                switch(c)\n                {\n                   \
    \ case '(':\n                        depth++;\n                        max_depth\
    \ = max(max_depth, depth);\n                        break;\n                 \
    \   case ')':\n                        depth--;\n                        break;\n\
    \                }\n            }\n            ret ~= max_depth;\n        }\n\
    \        return ret;\n    }\n    return [2L, 3L, 1L, 3L];\n}\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxnfmk7q6.d(16): Error: no property `by_token` for type `string`

    /tmp/tmpxnfmk7q6.d(37): Error: cannot implicitly convert expression `ret` of type
    `void[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxnfmk7q6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // split\
    \ the string by spaces\n    string[] groups = paren_string.split(\" \");\n   \
    \ // allocate a dynamic array to store the result\n    long[] result = new long[0];\n\
    \    // for each group, calculate the depth and add it to the result array\n \
    \   foreach(int i, string group; groups)\n    {\n        enum depth = 0;\n   \
    \     long[] temp = new long[1];\n        foreach(char c; group)\n        {\n\
    \            if(c == '(')\n            {\n                depth++;\n         \
    \   }\n            else if(c == ')')\n            {\n                depth--;\n\
    \            }\n            temp[0] = depth;\n        }\n        result ~= temp[0];\n\
    \    }\n    return result;\n}\n// test the function\nassert(parse_nested_parens(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n// test the function\nassert(parse_nested_parens(\"\
    ()()(())\") == [1L, 1L, 2L]);\n \n \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\
    // 27.  Write a function to flatten an arbitrary-depth list of numbers.\n// Input:\
    \ [1, 2, 3, [4, 5, [6, 7, 8]], 9, 10]\n// Output: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10]\n// Hint: Use std.typecons.Tuple to store the input list. \n \nimport std.algorithm.iteration\
    \ : map;\nimport std.range : take;\nimport std.typecons : Tuple;\n/*\n Input to\
    \ this function is a nested list.\n    Output is a flatten list.\n    E.g. [1,\
    \ 2, 3, [4, 5, [6, 7, 8]], 9, 10] => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Hint:\
    \ Use std.typecons.Tuple to store the input list. \n*/\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqmy7902o.d(40): Error: declaration expected, not `assert`

    /tmp/tmpqmy7902o.d(42): Error: declaration expected, not `assert`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmy7902o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm.iteration : iter, unaryFun;\n    import std.algorithm.comparison\
    \ : max;\n    import std.conv : text;\n    import std.string : find;\n    return\
    \ paren_string.split(\" \").map!((string s)\n        {\n            long max_nesting\
    \ = 1;\n            string paren_group = s;\n            long open_parens = 0;\n\
    \            long close_parens = 0;\n            size_t paren_idx = 0;\n     \
    \       for (size_t i = 0; i < paren_group.length; i++) \n            {\n    \
    \            if (paren_group[i] == '(') \n                {\n                \
    \    open_parens++;\n                    long paren_nesting = open_parens - close_parens;\n\
    \                    max_nesting = max(max_nesting, paren_nesting);\n        \
    \        } \n                else if (paren_group[i] == ')') \n              \
    \  {\n                    close_parens++;\n                }\n            }\n\
    \            return max_nesting;\n        }).array;\n}\n@safe unittest\n{\n  \
    \  assert(parse_nested_parens(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L,\
    \ 3L]);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpftsu0wm9.d(14): Error: module `std.algorithm.iteration` import
    `iter` not found

    /tmp/tmpftsu0wm9.d(14): Deprecation: Symbol `std.functional.unaryFun(alias fun,
    string parmName = "a")` is not visible from module `tmpftsu0wm9` because it is
    privately imported in module `iteration`

    /tmp/tmpftsu0wm9.d(17): Error: module `std.string` import `find` not found

    /tmp/tmpftsu0wm9.d(18): Error: no property `split` for type `string`

    /tmp/tmpftsu0wm9.d(43): Error: `@safe` function `tmpftsu0wm9.__unittest_L41_C7`
    cannot call `@system` function `tmpftsu0wm9.parse_nested_parens`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpftsu0wm9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split;\n    long[] depths;\n    long max_depth;\n\
    \    long depth;\n    // For each of the group, output the deepest level of nesting\
    \ of parentheses.\n    foreach(paren_group; paren_groups) \n    {\n        depth\
    \ = 0;\n        max_depth = 0;\n        foreach(paren; paren_group) \n       \
    \ {\n            if(paren == '(') \n            {\n                depth++;\n\
    \            }\n            else if(paren == ')') \n            {\n          \
    \      depth--;\n            }\n            max_depth = max(max_depth, depth);\n\
    \        }\n        depths ~= max_depth;\n    }\n    return depths;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80f4s01o.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80f4s01o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = new long[](0);\n    auto tokenizer = split(paren_string, \" \");\n\
    \    foreach(paren_string; tokenizer) \n    {\n        long level = 0L;\n    \
    \    long max_level = 0L;\n        foreach(c; paren_string) \n        {\n    \
    \        if(c == '(')\n                level++;\n            else\n          \
    \      level--;\n            max_level = max(max_level, level);\n        }\n \
    \       result ~= max_level;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwcqtwfzb.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcqtwfzb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    string[] split_string = paren_string.split(\" \");\n    foreach(string\
    \ s; split_string)\n    {\n        long num_open_parens = 0;\n        long max_parens\
    \ = 0;\n        long s_size = s.length;\n        for(int i = 0; i < s_size; i++)\n\
    \        {\n            if(s[i] == '(')\n            {\n                num_open_parens++;\n\
    \                max_parens = max(max_parens, num_open_parens);\n            }\n\
    \            else if(s[i] == ')')\n            {\n                num_open_parens--;\n\
    \            }\n        }\n        result ~= max_parens;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu5iry3tm.d(15): Error: no property `split` for type `string`

    /tmp/tmpu5iry3tm.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu5iry3tm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ output;\n    int cur_max = 0; // current max\n    int max = 0;\n    foreach\
    \ (paren; paren_string) \n    {\n        if (paren == \"(\") \n        {\n   \
    \         cur_max += 1;\n            if (cur_max > max) \n            {\n    \
    \            max = cur_max;\n            }\n        } \n        else if (paren\
    \ == \")\") \n        {\n            if (cur_max > 0) \n            {\n      \
    \          cur_max -= 1;\n            } \n            else \n            {\n \
    \               return [];\n            }\n        } \n        else if (paren\
    \ == \" \") \n        {\n            output ~= max;\n            max = 0;\n  \
    \          cur_max = 0;\n        }\n    }\n    output ~= max;\n    return output;\n\
    }\nlong[] parse_nested_parens_solution(string paren_string) \n{\n    long[] result;\n\
    \    // Process the string, replacing each space with a ')'\n    // With each\
    \ '(' increment the count, with each ')' decrement it.\n    // The max count is\
    \ the deepest level of nesting.\n    string modified = replace(paren_string, \"\
    \ \", \")\");\n    long count = 0;\n    long max = 0;\n    foreach (c; modified)\
    \ \n    {\n        if (c == '(') \n        {\n            count++;\n         \
    \   if (count > max) \n            {\n                max = count;\n         \
    \   }\n        } \n        else if (c == ')') \n        {\n            count--;\n\
    \            if (count < 0) \n            {\n                return result;\n\
    \            }\n        } \n        else \n        {\n            result ~= max;\n\
    \            max = 0;\n        }\n    }\n    result ~= max;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptwqnw4s8.d(19): Error: incompatible types for `(paren) == ("(")`:
    `immutable(char)` and `string`

    /tmp/tmptwqnw4s8.d(27): Error: incompatible types for `(paren) == (")")`: `immutable(char)`
    and `string`

    /tmp/tmptwqnw4s8.d(38): Error: incompatible types for `(paren) == (" ")`: `immutable(char)`
    and `string`

    /tmp/tmptwqnw4s8.d(54): Error: undefined identifier `replace`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptwqnw4s8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \     * append an extra closing parenthesis so that we don't have to check\n \
    \    * for end of string\n     */\n    paren_string ~= \")\";\n    /*\n     *\
    \ set to long(0) so that we can use it as an array index\n     */\n    int last_paren_level\
    \ = 0;\n    /*\n     * use a unique type for the stack so that we can index to\
    \ the\n     * last character in the string\n     */\n    auto LStack = new Tuple!(long[],\
    \ long);\n    auto stack = LStack(long[], 0);\n    /*\n     * use int for the\
    \ loop variable\n     */\n    for (int i = 0; i < paren_string.length; i++)\n\
    \    {\n        switch (paren_string[i])\n        {\n            case '(':\n \
    \               /*\n                 * add an element to the stack\n         \
    \        */\n                stack.length++;\n                stack[0][stack.length\
    \ - 1] = last_paren_level + 1;\n                break;\n            case ')':\n\
    \                /*\n                 * pop the last element\n               \
    \  */\n                last_paren_level = stack[0][stack.length - 1];\n      \
    \          stack.length--;\n                break;\n        }\n    }\n    return\
    \ last_paren_level.dup;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmgc9umsd.d(28): Error: found `[` when expecting `.` following long

    /tmp/tmpmgc9umsd.d(28): Error: found `]` when expecting identifier following `long`.

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmgc9umsd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ longest_chain = (TextGroup[] groups)\n    {\n        long[] results;\n     \
    \   long max = 0;\n        foreach(g; groups)\n        {\n            long len\
    \ = g.span.length;\n            if(len > max)\n            {\n               \
    \ max = len;\n            }\n        }\n        foreach(g; groups)\n        {\n\
    \            if(g.span.length == max)\n            {\n                results\
    \ ~= max;\n            }\n        }\n        return results;\n    };\n    auto\
    \ groups = parse(paren_string, r\"([(]+)\");\n    return longest_chain(groups);\n\
    }\n \n//unittest\nassert(parse_nested_parens(\"(()()) ((())) () ((())()())\")\
    \ == [2L, 3L, 1L, 3L]);\n \nassert(parse_nested_parens(\"((()((()))))\") == [4L]);\n\
    \ \nassert(parse_nested_parens(\"((()((())))) (((())))\") == [4L, 3L]);\n \nassert(parse_nested_parens(\"\
    (((())())) (((())))\") == [4L, 3L]);\n \nassert(parse_nested_parens(\"(((())()))\
    \ (((())))\") == [4L, 3L]);\n \nassert(parse_nested_parens(\"(((())())) (((())))\"\
    ) == [4L, 3L]);\n \nassert(parse_nested_parens(\"()()()()()()\") == [1L, 1L, 1L,\
    \ 1L, 1L, 1L]);\n \nassert(parse_nested_parens(\"(())()()()()()\") == [1L, 1L,\
    \ 1L, 1L, 1L, 1L]);\n \nassert(parse_nested_parens(\"(()())()()()()\") == [2L,\
    \ 1L, 1L, 1L, 1L]);\n \nassert(parse_nested_parens(\"((()))()()()()\") == [3L,\
    \ 1L, 1L, 1L]);\n \nassert(parse_nested_parens\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp68ln9ijy.d(40): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(42): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(44): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(46): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(48): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(50): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(52): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(54): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(56): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(58): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(60): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(65): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(66): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(67): Error: declaration expected, not `assert`

    /tmp/tmp68ln9ijy.d(68): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_levels = [];\n    string[] paren_groups = paren_string.split();\n    for\
    \ (string paren_group; paren_group = paren_groups.popFront()) \n    {\n      \
    \  long level = 0;\n        long max_level = 0;\n        for (long i = 0; i <\
    \ paren_group.length; i++) \n        {\n            switch (paren_group[i]) \n\
    \            {\n                case '(':\n                    level++;\n    \
    \                break;\n                case ')':\n                    level--;\n\
    \                    break;\n            }\n            max_level = max(max_level,\
    \ level);\n        }\n        paren_levels ~= max_level;\n    }\n    return paren_levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2zdkn7ib.d(16): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp2zdkn7ib.d(35): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zdkn7ib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong result;\n\
    \timport std.stdio;\n\tauto paren_list = paren_string.split(\" \");\n\tforeach(paren;\
    \ paren_list)\n\t{\n\t\twriteln(paren);\n\t}\n\treturn [];\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjkgpt0r7.d(16): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkgpt0r7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ lines = paren_string.split;\n    long[] res;\n    foreach(line; lines)\n   \
    \ {\n        long max = 0;\n        long nested = 0;\n        foreach(c; line)\n\
    \        {\n            if(c == '(')\n            {\n                nested++;\n\
    \                if(nested > max)\n                    max = nested;\n       \
    \     }\n            else if(c == ')')\n            {\n                nested--;\n\
    \            }\n        }\n        res ~= max;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeyio24p5.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyio24p5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_counts;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1jn2ubgv.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jn2ubgv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ length = paren_string.length;\n    //parse_nested_parens\n    long[] res = new\
    \ long[];\n    int i = 0;\n    while(i < length) \n    {\n        if(paren_string[i]\
    \ == '(') \n        {\n            int j = i + 1;\n            long max_depth\
    \ = 0;\n            long depth = 0;\n            while(j < length) \n        \
    \    {\n                if(paren_string[j] == '(') \n                {\n     \
    \               depth++;\n                    max_depth = max(max_depth, depth);\n\
    \                } \n                else if(paren_string[j] == ')') \n      \
    \          {\n                    depth--;\n                }\n              \
    \  else if(paren_string[j] == ' ') \n                {\n                    break;\n\
    \                }\n                j++;\n            }\n            res ~= max_depth;\n\
    \            i = j;\n        }\n        else \n        {\n            i++;\n \
    \       }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz8k5vqoj.d(14): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    /tmp/tmpz8k5vqoj.d(16): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpz8k5vqoj.d(30): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz8k5vqoj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    long\
    \ level = 0L;\n    long[] res = new long[];\n    foreach(w; paren_string.split)\
    \ \n    {\n        if(w.length > 1)\n        {\n            foreach(c; w)\n  \
    \          {\n                if(c == '(')\n                    level += 1L;\n\
    \                else\n                    level -= 1L;\n            }\n     \
    \       res ~= level;\n        }\n    }\n    return res;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9za0ftf8.d(15): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp9za0ftf8.d(16): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9za0ftf8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    A generalized solution.\n    */\n    auto it = paren_string.splitter;\n \
    \   auto parens = paren_string.splitter;\n    long[] retval;\n    foreach(paren;\
    \ it)\n    {\n        int level = 0;\n        foreach(c; paren)\n        {\n \
    \           if(c == '(') level++;\n            else if(c == ')') level--;\n  \
    \      }\n        retval ~= level;\n    }\n    return retval;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmponqx8_ou.d(17): Error: no property `splitter` for type `string`

    /tmp/tmponqx8_ou.d(18): Error: no property `splitter` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponqx8_ou.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \     * We do this by using a stack. A depth stack is used to keep track of depths\n\
    \     * for each '(' and ')' pair. \n     *\n     * (()()((()))) -> [0, 1, 2,\
    \ 1, 0, 1, 2, 3, 2, 1, 0]\n     *\n     * This list is then processed to determine\
    \ the max depth at each level.\n     *\n     * [0, 1, 2, 1, 0, 1, 2, 3, 2, 1,\
    \ 0] -> [2, 3]\n     *\n     * Iterating through the stack:\n     * \n     * \
    \ '(': depth += 1\n     *  ')': depth -= 1, and the depth is the max depth at\
    \ this level\n     *\n     *  For example:\n     *  \n     *  (()) -> [0, 1, 2,\
    \ 1]\n     *  \n     *  or\n     *\n     *  ((())) -> [0, 1, 2, 3, 2, 1, 0]\n\
    \     *\n     *  and so on.\n     *\n     *  The 'depth' vector is then processed\
    \ to determine the max depth at each\n     *  level, which is the solution.\n\
    \     */\n    long[] depth = new long[paren_string.length];\n    long[] max_depth\
    \ = new long[paren_string.length];\n    long[] result = new long[];\n    auto\
    \ current_depth = 0L;\n    auto current_index = 0L;\n    immutable auto total_depth\
    \ = 0L;\n    immutable auto result_index = 0L;\n    immutable auto max_depth_index\
    \ = 0L;\n    /*\n     * Iterate through the paren_string and extract the number\
    \ of parenthesis.\n     *\n     * There is a little bug here if you have an empty\
    \ string. It will return a depth\n     * of one for an empty string, instead of\
    \ zero.\n     */\n    foreach (paren; paren_string) \n    {\n        //println(paren);\n\
    \        if (paren == '(') \n        {\n            current_depth += 1;\n    \
    \        depth[current_index] = current_depth;\n            current_index += 1\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxf_5q_nc.d(64): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpxf_5q_nc.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxf_5q_nc.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxf_5q_nc.d(72): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxf_5q_nc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.range;\n    import std.typecons;\n    import\
    \ std.array;\n    import std.typecons;\n    // TODO check for invalid string such\
    \ as \"(()((()\"\n    // TODO check for wrong usage of brackets such as ()(())()\
    \ and ()())()\n    // TODO check for missing input string\n    long[] res = new\
    \ long[paren_string.count(\" \") + 1];\n    int idx = 0;\n    for (int i = 0;\
    \ i < paren_string.length; i++)\n    {\n        if (paren_string[i] == ' ')\n\
    \        {\n            idx++;\n            continue;\n        }\n        res[idx]\
    \ = max(res[idx], recursive_paren_check(paren_string[i .. $]));\n    }\n    return\
    \ res;\n}\nlong recursive_paren_check(string str)\n{\n    if (str.front() != '(')\
    \ return 0;\n    if (str.back() != ')') return 0;\n    import std.range;\n   \
    \ auto str_2 = str[1 .. $ - 1];\n    long num_open = 0;\n    long num_close =\
    \ 0;\n    foreach (idx, c; str_2)\n    {\n        if (c == '(') num_open++;\n\
    \        if (c == ')') num_close++;\n        if (num_open == num_close) return\
    \ 1 + recursive_paren_check(str_2[idx + 1 .. $]);\n    }\n    return 1;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9mfbi6li.d(37): Error: no property `front` for type `string`

    /tmp/tmp9mfbi6li.d(38): Error: no property `back` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mfbi6li.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ get_nested_parens = () {\n        size_t max_level = 0;\n        long[] paren_levels;\n\
    \        foreach (level; paren_levels) {\n            max_level = max(max_level,\
    \ level);\n        }\n        return max_level;\n    };\n    return paren_string.split(\"\
    \ \").map!(a => (a.chunks(1)).map!(b => get_nested_parens()));\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppxnoyuon.d(18): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmppxnoyuon.d(22): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppxnoyuon.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    \n \
    \   \n    import std.string;\n    auto parts = split(paren_string);\n    auto\
    \ output = new long[];\n    foreach(part; parts)\n    {\n        long part_len\
    \ = part.length;\n        long longest_len = 0;\n        long current_longest_len\
    \ = 0;\n        long current_paren_count = 0;\n        for(long i = 0; i < part_len;\
    \ i++)\n        {\n            if(part[i] == '(')\n            {\n           \
    \     current_paren_count++;\n                current_longest_len++;\n       \
    \     }\n            else if(part[i] == ')')\n            {\n                current_paren_count--;\n\
    \                if(current_paren_count == 0)\n                {\n           \
    \         longest_len = max(longest_len, current_longest_len);\n             \
    \       current_longest_len = 0;\n                }\n            }\n        }\n\
    \        output ~= longest_len;\n    }\n    return output;\n}\n \n/*\n Given a\
    \ list of strings representing stock trade data,\n    determine the maximum profit\
    \ that could have been made buying and selling the stocks.\n    Assume you can\
    \ only buy and sell once (You can't buy and sell several times and use the proceeds\
    \ from one trade on another).\n    E.g. the list [\"7 1 5 3 6 4\"] would return\
    \ 5, since you can buy for 1 and sell for 6.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp06vb94ho.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp06vb94ho.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    paren_string\
    \ = paren_string.replace(\" \", \"\");\n    int length = paren_string.length;\n\
    \    long[] levels = new long[length];\n    int[] current_level = new int[length];\n\
    \    int open_parens = 0;\n    foreach (int i, char c; paren_string)\n    {\n\
    \        if (c == '(')\n        {\n            open_parens++;\n            current_level[i]\
    \ = open_parens;\n        }\n        else if (c == ')')\n        {\n         \
    \   levels[i] = current_level[i];\n            current_level[i] = 0;\n       \
    \     open_parens--;\n        }\n    }\n    return levels;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt89uk1dt.d(14): Error: no property `replace` for type `string`

    /tmp/tmpt89uk1dt.d(15): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt89uk1dt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.regex;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmrj6_sqq.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmrj6_sqq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    Pseudo code:\n    split the string by space\n    for each group of parenthese:\n\
    \        use stack to keep track of the order and level of nesting, empty the\
    \ stack when encounter ')'\n        for each character in the string:\n      \
    \      if ch == '(':\n                stack.push(1);\n            else:\n    \
    \            if stack.length == 0:\n                    continue;\n          \
    \      else:\n                    stack.pop();\n        push the length of stack\
    \ to the output list\n    */\n    long[] output;\n    output.length = 0;\n   \
    \ long[] stack;\n    stack.length = 0;\n    auto paren_groups = paren_string.split(\"\
    \ \");\n    foreach(auto paren_group; paren_groups)\n    {\n        foreach(auto\
    \ ch; paren_group)\n        {\n            if (ch == '(')\n            {\n   \
    \             stack ~= 1;\n            }\n            else\n            {\n  \
    \              if (stack.length == 0)\n                {\n                   \
    \ continue;\n                }\n                else\n                {\n    \
    \                stack.pop();\n                }\n            }\n        }\n \
    \       output ~= stack.length;\n        stack.length = 0;\n    }\n    return\
    \ output;\n}\nimport std.range;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0c2pntr.d(34): Error: basic type expected, not `auto`

    /tmp/tmpe0c2pntr.d(34): Error: no identifier for declarator `_error_`

    /tmp/tmpe0c2pntr.d(34): Error: found `auto` when expecting `;`

    /tmp/tmpe0c2pntr.d(34): Error: found `;` when expecting `)`

    /tmp/tmpe0c2pntr.d(34): Error: found `)` when expecting `;` following statement

    /tmp/tmpe0c2pntr.d(36): Error: basic type expected, not `auto`

    /tmp/tmpe0c2pntr.d(36): Error: no identifier for declarator `_error_`

    /tmp/tmpe0c2pntr.d(36): Error: found `auto` when expecting `;`

    /tmp/tmpe0c2pntr.d(36): Error: found `;` when expecting `)`

    /tmp/tmpe0c2pntr.d(36): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0c2pntr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    auto result = new long[](paren_string.count('('));\n    size_t\
    \ index = 0;\n    size_t i = 0;\n    while (i < paren_string.length)\n    {\n\
    \        if (paren_string[i] == '(')\n        {\n            long left_count =\
    \ 1;\n            long right_count = 0;\n            auto inner_result = new long[];\n\
    \            i += 1;\n            for (;i < paren_string.length; i++)\n      \
    \      {\n                if (paren_string[i] == '(')\n                {\n   \
    \                 left_count += 1;\n                }\n                else if\
    \ (paren_string[i] == ')')\n                {\n                    right_count\
    \ += 1;\n                }\n                if (left_count == right_count)\n \
    \               {\n                    i += 1;\n                    result[index]\
    \ = left_count;\n                    index += 1;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      i += 1;\n        }\n    }\n    return result[0..index];\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn5nfwm1y.d(15): Error: no property `count` for type `string`

    /tmp/tmpn5nfwm1y.d(24): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5nfwm1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ out = new long[];\n    // the accumulator for nested level\n    long nest =\
    \ 0;\n    // the maximum of the `nest`\n    long max_nest = 0;\n    // the tokenizer\
    \ \n    auto toks = split(paren_string, \" \");\n    // for each token\n    foreach(token;\
    \ toks)\n    {\n        // for each char\n        foreach(ch; token)\n       \
    \ {\n            if(ch == '(')\n            {\n                // increase the\
    \ depth of nesting\n                nest += 1;\n                // keep track\
    \ of the maximum\n                max_nest = max(max_nest, nest);\n          \
    \  }\n            else if(ch == ')')\n            {\n                // decrease\
    \ the depth of nesting\n                nest -= 1;\n            }\n        }\n\
    \        // add max_nest to the out\n        out ~= max_nest;\n        // reset\
    \ both counters to 0\n        nest = 0;\n        max_nest = 0;\n    }\n    return\
    \ out;\n}\n \n/*\n Given a 2D matrix (vector of vectors) where each row represents\
    \ a string, find the longest common prefix for all the rows in the given matrix.\n\
    \ \n >>> longest_common_prefix([\"etw\", \"ets\", \"etwo\"])\n \"et\"\n \n >>>\
    \ longest_common_prefix([\"flower\", \"flow\", \"flight\"])\n \"fl\"\n*/\nstring\
    \ longest_common_prefix(string[] strings)\n{\n    // Base case\n    if(strings.length\
    \ == 0)\n    {\n        return \"\";\n    }\n    // initialize the shortest string\
    \ and its length\n    string shortest = strings[0];\n    long len = $shortest;\n\
    \    // find the shortest\n    foreach(s; strings)\n    {\n        if($s < len)\n\
    \        {\n            shortest = s;\n            len = $s;\n        }\n    }\n\
    \    // iterate over each char\n    foreach(i; 0..len)\n    {\n        foreach(s;\
    \ strings)\n        {\n            // if there is a string that doesn't match\
    \ the shortest string\n            if(s[i] != shortest[\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnjutq4np.d(14): Error: no identifier for declarator `long[]`

    /tmp/tmpnjutq4np.d(14): Error: found `out` instead of statement

    /tmp/tmpnjutq4np.d(41): Error: found `out` instead of statement

    /tmp/tmpnjutq4np.d(46): Error: expression expected, not `out`

    /tmp/tmpnjutq4np.d(67): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpnjutq4np.d(67): Error: semicolon expected, not `shortest`

    /tmp/tmpnjutq4np.d(71): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpnjutq4np.d(71): Error: found `s` when expecting `)`

    /tmp/tmpnjutq4np.d(71): Error: found `<` instead of statement

    /tmp/tmpnjutq4np.d(74): Error: `$` is valid only inside [] of index or slice

    /tmp/tmpnjutq4np.d(74): Error: found `s` when expecting `;` following statement

    /tmp/tmpnjutq4np.d(74): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpnjutq4np.d(78): Error: declaration expected, not `foreach`

    /tmp/tmpnjutq4np.d(78): Error: declaration expected, not `0`

    /tmp/tmpnjutq4np.d(80): Error: no identifier for declarator'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ split_strs = split(paren_string, \" \");\n    long[] result = new long[split_strs.length];\n\
    \    long i = 0;\n    foreach(string parens; split_strs)\n    {\n        long\
    \ level = 0;\n        long max_level = 0;\n        for(char c : parens)\n    \
    \    {\n            if(c == '(')\n            {\n                level++;\n  \
    \              max_level = max(max_level, level);\n            }\n           \
    \ else if(c == ')')\n            {\n                level--;\n            }\n\
    \        }\n        result[i] = max_level;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv8lbmq0p.d(21): Error: semicolon expected, not `:`

    /tmp/tmpv8lbmq0p.d(21): Error: expression expected, not `:`

    /tmp/tmpv8lbmq0p.d(21): Error: found `parens` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv8lbmq0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ max_level = 0;\n    int level = 0;\n    long[] paren_levels;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c=='(')\n        {\n            level++;\n\
    \            max_level = max(max_level, level);\n        }\n        else if(c==')')\n\
    \        {\n            level--;\n        }\n        else if(c==' ')\n       \
    \ {\n            paren_levels ~= max_level;\n            max_level = 0;\n    \
    \        level = 0;\n        }\n    }\n    return paren_levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsomaey4.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsomaey4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.typecons;\n    auto nested_parens = paren_string.split(\" \");\n    long[]\
    \ output;\n    foreach(paren_group; nested_parens) \n    {\n        output ~=\
    \ countUntil!(paren_group.array, \n                            (char c) => c ==\
    \ '(', \n                            (char c) => c == ')');\n    }\n    return\
    \ output;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphf4g0m6u.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphf4g0m6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n    in (paren_string)\
    \ out (result)\n{\n    size_t paren_string_len = paren_string.length;\n    long[]\
    \ result;\n    static if (paren_string_len >= 2)\n    {\n        string[] split_paren_string\
    \ = paren_string.split;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ktzpngk.d(20): Error: found `unittest` instead of statement

    /tmp/tmp2ktzpngk.d(28): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ktzpngk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Use\
    \ a stack to track the nesting level\n    auto stack = new Stack!(long)();\n \
    \   long level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc5xe0_wh.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5xe0_wh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    long max_level = 0;\n    long level = 0;\n    long depth = 0;\n  \
    \  while (depth < paren_string.length)\n    {\n        char paren = paren_string[depth];\n\
    \        if (paren == '(')\n        {\n            level++;\n            if (level\
    \ > max_level)\n            {\n                max_level = level;\n          \
    \  }\n        }\n        else if (paren == ')')\n        {\n            level--;\n\
    \        }\n        else if (paren == ' ')\n        {\n            res ~= max_level;\n\
    \            max_level = 0;\n            level = 0;\n        }\n        depth++;\n\
    \    }\n    return res;\n}\n/*\n    Given a two dimensional array, each row and\
    \ column is sorted, find if a given integer is in the array.\n    >>> int_search([[0,\
    \ 1, 5, 8],\n                    [2, 6, 8, 9],\n                    [3, 7, 9,\
    \ 10],\n                    [4, 8, 10, 11]])\n    [[1, true], [3, true], [5, true],\
    \ [8, true], [0, false], [2, false], [9, false], [11, false]]\n*/\nTuple!(long,\
    \ bool)[] int_search(long[][] A) \n{\n    long row = 0;\n    long col = A[0].length\
    \ - 1;\n    long n = A.length;\n    long m = A[0].length;\n    Tuple!(long, bool)[]\
    \ res;\n    long[] test_data = [1, 3, 5, 8, 0, 2, 9, 11];\n    foreach (data;\
    \ test_data)\n    {\n        bool found = false;\n        while (row < n && col\
    \ >= 0)\n        {\n            if (A[row][col] == data)\n            {\n    \
    \            found = true;\n                break;\n            }\n          \
    \  else if (A[row][col] > data)\n            {\n                col--;\n     \
    \       }\n            else\n            {\n                row++;\n         \
    \   }\n        }\n        res ~= tuple(\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr68cq30f.d(79): Error: expression expected, not `unittest`

    /tmp/tmpr68cq30f.d(80): Error: found `{` when expecting `,`

    /tmp/tmpr68cq30f.d(81): Error: expression expected, not `alias`

    /tmp/tmpr68cq30f.d(81): Error: found `candidate` when expecting `,`

    /tmp/tmpr68cq30f.d(81): Error: expression expected, not `=`

    /tmp/tmpr68cq30f.d(81): Error: found `parse_nested_parens` when expecting `,`

    /tmp/tmpr68cq30f.d(81): Error: expression expected, not `;`

    /tmp/tmpr68cq30f.d(83): Error: found `assert` when expecting `,`

    /tmp/tmpr68cq30f.d(83): Error: found `;` when expecting `,`

    /tmp/tmpr68cq30f.d(84): Error: found `;` when expecting `,`

    /tmp/tmpr68cq30f.d(85): Error: found `;` when expecting `,`

    /tmp/tmpr68cq30f.d(86): Error: expression expected, not `}`

    /tmp/tmpr68cq30f.d(87): Error: found `void` when expecting `,`

    /tmp/tmpr68cq30f.d(87): Error: found `{` when expecting `,`

    /tmp/tmpr68cq30f.d(87): Error: expression expected, not `}`

    /tmp/tmpr68cq30f.d(87): Error: found `End of File` when expecting `,`

    /tmp/tmpr'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tbool is_paren_open\
    \ = false;\n\tlong paren_count = 0;\n\tlong[] result = [];\n\tstring current_group\
    \ = \"\";\n\tforeach(c; paren_string)\n\t{\n\t\tif(c == ' ')\n\t\t{\n\t\t\tif(is_paren_open)\n\
    \t\t\t{\n\t\t\t\tresult ~= paren_count;\n\t\t\t\tis_paren_open = false;\n\t\t\t\
    \tparen_count = 0;\n\t\t\t\tcurrent_group = \"\";\n\t\t\t}\n\t\t}\n\t\telse\n\t\
    \t{\n\t\t\tcurrent_group ~= c;\n\t\t\tis_paren_open = true;\n\t\t\tif(c == '(')\n\
    \t\t\t{\n\t\t\t\tparen_count += 1;\n\t\t\t}\n\t\t\telse if(c == ')')\n\t\t\t{\n\
    \t\t\t\tparen_count -= 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(is_paren_open)\n\t{\n\t\t\
    result ~= paren_count;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmbfkmq72.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x428435]

    ??:? void tmpmbfkmq72.__unittest_L50_C1() [0x428021]

    ??:? void tmpmbfkmq72.__modtest() [0x4281b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430ba0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43067d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc75]

    ??:? runModuleUnitTests [0x42cbe1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428884]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    while (i < paren_string.length)\n    {\n      \
    \  auto paren_count = 0;\n        while (paren_string[i] != ' ' && i < paren_string.length)\n\
    \        {\n            if (paren_string[i] == '(') \n                paren_count++;\n\
    \            i++;\n        }\n        result ~= paren_count;\n        while (paren_string[i]\
    \ == ' ' && i < paren_string.length) \n            i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_ejs_ewl.d(19): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42846e]

    ??:? long[] tmp_ejs_ewl.parse_nested_parens(immutable(char)[]) [0x427e5a]

    ??:? void tmp_ejs_ewl.__unittest_L31_C1() [0x427f43]

    ??:? void tmp_ejs_ewl.__modtest() [0x428140]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce07]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bc9a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b9c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430679]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc71]

    ??:? runModuleUnitTests [0x42cbdd]

    ??:? void rt.dmain2._d_run_main(int, char**, exter'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvo1zkdk1.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvo1zkdk1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tTuple!(uint,uint)[]\
    \ result = new Tuple!(uint,uint)[];\n\tforeach(paren_string.split(\" \"), sub_string\
    \ => \n\t{\n\t\tuint max_level = 0;\n\t\tuint level = 0;\n\t\tforeach(sub_string,\
    \ ch =>\n\t\t{\n\t\t\tif(ch == '(')\n\t\t\t{\n\t\t\t\tlevel += 1;\n\t\t\t\tmax_level\
    \ = max(max_level, level);\n\t\t\t}\n\t\t\telse if(ch == ')')\n\t\t\t{\n\t\t\t\
    \tlevel -= 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new Exception(\"Invalid\
    \ input string. Only '(' and ')' allowed\");\n\t\t\t}\n\t\t});\n\t\tresult ~=\
    \ tuple(max_level, level);\n\t});\n\treturn result.map!(a => a[0]);\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwbr_tc4y.d(15): Error: unexpected `(` in declarator

    /tmp/tmpwbr_tc4y.d(15): Error: basic type expected, not `" "`

    /tmp/tmpwbr_tc4y.d(15): Error: found `" "` when expecting `)`

    /tmp/tmpwbr_tc4y.d(15): Error: no identifier for declarator `paren_string.split(_error_)`

    /tmp/tmpwbr_tc4y.d(15): Error: found `)` when expecting `;`

    /tmp/tmpwbr_tc4y.d(15): Error: expression expected, not `,`

    /tmp/tmpwbr_tc4y.d(15): Error: found `sub_string` when expecting `)`

    /tmp/tmpwbr_tc4y.d(15): Error: found `=>` instead of statement

    /tmp/tmpwbr_tc4y.d(19): Error: no identifier for declarator `ch`

    /tmp/tmpwbr_tc4y.d(19): Error: found `=>` when expecting `;`

    /tmp/tmpwbr_tc4y.d(34): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmpwbr_tc4y.d(36): Error: declaration expected, not `)`

    /tmp/tmpwbr_tc4y.d(37): Error: declaration expected, not `return`

    /tmp/tmpwbr_tc4y.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbr_tc4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    paren_string=paren_string.replace(\"\
    (\", \" ( \");\n    paren_string=paren_string.replace(\")\", \" ) \");\n    auto\
    \ tokens=paren_string.split;\n    long[] op_parens_indices=typeof(tokens).init;\n\
    \    long[] cl_parens_indices=typeof(tokens).init;\n    foreach(idx, token; tokens)\n\
    \    {\n        if(token==\"(\")\n        {\n            op_parens_indices~=idx;\n\
    \        }\n        else if(token==\")\")\n        {\n            cl_parens_indices~=idx;\n\
    \        }\n    }\n    long[] levels=typeof(op_parens_indices).init;\n    foreach(idx,\
    \ op_paren_idx; op_parens_indices)\n    {\n        long cl_paren_idx=cl_parens_indices[idx];\n\
    \        long nesting_level=1;\n        foreach(cl_paren_idx_2; cl_parens_indices[idx+1..$])\n\
    \        {\n            if(cl_paren_idx_2<cl_paren_idx)\n            {\n     \
    \           nesting_level++;\n            }\n        }\n        levels~=nesting_level;\n\
    \    }\n    return levels;\n}\n/*\n    Given a list of words, output a list of\
    \ words such that each word is at most two positions away from the previous word.\n\
    \    If it is not possible to achieve this without breaking the list, return null.\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf54iunpp.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf54iunpp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    Input:\n        paren_string :: string -- Input string\n    Output:\n   \
    \     max_list :: long[]  -- List of longs representing the max depth of parentheses\
    \ for each group.\n    */\n    long[] max_list;\n    int count = 0;\n    long\
    \ max = 0;\n    foreach(char p; paren_string) \n    {\n        if(p == '(') \n\
    \        {\n            count++;\n            max = max(max, count);\n       \
    \ }\n        else if(p == ')') \n        {\n            count--;\n        }\n\
    \        else if(p == ' ') \n        {\n            max_list ~= max;\n       \
    \     max = 0;\n            count = 0;\n        }\n    }\n    max_list ~= max;\n\
    \    return max_list;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkx9qq3vd.d(28): Error: function expected before `()`, not `max`
    of type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkx9qq3vd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ n = paren_string.length;\n    int[long] max_depth;\n    string[long] groups;\n\
    \    long[] max_depths;\n    long s = 0;\n    long e = 0;\n    long i = 0;\n \
    \   int idx = 0;\n    int cur_depth = 0;\n    bool in_group = false;\n    long\
    \ max_depth_for_group = 0;\n    while (i < n) \n    {\n        if (paren_string[i]\
    \ == '(') \n        {\n            if (!in_group) \n            {\n          \
    \      s = i;\n                in_group = true;\n            }\n            cur_depth++;\n\
    \            max_depth_for_group = max(max_depth_for_group, cur_depth);\n    \
    \    } \n        else if (paren_string[i] == ')') \n        {\n            cur_depth--;\n\
    \        } \n        else if (paren_string[i] == ' ') \n        {\n          \
    \  if (in_group) \n            {\n                e = i;\n                groups[idx]\
    \ = paren_string[s..e];\n                max_depth[idx] = max_depth_for_group;\n\
    \                idx++;\n                max_depth_for_group = 0;\n          \
    \      in_group = false;\n            }\n        }\n        i++;\n    }\n    if\
    \ (in_group) \n    {\n        e = i;\n        groups[idx] = paren_string[s..e];\n\
    \        max_depth[idx] = max_depth_for_group;\n        idx++;\n    }\n    return\
    \ max_depth.values;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz16hejxy.d(35): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpz16hejxy.d(47): Error: cannot implicitly convert expression `max_depth_for_group`
    of type `long` to `int`

    /tmp/tmpz16hejxy.d(59): Error: cannot implicitly convert expression `max_depth_for_group`
    of type `long` to `int`

    /tmp/tmpz16hejxy.d(62): Error: cannot implicitly convert expression `values(max_depth)`
    of type `int[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz16hejxy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    import std.algorithm;\n    import std.conv;\n    import std.range;\n\
    \    import std.string;\n    import std.typecons;\n    import std.regex;\n   \
    \ // version 1\n    //long[] levels = paren_string.split(\" \").map!((group) =>\
    \ {return to!long(group.count(\"(\")) - to!long(group.count(\")\"));}).array;\n\
    \    //long[] levels = paren_string.split(\" \").map!((group) => {return group.count(\"\
    (\") - group.count(\")\");}).array;\n    long[] levels = paren_string.split(\"\
    \ \").map!((group) => \n    {\n        //return group.filter!(unaryFun!((x) =>\
    \ x == '(' || x == ')')).array.count(\"(\");\n        return group.filter!(unaryFun!((x)\
    \ => x == '(' || x == ')')).array.filter!(unaryFun!((x) => x == '(')).array.length;\n\
    \    }).array;\n    //static if (false)\n    {\n        //auto levels = paren_string.split(\"\
    \ \").map!((group) => \n        //{\n        //    return group.filter!(unaryFun!((x)\
    \ => x == '(' || x == ')')).array.filter!(unaryFun!((x) => x == '(')).array.length;\n\
    \        //}).array;\n    }\n    return levels;\n}\nlong[] parse_nested_parens_v2(string\
    \ paren_string) \n{\n    import std.array;\n    import std.algorithm;\n    import\
    \ std.conv;\n    import std.range;\n    import std.string;\n    import std.typecons;\n\
    \    import std.regex;\n    // version 2\n    long[] levels = paren_string.split(\"\
    \ \").map!((group) => {return group.count(\"(\") - group.count(\")\");}).array;\n\
    \    //return levels;\n    //static if (false)\n    {\n        auto levels = p\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_iqcy8x.d(53): Error: semicolon expected following auto declaration,
    not `unittest`

    /tmp/tmpo_iqcy8x.d(53): Error: found `unittest` instead of statement

    /tmp/tmpo_iqcy8x.d(61): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_iqcy8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  immutable\
    \ res = [];\n  immutable stack = [];\n  immutable max_count = 0;\n  foreach(const\
    \ curr_char; paren_string) \n  {\n    if(curr_char == '(') \n    {\n      stack\
    \ ~= curr_char;\n      max_count = max(max_count, stack.length);\n    } \n   \
    \ else if(curr_char == ')') \n    {\n      if(stack.length == 0) \n      {\n \
    \       throw new Exception(\"Parenthsis string is not balanced\");\n      }\n\
    \      stack.pop();\n    } \n    else if(curr_char == ' ') \n    {\n      res\
    \ ~= max_count;\n      max_count = 0;\n    }\n  }\n  return res;\n}\n \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8o9603ih.d(21): Error: cannot modify `immutable` expression `stack`

    /tmp/tmp8o9603ih.d(22): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp8o9603ih.d(30): Error: no property `pop` for type `immutable(void[])`

    /tmp/tmp8o9603ih.d(34): Error: cannot modify `immutable` expression `res`

    /tmp/tmp8o9603ih.d(35): Error: cannot modify `immutable` expression `max_count`

    /tmp/tmp8o9603ih.d(38): Error: cannot implicitly convert expression `res` of type
    `immutable(void[])` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8o9603ih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ temp_array = explode(paren_string);\n    auto array_list = map!(paren_string\
    \ => to!long(paren_string), temp_array);\n    auto max_list = map!(paren_string\
    \ => count_nesting(paren_string), temp_array);\n    return max_list;\n}\n// This\
    \ function is used to count the nesting level of parentheses.\nlong count_nesting(string\
    \ paren_string)\n{\n    long nested_level = 0;\n    long max_level = 0;\n    foreach(letter;\
    \ paren_string)\n    {\n        if(letter == '(')\n        {\n            nested_level\
    \ += 1;\n            if(nested_level > max_level)\n            {\n           \
    \     max_level = nested_level;\n            }\n        }\n        else if(letter\
    \ == ')')\n        {\n            nested_level -= 1;\n        }\n    }\n    return\
    \ max_level;\n}\n// --------> python code <----------\n// def parse_nested_parens(paren_string):\n\
    //     paren_array = paren_string.split(' ')\n//     return map(count_nesting,\
    \ paren_array)\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4fnmzybx.d(14): Error: undefined identifier `explode`

    /tmp/tmp4fnmzybx.d(15): Error: template instance `map!((paren_string) => to!long(paren_string),
    temp_array)` template `map` is not defined

    /tmp/tmp4fnmzybx.d(16): Error: template instance `map!((paren_string) => count_nesting(paren_string),
    temp_array)` template `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fnmzybx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren; paren_string.split)\n    {\n      \
    \  long max = 0L;\n        long cur = 0L;\n        foreach(c; paren)\n       \
    \ {\n            if(c == '(')\n            {\n                cur += 1L;\n   \
    \             max = max(max, cur);\n            }\n            else if(c == ')')\n\
    \            {\n                cur -= 1L;\n            }\n        }\n       \
    \ result ~= max;\n    }\n    return result;\n}\n// Uncomment to test.\nunittest\
    \ \n{\n    assert(parse_nested_parens(\"(()()) ((())) () ((())()())\") == [2L,\
    \ 3L, 1L, 3L]);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe7f9ryd_.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpe7f9ryd_.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7f9ryd_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ long[] arr;\n    foreach(paren_stack; split(paren_string))\n    {\n        long[]\
    \ stack;\n        foreach(c; paren_stack)\n        {\n            switch(c)\n\
    \            {\n                case '(':\n                    stack ~= 1;\n \
    \                   break;\n                case ')':\n                    assert(stack.length\
    \ > 0);\n                    stack.length -= 1;\n                    break;\n\
    \                default:\n                    assert(0);\n            }\n   \
    \     }\n        assert(stack.length == 0);\n        arr ~= paren_stack.length\
    \ - 1;\n    }\n    return arr;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26b6w573.d(15): Error: undefined identifier `split`

    /tmp/tmp26b6w573.d(36): Error: cannot implicitly convert expression `arr` of type
    `immutable(long[])` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26b6w573.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res;\n    char[] current_group;\n    foreach(current_group; paren_string.split)\n\
    \    {\n        long depth = 0;\n        long max_depth = 0;\n        foreach(char\
    \ c; current_group)\n        {\n            if(c == '(')\n            {\n    \
    \            depth += 1;\n                max_depth = max(max_depth, depth);\n\
    \            }\n            else if(c == ')')\n            {\n               \
    \ depth -= 1;\n            }\n        }\n        if(depth != 0)\n        {\n \
    \           writeln(\"Error: ill-formed paren-string\");\n            return res;\n\
    \        }\n        res ~= max_depth;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_r2tui8.d(16): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_r2tui8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto groups\
    \ = paren_string.split;\n\tlong[] result;\n\tfor (auto g; groups) \n\t{\n\t\t\
    long count = 0L;\n\t\tlong max = 0L;\n\t\tfor (auto c; g) \n\t\t{\n\t\t\tswitch\
    \ (c) \n\t\t\t{\n\t\t\t\tcase '(': count++; break;\n\t\t\t\tcase ')': count--;\
    \ max = max(max, count); break;\n\t\t\t}\n\t\t}\n\t\tresult ~= max;\n\t}\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpegcjtg5y.d(16): Error: no identifier for declarator `g`

    /tmp/tmpegcjtg5y.d(20): Error: no identifier for declarator `c`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpegcjtg5y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    auto\
    \ parens = split(paren_string, \" \");\n    long[] res;\n    for (; !parens.empty;\
    \ parens.popFront)\n    {\n        // This one counts the parentheses in a single\
    \ group.\n        long counter = 0L;\n        long ans = 0L;\n        for (; !parens.front.empty;\
    \ parens.front.popFront)\n        {\n            if (parens.front.front == '(')\n\
    \            {\n                ++counter;\n                ans = max(ans, counter);\n\
    \            }\n            else if (parens.front.front == ')')\n            {\n\
    \                --counter;\n            }\n        }\n        res ~= ans;\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb4ni2b61.d(14): Error: undefined identifier `split`

    /tmp/tmpb4ni2b61.d(26): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4ni2b61.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ paren_count = [];\n\tlong c = 0L;\n\t//char[] parsed = paren_string.toCharArray();\n\
    \tfor (long i = 0L; i < paren_string.length; i++) \n\t{\n\t\tif (paren_string[i]\
    \ == '(') \n\t\t{\n\t\t\tc++;\n\t\t}\n\t\telse if (paren_string[i] == ')') \n\t\
    \t{\n\t\t\tc--;\n\t\t}\n\t\telse if (paren_string[i] == ' ') \n\t\t{\n\t\t\tparen_count\
    \ ~= c;\n\t\t\tc = 0L;\n\t\t}\n\t}\n\treturn paren_count;\n}\n/*\n * Function\
    \ to reverse the order of elements in the linked list.\n * >>> reverse_linked_list(toLinkedList([1,\
    \ 2, 3, 4, 5]))\n * LinkedList!(int)(5, 4, 3, 2, 1)\n */\nLinkedList!(T) reverse_linked_list(LinkedList!(T)\
    \ list) \n{\n\tLinkedList!(T) rev_list = null;\n\tfor (T element; !list.empty;\
    \ list.popFront()) \n\t{\n\t\telement = list.front;\n\t\trev_list.pushFront(element);\n\
    \t}\n\treturn rev_list;\n}\n/*\n * Function to return the greatest common divisor\
    \ of two integers.\n * >>> greatest_common_divisor(9, 12)\n * 3\n */\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptd9szpga.d(40): Error: template instance `LinkedList!T` template
    `LinkedList` is not defined

    /tmp/tmptd9szpga.d(40): Error: template instance `LinkedList!T` template `LinkedList`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptd9szpga.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // TODO:\
    \ add your code here\n    long[] result;\n    string[] paren_strings = split(paren_string,\
    \ \" \");\n    int length = paren_strings.length;\n    for (int i = 0; i < length;\
    \ i++)\n    {\n        string paren_string = paren_strings[i];\n        int level\
    \ = 0;\n        int max = 0;\n        int index = 0;\n        while (index < paren_string.length)\n\
    \        {\n            if (paren_string[index] == '(')\n            {\n     \
    \           level++;\n                if (level > max)\n                {\n  \
    \                  max = level;\n                }\n            }\n          \
    \  else if (paren_string[index] == ')')\n            {\n                level--;\n\
    \            }\n            index++;\n        }\n        result ~= max;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmf17hqte.d(16): Error: undefined identifier `split`

    /tmp/tmpmf17hqte.d(17): Error: cannot implicitly convert expression `paren_strings.length`
    of type `ulong` to `int`

    /tmp/tmpmf17hqte.d(20): Error: variable `paren_string` is shadowing variable `tmpmf17hqte.parse_nested_parens.paren_string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmf17hqte.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[0];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xuocj63.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xuocj63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ deepest = new long[paren_string.countSpaces() + 1];\n    string t = replace(paren_string,\
    \ \" \", \"\");\n    foreach (c; t) \n    {\n        static if (c == '(') \n \
    \       {\n            static int i = 0;\n            static int level = 0;\n\
    \            level++;\n            if (level > deepest[i])\n                deepest[i]\
    \ = level;\n        }\n        else if (c == ')') \n        {\n            level--;\n\
    \            if (level == 0)\n                i++;\n        }\n    }\n    return\
    \ deepest;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36lobvvc.d(14): Error: no property `countSpaces` for type `string`

    /tmp/tmp36lobvvc.d(15): Error: undefined identifier `replace`

    /tmp/tmp36lobvvc.d(16): Error: variable `__r73` cannot be read at compile time

    /tmp/tmp36lobvvc.d(18):        while evaluating c.init

    /tmp/tmp36lobvvc.d(28): Error: undefined identifier `level`

    /tmp/tmp36lobvvc.d(29): Error: undefined identifier `level`

    /tmp/tmp36lobvvc.d(30): Error: undefined identifier `i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36lobvvc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// Convert\
    \ string to char array\n\tauto paren_char = paren_string.array;\n\t// Initialize\
    \ deque\n\tauto parse_parens = deque!long();\n\t// Initialize current nested parenthesis\
    \ level\n\tlong curr_level = 0;\n\t// Iterate over char array\n\tforeach(ch; paren_char)\n\
    \t{\n\t\t// switch statement to do the following:\n\t\t// \t1. if we encounter\
    \ (, increment the current level by 1\n\t\t// \t2. if we encounter ), decrease\
    \ the current level by 1\n\t\t// \t3. if we encounter space, store the value of\
    \ current level and reset the current level to 0\n\t\tswitch(ch)\n\t\t{\n\t\t\t\
    case '(':\n\t\t\t\tcurr_level++;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tcurr_level--;\n\
    \t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tparse_parens.insertBack(curr_level);\n\
    \t\t\t\tcurr_level = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t// return tuple of the\
    \ deque\n\treturn tuple(parse_parens);\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpva35nwhq.d(15): Error: no property `array` for type `string`

    /tmp/tmpva35nwhq.d(17): Error: template instance `deque!long` template `deque`
    is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpva35nwhq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // Use\
    \ assert to make sure the input string is valid\n  assert(paren_string.filter!((c)\
    \ => c == '(' || c == ')').empty);\n  \n  // Split the string by space and get\
    \ a list of groups\n  auto groups = paren_string.split;\n  \n  // Iterate over\
    \ each group\n  return groups.map!((string group) => {\n      // Initialize max_level\
    \ to zero\n      long max_level = 0L;\n      // Initialize current_level to zero\n\
    \      long current_level = 0L;\n      // Iterate over the characters in the group\n\
    \      foreach (char ch; group) \n      {\n          // If the character is an\
    \ open paren, increment the current_level by 1\n          if (ch == '(') \n  \
    \        {\n              current_level++;\n          }\n          // If the character\
    \ is a close paren, decrement the current_level by 1\n          else if (ch ==\
    \ ')') \n          {\n              current_level--;\n          }\n          //\
    \ Make sure current_level doesn't go below zero\n          assert(current_level\
    \ >= 0L);\n          // Update max_level if needed\n          max_level = max(max_level,\
    \ current_level);\n      }\n      // Make sure all parens are closed for the group\n\
    \      assert(current_level == 0L);\n      // Return the max_level for the group\n\
    \      return max_level;\n  }).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfli6eeqh.d(15): Error: no property `filter` for type `string`

    /tmp/tmpfli6eeqh.d(18): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfli6eeqh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tenum NestedParentheses\
    \ { left, right, other }\n\tenum ParenthesesGroupType { empty, paren }\n\t\n\t\
    // Peek at the iterator, but don't advance it\n\tchar peek(R)(R r)\n\t{\n\t\t\
    auto c = r.front;\n\t\treturn c;\n\t}\n\t\n\t// Advance iterator and return the\
    \ peeked at character\n\tchar adv(R)(ref R r)\n\t{\n\t\tauto c = r.front;\n\t\t\
    r.popFront();\n\t\treturn c;\n\t}\n\t\n\t// Get the next parentheses group\n\t\
    template getNextParenthesesGroup(R)\n\t{\n\t\tstatic if (is(ElementType!R == dchar))\n\
    \t\t{\n\t\t\tParenthesesGroupType getNextParenthesesGroup(R)(ref R r)\n\t\t\t\
    {\n\t\t\t\tauto n = 0;\n\t\t\t\twhile (!r.empty)\n\t\t\t\t{\n\t\t\t\t\tconst c\
    \ = adv(r);\n\t\t\t\t\tstatic if (is(NestedParentheses.other : c))\n\t\t\t\t\t\
    {\n\t\t\t\t\t\tif (c == '(')\n\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\telse if (c == ')')\n\
    \t\t\t\t\t\t\tn--;\n\t\t\t\t\t}\n\t\t\t\t\tif (c == ' ' || n < 0)\n\t\t\t\t\t\t\
    break;\n\t\t\t\t}\n\t\t\t\treturn n == 0 ? ParenthesesGroupType.empty :\n\t\t\t\
    \t\tn > 0 ? ParenthesesGroupType.paren : ParenthesesGroupType.empty;\n\t\t\t}\n\
    \t\t}\n\t\telse static if (is(ElementType!R == char))\n\t\t{\n\t\t\tParenthesesGroupType\
    \ getNextParenthesesGroup(R)(ref R r)\n\t\t\t{\n\t\t\t\tauto n = 0;\n\t\t\t\t\
    while (!r.empty)\n\t\t\t\t{\n\t\t\t\t\tconst c = adv(r);\n\t\t\t\t\tstatic if\
    \ (is(NestedParentheses.other : c))\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt9zd8s0g.d(66): Error: found `unittest` instead of statement

    /tmp/tmpt9zd8s0g.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpt9zd8s0g.d(74): Error: matching `}` expected, not `End of File`

    /tmp/tmpt9zd8s0g.d(74): Error: matching `}` expected, not `End of File`

    /tmp/tmpt9zd8s0g.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt9zd8s0g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[];\n    paren_string.split(\" \").each!(input =>\n       \
    \ levels ~= deep_nesting_level(input)\n    );\n    return levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_vbyzufu.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp_vbyzufu.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vbyzufu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ ret = [];\n    for (i, part; paren_string.splitWhitespace.indexOf(part, i))\n\
    \    {\n        assert(part.startsWith(\"(\") && part.endsWith(\")\"));\n    \
    \    int count = 0;\n        int max = 0;\n        for (ch; part)\n        {\n\
    \            if (ch == '(')\n                count++;\n            else\n    \
    \            count--;\n            max = max(max, count);\n        }\n       \
    \ ret ~= max;\n    }\n    return ret;\n}\n// https://www.hackerrank.com/challenges/ctci-ransom-note/problem\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7j4cmsnd.d(15): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp7j4cmsnd.d(20): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmp7j4cmsnd.d(28): Error: found `ret` when expecting `)`

    /tmp/tmp7j4cmsnd.d(28): Error: found `~=` instead of statement

    /tmp/tmp7j4cmsnd.d(30): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7j4cmsnd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ result = new long[](paren_string.count(\" \")+1);\n    auto i = 0L;\n    auto\
    \ token = \"\";\n    foreach(token; split(paren_string, \" \"))\n    {\n     \
    \   auto max_depth = 0L;\n        auto depth = 0L;\n        foreach(c; token)\n\
    \        {\n            if(c == '(')\n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(c == ')')\n            {\n                depth--;\n            }\n\
    \        }\n        result[i++] = max_depth;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgk9o_lr4.d(14): Error: no property `count` for type `string`

    /tmp/tmpgk9o_lr4.d(17): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgk9o_lr4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\treturn\
    \ paren_string.\n\t\tsplit().\n\t\tmap!(p => \n\t\t{\n\t\t\tlong nest_level =\
    \ 0L;\n\t\t\tforeach(char c; p)\n\t\t\t{\n\t\t\t\tnest_level += (c == '(') ? 1L\
    \ : -1L;\n\t\t\t}\n\t\t\treturn nest_level;\n\t\t}\n\t).array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy5lbh7ff.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5lbh7ff.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ nesting_count;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp12fx8ydq.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp12fx8ydq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_stack;\n    long[] paren_levels;\n    long max_level;\n    paren_stack\
    \ = [];\n    paren_levels = [];\n    max_level = 0L;\n    foreach (c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            paren_stack ~= 1L;\n\
    \            max_level += 1L;\n        }\n        else if (c == ')') \n      \
    \  {\n            max_level -= 1L;\n            paren_stack ~= 0L;\n        }\n\
    \        else if (c == ' ') \n        {\n            paren_levels ~= max_level;\n\
    \            paren_stack = [];\n            max_level = 0L;\n        }\n    }\n\
    \    paren_levels ~= max_level;\n    paren_stack = [];\n    max_level = 0L;\n\
    \    return paren_levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeomtmpwz.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284bd]

    ??:? void tmpeomtmpwz.__unittest_L44_C1() [0x4280a9]

    ??:? void tmpeomtmpwz.__modtest() [0x42823c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ce93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bd26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430779]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c28]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430705]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bcfd]

    ??:? runModuleUnitTests [0x42cc69]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42890c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvo1zkdk1.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvo1zkdk1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_list;\n    foreach(paren_group; paren_string.split())\n    {\n       \
    \ int previous_depth = 0;\n        int current_depth = 0;\n        foreach(c;\
    \ paren_group)\n        {\n            if(c == '(')\n            {\n         \
    \       ++current_depth;\n            }\n            else if(c == ')')\n     \
    \       {\n                --current_depth;\n            }\n            previous_depth\
    \ = max(previous_depth, current_depth);\n        }\n        paren_list ~= previous_depth;\n\
    \    }\n    return paren_list;\n}\nimport std.algorithm : map;\nassert([\"2\"\
    , \"3\", \"1\", \"3\"] ==\n    parse_nested_parens(\"(()()) ((())) () ((())()())\"\
    ).map!(to!string));\n \n/*\n    Given two numbers A and B, output 1 if bitwise\
    \ and of A and B is greater than bitwise or of A and B, else 0.\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbi2xjq1d.d(36): Error: declaration expected, not `assert`

    /tmp/tmpbi2xjq1d.d(39): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbi2xjq1d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ stack = Stack!char(16);\n    long[] output;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        stack.clear();\n        size_t max_stack_size = 0;\n \
    \       foreach (paren; paren_group) \n        {\n            if (paren == '(')\
    \ \n            {\n                stack.push(paren);\n                if (stack.length\
    \ > max_stack_size)\n                    max_stack_size = stack.length;\n    \
    \        }\n            else if (paren == ')') \n            {\n             \
    \   if (stack.length > 0)\n                    stack.pop();\n            }\n \
    \       }\n        output ~= max_stack_size;\n    }\n    return output;\n}\n//\
    \ import std.stdio;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfsid8r_.d(14): Error: template instance `Stack!char` template
    `Stack` is not defined

    /tmp/tmpbfsid8r_.d(16): Error: no property `split` for type `string`

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    size_t[int]\
    \ stack = new size_t[int];\n    long[] depth = new long[];\n    stack.length =\
    \ paren_string.length;\n    stack.length = 0;\n    char[] chars = paren_string.dup;\n\
    \    foreach (size_t i, char ch; chars) \n    {\n        if (ch == '(') \n   \
    \     {\n            stack ~= i;\n        }\n        else if (ch == ')') \n  \
    \      {\n            size_t idx = stack.pop;\n            if (stack.length ==\
    \ 0) \n            {\n                depth ~= i - idx + 1;\n            }\n \
    \       }\n    }\n    return depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi5pvr81n.d(14): Error: need size of rightmost array, not type `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5pvr81n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split.map!((s) => s.filter!(ch => ch == '(').length - s.filter!(ch\
    \ => ch == ')').length).filter!(p => p == 0).map!(m => {auto v = m.to!(ulong);return\
    \ ulong.max(v, 0L);});\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkxrjyd0_.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkxrjyd0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Starting\
    \ and ending indices of the substrings within paren_string that do not contain\
    \ ' '.\n    // These substrings contain the groups to be parsed.\n    int[] sub_paren_ranges\
    \ = [0];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1zizykwk.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1zizykwk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = paren_string.split(\" \");\n    return parens.map!((string p) =>\n\
    \    {\n        long max_level = 0;\n        long current_level = 0;\n       \
    \ foreach(ch; p)\n        {\n            switch(ch)\n            {\n         \
    \       case '(':\n                    ++current_level;\n                    max_level\
    \ = max(max_level, current_level);\n                    break;\n             \
    \   case ')':\n                    --current_level;\n                    break;\n\
    \            }\n        }\n        return max_level;\n    }).array;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2bb4bou4.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2bb4bou4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i, previous_ending_brace;\n    int paren_idx;\n    uint paren_string_size;\n\
    \    // We will store the position of the left parentheses and of the ending brace\n\
    \    //   in two arrays.\n    // The size of the second array is one more than\
    \ the first one to handle the special case\n    //   when the last parenthesis\
    \ doesn't have a closing brace (no closing brace).\n    uint[] start_paren_idx_array;\n\
    \    uint[] end_paren_idx_array;\n    bool is_previous_parenthesis_open;\n   \
    \ int previous_open_paren_idx;\n    uint start_paren_idx_array_size;\n    uint[]\
    \ start_paren_idx_array_temp;\n    uint[] end_paren_idx_array_temp;\n    uint\
    \ level;\n    uint[] level_array;\n    uint[] level_array_temp;\n    bool is_paren_string_empty;\n\
    \    // Check if the string is empty.\n    is_paren_string_empty = true;\n   \
    \ i = 0;\n    while(i < paren_string.length) \n    {\n        if(paren_string[i]\
    \ != ' ') \n        {\n            is_paren_string_empty = false;\n          \
    \  break;\n        }\n        i += 1;\n    }\n    if(is_paren_string_empty) \n\
    \    {\n        return [];\n    }\n    // Allocate memory for the two arrays\n\
    \    start_paren_idx_array = new uint[paren_string.length];\n    end_paren_idx_array\
    \ = new uint[paren_string.length + 1L];\n    //\n    //   Go through the string\
    \ and store the position of the left parentheses and of the ending brace\n   \
    \ //   in two arrays.\n    //\n    //   Note that we assume there is at least\
    \ one parenthesis in the string.\n    start_paren_idx_array_size = 0UL;\n    is_previous_parenthesis_open\
    \ = false;\n    previous_open_paren_idx = -1;\n    i = 0;\n    while(i < paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbdf1xkg.d(62): Error: found `unittest` when expecting `)`

    /tmp/tmpnbdf1xkg.d(70): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbdf1xkg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting_levels = new long[];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5jttvi29.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jttvi29.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels;\n    int n = 0;\n    int parenthesis_depth = 0;\n    int parenthesis_start\
    \ = 0;\n    int parenthesis_end = 0;\n    long paren_count = 0;\n    foreach(i,\
    \ char c; paren_string) \n    {\n        if (c == '(') \n        {\n         \
    \   parenthesis_depth++;\n            paren_count++;\n            if (parenthesis_depth\
    \ == 1) \n            {\n                parenthesis_start = i;\n            }\n\
    \        } \n        else if (c == ')') \n        {\n            parenthesis_depth--;\n\
    \            if (parenthesis_depth == 0) \n            {\n                levels\
    \ ~= count_nested_parens(paren_string[parenthesis_start..i]);\n            }\n\
    \        }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7f_t5i1j.d(28): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp7f_t5i1j.d(36): Error: undefined identifier `count_nested_parens`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7f_t5i1j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split(' ').map!(g => \n                                       \
    \     g.filter!(p => p == '(' || p == ')')\n                                 \
    \            .to!string()\n                                             .length);\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdixtn23h.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdixtn23h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_levels = new long[];\n    long level = 0;\n    foreach(ch; paren_string)\n\
    \    {\n        if(ch == '(')\n        {\n            level++;\n        }\n  \
    \      else if(ch == ')')\n        {\n            paren_levels ~= level;\n   \
    \         level--;\n        }\n    }\n    return paren_levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9jzv6txc.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9jzv6txc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // define\
    \ a template that contains the information needed to parse the parens\n    struct\
    \ Parens\n    {\n        string paren_string;\n        int position;\n       \
    \ int depth;\n        long[] groups;\n    }\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_rggxjw.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_rggxjw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ map!(paren_string, (s) => paren_string.length);\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwd19c1f.d(14): Error: template instance `map!(paren_string, (s)
    => paren_string.length)` template `map` is not defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwd19c1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Find\
    \ first open bracket\n    int i = 0;\n    while (paren_string[i] != '(')\n   \
    \ {\n        i++;\n    }\n    // Create tuple\n    Tuple!(long, long) longest\
    \ = Tuple!(long, long)(1, 0);\n    long level = 1;\n    bool open = true;\n  \
    \  long last_i = i;\n    // Read until end of string\n    while (i < paren_string.length)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            if (open)\n\
    \            {\n                level++;\n            }\n            else\n  \
    \          {\n                level = 1;\n                open = true;\n     \
    \       }\n        }\n        else if (paren_string[i] == ')')\n        {\n  \
    \          if (open)\n            {\n                open = false;\n         \
    \       if (level > longest[0])\n                {\n                    longest\
    \ = Tuple!(long, long)(level, last_i);\n                }\n            }\n   \
    \         else\n            {\n                level--;\n            }\n     \
    \   }\n        else if (paren_string[i] == ' ')\n        {\n            // Recursive\
    \ call\n            if (!open)\n            {\n                return parse_nested_parens(paren_string[last_i\
    \ .. i]);\n            }\n        }\n        i++;\n    }\n    // Return tuple\n\
    \    return longest;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph268igx6.d(66): Error: cannot implicitly convert expression `longest`
    of type `Tuple!(long, long)` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph268igx6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ max_nesting = 0;\n    int curr_nesting = 0;\n    auto result = Appender!(long[])();\n\
    \    foreach(ch; paren_string)\n    {\n        if(ch == '(')\n        {\n    \
    \        curr_nesting++;\n            max_nesting = max(max_nesting, curr_nesting);\n\
    \        }\n        else if(ch == ')')\n        {\n            if(curr_nesting\
    \ > 0)\n            {\n                curr_nesting--;\n            }\n      \
    \      else\n            {\n                result.put(0L);\n                curr_nesting\
    \ = 0;\n                max_nesting = 0;\n            }\n        }\n        else\
    \ if(ch == ' ')\n        {\n            result.put(max_nesting);\n           \
    \ curr_nesting = 0;\n            max_nesting = 0;\n        }\n    }\n    if(curr_nesting\
    \ == 0)\n    {\n        result.put(max_nesting);\n    }\n    else\n    {\n   \
    \     result.put(0L);\n    }\n    return result.data;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzfluqhy1.d(16): Error: template instance `Appender!(long[])` template
    `Appender` is not defined

    /tmp/tmpzfluqhy1.d(22): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzfluqhy1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.format;\n    import std.array;\n    import std.typecons;\n    import std.conv;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.range.primitives;\n\
    \    import std.string;\n    import std.functional;\n    import std.typecons;\n\
    \    import std.stdio;\n    import std.bigint;\n    import std.math;\n    import\
    \ std.range;\n    import std.exception;\n    import std.digest.sha;\n    import\
    \ std.digest.crc;\n    import std.digest.hmac;\n    import std.digest.md;\n  \
    \  import std.digest.blake2;\n    import std.digest.whirlpool;\n    import std.digest.tiger;\n\
    \    import std.digest.sha2;\n    import std.digest.md5;\n    import std.array;\n\
    \    import std.algorithm;\n    import std.datetime;\n    import std.string;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.range;\n\
    \    import std.range;\n    import std.range;\n    import std.range;\n    import\
    \ std.range;\n    import std.range;\n    import std.range;\n    import std.\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8505qx05.d(80): Error: identifier expected following `package`

    /tmp/tmp8505qx05.d(80): Error: `;` expected

    /tmp/tmp8505qx05.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8505qx05.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[];\n\tstring[] groups = paren_string.split(\" \");\n\tforeach(string\
    \ group; groups)\n\t{\n\t\tlong current_depth = 0L;\n\t\tlong max_depth = 0L;\n\
    \t\tforeach(char ch; group)\n\t\t{\n\t\t\tcurrent_depth += ch == '(' ? 1L : -1L;\n\
    \t\t\tmax_depth = max(max_depth, current_depth);\n\t\t}\n\t\tresult ~= max_depth;\n\
    \t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr_92xi4y.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpr_92xi4y.d(15): Error: no property `split` for type `string`

    /tmp/tmpr_92xi4y.d(23): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_92xi4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ split = paren_string.split;\n    return split.map!(p => {\n        return p.count(c\
    \ => c == '(') + 1L;\n    }).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ziwr_dh.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ziwr_dh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return(paren_string.split().map!(s\
    \ => s.strip(\"()\").count(\"()\") + 1).array);\n}\n \n/*\n Write a function that\
    \ takes a string of words separated by spaces and returns a new string\n with\
    \ each word reversed. For example, `reverse_words(\"Hello world!\")` should return\
    \ `\"olleH !dlrow\"`.\n \n*/\nstring reverse_words(string words) \n{\n    return(words.split().map!(s\
    \ => s.reverse).join(\" \"));\n}\n/*\nThis function takes as input a string of\
    \ words separated by spaces.\n    The function returns true if the sentence is\
    \ a palindrome, false otherwise.\n    A palindrome is a sequence of characters\
    \ which is the same when read backwards.\n    All punctuation should be ignored\
    \ when determining whether a sentence is a palindrome.\n    Example:\n    >>>\
    \ is_palindrome(\"Are we not drawn onward, we few, drawn onward to new era?\"\
    )\n    true\n    >>> is_palindrome(\"Sore was I ere I saw Eros.\")\n    true\n\
    \    >>> is_palindrome(\"Never odd or even.\")\n    true\n    >>> is_palindrome(\"\
    Hello world!\")\n    false\n*/\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpirsxd4rd.d(14): Error: no property `split` for type `string`

    /tmp/tmpirsxd4rd.d(24): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpirsxd4rd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Split\
    \ the input string by space and get a list of string\n    immutable(string[])\
    \ paren_splits = paren_string.split();\n    auto paren_levels = paren_splits.map!(paren_level)();\n\
    \    // Get the deepest level of nesting of parentheses for each string\n    return\
    \ paren_levels.array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6picymmb.d(15): Error: no property `split` for type `string`

    /tmp/tmp6picymmb.d(16): Error: no property `map` for type `immutable(string[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6picymmb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Split\
    \ into groups\n    string[] groups = paren_string.split();\n    long n_groups\
    \ = groups.length;\n    // Create a tuple of max depth and its corresponding indices\
    \ in the original string\n    auto[] max_depths = new Tuple!(long,string[])();\n\
    \    foreach(string group; groups)\n    {\n        long max_depth = 0L;\n    \
    \    string[] idx_depth = new string[2];\n        ulong len = group.length;\n\
    \        // Keep count of the number of parens encountered\n        long stack_counter\
    \ = 0L;\n        // Keep track of the indices of parens of max depth\n       \
    \ string[] max_idx = [];\n        for(ulong i = 0; i < len; i++)\n        {\n\
    \            if(group[i] == '(')\n            {\n                stack_counter++;\n\
    \                if(stack_counter > max_depth)\n                {\n          \
    \          max_depth = stack_counter;\n                    max_idx = [];\n   \
    \                 max_idx ~= to!string(i);\n                }\n              \
    \  else if(stack_counter == max_depth)\n                {\n                  \
    \  max_idx ~= to!string(i);\n                }\n            }\n            else\
    \ if(group[i] == ')')\n            {\n                stack_counter--;\n     \
    \       }\n        }\n        idx_depth[0] = to!string(max_depth);\n        idx_depth[1]\
    \ = join(max_idx,\",\");\n        max_depths ~= tuple(max_depth,max_idx);\n  \
    \  }\n    return max_depths.tupleof[0];\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpye7t6d20.d(18): Error: basic type expected, not `[`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpye7t6d20.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ zip(\"(\"~paren_string~\")\").map!((x) {return maxElement(scan!(\"(\" ~ c.retreat\
    \ ~ \")\")(\"(\"~x~\")\"));}).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6iwd1kpr.d(14): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6iwd1kpr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  auto parens\
    \ = split(paren_string, \" \");\n  auto result = new long[parens.length];\n  foreach\
    \ (i, paren; parens) \n  {\n    long max_paren_depth = 0;\n    long paren_depth\
    \ = 0;\n    foreach (c; paren) \n    {\n      switch (c) \n      {\n        case\
    \ '(': \n          ++paren_depth;\n          max_paren_depth = max(max_paren_depth,\
    \ paren_depth);\n          break;\n        case ')':\n          --paren_depth;\n\
    \          break;\n      }\n    }\n    assert(paren_depth == 0);\n    result[i]\
    \ = max_paren_depth;\n  }\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplo4x_jtj.d(14): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplo4x_jtj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = paren_string.split(\" \");\n    return parens.map!(paren => paren.walkLength).array;\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the deepest level of nesting\n    >>> parse_parens(\"(()()) ((())) () ((())()())\"\
    )\n    3L\n*/\nlong parse_parens(string paren_string)\n{\n    return max(parse_nested_parens(paren_string));\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the number of groups with maximum nesting level\n    >>> parse_parens(\"(()())\
    \ ((())) () ((())()())\")\n    3L\n*/\nlong count_parens(string paren_string)\n\
    {\n    return count(parse_nested_parens(paren_string), max(parse_nested_parens(paren_string)));\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the index (indexed from 1) \n    of the group with maximum nesting level\n \
    \   >>> parse_parens(\"(()()) ((())) () ((())()())\")\n    2L\n*/\nlong count_parens(string\
    \ paren_string)\n{\n    return count(parse_nested_parens(paren_string), max(parse_nested_parens(paren_string)));\n\
    }\n \n/*\n Define a function that takes a list of nested parentheses and ouputs\
    \ the index (indexed from 1) \n    of the group with maximum nesting level\n \
    \   >>> parse_parens(\"(()()) ((())) () ((())()())\")\n    2L\n*/\nlong find_parens(string\
    \ paren_string)\n{\n    auto parens = paren_string.split(\" \");\n    auto paren_array\
    \ = parens.map!(paren => paren.walkLength).array;\n    return find(paren_array,\
    \ max(paren_array)) + 1;\n}\n \n/*\n Define a function that takes a list of nested\
    \ parentheses and ouputs the index (indexed from 1) \n   \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpho90cmon.d(62): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpho90cmon.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm : map;\n    import std.algorithm : reduce;\n    import std.functional\
    \ : max;\n    import std.range : iota;\n    import std.range : zip;\n    import\
    \ std.stdio : writeln;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    string[] s = paren_string.split(\" \");\n    return s.map!(x =>\
    \ \n        x.zip(iota(0)).map!(p => p[0] == '(' ? p[1] : -p[1])\n           \
    \ .reduce!max(0)).array;\n}\n \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1yucl8vj.d(16): Error: module `std.functional` import `max` not
    found

    /tmp/tmp1yucl8vj.d(22): Error: no property `split` for type `string`

    /tmp/tmp1yucl8vj.d(25): Error: no property `array` for type `MapResult!(__lambda2,
    string[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1yucl8vj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    static\
    \ int __f = '(';\n    static int __b = ')';\n    static int __s = ' ';\n    long[]\
    \ result;\n    int i = 0;\n    int count = 0;\n    int max = 0;\n    int check\
    \ = 0;\n    for (; i < paren_string.length; ++i) \n    {\n        if (paren_string[i]\
    \ == __f) \n        {\n            ++count;\n            if (count > max) \n \
    \           {\n                max = count;\n            }\n        }\n      \
    \  else if (paren_string[i] == __b) \n        {\n            --count;\n      \
    \  }\n        else if (paren_string[i] == __s) \n        {\n            result\
    \ ~= max;\n            max = 0;\n            count = 0;\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5b8aj7ad.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x42854d]

    ??:? void tmp5b8aj7ad.__unittest_L45_C1() [0x42813d]

    ??:? void tmp5b8aj7ad.__modtest() [0x4282d0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cf97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42be2a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43087d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430809]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be01]

    ??:? runModuleUnitTests [0x42cd6d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a10]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ groups = paren_string.split;\n    long[] ans;\n    foreach( auto g; groups )\n\
    \    {\n        int count = 0;\n        int max_count = 0;\n        foreach( auto\
    \ c; g )\n        {\n            if( c == '(' )\n                count += 1;\n\
    \            else if( c == ')' )\n                count -= 1;\n            if(\
    \ count > max_count )\n                max_count = count;\n        }\n       \
    \ ans ~= max_count;\n    }\n    return ans;\n}\n/*\n Parses the given string which\
    \ should contain a set of integers separated by spaces.\n    >>> parse_integers(\"\
    1 2 1 0 0 2\")\n    [1L, 2L, 1L, 0L, 0L, 2L]\n    \n*/\nlong[] parse_integers(string\
    \ input) \n{\n    long[] ans;\n    auto ints = input.split;\n    foreach( auto\
    \ i; ints )\n        ans ~= i.to!long;\n    return ans;\n}\n/*\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprij37tt7.d(16): Error: basic type expected, not `auto`

    /tmp/tmprij37tt7.d(16): Error: no identifier for declarator `_error_`

    /tmp/tmprij37tt7.d(16): Error: found `auto` when expecting `;`

    /tmp/tmprij37tt7.d(16): Error: found `;` when expecting `)`

    /tmp/tmprij37tt7.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmprij37tt7.d(20): Error: basic type expected, not `auto`

    /tmp/tmprij37tt7.d(20): Error: no identifier for declarator `_error_`

    /tmp/tmprij37tt7.d(20): Error: found `auto` when expecting `;`

    /tmp/tmprij37tt7.d(20): Error: found `;` when expecting `)`

    /tmp/tmprij37tt7.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmprij37tt7.d(43): Error: basic type expected, not `auto`

    /tmp/tmprij37tt7.d(43): Error: no identifier for declarator `_error_`

    /tmp/tmprij37tt7.d(43): Error: found `auto` when expecting `;`

    /tmp/tmprij37tt7.d(43): Error: found `;` when expecting `)`

    /tmp/tmprij37tt7.d(43): Error: found `)` when expecting `;` following statement

    /tmp/tmprij37tt7'
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ tokens = paren_string.split;\n    long[] max_depth = new long[tokens.length];\n\
    \    int i = 0;\n    foreach(token; tokens) \n    {\n        long depth = 0L;\n\
    \        max_depth[i] = 0L;\n        foreach(char c; token) \n        {\n    \
    \        if(c == '(')\n                depth++;\n            else if(c == ')')\n\
    \                depth--;\n            max_depth[i] = max(max_depth[i], depth);\n\
    \        }\n        i++;\n    }\n    return max_depth;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4ljluw5.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4ljluw5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.regex;\n    auto matches\
    \ = paren_string.match(regex(r\"\\((.*?)\\)\"));\n    auto counts = matches.map!((Match!(string)\
    \ m) => \n    {\n        size_t max_count = 0;\n        size_t count = 0;\n  \
    \      foreach(c; m.matched())\n        {\n            if(c == '(')\n        \
    \        count++;\n            else if(c == ')')\n                count--;\n \
    \           max_count = max(max_count, count);\n        }\n        return max_count;\n\
    \    });\n    return counts.array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi5r1i954.d(18): Error: template instance `Match!string` template
    `Match` is not defined, did you mean match(R, RegEx)(R input, RegEx re) if (isSomeString!R
    && isRegexFor!(RegEx, R))?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5r1i954.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164107
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /* Stack\
    \ for keeping a track of the maximum number of\n       nested parentheses seen\
    \ so far\n    */\n    Stack!(long[]) max_depth_stack;\n    /* Stack for keeping\
    \ a track of the current nesting\n       depth in each of the groups.\n    */\n\
    \    Stack!(long[]) depth_stack;\n    foreach (index, elem; paren_string.split)\
    \ \n    {\n        // Open bracket found\n        if (elem == '(') \n        {\n\
    \            depth_stack.push(1);\n            if (max_depth_stack.empty) \n \
    \           {\n                max_depth_stack.push(1);\n            } \n    \
    \        else \n            {\n                auto max_depth = max_depth_stack.pop;\n\
    \                max_depth_stack.push(max_depth);\n                max_depth_stack.push(max_depth\
    \ + 1);\n            }\n        } \n        else if (elem == ')') \n        {\n\
    \            auto depth = depth_stack.pop;\n            if (depth_stack.empty)\
    \ \n            {\n                max_depth_stack.push(depth);\n            }\
    \ \n            else \n            {\n                auto max_depth = max_depth_stack.pop;\n\
    \                max_depth_stack.push(max_depth);\n                depth_stack.push(depth\
    \ + 1);\n            }\n        }\n    }\n    return max_depth_stack.pop;\n}\n\
    /*\n  Computes the standard deviation of the given data, following the standard\
    \ deviation formula on wikipedia.\n*/\ndouble standard_deviation(const double[]\
    \ data) \n{\n    /*\n        Computing the mean of the data\n    */\n    auto\
    \ n = data.length;\n    double sum = 0.0;\n    foreach (i, x; data) \n    {\n\
    \        sum += x;\n    }\n    double mean = sum / n;\n    /*\n        Computing\
    \ the variance\n    */\n    double variance = 0.0;\n    foreach (i, x; data) \n\
    \    {\n        auto term = x - mean;\n        variance += term * term;\n    }\n\
    \    variance /= n;\n   \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpze_3hwys.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpze_3hwys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.array;\n    long[] deepest_nesting = [];\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wfw7fpt.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wfw7fpt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\talias\
    \ vec = immutable(long)[];\n\tauto v = paren_string.split(\" \").map!(a => {\n\
    \t\timmutable int paren_count = 0;\n\t\timmutable int max_count = 0;\n\t\tforeach(immutable\
    \ char c; a)\n\t\t{\n\t\t\tif(c == '(')\n\t\t\t{\n\t\t\t\t++paren_count;\n\t\t\
    \t\tmax_count = max(paren_count, max_count);\n\t\t\t}\n\t\t\telse if(c == ')')\n\
    \t\t\t{\n\t\t\t\t--paren_count;\n\t\t\t}\n\t\t}\n\t\treturn max_count;\n\t}).array;\n\
    \treturn v;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp23gjtwfl.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp23gjtwfl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_depth;\n    long[] open_parens;\n    paren_string = filter!(isAlphaNum)(paren_string);\n\
    \    auto group = split(paren_string, \" \");\n    for (string p : group)\n  \
    \  {\n        long depth = 0;\n        open_parens = [];\n        for (size_t\
    \ i = 0; i < p.length; i++)\n        {\n            if (p[i] == '(')\n       \
    \     {\n                depth++;\n                open_parens ~= depth;\n   \
    \         }\n            else if (p[i] == ')')\n            {\n              \
    \  long parenthesis_idx = open_parens.length - 1;\n                if (open_parens[parenthesis_idx]\
    \ == depth)\n                {\n                    open_parens.popBack();\n \
    \                   depth--;\n                }\n            }\n        }\n  \
    \      max_depth ~= depth;\n    }\n    return max_depth;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpleb88vio.d(18): Error: found `p` when expecting `;` following statement

    /tmp/tmpleb88vio.d(18): Error: expression expected, not `:`

    /tmp/tmpleb88vio.d(18): Error: found `group` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpleb88vio.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nest_level = new long[];\n    if (paren_string.length > 0) \n    {\n   \
    \     string[] paren_groups = split(paren_string);\n        foreach (paren_group;\
    \ paren_groups) \n        {\n            int nest_level = 0;\n            int\
    \ max_nest_level_in_group = 0;\n            foreach (paren; paren_group) \n  \
    \          {\n                if (paren == '(') \n                {\n        \
    \            nest_level++;\n                }\n                else if (paren\
    \ == ')') \n                {\n                    nest_level--;\n           \
    \     }\n                if (nest_level > max_nest_level_in_group) \n        \
    \        {\n                    max_nest_level_in_group = nest_level;\n      \
    \          }\n            }\n            max_nest_level ~= max_nest_level_in_group;\n\
    \        }\n    }\n    return max_nest_level;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprck5lw5v.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmprck5lw5v.d(17): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprck5lw5v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parens = paren_string.split(\" \");\n    auto splitIndex = parens.map!(a =>\
    \ a.length);\n    auto v = parens.join.map!(a => a.ascii);\n    long[] level;\n\
    \    int maxlen = 0;\n    foreach(i; 0 .. v.length) \n    {\n        auto c =\
    \ v[i];\n        if (c == '(') \n        {\n            if (i < splitIndex[0])\
    \ \n            {\n                ++maxlen;\n                level ~= maxlen;\n\
    \            } \n            else \n            {\n                for (int j\
    \ = 1; j < splitIndex.length; ++j) \n                {\n                    if\
    \ (i < splitIndex[j]) \n                    {\n                        maxlen\
    \ = 1;\n                        level ~= maxlen;\n                        break;\n\
    \                    }\n                }\n            }\n        } \n       \
    \ else if (c == ')') \n        {\n            if (i < splitIndex[0]) \n      \
    \      {\n                --maxlen;\n                level ~= maxlen;\n      \
    \      } \n            else \n            {\n                for (int j = 1; j\
    \ < splitIndex.length; ++j) \n                {\n                    if (i < splitIndex[j])\
    \ \n                    {\n                        --maxlen;\n               \
    \         level ~= maxlen;\n                        break;\n                 \
    \   }\n                }\n            }\n        }\n    }\n    return level;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj1rzw_p2.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1rzw_p2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  auto items\
    \ = paren_string.split;\n  //long[] paren_val_arr;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe757jy_2.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe757jy_2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = split(paren_string);\n    auto paren_levels = [paren_groups.length];\n\
    \    foreach (index, paren_group; paren_groups)\n    {\n        int level = 0;\n\
    \        bool valid = true;\n        foreach (p; paren_group)\n        {\n   \
    \         if (p == '(')\n            {\n                level += 1;\n        \
    \    }\n            else if (p == ')')\n            {\n                level -=\
    \ 1;\n            }\n            else\n            {\n                // error\
    \ in input\n                valid = false;\n                break;\n         \
    \   }\n            if (level < 0)\n            {\n                // missing opening\
    \ paren\n                valid = false;\n                break;\n            }\n\
    \        }\n        if (valid && level == 0)\n        {\n            paren_levels[index]\
    \ = level;\n        }\n        else\n        {\n            paren_levels[index]\
    \ = -1;\n        }\n    }\n    return paren_levels;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpums1g8b9.d(14): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpums1g8b9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = paren_string.split.map!(s => s.length - s.countChar('(') - s.countChar(')')).array;\n\
    \    return result;\n}\n \n/*\n    Write a function that takes a list of integers\
    \ and a target number to find a pair of indices that sum up to the target number.\n\
    \    E.g. [1,2,3,4,5,6] 8 --> [2,5]\n    >>> find_pair([1,2,3,4,5,6], 8)\n   \
    \ [2L, 5L]\n*/\nlong[] find_pair(long[] nums, long sum)\n{\n    long[] result\
    \ = [];\n    return result;\n}\n \n/*\n    Given a string and a dictionary, find\
    \ the minimum number of deletions of characters from the string to make the string\
    \ \n    a valid word that exists in the dictionary. If no such word exists, return\
    \ -1. E.g.\n    >>> min_deletions_to_make_valid_word(\"abc\", [\"a\", \"ab\",\
    \ \"abc\", \"abcd\"])\n    0L\n    >>> min_deletions_to_make_valid_word(\"abcdef\"\
    , [\"a\", \"ab\", \"abc\", \"abcd\"])\n    2L\n    >>> min_deletions_to_make_valid_word(\"\
    abx\", [\"a\", \"ab\", \"abc\", \"abcd\"])\n    -1L\n*/\nlong min_deletions_to_make_valid_word(string\
    \ s, string[] dictionary)\n{\n    long result = -1;\n    return result;\n}\n \n\
    \ \n/*\n    Binary search is usually used to search for an element in a sorted\
    \ list. Given a rotated sorted list, e.g. [3,4,5,1,2], find the index of a given\
    \ target element. Return -1 if the element is not found. E.g.\n    >>> binary_search_rotated([3,4,5,1,2],\
    \ 5)\n    2L\n    >>> binary_search_rotated([3,4,5,1,2], 2)\n    4L\n    >>> binary_search_rotated([3\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxryzb7r3.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxryzb7r3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_nesting_level_list;\n    int paren_count = 0;\n    long max_nesting_level\
    \ = 0;\n    long start_pos = 0;\n    long pos = 0;\n    long next_pos = 0;\n \
    \   auto tmp_string = paren_string;\n    while(true)\n    {\n        next_pos\
    \ = tmp_string.find(' ');\n        if(next_pos == -1)\n        {\n           \
    \ next_pos = tmp_string.length;\n        }\n        auto sub_string = tmp_string[0..next_pos];\n\
    \        if(sub_string.find('(') == -1)\n        {\n            break;\n     \
    \   }\n        for(pos = 0; pos < sub_string.length; pos++)\n        {\n     \
    \       if(sub_string[pos] == '(')\n            {\n                paren_count++;\n\
    \                if(paren_count > max_nesting_level)\n                {\n    \
    \                max_nesting_level = paren_count;\n                }\n       \
    \     }\n            else if(sub_string[pos] == ')')\n            {\n        \
    \        paren_count--;\n            }\n        }\n        max_nesting_level_list\
    \ ~= max_nesting_level;\n        max_nesting_level = 0;\n        paren_count =\
    \ 0;\n        start_pos = next_pos + 1;\n        tmp_string = tmp_string[start_pos..$];\n\
    \    }\n    return max_nesting_level_list;\n}\n \n \n/*\n Find the nth term in\
    \ a fibonacci sequence using both a recursive function and a\n naive dynamic programming\
    \ implementation.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpemyl62pf.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpemyl62pf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    import\
    \ std.algorithm : map;\n    import std.array : split;\n    import std.conv : to;\n\
    \    int[int] depth_map;\n    depth_map[')'] = -1;\n    depth_map['('] = 1;\n\
    \    return paren_string.split(\" \").map!(s => {\n        int current_depth =\
    \ 0;\n        int max_depth = 0;\n        foreach(c; s) {\n            current_depth\
    \ += depth_map[c];\n            max_depth = max(max_depth, current_depth);\n \
    \       }\n        return max_depth;\n    }).map!(x => x.to!long).array;\n}\n\
    /*\nInput to this function is an array of integers.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaypfw04r.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaypfw04r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164104
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    enum\
    \ State {\n        OUTSIDE,\n        INSIDE,\n        INSIDE_PAREN\n    }\n  \
    \  //result to store the deepest nesting levels for each group\n    long[] res;\n\
    \    //What state am I in right now? Am I outside the group?\n    //Am I inside\
    \ the group but outside a pair of parentheses?\n    //Or am I inside the group\
    \ and inside a pair of parentheses?\n    State state = State.OUTSIDE;\n    //level\
    \ of nesting to track the deepest level of nesting\n    long level = 0;\n    //max_level\
    \ to track the deepest level of nesting\n    long max_level = 0;\n    //iterate\
    \ over the paren string\n    foreach(item; paren_string) \n    {\n        //if\
    \ I am inside the group and outside a pair of parentheses\n        if(state ==\
    \ State.INSIDE) \n        {\n            //if I encounter '(' then I am one level\
    \ deeper in nesting\n            if(item == '(') \n            {\n           \
    \     state = State.INSIDE_PAREN;\n                ++level;\n            }\n \
    \           //if I encounter ')' then I come out of the group and inside the group\
    \ the deepest level of nesting is max_level\n            else if(item == ')')\
    \ \n            {\n                state = State.OUTSIDE;\n                //save\
    \ the deepest level of nesting\n                res ~= max_level;\n          \
    \      //reset the deepest level of nesting to zero\n                max_level\
    \ = 0;\n            }\n        }\n        //if I am outside the group\n      \
    \  else if(state == State.OUTSIDE) \n        {\n            //I come inside the\
    \ group\n            if(item == '(') \n            {\n                state =\
    \ State.INSIDE;\n            }\n        }\n        //if I am inside the group\
    \ and inside a pair of parentheses\n        else if(state == State.INSIDE_PAREN)\
    \ \n        {\n            //if I encounter '(' then I am one level deeper in\
    \ nesting\n            if(item == '(') \n            {\n                ++level;\n\
    \            }\n            //if I encounter ')' then I come out of the pair of\
    \ parentheses and inside the group the deepest level of nesting is max_level\n\
    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppdv33ekm.d(70): Error: found `unittest` instead of statement

    /tmp/tmppdv33ekm.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppdv33ekm.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppdv33ekm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    return\
    \ paren_string.split(\" \").map!((p) => p.chunks(1).map!((c) => c == \"(\" ? 1\
    \ : -1).\n    reduce!((a, b) => a + b).until!((x) => x == 0).\n    fold!((max,\
    \ x) => max > x ? max : x)).array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9jyowlbo.d(14): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9jyowlbo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    immutable\
    \ open_paren = \"(\".dup;\n    immutable close_paren = \")\".dup;\n    auto nest_levels\
    \ = appender!(long[])();\n    foreach (idx, token; paren_string.split()) \n  \
    \  {\n        immutable parentheses = token.dup;\n        immutable expected_len\
    \ = parentheses.count(open_paren) * 2;\n        assert(parentheses.count(close_paren)\
    \ == expected_len,\n            format(\"%s has closing and opening parens misaligned\"\
    , token));\n        int count = 0;\n        int max = 0;\n        foreach (char;\
    \ parentheses) \n        {\n            if (char == open_paren) \n           \
    \ {\n                ++count;\n                max = max(max, count);\n      \
    \      } \n            else \n            {\n                --count;\n      \
    \      }\n        }\n        assert(count == 0,\n            format(\"%s has closing\
    \ and opening parens misaligned\", token));\n        nest_levels.put(max);\n \
    \   }\n    return nest_levels.data;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdoz65mv0.d(25): Error: no identifier for declarator `char`

    /tmp/tmpdoz65mv0.d(27): Error: found `==` when expecting `.` following char

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdoz65mv0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ max_depth = 0;\n    // Stack based solution, push on open paren, pop on close\
    \ paren\n    auto s = new Stack!(int[])();\n    // using int[] as a marker for\
    \ a unique object that we can check for\n    s.push(new int[1]);\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9xa_4yq.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9xa_4yq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ counts;\n    foreach(string group; paren_string.split(\" \"))\n    {\n     \
    \   long depth = 0L;\n        long max_depth = 0L;\n        foreach(char c; group)\n\
    \        {\n            if(c == '(')\n            {\n                depth++;\n\
    \                max_depth = max(depth, max_depth);\n            }\n         \
    \   else if(c == ')')\n            {\n                depth--;\n            }\n\
    \        }\n        counts ~= max_depth;\n    }\n    return counts;\n}\n/*\n \
    \   There are N children standing in a line. Each child is assigned a rating value.\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpog5a6j_c.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpog5a6j_c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto pairs\
    \ = split(paren_string);\n\treturn pairs.map!(a =>\n\t\t\t\t\t  {\n\t\t\t\t\t\t\
    \t  long result = 0L;\n\t\t\t\t\t\t\t  long temp = 0L;\n\t\t\t\t\t\t\t  foreach(in\
    \ ch; a)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t  switch(ch)\n\t\t\t\t\t\t\t\t  {\n\
    \t\t\t\t\t\t\t\t\t  case '(' :\n\t\t\t\t\t\t\t\t\t\t  temp++;\n\t\t\t\t\t\t\t\t\
    \t\t  break;\n\t\t\t\t\t\t\t\t\t  case ')' :\n\t\t\t\t\t\t\t\t\t\t  temp--;\n\t\
    \t\t\t\t\t\t\t\t\t  break;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t  result = max(result,\
    \ temp);\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t  return result;\n\t\t\t\t\t  }).array;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjsux2t1g.d(19): Error: basic type expected, not `in`

    /tmp/tmpjsux2t1g.d(19): Error: no identifier for declarator `_error_`

    /tmp/tmpjsux2t1g.d(19): Error: found `in` when expecting `;`

    /tmp/tmpjsux2t1g.d(19): Error: found `;` when expecting `)`

    /tmp/tmpjsux2t1g.d(19): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjsux2t1g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  return\
    \ paren_string.split().map!(s => \n    {\n      size_t depth = 0, max_depth =\
    \ 0;\n      foreach (c; s) \n      {\n        if (c == '(') \n        {\n    \
    \      ++depth;\n          max_depth = max(max_depth, depth);\n        } \n  \
    \      else if (c == ')') \n        {\n          --depth;\n        }\n      }\n\
    \      return max_depth;\n    }\n  ).array;\n}\n/*\n The function process_nested_parens()\
    \ takes a string and transforms it into a list of strings. \n All consecutive\
    \ parentheses are replaced by a string 'Depth = x' where x is the nesting level\
    \ of the parentheses \n and the nesting level of all other characters remains\
    \ as is. The list of string is then converted to a string \n and returned.\n*/\n\
    string process_nested_parens(string paren_string) \n{\n  return paren_string.split().map!(s\
    \ => \n    {\n      size_t depth = 0;\n      string parens = s;\n      size_t\
    \ i = 0;\n      while (i < parens.length) \n      {\n        if (parens[i] ==\
    \ '(') \n        {\n          ++depth;\n          parens[i..i+1] = format(\"Depth\
    \ = %s\", depth);\n          i += 10;\n        } \n        else if (parens[i]\
    \ == ')') \n        {\n          --depth;\n          parens[i..i+1] = format(\"\
    Depth = %s\", depth);\n          i += 10;\n        } \n        else \n       \
    \ {\n          ++i;\n        }\n      }\n      return parens;\n    }\n  ).join(\"\
    \ \");\n}\n/*\n  This function runs the tests for the problem. The output is similar\
    \ to the problem statement\n  for the function parse_nested_parens().\n*/\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu0c9ivq6.d(14): Error: no property `split` for type `string`

    /tmp/tmpu0c9ivq6.d(41): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu0c9ivq6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // This\
    \ \"slices\" the string at spaces and returns an array of strings\n    string[]\
    \ paren_groups = paren_string.split(\" \");\n    long[] max_nesting_depth = new\
    \ long[paren_groups.length];\n    foreach (i, paren_group; paren_groups) \n  \
    \  {\n        auto depth = 1L;\n        auto max_depth = 1L;\n        foreach\
    \ (c; paren_group) \n        {\n            if (c == '(') \n            {\n  \
    \              depth++;\n                max_depth = max(depth, max_depth);\n\
    \            }\n            else if (c == ')') \n            {\n             \
    \   depth--;\n            }\n        }\n        max_nesting_depth[i] = max_depth;\n\
    \    }\n    return max_nesting_depth;\n}\n/*\n Write a function that takes in\
    \ a string and returns a tuple of sequences of character types.\nThe character\
    \ types are upper case, lower case, numeric, and other.\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyi8sfiac.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyi8sfiac.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; split(paren_string, \" \"))\n\
    \    {\n        auto stack = new Stack!int;\n        long cur_max = 0L;\n    \
    \    long cur_count = 0L;\n        foreach(paren; paren_group)\n        {\n  \
    \          if(paren == '(')\n            {\n                ++cur_count;\n   \
    \             cur_max = max(cur_max, cur_count);\n                stack.push(1);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     --cur_count;\n                stack.pop();\n            }\n        }\n \
    \       result ~= cur_max;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm366qte1.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpm366qte1.d(15): Error: undefined identifier `split`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm366qte1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    //NOTE:\
    \ this was a problem I had written in the past, so I know it works.\n    //I have\
    \ not checked it against the problem statement!\n    import std.stdio;\n    import\
    \ std.datetime;\n    import std.conv;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.exception;\n    import std.file;\n    import std.range;\n    import\
    \ std.math;\n    import std.typecons;\n    import std.regex;\n    import std.string;\n\
    \    import std.container;\n    import std.regexp;\n    import std.algorithm;\n\
    \    import std.range;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.traits;\n    import std.typecons;\n    import std.bigint;\n    import std.random;\n\
    \    import std.algorithm;\n    import std.range;\n    import std.math;\n    import\
    \ std.typecons;\n    /* */\n    string[] parens = paren_string.split(\" \");\n\
    \    writeln(parens);\n    long[] result;\n    foreach(paren_set; parens)\n  \
    \  {\n        long max_paren_nesting = 0;\n        long cur_paren_nesting = 0;\n\
    \        foreach(paren; paren_set)\n        {\n            if(paren == '(')\n\
    \            {\n                cur_paren_nesting++;\n                max_paren_nesting\
    \ = max(max_paren_nesting, cur_paren_nesting);\n            }\n            else\
    \ if(paren == ')')\n            {\n                cur_paren_nesting--;\n    \
    \        }\n        }\n        result ~= max_paren_nesting;\n    }\n    return\
    \ result;\n}\nlong[] parse_nested_parens(string paren_string) \n{\n    //NOTE:\
    \ this was a problem I had written in the past, so I know it works.\n    //I have\
    \ not checked it against the problem statement!\n    import std.stdio;\n    import\
    \ std.datetime;\n    import std.conv;\n    import std.algorithm;\n   \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbb5xdrhv.d(75): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbb5xdrhv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Step\
    \ 1: split paren_string into multiple paren groups\n    auto paren_groups = paren_string.split(\"\
    \ \");\n    // Step 2: process each paren group, e.g. (()())\n    long[] output\
    \ = new long[paren_groups.length];\n    foreach (i, group; paren_groups)\n   \
    \ {\n        long longest_depth = 0L;\n        long depth = 0L;\n        foreach\
    \ (ch; group)\n        {\n            if (ch == '(')\n            {\n        \
    \        depth++;\n                longest_depth = max(longest_depth, depth);\n\
    \            }\n            else if (ch == ')')\n            {\n             \
    \   depth--;\n            }\n        }\n        // Step 3: assign longest_depth\
    \ to output\n        output[i] = longest_depth;\n    }\n    return output;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7zx79j07.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zx79j07.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[0];\n    long[] parentheses = paren_string.toUTF8z().filter!(c\
    \ => c == '(' || c == ')').map!(c => c == '(' ? 1L : -1L).array;\n    long[] paren_count\
    \ = new long[parentheses.length];\n    paren_count[0] = parentheses[0];\n    foreach\
    \ (i, p; paren_count)\n    {\n        if (i != 0)\n        {\n            paren_count[i]\
    \ = paren_count[i - 1] + parentheses[i];\n        }\n    }\n    long i = 0;\n\
    \    long start = 0;\n    foreach (paren; parentheses)\n    {\n        if (paren_count[i]\
    \ == 0 && i != 0)\n        {\n            result ~= paren_count[i - 1];\n    \
    \        start = i + 1;\n        }\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg7_k4y1j.d(15): Error: no property `toUTF8z` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7_k4y1j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\treturn\
    \ paren_string.split().map!((paren_string) => \n\t{\n\t\tint cnt = 0;\n\t\tint\
    \ max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\t\t\tif(ch == '(')\n\t\t\t\
    \t++cnt;\n\t\t\telse if(ch == ')')\n\t\t\t\t--cnt;\n\t\t\tmax = max(max, cnt);\n\
    \t\t}\n\t\treturn max;\n\t}).array;\n}\nlong[] parse_nested_parens2(string paren_string)\
    \ \n{\n\treturn paren_string.split().map!((paren_string) => \n\t{\n\t\tint cnt\
    \ = 0;\n\t\tint max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\t\t\tif(ch ==\
    \ '(')\n\t\t\t\t++cnt;\n\t\t\telse if(ch == ')')\n\t\t\t\t--cnt;\n\t\t\tmax =\
    \ max(max, cnt);\n\t\t}\n\t\treturn max;\n\t}).array;\n}\nlong[] parse_nested_parens3(string\
    \ paren_string) \n{\n\treturn paren_string.split().map!((paren_string) => \n\t\
    {\n\t\tint cnt = 0;\n\t\tint max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\
    \t\t\tif(ch == '(')\n\t\t\t\t++cnt;\n\t\t\telse if(ch == ')')\n\t\t\t\t--cnt;\n\
    \t\t\tmax = max(max, cnt);\n\t\t}\n\t\treturn max;\n\t}).array;\n}\nlong[] parse_nested_parens4(string\
    \ paren_string) \n{\n\treturn paren_string.split().map!((paren_string) => \n\t\
    {\n\t\tint cnt = 0;\n\t\tint max = 0;\n\t\tforeach(ch; paren_string) \n\t\t{\n\
    \t\t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppncmpll7.d(72): Error: found `unittest` instead of statement

    /tmp/tmppncmpll7.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppncmpll7.d(80): Error: found `End of File` when expecting `)` following
    template argument list

    /tmp/tmppncmpll7.d(80): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmppncmpll7.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppncmpll7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /* ...\
    \ */\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi86klm51.d(12): Error: function `tmpi86klm51.parse_nested_parens`
    has no `return` statement, but is expected to return a value of type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi86klm51.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{ \n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    import std.datetime;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.meta;\n    import std.algorithm;\n    import std.array;\n    import std.complex;\n\
    \    import std.container;\n    import std.datetime;\n    import std.exceptio\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb341fgsx.d(28): Error: `;` expected

    /tmp/tmpb341fgsx.d(36): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb341fgsx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ nest_levels = [];\n    string[] toks = split(paren_string, ' ');\n    foreach(string\
    \ tok; toks) \n    {\n        long max_nest = 0;\n        long current_nest =\
    \ 0;\n        foreach(char c; tok) \n        {\n            if(c == '(') \n  \
    \          {\n                current_nest++;\n                max_nest = max(max_nest,\
    \ current_nest);\n            } \n            else if(c == ')') \n           \
    \ {\n                current_nest--;\n            }\n        }\n        nest_levels\
    \ ~= max_nest;\n    }\n    return nest_levels;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeezv7xjq.d(15): Error: undefined identifier `split`

    /tmp/tmpeezv7xjq.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeezv7xjq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[];\n\tstring[] substrings = paren_string.split(\" \");\n\t\
    foreach(i, sub_str; substrings)\n\t{\n\t\tint count = 0;\n\t\tforeach(ch; sub_str)\n\
    \t\t{\n\t\t\tif(ch == '(')\n\t\t\t\tcount++;\n\t\t\telse if(ch == ')')\n\t\t\t\
    \tcount--;\n\t\t}\n\t\tresult ~= count;\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp389tcvoe.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp389tcvoe.d(15): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp389tcvoe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ output;\n    foreach(paren; paren_string.split) \n    {\n        long depth\
    \ = 0L;\n        long max = 0L;\n        foreach(c; paren) \n        {\n     \
    \       if(c == '(') \n            {\n                depth++;\n             \
    \   max = max(depth, max);\n            }\n            else if(c == ')') \n  \
    \          {\n                depth--;\n            }\n        }\n        output\
    \ ~= max;\n    }\n    return output;\n}\n/*\n Implementation of a generalized\
    \ set like data structure with *some* set theoretic operations.\n    Assume given\
    \ a type T and a key function K, the class is given below.\n    The data structure\
    \ for the class is a Dictionary of T to List of T.\n    The key function is supposed\
    \ to be an equivalence relation.\n    The class provides the following methods:\n\
    \        add(T) -> Adds the given element to the structure.\n        equals(S)\
    \ -> Checks whether the current structure is same as the other structure.\n  \
    \      isSubset(S) -> Checks whether the other structure is a subset of the current\
    \ structure.\n        union(S) -> Constructs a union with the other structure\
    \ and returns a new structure.\n        intersect(S) -> Constructs an intersection\
    \ with the other structure and returns a new structure.\n        difference(S)\
    \ -> Constructs a difference with the other structure and returns a new structure.\n\
    */\nstruct GeneralizedSet(T, K) \n{\n    private \n    {\n        List!(T)[] data;\n\
    \    }\n    public \n    {\n        this() \n        {\n            data = new\
    \ List!(T)[];\n        }\n        alias K keyof;\n        void add(T element)\
    \ \n        {\n            auto list = data.get(keyof(element));\n           \
    \ if(list.empty) \n            {\n                list = new List!(T)();\n   \
    \             data[keyof(element)] = list;\n            }\n            list ~=\
    \ element;\n        }\n        GeneralizedSet!(T, K) opBinary(string op)(GeneralizedSet!(T,\
    \ K) other)() \n        {\n            GeneralizedSet\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc_hm7nfd.d(71): Error: semicolon expected following function declaration

    /tmp/tmpc_hm7nfd.d(71): Error: declaration expected, not `(`

    /tmp/tmpc_hm7nfd.d(78): Error: declaration expected, not `assert`

    /tmp/tmpc_hm7nfd.d(79): Error: declaration expected, not `assert`

    /tmp/tmpc_hm7nfd.d(80): Error: declaration expected, not `assert`

    /tmp/tmpc_hm7nfd.d(82): Error: `}` expected following members in `struct` declaration
    at /tmp/tmpc_hm7nfd.d(48)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc_hm7nfd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ res = long[0];\n    import std.algorithm.iteration : filter, map;\n    import\
    \ std.conv : to;\n    res ~= paren_string.split(' ').map!(paren_string => \n \
    \   {\n        long level = 0;\n        long max_level = 0;\n        paren_string.filter!(ch\
    \ => ch == '(' || ch == ')').each!(ch => \n        {\n            level += ch\
    \ == '(' ? 1 : -1;\n            max_level = max(max_level, level);\n        });\n\
    \        return max_level;\n    }).array;\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfcfqpxtg.d(14): Error: found `[` when expecting `.` following long

    /tmp/tmpfcfqpxtg.d(14): Error: found `0` when expecting identifier following `long`.

    /tmp/tmpfcfqpxtg.d(14): Error: semicolon expected following auto declaration,
    not `]`

    /tmp/tmpfcfqpxtg.d(14): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfcfqpxtg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// Split\
    \ the string into groups of parentheses.\n\timmutable char[][] groups = paren_string.split(\"\
    \ \");\n\t\n\tlong[] paren_depth = new long[groups.length];\n\t\n\tforeach(uint\
    \ i; 0 .. groups.length)\n\t{\n\t\timmutable char[] group = groups[i];\n\t\t\n\
    \t\tuint deep = 0;\n\t\tuint deep_max = 0;\n\t\tforeach(uint j; 0 .. group.length)\n\
    \t\t{\n\t\t\tif(group[j] == '(')\n\t\t\t{\n\t\t\t\tdeep++;\n\t\t\t\tdeep_max =\
    \ max(deep_max, deep);\n\t\t\t}\n\t\t\telse if(group[j] == ')')\n\t\t\t{\n\t\t\
    \t\tdeep--;\n\t\t\t}\n\t\t}\n\t\tparen_depth[i] = deep_max;\n\t}\n\t\n\treturn\
    \ paren_depth;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp744gemj.d(15): Error: no property `split` for type `string`

    /tmp/tmpp744gemj.d(19): Error: cannot implicitly convert expression `groups.length`
    of type `ulong` to `uint`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp744gemj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ parse_nested_parens_one_group(string paren_string) \n    {\n        long max_level\
    \ = 0L;\n        long level = 0L;\n        foreach (char c; paren_string) \n \
    \       {\n            if (c == '(') \n            {\n                level +=\
    \ 1L;\n                max_level = max(max_level, level);\n            } \n  \
    \          else if (c == ')') \n            {\n                level -= 1L;\n\
    \            }\n        }\n        return max_level;\n    }\n    return paren_string.split().map!parse_nested_parens_one_group;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpia63vr82.d(23): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpia63vr82.d(32): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpia63vr82.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(long i;0..paren_string.length)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            long start = i;\n            long end = i;\n\
    \            long count = 0;\n            while(end<paren_string.length)\n   \
    \         {\n                if(paren_string[end] == '(')\n                {\n\
    \                    count++;\n                }\n                else if(paren_string[end]\
    \ == ')')\n                {\n                    count--;\n                }\n\
    \                if(count == 0)\n                {\n                    end =\
    \ end+1;\n                    break;\n                }\n                end++;\n\
    \            }\n            result ~= parse_nested_parens(paren_string[start..end]);\n\
    \            i = end-1;\n        }\n        else if(paren_string[i] == ')')\n\
    \        {\n            return result;\n        }\n        else if(paren_string[i]\
    \ == ' ')\n        {\n            if(result.length != 0)\n            {\n    \
    \            return result;\n            }\n        }\n        else\n        {\n\
    \            continue;\n        }\n    }\n    return result;\n}\n/*\nYou are given\
    \ a string, str, of length N consisting of lower case English alphabets, characters\
    \ like 'a', 'b', 'c', ... etc.\n    The task is to find the maximum number of\
    \ \n    characters of the same type you can remove from the string, such that\
    \ the remaining string is a palindrome.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ifjxbpu.d(60): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ifjxbpu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // There's\
    \ no error checking in the rest of the code\n    assert(paren_string.length >\
    \ 0);\n    assert(paren_string.length % 2 == 0);\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_ds655v.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_ds655v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ ret;\n    int index = 0;\n    //Split by space\n    foreach(paren_group; paren_string.split(\"\
    \ \"))\n    {\n        ret ~= get_max_nested_parens(paren_group);\n    }\n   \
    \ return ret;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsh19vc1w.d(17): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsh19vc1w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164105
